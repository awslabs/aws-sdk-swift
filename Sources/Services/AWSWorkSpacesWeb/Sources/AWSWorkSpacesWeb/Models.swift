//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// There is an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// There is a throttling error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension WorkSpacesWebClientTypes {

    /// Information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension WorkSpacesWebClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// There is a validation error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error.
        public internal(set) var fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateBrowserSettingsInput: Swift.Sendable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateBrowserSettingsOutput: Swift.Sendable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateIpAccessSettingsInput: Swift.Sendable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateIpAccessSettingsOutput: Swift.Sendable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateNetworkSettingsInput: Swift.Sendable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateNetworkSettingsOutput: Swift.Sendable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

public struct AssociateTrustStoreInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

public struct AssociateTrustStoreOutput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

public struct AssociateUserAccessLoggingSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

public struct AssociateUserAccessLoggingSettingsOutput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

public struct AssociateUserSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

public struct AssociateUserSettingsOutput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iamIdentityCenter
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .iamIdentityCenter,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamIdentityCenter: return "IAM_Identity_Center"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension WorkSpacesWebClientTypes {

    /// The tag.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreateBrowserSettingsInput: Swift.Sendable {
    /// Additional encryption context of the browser settings.
    public var additionalEncryptionContext: [Swift.String: Swift.String]?
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    /// This member is required.
    public var browserPolicy: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the browser settings.
    public var customerManagedKey: Swift.String?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
        browserPolicy: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.browserPolicy = browserPolicy
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.tags = tags
    }
}

extension CreateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), browserPolicy: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateBrowserSettingsOutput: Swift.Sendable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

public struct DeleteBrowserSettingsInput: Swift.Sendable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

public struct DeleteBrowserSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetBrowserSettingsInput: Swift.Sendable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    /// The browser settings resource that can be associated with a web portal. Once associated with a web portal, browser settings control how the browser will behave once a user starts a streaming session for the web portal.
    public struct BrowserSettings: Swift.Sendable {
        /// The additional encryption context of the browser settings.
        public var additionalEncryptionContext: [Swift.String: Swift.String]?
        /// A list of web portal ARNs that this browser settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public var browserPolicy: Swift.String?
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?
        /// The customer managed key used to encrypt sensitive information in the browser settings.
        public var customerManagedKey: Swift.String?

        public init(
            additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
            associatedPortalArns: [Swift.String]? = nil,
            browserPolicy: Swift.String? = nil,
            browserSettingsArn: Swift.String? = nil,
            customerManagedKey: Swift.String? = nil
        )
        {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
            self.customerManagedKey = customerManagedKey
        }
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettings(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), browserPolicy: \"CONTENT_REDACTED\")"}
}

public struct GetBrowserSettingsOutput: Swift.Sendable {
    /// The browser settings.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

public struct ListBrowserSettingsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary for browser settings.
    public struct BrowserSettingsSummary: Swift.Sendable {
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init(
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
        }
    }
}

public struct ListBrowserSettingsOutput: Swift.Sendable {
    /// The browser settings.
    public var browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.browserSettings = browserSettings
        self.nextToken = nextToken
    }
}

public struct UpdateBrowserSettingsInput: Swift.Sendable {
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    public var browserPolicy: Swift.String?
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?

    public init(
        browserPolicy: Swift.String? = nil,
        browserSettingsArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.browserPolicy = browserPolicy
        self.browserSettingsArn = browserSettingsArn
        self.clientToken = clientToken
    }
}

extension UpdateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), clientToken: \(Swift.String(describing: clientToken)), browserPolicy: \"CONTENT_REDACTED\")"}
}

public struct UpdateBrowserSettingsOutput: Swift.Sendable {
    /// The browser settings.
    /// This member is required.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

public struct ExpireSessionInput: Swift.Sendable {
    /// The ID of the web portal for the session.
    /// This member is required.
    public var portalId: Swift.String?
    /// The ID of the session to expire.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        portalId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.sessionId = sessionId
    }
}

public struct ExpireSessionOutput: Swift.Sendable {

    public init() { }
}

public struct GetSessionInput: Swift.Sendable {
    /// The ID of the web portal for the session.
    /// This member is required.
    public var portalId: Swift.String?
    /// The ID of the session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        portalId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.sessionId = sessionId
    }
}

extension WorkSpacesWebClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .active,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .terminated: return "Terminated"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesWebClientTypes {

    /// Information about a secure browser session.
    public struct Session: Swift.Sendable {
        /// The IP address of the client.
        public var clientIpAddresses: [Swift.String]?
        /// The end time of the session.
        public var endTime: Foundation.Date?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The ID of the session.
        public var sessionId: Swift.String?
        /// The start time of the session.
        public var startTime: Foundation.Date?
        /// The status of the session.
        public var status: WorkSpacesWebClientTypes.SessionStatus?
        /// The username of the session.
        public var username: Swift.String?

        public init(
            clientIpAddresses: [Swift.String]? = nil,
            endTime: Foundation.Date? = nil,
            portalArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: WorkSpacesWebClientTypes.SessionStatus? = nil,
            username: Swift.String? = nil
        )
        {
            self.clientIpAddresses = clientIpAddresses
            self.endTime = endTime
            self.portalArn = portalArn
            self.sessionId = sessionId
            self.startTime = startTime
            self.status = status
            self.username = username
        }
    }
}

extension WorkSpacesWebClientTypes.Session: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Session(endTime: \(Swift.String(describing: endTime)), portalArn: \(Swift.String(describing: portalArn)), sessionId: \(Swift.String(describing: sessionId)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), clientIpAddresses: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct GetSessionOutput: Swift.Sendable {
    /// The sessions in a list.
    public var session: WorkSpacesWebClientTypes.Session?

    public init(
        session: WorkSpacesWebClientTypes.Session? = nil
    )
    {
        self.session = session
    }
}

extension WorkSpacesWebClientTypes {

    public enum IdentityProviderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case facebook
        case google
        case loginwithamazon
        case oidc
        case saml
        case signinwithapple
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .facebook,
                .google,
                .loginwithamazon,
                .oidc,
                .saml,
                .signinwithapple
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .facebook: return "Facebook"
            case .google: return "Google"
            case .loginwithamazon: return "LoginWithAmazon"
            case .oidc: return "OIDC"
            case .saml: return "SAML"
            case .signinwithapple: return "SignInWithApple"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIdentityProviderInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    ///
    /// * IDPInit (boolean) optional
    ///
    /// * RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256
    ///
    /// * EncryptedResponses (boolean) optional
    /// This member is required.
    public var identityProviderDetails: [Swift.String: Swift.String]?
    /// The identity provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// The identity provider type.
    /// This member is required.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The tags to add to the identity provider resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderDetails: [Swift.String: Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil,
        portalArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
        self.portalArn = portalArn
        self.tags = tags
    }
}

extension CreateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderType: \(Swift.String(describing: identityProviderType)), portalArn: \(Swift.String(describing: portalArn)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateIdentityProviderOutput: Swift.Sendable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

public struct DeleteIdentityProviderInput: Swift.Sendable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

public struct DeleteIdentityProviderOutput: Swift.Sendable {

    public init() { }
}

public struct GetIdentityProviderInput: Swift.Sendable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

extension WorkSpacesWebClientTypes {

    /// The identity provider.
    public struct IdentityProvider: Swift.Sendable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
        ///
        /// * For Google and Login with Amazon:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For Facebook:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        /// * api_version
        ///
        ///
        ///
        ///
        /// * For Sign in with Apple:
        ///
        /// * client_id
        ///
        /// * team_id
        ///
        /// * key_id
        ///
        /// * private_key
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For OIDC providers:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * attributes_request_method
        ///
        /// * oidc_issuer
        ///
        /// * authorize_scopes
        ///
        /// * authorize_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * token_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * attributes_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
        ///
        ///
        ///
        ///
        /// * For SAML providers:
        ///
        /// * MetadataFile OR MetadataURL
        ///
        /// * IDPSignout (boolean) optional
        ///
        /// * IDPInit (boolean) optional
        ///
        /// * RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256
        ///
        /// * EncryptedResponses (boolean) optional
        public var identityProviderDetails: [Swift.String: Swift.String]?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderDetails: [Swift.String: Swift.String]? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProvider(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

public struct GetIdentityProviderOutput: Swift.Sendable {
    /// The identity provider.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

public struct ListIdentityProvidersInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalArn = portalArn
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of the identity provider.
    public struct IdentityProviderSummary: Swift.Sendable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderSummary(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderName: \"CONTENT_REDACTED\")"}
}

public struct ListIdentityProvidersOutput: Swift.Sendable {
    /// The identity providers.
    public var identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviders = identityProviders
        self.nextToken = nextToken
    }
}

public struct UpdateIdentityProviderInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    ///
    /// * IDPInit (boolean) optional
    ///
    /// * RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256
    ///
    /// * EncryptedResponses (boolean) optional
    public var identityProviderDetails: [Swift.String: Swift.String]?
    /// The name of the identity provider.
    public var identityProviderName: Swift.String?
    /// The type of the identity provider.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderArn: Swift.String? = nil,
        identityProviderDetails: [Swift.String: Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderArn = identityProviderArn
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
    }
}

extension UpdateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

public struct UpdateIdentityProviderOutput: Swift.Sendable {
    /// The identity provider.
    /// This member is required.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

extension WorkSpacesWebClientTypes {

    /// The IP rules of the IP access settings.
    public struct IpRule: Swift.Sendable {
        /// The description of the IP rule.
        public var description: Swift.String?
        /// The IP range of the IP rule.
        /// This member is required.
        public var ipRange: Swift.String?

        public init(
            description: Swift.String? = nil,
            ipRange: Swift.String? = nil
        )
        {
            self.description = description
            self.ipRange = ipRange
        }
    }
}

extension WorkSpacesWebClientTypes.IpRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpRule(description: \"CONTENT_REDACTED\", ipRange: \"CONTENT_REDACTED\")"}
}

public struct CreateIpAccessSettingsInput: Swift.Sendable {
    /// Additional encryption context of the IP access settings.
    public var additionalEncryptionContext: [Swift.String: Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the IP access settings.
    public var customerManagedKey: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The IP rules of the IP access settings.
    /// This member is required.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?
    /// The tags to add to the IP access settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.description = description
        self.displayName = displayName
        self.ipRules = ipRules
        self.tags = tags
    }
}

extension CreateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIpAccessSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateIpAccessSettingsOutput: Swift.Sendable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

public struct DeleteIpAccessSettingsInput: Swift.Sendable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

public struct DeleteIpAccessSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetIpAccessSettingsInput: Swift.Sendable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    /// The IP access settings resource that can be associated with a web portal.
    public struct IpAccessSettings: Swift.Sendable {
        /// The additional encryption context of the IP access settings.
        public var additionalEncryptionContext: [Swift.String: Swift.String]?
        /// A list of web portal ARNs that this IP access settings resource is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The creation date timestamp of the IP access settings.
        public var creationDate: Foundation.Date?
        /// The customer managed key used to encrypt sensitive information in the IP access settings.
        public var customerManagedKey: Swift.String?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings resource.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?
        /// The IP rules of the IP access settings.
        public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

        public init(
            additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
            associatedPortalArns: [Swift.String]? = nil,
            creationDate: Foundation.Date? = nil,
            customerManagedKey: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
        )
        {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.customerManagedKey = customerManagedKey
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettings(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), creationDate: \(Swift.String(describing: creationDate)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

public struct GetIpAccessSettingsOutput: Swift.Sendable {
    /// The IP access settings.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

public struct ListIpAccessSettingsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of IP access settings.
    public struct IpAccessSettingsSummary: Swift.Sendable {
        /// The creation date timestamp of the IP access settings.
        public var creationDate: Foundation.Date?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of IP access settings.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettingsSummary(creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

public struct ListIpAccessSettingsOutput: Swift.Sendable {
    /// The IP access settings.
    public var ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
        self.nextToken = nextToken
    }
}

public struct UpdateIpAccessSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The updated IP rules of the IP access settings.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipAccessSettingsArn: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.ipRules = ipRules
    }
}

extension UpdateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIpAccessSettingsInput(clientToken: \(Swift.String(describing: clientToken)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

public struct UpdateIpAccessSettingsOutput: Swift.Sendable {
    /// The IP access settings.
    /// This member is required.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

extension WorkSpacesWebClientTypes {

    public enum SessionSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startTimeAscending
        case startTimeDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionSortBy] {
            return [
                .startTimeAscending,
                .startTimeDescending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startTimeAscending: return "StartTimeAscending"
            case .startTimeDescending: return "StartTimeDescending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ID of the web portal for the sessions.
    /// This member is required.
    public var portalId: Swift.String?
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// The method in which the returned sessions should be sorted.
    public var sortBy: WorkSpacesWebClientTypes.SessionSortBy?
    /// The status of the session.
    public var status: WorkSpacesWebClientTypes.SessionStatus?
    /// The username of the session.
    public var username: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sortBy: WorkSpacesWebClientTypes.SessionSortBy? = nil,
        status: WorkSpacesWebClientTypes.SessionStatus? = nil,
        username: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
        self.sessionId = sessionId
        self.sortBy = sortBy
        self.status = status
        self.username = username
    }
}

extension ListSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSessionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), portalId: \(Swift.String(describing: portalId)), sessionId: \(Swift.String(describing: sessionId)), sortBy: \(Swift.String(describing: sortBy)), status: \(Swift.String(describing: status)), username: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {

    /// Summary information about a secure browser session.
    public struct SessionSummary: Swift.Sendable {
        /// The end time of the session.
        public var endTime: Foundation.Date?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The ID of the session.
        public var sessionId: Swift.String?
        /// The start time of the session.
        public var startTime: Foundation.Date?
        /// The status of the session.
        public var status: WorkSpacesWebClientTypes.SessionStatus?
        /// The username of the session.
        public var username: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            portalArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: WorkSpacesWebClientTypes.SessionStatus? = nil,
            username: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.portalArn = portalArn
            self.sessionId = sessionId
            self.startTime = startTime
            self.status = status
            self.username = username
        }
    }
}

extension WorkSpacesWebClientTypes.SessionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionSummary(endTime: \(Swift.String(describing: endTime)), portalArn: \(Swift.String(describing: portalArn)), sessionId: \(Swift.String(describing: sessionId)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), username: \"CONTENT_REDACTED\")"}
}

public struct ListSessionsOutput: Swift.Sendable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The sessions in a list.
    /// This member is required.
    public var sessions: [WorkSpacesWebClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [WorkSpacesWebClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags of the resource.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNetworkSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags to add to the network settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// The VPC that streaming instances will connect to.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

extension CreateNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSettingsInput(clientToken: \(Swift.String(describing: clientToken)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNetworkSettingsOutput: Swift.Sendable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

public struct DeleteNetworkSettingsInput: Swift.Sendable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

public struct DeleteNetworkSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetNetworkSettingsInput: Swift.Sendable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    /// A network settings resource that can be associated with a web portal. Once associated with a web portal, network settings define how streaming instances will connect with your specified VPC.
    public struct NetworkSettings: Swift.Sendable {
        /// A list of web portal ARNs that this network settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public var securityGroupIds: [Swift.String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public var subnetIds: [Swift.String]?
        /// The VPC that streaming instances will connect to.
        public var vpcId: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            networkSettingsArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

public struct GetNetworkSettingsOutput: Swift.Sendable {
    /// The network settings.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

public struct ListNetworkSettingsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of network settings.
    public struct NetworkSettingsSummary: Swift.Sendable {
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// The VPC ID of the network settings.
        public var vpcId: Swift.String?

        public init(
            networkSettingsArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }
    }
}

public struct ListNetworkSettingsOutput: Swift.Sendable {
    /// The network settings.
    public var networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSettings = networkSettings
        self.nextToken = nextToken
    }
}

public struct UpdateNetworkSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    public var subnetIds: [Swift.String]?
    /// The VPC that streaming instances will connect to.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkSettingsArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSettingsArn = networkSettingsArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public struct UpdateNetworkSettingsOutput: Swift.Sendable {
    /// The network settings.
    /// This member is required.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

extension WorkSpacesWebClientTypes {

    public enum BrowserType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chrome
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserType] {
            return [
                .chrome
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chrome: return "Chrome"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesWebClientTypes {

    public enum InstanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case standardLarge
        case standardRegular
        case standardXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .standardLarge,
                .standardRegular,
                .standardXlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .standardLarge: return "standard.large"
            case .standardRegular: return "standard.regular"
            case .standardXlarge: return "standard.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePortalInput: Swift.Sendable {
    /// The additional encryption context of the portal.
    public var additionalEncryptionContext: [Swift.String: Swift.String]?
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The customer managed key of the web portal.
    public var customerManagedKey: Swift.String?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The type and resources of the underlying instance.
    public var instanceType: WorkSpacesWebClientTypes.InstanceType?
    /// The maximum number of concurrent sessions for the portal.
    public var maxConcurrentSessions: Swift.Int?
    /// The tags to add to the web portal. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        displayName: Swift.String? = nil,
        instanceType: WorkSpacesWebClientTypes.InstanceType? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.authenticationType = authenticationType
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.displayName = displayName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.tags = tags
    }
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), authenticationType: \(Swift.String(describing: authenticationType)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), instanceType: \(Swift.String(describing: instanceType)), maxConcurrentSessions: \(Swift.String(describing: maxConcurrentSessions)), displayName: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreatePortalOutput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The endpoint URL of the web portal that users access in order to start streaming sessions.
    /// This member is required.
    public var portalEndpoint: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        portalEndpoint: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalEndpoint = portalEndpoint
    }
}

public struct DeletePortalInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DeletePortalOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateBrowserSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateBrowserSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateIpAccessSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateIpAccessSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateNetworkSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateNetworkSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateTrustStoreInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateTrustStoreOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateUserAccessLoggingSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateUserAccessLoggingSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateUserSettingsInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct DisassociateUserSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetPortalInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

extension WorkSpacesWebClientTypes {

    public enum PortalStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case incomplete
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalStatus] {
            return [
                .active,
                .incomplete,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .incomplete: return "Incomplete"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesWebClientTypes {

    public enum RendererType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appstream
        case sdkUnknown(Swift.String)

        public static var allCases: [RendererType] {
            return [
                .appstream
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "AppStream"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesWebClientTypes {

    /// The web portal.
    public struct Portal: Swift.Sendable {
        /// The additional encryption context of the portal.
        public var additionalEncryptionContext: [Swift.String: Swift.String]?
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with this web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser that users see when using a streaming session.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: Foundation.Date?
        /// The customer managed key used to encrypt sensitive information in the portal.
        public var customerManagedKey: Swift.String?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The type and resources of the underlying instance.
        public var instanceType: WorkSpacesWebClientTypes.InstanceType?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The maximum number of concurrent sessions for the portal.
        public var maxConcurrentSessions: Swift.Int?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// A message that explains why the web portal is in its current status.
        public var statusReason: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: Foundation.Date? = nil,
            customerManagedKey: Swift.String? = nil,
            displayName: Swift.String? = nil,
            instanceType: WorkSpacesWebClientTypes.InstanceType? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            maxConcurrentSessions: Swift.Int? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            statusReason: Swift.String? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.customerManagedKey = customerManagedKey
            self.displayName = displayName
            self.instanceType = instanceType
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.maxConcurrentSessions = maxConcurrentSessions
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }
}

extension WorkSpacesWebClientTypes.Portal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Portal(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), instanceType: \(Swift.String(describing: instanceType)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), maxConcurrentSessions: \(Swift.String(describing: maxConcurrentSessions)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), statusReason: \(Swift.String(describing: statusReason)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

public struct GetPortalOutput: Swift.Sendable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

public struct GetPortalServiceProviderMetadataInput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

public struct GetPortalServiceProviderMetadataOutput: Swift.Sendable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service provider SAML metadata.
    public var serviceProviderSamlMetadata: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

public struct ListPortalsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of the portal.
    public struct PortalSummary: Swift.Sendable {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with the web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser type of the web portal.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: Foundation.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The type and resources of the underlying instance.
        public var instanceType: WorkSpacesWebClientTypes.InstanceType?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The maximum number of concurrent sessions for the portal.
        public var maxConcurrentSessions: Swift.Int?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            instanceType: WorkSpacesWebClientTypes.InstanceType? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            maxConcurrentSessions: Swift.Int? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.instanceType = instanceType
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.maxConcurrentSessions = maxConcurrentSessions
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), instanceType: \(Swift.String(describing: instanceType)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), maxConcurrentSessions: \(Swift.String(describing: maxConcurrentSessions)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

public struct ListPortalsOutput: Swift.Sendable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The portals in the list.
    public var portals: [WorkSpacesWebClientTypes.PortalSummary]?

    public init(
        nextToken: Swift.String? = nil,
        portals: [WorkSpacesWebClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portals = portals
    }
}

public struct UpdatePortalInput: Swift.Sendable {
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The type and resources of the underlying instance.
    public var instanceType: WorkSpacesWebClientTypes.InstanceType?
    /// The maximum number of concurrent sessions for the portal.
    public var maxConcurrentSessions: Swift.Int?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        displayName: Swift.String? = nil,
        instanceType: WorkSpacesWebClientTypes.InstanceType? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.displayName = displayName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.portalArn = portalArn
    }
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(authenticationType: \(Swift.String(describing: authenticationType)), instanceType: \(Swift.String(describing: instanceType)), maxConcurrentSessions: \(Swift.String(describing: maxConcurrentSessions)), portalArn: \(Swift.String(describing: portalArn)), displayName: \"CONTENT_REDACTED\")"}
}

public struct UpdatePortalOutput: Swift.Sendable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

/// There are too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource affected.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(clientToken: \(Swift.String(describing: clientToken)), resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesWebClientTypes {

    /// The summary of the certificate.
    public struct CertificateSummary: Swift.Sendable {
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: Foundation.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: Foundation.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            issuer: Swift.String? = nil,
            notValidAfter: Foundation.Date? = nil,
            notValidBefore: Foundation.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }
}

public struct CreateTrustStoreInput: Swift.Sendable {
    /// A list of CA certificates to be added to the trust store.
    /// This member is required.
    public var certificateList: [Foundation.Data]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The tags to add to the trust store. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        certificateList: [Foundation.Data]? = nil,
        clientToken: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.certificateList = certificateList
        self.clientToken = clientToken
        self.tags = tags
    }
}

extension CreateTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrustStoreInput(certificateList: \(Swift.String(describing: certificateList)), clientToken: \(Swift.String(describing: clientToken)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateTrustStoreOutput: Swift.Sendable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

public struct DeleteTrustStoreInput: Swift.Sendable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

public struct DeleteTrustStoreOutput: Swift.Sendable {

    public init() { }
}

public struct GetTrustStoreInput: Swift.Sendable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

extension WorkSpacesWebClientTypes {

    /// A trust store that can be associated with a web portal. A trust store contains certificate authority (CA) certificates. Once associated with a web portal, the browser in a streaming session will recognize certificates that have been issued using any of the CAs in the trust store. If your organization has internal websites that use certificates issued by private CAs, you should add the private CA certificate to the trust store.
    public struct TrustStore: Swift.Sendable {
        /// A list of web portal ARNs that this trust store is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the trust store.
        /// This member is required.
        public var trustStoreArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            trustStoreArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }
    }
}

public struct GetTrustStoreOutput: Swift.Sendable {
    /// The trust store.
    public var trustStore: WorkSpacesWebClientTypes.TrustStore?

    public init(
        trustStore: WorkSpacesWebClientTypes.TrustStore? = nil
    )
    {
        self.trustStore = trustStore
    }
}

public struct GetTrustStoreCertificateInput: Swift.Sendable {
    /// The thumbprint of the trust store certificate.
    /// This member is required.
    public var thumbprint: Swift.String?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        thumbprint: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.thumbprint = thumbprint
        self.trustStoreArn = trustStoreArn
    }
}

extension WorkSpacesWebClientTypes {

    /// The certificate.
    public struct Certificate: Swift.Sendable {
        /// The body of the certificate.
        public var body: Foundation.Data?
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: Foundation.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: Foundation.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            body: Foundation.Data? = nil,
            issuer: Swift.String? = nil,
            notValidAfter: Foundation.Date? = nil,
            notValidBefore: Foundation.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }
}

public struct GetTrustStoreCertificateOutput: Swift.Sendable {
    /// The certificate of the trust store certificate.
    public var certificate: WorkSpacesWebClientTypes.Certificate?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificate: WorkSpacesWebClientTypes.Certificate? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.trustStoreArn = trustStoreArn
    }
}

public struct ListTrustStoreCertificatesInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the trust store
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

public struct ListTrustStoreCertificatesOutput: Swift.Sendable {
    /// The certificate list.
    public var certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.>
    public var nextToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificateList: [WorkSpacesWebClientTypes.CertificateSummary]? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificateList = certificateList
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

public struct ListTrustStoresInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of the trust store.
    public struct TrustStoreSummary: Swift.Sendable {
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init(
            trustStoreArn: Swift.String? = nil
        )
        {
            self.trustStoreArn = trustStoreArn
        }
    }
}

public struct ListTrustStoresOutput: Swift.Sendable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The trust stores.
    public var trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustStores = trustStores
    }
}

public struct UpdateTrustStoreInput: Swift.Sendable {
    /// A list of CA certificates to add to the trust store.
    public var certificatesToAdd: [Foundation.Data]?
    /// A list of CA certificates to delete from a trust store.
    public var certificatesToDelete: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificatesToAdd: [Foundation.Data]? = nil,
        certificatesToDelete: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificatesToAdd = certificatesToAdd
        self.certificatesToDelete = certificatesToDelete
        self.clientToken = clientToken
        self.trustStoreArn = trustStoreArn
    }
}

public struct UpdateTrustStoreOutput: Swift.Sendable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CreateUserAccessLoggingSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    /// This member is required.
    public var kinesisStreamArn: Swift.String?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.tags = tags
    }
}

extension CreateUserAccessLoggingSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserAccessLoggingSettingsInput(clientToken: \(Swift.String(describing: clientToken)), kinesisStreamArn: \(Swift.String(describing: kinesisStreamArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateUserAccessLoggingSettingsOutput: Swift.Sendable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

public struct DeleteUserAccessLoggingSettingsInput: Swift.Sendable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

public struct DeleteUserAccessLoggingSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetUserAccessLoggingSettingsInput: Swift.Sendable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    /// A user access logging settings resource that can be associated with a web portal.
    public struct UserAccessLoggingSettings: Swift.Sendable {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }
}

public struct GetUserAccessLoggingSettingsOutput: Swift.Sendable {
    /// The user access logging settings.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

public struct ListUserAccessLoggingSettingsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of user access logging settings.
    public struct UserAccessLoggingSettingsSummary: Swift.Sendable {
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }
}

public struct ListUserAccessLoggingSettingsOutput: Swift.Sendable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user access logging settings.
    public var userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

public struct UpdateUserAccessLoggingSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    public var kinesisStreamArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

public struct UpdateUserAccessLoggingSettingsOutput: Swift.Sendable {
    /// The user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

extension WorkSpacesWebClientTypes {

    /// Specifies a single cookie or set of cookies in an end user's browser.
    public struct CookieSpecification: Swift.Sendable {
        /// The domain of the cookie.
        /// This member is required.
        public var domain: Swift.String?
        /// The name of the cookie.
        public var name: Swift.String?
        /// The path of the cookie.
        public var path: Swift.String?

        public init(
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.path = path
        }
    }
}

extension WorkSpacesWebClientTypes.CookieSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CookieSpecification(domain: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", path: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {

    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public struct CookieSynchronizationConfiguration: Swift.Sendable {
        /// The list of cookie specifications that are allowed to be synchronized to the remote browser.
        /// This member is required.
        public var allowlist: [WorkSpacesWebClientTypes.CookieSpecification]?
        /// The list of cookie specifications that are blocked from being synchronized to the remote browser.
        public var blocklist: [WorkSpacesWebClientTypes.CookieSpecification]?

        public init(
            allowlist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil,
            blocklist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil
        )
        {
            self.allowlist = allowlist
            self.blocklist = blocklist
        }
    }
}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {

    public enum EnabledType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnabledType] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUserSettingsInput: Swift.Sendable {
    /// The additional encryption context of the user settings.
    public var additionalEncryptionContext: [Swift.String: Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    /// This member is required.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The customer managed key used to encrypt sensitive information in the user settings.
    public var customerManagedKey: Swift.String?
    /// Specifies whether the user can use deep links that open automatically when connecting to a session.
    public var deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    /// This member is required.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    /// This member is required.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    /// This member is required.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    /// This member is required.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?

    public init(
        additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        customerManagedKey: Swift.String? = nil,
        deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.customerManagedKey = customerManagedKey
        self.deepLinkAllowed = deepLinkAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.tags = tags
        self.uploadAllowed = uploadAllowed
    }
}

extension CreateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), deepLinkAllowed: \(Swift.String(describing: deepLinkAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateUserSettingsOutput: Swift.Sendable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

public struct DeleteUserSettingsInput: Swift.Sendable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

public struct DeleteUserSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct GetUserSettingsInput: Swift.Sendable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

extension WorkSpacesWebClientTypes {

    /// A user settings resource that can be associated with a web portal. Once associated with a web portal, user settings control how users can transfer data between a streaming session and the their local devices.
    public struct UserSettings: Swift.Sendable {
        /// The additional encryption context of the user settings.
        public var additionalEncryptionContext: [Swift.String: Swift.String]?
        /// A list of web portal ARNs that this user settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The customer managed key used to encrypt sensitive information in the user settings.
        public var customerManagedKey: Swift.String?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public var deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            additionalEncryptionContext: [Swift.String: Swift.String]? = nil,
            associatedPortalArns: [Swift.String]? = nil,
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            customerManagedKey: Swift.String? = nil,
            deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.customerManagedKey = customerManagedKey
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }
}

extension WorkSpacesWebClientTypes.UserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettings(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), copyAllowed: \(Swift.String(describing: copyAllowed)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), deepLinkAllowed: \(Swift.String(describing: deepLinkAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

public struct GetUserSettingsOutput: Swift.Sendable {
    /// The user settings.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

public struct ListUserSettingsInput: Swift.Sendable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesWebClientTypes {

    /// The summary of user settings.
    public struct UserSettingsSummary: Swift.Sendable {
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public var deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }
}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettingsSummary(copyAllowed: \(Swift.String(describing: copyAllowed)), deepLinkAllowed: \(Swift.String(describing: deepLinkAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

public struct ListUserSettingsOutput: Swift.Sendable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user settings.
    public var userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSettings = userSettings
    }
}

public struct UpdateUserSettingsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser. If the allowlist and blocklist are empty, the configuration becomes null.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can use deep links that open automatically when connecting to a session.
    public var deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        deepLinkAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.deepLinkAllowed = deepLinkAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.uploadAllowed = uploadAllowed
        self.userSettingsArn = userSettingsArn
    }
}

extension UpdateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsInput(clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), deepLinkAllowed: \(Swift.String(describing: deepLinkAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

public struct UpdateUserSettingsOutput: Swift.Sendable {
    /// The user settings.
    /// This member is required.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

extension AssociateBrowserSettingsInput {

    static func urlPathProvider(_ value: AssociateBrowserSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

extension AssociateBrowserSettingsInput {

    static func queryItemProvider(_ value: AssociateBrowserSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let browserSettingsArn = value.browserSettingsArn else {
            let message = "Creating a URL Query Item failed. browserSettingsArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let browserSettingsArnQueryItem = Smithy.URIQueryItem(name: "browserSettingsArn".urlPercentEncoding(), value: Swift.String(browserSettingsArn).urlPercentEncoding())
        items.append(browserSettingsArnQueryItem)
        return items
    }
}

extension AssociateIpAccessSettingsInput {

    static func urlPathProvider(_ value: AssociateIpAccessSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

extension AssociateIpAccessSettingsInput {

    static func queryItemProvider(_ value: AssociateIpAccessSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let ipAccessSettingsArn = value.ipAccessSettingsArn else {
            let message = "Creating a URL Query Item failed. ipAccessSettingsArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let ipAccessSettingsArnQueryItem = Smithy.URIQueryItem(name: "ipAccessSettingsArn".urlPercentEncoding(), value: Swift.String(ipAccessSettingsArn).urlPercentEncoding())
        items.append(ipAccessSettingsArnQueryItem)
        return items
    }
}

extension AssociateNetworkSettingsInput {

    static func urlPathProvider(_ value: AssociateNetworkSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

extension AssociateNetworkSettingsInput {

    static func queryItemProvider(_ value: AssociateNetworkSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let networkSettingsArn = value.networkSettingsArn else {
            let message = "Creating a URL Query Item failed. networkSettingsArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let networkSettingsArnQueryItem = Smithy.URIQueryItem(name: "networkSettingsArn".urlPercentEncoding(), value: Swift.String(networkSettingsArn).urlPercentEncoding())
        items.append(networkSettingsArnQueryItem)
        return items
    }
}

extension AssociateTrustStoreInput {

    static func urlPathProvider(_ value: AssociateTrustStoreInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

extension AssociateTrustStoreInput {

    static func queryItemProvider(_ value: AssociateTrustStoreInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let trustStoreArn = value.trustStoreArn else {
            let message = "Creating a URL Query Item failed. trustStoreArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let trustStoreArnQueryItem = Smithy.URIQueryItem(name: "trustStoreArn".urlPercentEncoding(), value: Swift.String(trustStoreArn).urlPercentEncoding())
        items.append(trustStoreArnQueryItem)
        return items
    }
}

extension AssociateUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: AssociateUserAccessLoggingSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

extension AssociateUserAccessLoggingSettingsInput {

    static func queryItemProvider(_ value: AssociateUserAccessLoggingSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let userAccessLoggingSettingsArn = value.userAccessLoggingSettingsArn else {
            let message = "Creating a URL Query Item failed. userAccessLoggingSettingsArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let userAccessLoggingSettingsArnQueryItem = Smithy.URIQueryItem(name: "userAccessLoggingSettingsArn".urlPercentEncoding(), value: Swift.String(userAccessLoggingSettingsArn).urlPercentEncoding())
        items.append(userAccessLoggingSettingsArnQueryItem)
        return items
    }
}

extension AssociateUserSettingsInput {

    static func urlPathProvider(_ value: AssociateUserSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

extension AssociateUserSettingsInput {

    static func queryItemProvider(_ value: AssociateUserSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let userSettingsArn = value.userSettingsArn else {
            let message = "Creating a URL Query Item failed. userSettingsArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let userSettingsArnQueryItem = Smithy.URIQueryItem(name: "userSettingsArn".urlPercentEncoding(), value: Swift.String(userSettingsArn).urlPercentEncoding())
        items.append(userSettingsArnQueryItem)
        return items
    }
}

extension CreateBrowserSettingsInput {

    static func urlPathProvider(_ value: CreateBrowserSettingsInput) -> Swift.String? {
        return "/browserSettings"
    }
}

extension CreateIdentityProviderInput {

    static func urlPathProvider(_ value: CreateIdentityProviderInput) -> Swift.String? {
        return "/identityProviders"
    }
}

extension CreateIpAccessSettingsInput {

    static func urlPathProvider(_ value: CreateIpAccessSettingsInput) -> Swift.String? {
        return "/ipAccessSettings"
    }
}

extension CreateNetworkSettingsInput {

    static func urlPathProvider(_ value: CreateNetworkSettingsInput) -> Swift.String? {
        return "/networkSettings"
    }
}

extension CreatePortalInput {

    static func urlPathProvider(_ value: CreatePortalInput) -> Swift.String? {
        return "/portals"
    }
}

extension CreateTrustStoreInput {

    static func urlPathProvider(_ value: CreateTrustStoreInput) -> Swift.String? {
        return "/trustStores"
    }
}

extension CreateUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: CreateUserAccessLoggingSettingsInput) -> Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

extension CreateUserSettingsInput {

    static func urlPathProvider(_ value: CreateUserSettingsInput) -> Swift.String? {
        return "/userSettings"
    }
}

extension DeleteBrowserSettingsInput {

    static func urlPathProvider(_ value: DeleteBrowserSettingsInput) -> Swift.String? {
        guard let browserSettingsArn = value.browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteIdentityProviderInput {

    static func urlPathProvider(_ value: DeleteIdentityProviderInput) -> Swift.String? {
        guard let identityProviderArn = value.identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteIpAccessSettingsInput {

    static func urlPathProvider(_ value: DeleteIpAccessSettingsInput) -> Swift.String? {
        guard let ipAccessSettingsArn = value.ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteNetworkSettingsInput {

    static func urlPathProvider(_ value: DeleteNetworkSettingsInput) -> Swift.String? {
        guard let networkSettingsArn = value.networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeletePortalInput {

    static func urlPathProvider(_ value: DeletePortalInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteTrustStoreInput {

    static func urlPathProvider(_ value: DeleteTrustStoreInput) -> Swift.String? {
        guard let trustStoreArn = value.trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: DeleteUserAccessLoggingSettingsInput) -> Swift.String? {
        guard let userAccessLoggingSettingsArn = value.userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteUserSettingsInput {

    static func urlPathProvider(_ value: DeleteUserSettingsInput) -> Swift.String? {
        guard let userSettingsArn = value.userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DisassociateBrowserSettingsInput {

    static func urlPathProvider(_ value: DisassociateBrowserSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

extension DisassociateIpAccessSettingsInput {

    static func urlPathProvider(_ value: DisassociateIpAccessSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

extension DisassociateNetworkSettingsInput {

    static func urlPathProvider(_ value: DisassociateNetworkSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

extension DisassociateTrustStoreInput {

    static func urlPathProvider(_ value: DisassociateTrustStoreInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

extension DisassociateUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: DisassociateUserAccessLoggingSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

extension DisassociateUserSettingsInput {

    static func urlPathProvider(_ value: DisassociateUserSettingsInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

extension ExpireSessionInput {

    static func urlPathProvider(_ value: ExpireSessionInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension GetBrowserSettingsInput {

    static func urlPathProvider(_ value: GetBrowserSettingsInput) -> Swift.String? {
        guard let browserSettingsArn = value.browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetIdentityProviderInput {

    static func urlPathProvider(_ value: GetIdentityProviderInput) -> Swift.String? {
        guard let identityProviderArn = value.identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetIpAccessSettingsInput {

    static func urlPathProvider(_ value: GetIpAccessSettingsInput) -> Swift.String? {
        guard let ipAccessSettingsArn = value.ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetNetworkSettingsInput {

    static func urlPathProvider(_ value: GetNetworkSettingsInput) -> Swift.String? {
        guard let networkSettingsArn = value.networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetPortalInput {

    static func urlPathProvider(_ value: GetPortalInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetPortalServiceProviderMetadataInput {

    static func urlPathProvider(_ value: GetPortalServiceProviderMetadataInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portalIdp/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension GetTrustStoreInput {

    static func urlPathProvider(_ value: GetTrustStoreInput) -> Swift.String? {
        guard let trustStoreArn = value.trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetTrustStoreCertificateInput {

    static func urlPathProvider(_ value: GetTrustStoreCertificateInput) -> Swift.String? {
        guard let trustStoreArn = value.trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificate"
    }
}

extension GetTrustStoreCertificateInput {

    static func queryItemProvider(_ value: GetTrustStoreCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let thumbprint = value.thumbprint else {
            let message = "Creating a URL Query Item failed. thumbprint is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let thumbprintQueryItem = Smithy.URIQueryItem(name: "thumbprint".urlPercentEncoding(), value: Swift.String(thumbprint).urlPercentEncoding())
        items.append(thumbprintQueryItem)
        return items
    }
}

extension GetUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: GetUserAccessLoggingSettingsInput) -> Swift.String? {
        guard let userAccessLoggingSettingsArn = value.userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetUserSettingsInput {

    static func urlPathProvider(_ value: GetUserSettingsInput) -> Swift.String? {
        guard let userSettingsArn = value.userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension ListBrowserSettingsInput {

    static func urlPathProvider(_ value: ListBrowserSettingsInput) -> Swift.String? {
        return "/browserSettings"
    }
}

extension ListBrowserSettingsInput {

    static func queryItemProvider(_ value: ListBrowserSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdentityProvidersInput {

    static func urlPathProvider(_ value: ListIdentityProvidersInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/identityProviders"
    }
}

extension ListIdentityProvidersInput {

    static func queryItemProvider(_ value: ListIdentityProvidersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIpAccessSettingsInput {

    static func urlPathProvider(_ value: ListIpAccessSettingsInput) -> Swift.String? {
        return "/ipAccessSettings"
    }
}

extension ListIpAccessSettingsInput {

    static func queryItemProvider(_ value: ListIpAccessSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNetworkSettingsInput {

    static func urlPathProvider(_ value: ListNetworkSettingsInput) -> Swift.String? {
        return "/networkSettings"
    }
}

extension ListNetworkSettingsInput {

    static func queryItemProvider(_ value: ListNetworkSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPortalsInput {

    static func urlPathProvider(_ value: ListPortalsInput) -> Swift.String? {
        return "/portals"
    }
}

extension ListPortalsInput {

    static func queryItemProvider(_ value: ListPortalsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())/sessions"
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let sessionId = value.sessionId {
            let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
            items.append(sessionIdQueryItem)
        }
        if let username = value.username {
            let usernameQueryItem = Smithy.URIQueryItem(name: "username".urlPercentEncoding(), value: Swift.String(username).urlPercentEncoding())
            items.append(usernameQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension ListTrustStoreCertificatesInput {

    static func urlPathProvider(_ value: ListTrustStoreCertificatesInput) -> Swift.String? {
        guard let trustStoreArn = value.trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificates"
    }
}

extension ListTrustStoreCertificatesInput {

    static func queryItemProvider(_ value: ListTrustStoreCertificatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTrustStoresInput {

    static func urlPathProvider(_ value: ListTrustStoresInput) -> Swift.String? {
        return "/trustStores"
    }
}

extension ListTrustStoresInput {

    static func queryItemProvider(_ value: ListTrustStoresInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: ListUserAccessLoggingSettingsInput) -> Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

extension ListUserAccessLoggingSettingsInput {

    static func queryItemProvider(_ value: ListUserAccessLoggingSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserSettingsInput {

    static func urlPathProvider(_ value: ListUserSettingsInput) -> Swift.String? {
        return "/userSettings"
    }
}

extension ListUserSettingsInput {

    static func queryItemProvider(_ value: ListUserSettingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateBrowserSettingsInput {

    static func urlPathProvider(_ value: UpdateBrowserSettingsInput) -> Swift.String? {
        guard let browserSettingsArn = value.browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateIdentityProviderInput {

    static func urlPathProvider(_ value: UpdateIdentityProviderInput) -> Swift.String? {
        guard let identityProviderArn = value.identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateIpAccessSettingsInput {

    static func urlPathProvider(_ value: UpdateIpAccessSettingsInput) -> Swift.String? {
        guard let ipAccessSettingsArn = value.ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateNetworkSettingsInput {

    static func urlPathProvider(_ value: UpdateNetworkSettingsInput) -> Swift.String? {
        guard let networkSettingsArn = value.networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdatePortalInput {

    static func urlPathProvider(_ value: UpdatePortalInput) -> Swift.String? {
        guard let portalArn = value.portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateTrustStoreInput {

    static func urlPathProvider(_ value: UpdateTrustStoreInput) -> Swift.String? {
        guard let trustStoreArn = value.trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateUserAccessLoggingSettingsInput {

    static func urlPathProvider(_ value: UpdateUserAccessLoggingSettingsInput) -> Swift.String? {
        guard let userAccessLoggingSettingsArn = value.userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateUserSettingsInput {

    static func urlPathProvider(_ value: UpdateUserSettingsInput) -> Swift.String? {
        guard let userSettingsArn = value.userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension CreateBrowserSettingsInput {

    static func write(value: CreateBrowserSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalEncryptionContext"].writeMap(value.additionalEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["browserPolicy"].write(value.browserPolicy)
        try writer["clientToken"].write(value.clientToken)
        try writer["customerManagedKey"].write(value.customerManagedKey)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIdentityProviderInput {

    static func write(value: CreateIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["identityProviderDetails"].writeMap(value.identityProviderDetails, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["identityProviderName"].write(value.identityProviderName)
        try writer["identityProviderType"].write(value.identityProviderType)
        try writer["portalArn"].write(value.portalArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIpAccessSettingsInput {

    static func write(value: CreateIpAccessSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalEncryptionContext"].writeMap(value.additionalEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["customerManagedKey"].write(value.customerManagedKey)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["ipRules"].writeList(value.ipRules, memberWritingClosure: WorkSpacesWebClientTypes.IpRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateNetworkSettingsInput {

    static func write(value: CreateNetworkSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension CreatePortalInput {

    static func write(value: CreatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalEncryptionContext"].writeMap(value.additionalEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["authenticationType"].write(value.authenticationType)
        try writer["clientToken"].write(value.clientToken)
        try writer["customerManagedKey"].write(value.customerManagedKey)
        try writer["displayName"].write(value.displayName)
        try writer["instanceType"].write(value.instanceType)
        try writer["maxConcurrentSessions"].write(value.maxConcurrentSessions)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTrustStoreInput {

    static func write(value: CreateTrustStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateList"].writeList(value.certificateList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeData(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateUserAccessLoggingSettingsInput {

    static func write(value: CreateUserAccessLoggingSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["kinesisStreamArn"].write(value.kinesisStreamArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateUserSettingsInput {

    static func write(value: CreateUserSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalEncryptionContext"].writeMap(value.additionalEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["cookieSynchronizationConfiguration"].write(value.cookieSynchronizationConfiguration, with: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.write(value:to:))
        try writer["copyAllowed"].write(value.copyAllowed)
        try writer["customerManagedKey"].write(value.customerManagedKey)
        try writer["deepLinkAllowed"].write(value.deepLinkAllowed)
        try writer["disconnectTimeoutInMinutes"].write(value.disconnectTimeoutInMinutes)
        try writer["downloadAllowed"].write(value.downloadAllowed)
        try writer["idleDisconnectTimeoutInMinutes"].write(value.idleDisconnectTimeoutInMinutes)
        try writer["pasteAllowed"].write(value.pasteAllowed)
        try writer["printAllowed"].write(value.printAllowed)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["uploadAllowed"].write(value.uploadAllowed)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeList(value.tags, memberWritingClosure: WorkSpacesWebClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBrowserSettingsInput {

    static func write(value: UpdateBrowserSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["browserPolicy"].write(value.browserPolicy)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateIdentityProviderInput {

    static func write(value: UpdateIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["identityProviderDetails"].writeMap(value.identityProviderDetails, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["identityProviderName"].write(value.identityProviderName)
        try writer["identityProviderType"].write(value.identityProviderType)
    }
}

extension UpdateIpAccessSettingsInput {

    static func write(value: UpdateIpAccessSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["ipRules"].writeList(value.ipRules, memberWritingClosure: WorkSpacesWebClientTypes.IpRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateNetworkSettingsInput {

    static func write(value: UpdateNetworkSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension UpdatePortalInput {

    static func write(value: UpdatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationType"].write(value.authenticationType)
        try writer["displayName"].write(value.displayName)
        try writer["instanceType"].write(value.instanceType)
        try writer["maxConcurrentSessions"].write(value.maxConcurrentSessions)
    }
}

extension UpdateTrustStoreInput {

    static func write(value: UpdateTrustStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificatesToAdd"].writeList(value.certificatesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeData(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["certificatesToDelete"].writeList(value.certificatesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateUserAccessLoggingSettingsInput {

    static func write(value: UpdateUserAccessLoggingSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["kinesisStreamArn"].write(value.kinesisStreamArn)
    }
}

extension UpdateUserSettingsInput {

    static func write(value: UpdateUserSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["cookieSynchronizationConfiguration"].write(value.cookieSynchronizationConfiguration, with: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.write(value:to:))
        try writer["copyAllowed"].write(value.copyAllowed)
        try writer["deepLinkAllowed"].write(value.deepLinkAllowed)
        try writer["disconnectTimeoutInMinutes"].write(value.disconnectTimeoutInMinutes)
        try writer["downloadAllowed"].write(value.downloadAllowed)
        try writer["idleDisconnectTimeoutInMinutes"].write(value.idleDisconnectTimeoutInMinutes)
        try writer["pasteAllowed"].write(value.pasteAllowed)
        try writer["printAllowed"].write(value.printAllowed)
        try writer["uploadAllowed"].write(value.uploadAllowed)
    }
}

extension AssociateBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateBrowserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateBrowserSettingsOutput()
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent() ?? ""
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        return value
    }
}

extension AssociateIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateIpAccessSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateIpAccessSettingsOutput()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent() ?? ""
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        return value
    }
}

extension AssociateNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateNetworkSettingsOutput()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent() ?? ""
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        return value
    }
}

extension AssociateTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTrustStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateTrustStoreOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension AssociateUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateUserAccessLoggingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateUserAccessLoggingSettingsOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension AssociateUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateUserSettingsOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBrowserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBrowserSettingsOutput()
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdentityProviderOutput()
        value.identityProviderArn = try reader["identityProviderArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIpAccessSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIpAccessSettingsOutput()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkSettingsOutput()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortalOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.portalEndpoint = try reader["portalEndpoint"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrustStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrustStoreOutput()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserAccessLoggingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserAccessLoggingSettingsOutput()
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserSettingsOutput()
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBrowserSettingsOutput {
        return DeleteBrowserSettingsOutput()
    }
}

extension DeleteIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdentityProviderOutput {
        return DeleteIdentityProviderOutput()
    }
}

extension DeleteIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIpAccessSettingsOutput {
        return DeleteIpAccessSettingsOutput()
    }
}

extension DeleteNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkSettingsOutput {
        return DeleteNetworkSettingsOutput()
    }
}

extension DeletePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortalOutput {
        return DeletePortalOutput()
    }
}

extension DeleteTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrustStoreOutput {
        return DeleteTrustStoreOutput()
    }
}

extension DeleteUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserAccessLoggingSettingsOutput {
        return DeleteUserAccessLoggingSettingsOutput()
    }
}

extension DeleteUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserSettingsOutput {
        return DeleteUserSettingsOutput()
    }
}

extension DisassociateBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateBrowserSettingsOutput {
        return DisassociateBrowserSettingsOutput()
    }
}

extension DisassociateIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateIpAccessSettingsOutput {
        return DisassociateIpAccessSettingsOutput()
    }
}

extension DisassociateNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateNetworkSettingsOutput {
        return DisassociateNetworkSettingsOutput()
    }
}

extension DisassociateTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateTrustStoreOutput {
        return DisassociateTrustStoreOutput()
    }
}

extension DisassociateUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateUserAccessLoggingSettingsOutput {
        return DisassociateUserAccessLoggingSettingsOutput()
    }
}

extension DisassociateUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateUserSettingsOutput {
        return DisassociateUserSettingsOutput()
    }
}

extension ExpireSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExpireSessionOutput {
        return ExpireSessionOutput()
    }
}

extension GetBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBrowserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBrowserSettingsOutput()
        value.browserSettings = try reader["browserSettings"].readIfPresent(with: WorkSpacesWebClientTypes.BrowserSettings.read(from:))
        return value
    }
}

extension GetIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdentityProviderOutput()
        value.identityProvider = try reader["identityProvider"].readIfPresent(with: WorkSpacesWebClientTypes.IdentityProvider.read(from:))
        return value
    }
}

extension GetIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIpAccessSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIpAccessSettingsOutput()
        value.ipAccessSettings = try reader["ipAccessSettings"].readIfPresent(with: WorkSpacesWebClientTypes.IpAccessSettings.read(from:))
        return value
    }
}

extension GetNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkSettingsOutput()
        value.networkSettings = try reader["networkSettings"].readIfPresent(with: WorkSpacesWebClientTypes.NetworkSettings.read(from:))
        return value
    }
}

extension GetPortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortalOutput()
        value.portal = try reader["portal"].readIfPresent(with: WorkSpacesWebClientTypes.Portal.read(from:))
        return value
    }
}

extension GetPortalServiceProviderMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortalServiceProviderMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortalServiceProviderMetadataOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.serviceProviderSamlMetadata = try reader["serviceProviderSamlMetadata"].readIfPresent()
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.session = try reader["session"].readIfPresent(with: WorkSpacesWebClientTypes.Session.read(from:))
        return value
    }
}

extension GetTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrustStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrustStoreOutput()
        value.trustStore = try reader["trustStore"].readIfPresent(with: WorkSpacesWebClientTypes.TrustStore.read(from:))
        return value
    }
}

extension GetTrustStoreCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrustStoreCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrustStoreCertificateOutput()
        value.certificate = try reader["certificate"].readIfPresent(with: WorkSpacesWebClientTypes.Certificate.read(from:))
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserAccessLoggingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserAccessLoggingSettingsOutput()
        value.userAccessLoggingSettings = try reader["userAccessLoggingSettings"].readIfPresent(with: WorkSpacesWebClientTypes.UserAccessLoggingSettings.read(from:))
        return value
    }
}

extension GetUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserSettingsOutput()
        value.userSettings = try reader["userSettings"].readIfPresent(with: WorkSpacesWebClientTypes.UserSettings.read(from:))
        return value
    }
}

extension ListBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBrowserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBrowserSettingsOutput()
        value.browserSettings = try reader["browserSettings"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.BrowserSettingsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIdentityProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityProvidersOutput()
        value.identityProviders = try reader["identityProviders"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.IdentityProviderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIpAccessSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIpAccessSettingsOutput()
        value.ipAccessSettings = try reader["ipAccessSettings"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.IpAccessSettingsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworkSettingsOutput()
        value.networkSettings = try reader["networkSettings"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.NetworkSettingsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPortalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortalsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.portals = try reader["portals"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.PortalSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessions = try reader["sessions"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrustStoreCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrustStoreCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrustStoreCertificatesOutput()
        value.certificateList = try reader["certificateList"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.CertificateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListTrustStoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrustStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrustStoresOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.trustStores = try reader["trustStores"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.TrustStoreSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserAccessLoggingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserAccessLoggingSettingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.userAccessLoggingSettings = try reader["userAccessLoggingSettings"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserSettingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.userSettings = try reader["userSettings"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.UserSettingsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBrowserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBrowserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrowserSettingsOutput()
        value.browserSettings = try reader["browserSettings"].readIfPresent(with: WorkSpacesWebClientTypes.BrowserSettings.read(from:))
        return value
    }
}

extension UpdateIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdentityProviderOutput()
        value.identityProvider = try reader["identityProvider"].readIfPresent(with: WorkSpacesWebClientTypes.IdentityProvider.read(from:))
        return value
    }
}

extension UpdateIpAccessSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIpAccessSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIpAccessSettingsOutput()
        value.ipAccessSettings = try reader["ipAccessSettings"].readIfPresent(with: WorkSpacesWebClientTypes.IpAccessSettings.read(from:))
        return value
    }
}

extension UpdateNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkSettingsOutput()
        value.networkSettings = try reader["networkSettings"].readIfPresent(with: WorkSpacesWebClientTypes.NetworkSettings.read(from:))
        return value
    }
}

extension UpdatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortalOutput()
        value.portal = try reader["portal"].readIfPresent(with: WorkSpacesWebClientTypes.Portal.read(from:))
        return value
    }
}

extension UpdateTrustStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrustStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTrustStoreOutput()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateUserAccessLoggingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserAccessLoggingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserAccessLoggingSettingsOutput()
        value.userAccessLoggingSettings = try reader["userAccessLoggingSettings"].readIfPresent(with: WorkSpacesWebClientTypes.UserAccessLoggingSettings.read(from:))
        return value
    }
}

extension UpdateUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserSettingsOutput()
        value.userSettings = try reader["userSettings"].readIfPresent(with: WorkSpacesWebClientTypes.UserSettings.read(from:))
        return value
    }
}

enum AssociateBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExpireSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortalServiceProviderMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrustStoreCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrustStoreCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrustStoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBrowserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIpAccessSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrustStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserAccessLoggingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.BrowserSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.BrowserSettings()
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent() ?? ""
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.browserPolicy = try reader["browserPolicy"].readIfPresent()
        value.customerManagedKey = try reader["customerManagedKey"].readIfPresent()
        value.additionalEncryptionContext = try reader["additionalEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.IdentityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.IdentityProvider()
        value.identityProviderArn = try reader["identityProviderArn"].readIfPresent() ?? ""
        value.identityProviderName = try reader["identityProviderName"].readIfPresent()
        value.identityProviderType = try reader["identityProviderType"].readIfPresent()
        value.identityProviderDetails = try reader["identityProviderDetails"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.IpAccessSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.IpAccessSettings()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent() ?? ""
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipRules = try reader["ipRules"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.IpRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerManagedKey = try reader["customerManagedKey"].readIfPresent()
        value.additionalEncryptionContext = try reader["additionalEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesWebClientTypes.IpRule {

    static func write(value: WorkSpacesWebClientTypes.IpRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["ipRange"].write(value.ipRange)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.IpRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.IpRule()
        value.ipRange = try reader["ipRange"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.NetworkSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.NetworkSettings()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent() ?? ""
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesWebClientTypes.Portal {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.Portal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.Portal()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.rendererType = try reader["rendererType"].readIfPresent()
        value.browserType = try reader["browserType"].readIfPresent()
        value.portalStatus = try reader["portalStatus"].readIfPresent()
        value.portalEndpoint = try reader["portalEndpoint"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent()
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent()
        value.authenticationType = try reader["authenticationType"].readIfPresent()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent()
        value.customerManagedKey = try reader["customerManagedKey"].readIfPresent()
        value.additionalEncryptionContext = try reader["additionalEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.maxConcurrentSessions = try reader["maxConcurrentSessions"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.Session {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.Session {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.Session()
        value.portalArn = try reader["portalArn"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        value.clientIpAddresses = try reader["clientIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesWebClientTypes.TrustStore {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.TrustStore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.TrustStore()
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesWebClientTypes.Certificate {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.Certificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.Certificate()
        value.thumbprint = try reader["thumbprint"].readIfPresent()
        value.subject = try reader["subject"].readIfPresent()
        value.issuer = try reader["issuer"].readIfPresent()
        value.notValidBefore = try reader["notValidBefore"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notValidAfter = try reader["notValidAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.body = try reader["body"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.UserAccessLoggingSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.UserAccessLoggingSettings()
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent() ?? ""
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.kinesisStreamArn = try reader["kinesisStreamArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.UserSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.UserSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.UserSettings()
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent() ?? ""
        value.associatedPortalArns = try reader["associatedPortalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.copyAllowed = try reader["copyAllowed"].readIfPresent()
        value.pasteAllowed = try reader["pasteAllowed"].readIfPresent()
        value.downloadAllowed = try reader["downloadAllowed"].readIfPresent()
        value.uploadAllowed = try reader["uploadAllowed"].readIfPresent()
        value.printAllowed = try reader["printAllowed"].readIfPresent()
        value.disconnectTimeoutInMinutes = try reader["disconnectTimeoutInMinutes"].readIfPresent()
        value.idleDisconnectTimeoutInMinutes = try reader["idleDisconnectTimeoutInMinutes"].readIfPresent()
        value.cookieSynchronizationConfiguration = try reader["cookieSynchronizationConfiguration"].readIfPresent(with: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.read(from:))
        value.customerManagedKey = try reader["customerManagedKey"].readIfPresent()
        value.additionalEncryptionContext = try reader["additionalEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deepLinkAllowed = try reader["deepLinkAllowed"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration {

    static func write(value: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowlist"].writeList(value.allowlist, memberWritingClosure: WorkSpacesWebClientTypes.CookieSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blocklist"].writeList(value.blocklist, memberWritingClosure: WorkSpacesWebClientTypes.CookieSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.CookieSynchronizationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.CookieSynchronizationConfiguration()
        value.allowlist = try reader["allowlist"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.CookieSpecification.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.blocklist = try reader["blocklist"].readListIfPresent(memberReadingClosure: WorkSpacesWebClientTypes.CookieSpecification.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesWebClientTypes.CookieSpecification {

    static func write(value: WorkSpacesWebClientTypes.CookieSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domain"].write(value.domain)
        try writer["name"].write(value.name)
        try writer["path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.CookieSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.CookieSpecification()
        value.domain = try reader["domain"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.BrowserSettingsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.BrowserSettingsSummary()
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.IdentityProviderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.IdentityProviderSummary()
        value.identityProviderArn = try reader["identityProviderArn"].readIfPresent() ?? ""
        value.identityProviderName = try reader["identityProviderName"].readIfPresent()
        value.identityProviderType = try reader["identityProviderType"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.IpAccessSettingsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.IpAccessSettingsSummary()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.NetworkSettingsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.NetworkSettingsSummary()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent() ?? ""
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.PortalSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.PortalSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.PortalSummary()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.rendererType = try reader["rendererType"].readIfPresent()
        value.browserType = try reader["browserType"].readIfPresent()
        value.portalStatus = try reader["portalStatus"].readIfPresent()
        value.portalEndpoint = try reader["portalEndpoint"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.browserSettingsArn = try reader["browserSettingsArn"].readIfPresent()
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent()
        value.networkSettingsArn = try reader["networkSettingsArn"].readIfPresent()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent()
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent()
        value.authenticationType = try reader["authenticationType"].readIfPresent()
        value.ipAccessSettingsArn = try reader["ipAccessSettingsArn"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.maxConcurrentSessions = try reader["maxConcurrentSessions"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.SessionSummary()
        value.portalArn = try reader["portalArn"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesWebClientTypes.Tag {

    static func write(value: WorkSpacesWebClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesWebClientTypes.CertificateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.CertificateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.CertificateSummary()
        value.thumbprint = try reader["thumbprint"].readIfPresent()
        value.subject = try reader["subject"].readIfPresent()
        value.issuer = try reader["issuer"].readIfPresent()
        value.notValidBefore = try reader["notValidBefore"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notValidAfter = try reader["notValidAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesWebClientTypes.TrustStoreSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.TrustStoreSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.TrustStoreSummary()
        value.trustStoreArn = try reader["trustStoreArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary()
        value.userAccessLoggingSettingsArn = try reader["userAccessLoggingSettingsArn"].readIfPresent() ?? ""
        value.kinesisStreamArn = try reader["kinesisStreamArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.UserSettingsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.UserSettingsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.UserSettingsSummary()
        value.userSettingsArn = try reader["userSettingsArn"].readIfPresent() ?? ""
        value.copyAllowed = try reader["copyAllowed"].readIfPresent()
        value.pasteAllowed = try reader["pasteAllowed"].readIfPresent()
        value.downloadAllowed = try reader["downloadAllowed"].readIfPresent()
        value.uploadAllowed = try reader["uploadAllowed"].readIfPresent()
        value.printAllowed = try reader["printAllowed"].readIfPresent()
        value.disconnectTimeoutInMinutes = try reader["disconnectTimeoutInMinutes"].readIfPresent()
        value.idleDisconnectTimeoutInMinutes = try reader["idleDisconnectTimeoutInMinutes"].readIfPresent()
        value.cookieSynchronizationConfiguration = try reader["cookieSynchronizationConfiguration"].readIfPresent(with: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.read(from:))
        value.deepLinkAllowed = try reader["deepLinkAllowed"].readIfPresent()
        return value
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesWebClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesWebClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum WorkSpacesWebClientTypes {}
