// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let browserSettingsArn = browserSettingsArn else {
                let message = "Creating a URL Query Item failed. browserSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let browserSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "browserSettingsArn".urlPercentEncoding(), value: Swift.String(browserSettingsArn).urlPercentEncoding())
            items.append(browserSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/browserSettings"
    }
}

public struct AssociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsInputBody: Swift.Equatable {
}

extension AssociateBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.browserSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let browserSettingsArn: Swift.String?
}

extension AssociateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let networkSettingsArn = networkSettingsArn else {
                let message = "Creating a URL Query Item failed. networkSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let networkSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "networkSettingsArn".urlPercentEncoding(), value: Swift.String(networkSettingsArn).urlPercentEncoding())
            items.append(networkSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/networkSettings"
    }
}

public struct AssociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsInputBody: Swift.Equatable {
}

extension AssociateNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.networkSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let networkSettingsArn: Swift.String?
}

extension AssociateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

extension AssociateTrustStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let trustStoreArn = trustStoreArn else {
                let message = "Creating a URL Query Item failed. trustStoreArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let trustStoreArnQueryItem = ClientRuntime.URLQueryItem(name: "trustStoreArn".urlPercentEncoding(), value: Swift.String(trustStoreArn).urlPercentEncoding())
            items.append(trustStoreArnQueryItem)
            return items
        }
    }
}

extension AssociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/trustStores"
    }
}

public struct AssociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreInputBody: Swift.Equatable {
}

extension AssociateTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.portalArn = nil
            self.trustStoreArn = nil
        }
    }
}

public struct AssociateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let trustStoreArn: Swift.String?
}

extension AssociateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
                let message = "Creating a URL Query Item failed. userAccessLoggingSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let userAccessLoggingSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userAccessLoggingSettingsArn".urlPercentEncoding(), value: Swift.String(userAccessLoggingSettingsArn).urlPercentEncoding())
            items.append(userAccessLoggingSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/userAccessLoggingSettings"
    }
}

public struct AssociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension AssociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.portalArn = nil
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct AssociateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userAccessLoggingSettingsArn: Swift.String?
}

extension AssociateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userAccessLoggingSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension AssociateUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userSettingsArn = userSettingsArn else {
                let message = "Creating a URL Query Item failed. userSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let userSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userSettingsArn".urlPercentEncoding(), value: Swift.String(userSettingsArn).urlPercentEncoding())
            items.append(userSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/userSettings"
    }
}

public struct AssociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsInputBody: Swift.Equatable {
}

extension AssociateUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.portalArn = nil
            self.userSettingsArn = nil
        }
    }
}

public struct AssociateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userSettingsArn: Swift.String?
}

extension AssociateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case browserPolicy
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The browser settings resource that can be associated with a web portal. Once associated with a web portal, browser settings control how the browser will behave once a user starts a streaming session for the web portal.
    public struct BrowserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this browser settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public var browserPolicy: Swift.String?
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            browserPolicy: Swift.String? = nil,
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary for browser settings.
    public struct BrowserSettingsSummary: Swift.Equatable {
        /// The ARN of the browser settings.
        public var browserSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum BrowserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chrome
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserType] {
            return [
                .chrome,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrome: return "Chrome"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrowserType(rawValue: rawValue) ?? BrowserType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The certificate.
    public struct Certificate: Swift.Equatable {
        /// The body of the certificate.
        public var body: ClientRuntime.Data?
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init (
            body: ClientRuntime.Data? = nil,
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension WorkSpacesWebClientTypes.CertificateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the certificate.
    public struct CertificateSummary: Swift.Equatable {
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init (
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension CreateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct CreateBrowserSettingsInput: Swift.Equatable {
    /// Additional encryption context of the browser settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    /// This member is required.
    public var browserPolicy: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the browser settings.
    public var customerManagedKey: Swift.String?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        browserPolicy: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.browserPolicy = browserPolicy
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.tags = tags
    }
}

struct CreateBrowserSettingsInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
        } else {
            self.browserSettingsArn = nil
        }
    }
}

public struct CreateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct CreateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettingsArn: Swift.String?
}

extension CreateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension CreateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderType: \(Swift.String(describing: identityProviderType)), portalArn: \(Swift.String(describing: portalArn)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension CreateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
    }
}

extension CreateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identityProviders"
    }
}

public struct CreateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    /// This member is required.
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The identity provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// The identity provider type.
    /// This member is required.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
        self.portalArn = portalArn
    }
}

struct CreateIdentityProviderInputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderArn = output.identityProviderArn
        } else {
            self.identityProviderArn = nil
        }
    }
}

public struct CreateIdentityProviderOutputResponse: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct CreateIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProviderArn: Swift.String?
}

extension CreateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
    }
}

extension CreateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct CreateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags to add to the network settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// The VPC that streaming instances will connect to.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
        } else {
            self.networkSettingsArn = nil
        }
    }
}

public struct CreateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct CreateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettingsArn: Swift.String?
}

extension CreateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct CreatePortalInput: Swift.Equatable {
    /// The additional encryption context of the portal.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The customer managed key of the web portal.
    public var customerManagedKey: Swift.String?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The tags to add to the web portal. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.displayName = displayName
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalEndpoint = output.portalEndpoint
        } else {
            self.portalArn = nil
            self.portalEndpoint = nil
        }
    }
}

public struct CreatePortalOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The endpoint URL of the web portal that users access in order to start streaming sessions.
    /// This member is required.
    public var portalEndpoint: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        portalEndpoint: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalEndpoint = portalEndpoint
    }
}

struct CreatePortalOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let portalEndpoint: Swift.String?
}

extension CreatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
    }
}

extension CreateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateList = certificateList {
            var certificateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateList)
            for certificateauthoritybody0 in certificateList {
                try certificateListContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct CreateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to be added to the trust store.
    /// This member is required.
    public var certificateList: [ClientRuntime.Data]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The tags to add to the trust store. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        certificateList: [ClientRuntime.Data]? = nil,
        clientToken: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.certificateList = certificateList
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateTrustStoreInputBody: Swift.Equatable {
    let certificateList: [ClientRuntime.Data]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificateList)
        var certificateListDecoded0:[ClientRuntime.Data]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificateListContainer {
                if let blob0 = blob0 {
                    certificateListDecoded0?.append(blob0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct CreateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct CreateTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension CreateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension CreateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct CreateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    /// This member is required.
    public var kinesisStreamArn: Swift.String?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.tags = tags
    }
}

struct CreateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct CreateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct CreateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettingsArn: Swift.String?
}

extension CreateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension CreateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension CreateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct CreateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    /// This member is required.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    /// This member is required.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    /// This member is required.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    /// This member is required.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    /// This member is required.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?

    public init (
        clientToken: Swift.String? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil
    )
    {
        self.clientToken = clientToken
        self.copyAllowed = copyAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.tags = tags
        self.uploadAllowed = uploadAllowed
    }
}

struct CreateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
}

extension CreateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.userSettingsArn = nil
        }
    }
}

public struct CreateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct CreateUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettingsArn: Swift.String?
}

extension CreateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension DeleteBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn)"
    }
}

public struct DeleteBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct DeleteBrowserSettingsInputBody: Swift.Equatable {
}

extension DeleteBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBrowserSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn)"
    }
}

public struct DeleteIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct DeleteIdentityProviderInputBody: Swift.Equatable {
}

extension DeleteIdentityProviderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn)"
    }
}

public struct DeleteNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct DeleteNetworkSettingsInputBody: Swift.Equatable {
}

extension DeleteNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)"
    }
}

public struct DeletePortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePortalOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn)"
    }
}

public struct DeleteTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct DeleteTrustStoreInputBody: Swift.Equatable {
}

extension DeleteTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTrustStoreOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn)"
    }
}

public struct DeleteUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct DeleteUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DeleteUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserAccessLoggingSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn)"
    }
}

public struct DeleteUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct DeleteUserSettingsInputBody: Swift.Equatable {
}

extension DeleteUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/browserSettings"
    }
}

public struct DisassociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateBrowserSettingsInputBody: Swift.Equatable {
}

extension DisassociateBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateBrowserSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/networkSettings"
    }
}

public struct DisassociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateNetworkSettingsInputBody: Swift.Equatable {
}

extension DisassociateNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateNetworkSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/trustStores"
    }
}

public struct DisassociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateTrustStoreInputBody: Swift.Equatable {
}

extension DisassociateTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTrustStoreOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/userAccessLoggingSettings"
    }
}

public struct DisassociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/userSettings"
    }
}

public struct DisassociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateUserSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesWebClientTypes {
    public enum EnabledType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnabledType] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnabledType(rawValue: rawValue) ?? EnabledType.sdkUnknown(rawValue)
        }
    }
}

extension GetBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn)"
    }
}

public struct GetBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct GetBrowserSettingsInputBody: Swift.Equatable {
}

extension GetBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct GetBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init (
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct GetBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension GetBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

extension GetIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn)"
    }
}

public struct GetIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct GetIdentityProviderInputBody: Swift.Equatable {
}

extension GetIdentityProviderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct GetIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init (
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct GetIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension GetIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

extension GetNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn)"
    }
}

public struct GetNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct GetNetworkSettingsInputBody: Swift.Equatable {
}

extension GetNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct GetNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init (
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct GetNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension GetNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

extension GetPortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)"
    }
}

public struct GetPortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalInputBody: Swift.Equatable {
}

extension GetPortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct GetPortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init (
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct GetPortalOutputResponseBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension GetPortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

extension GetPortalServiceProviderMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portalIdp/\(portalArn)"
    }
}

public struct GetPortalServiceProviderMetadataInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalServiceProviderMetadataInputBody: Swift.Equatable {
}

extension GetPortalServiceProviderMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalServiceProviderMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortalServiceProviderMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPortalServiceProviderMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortalServiceProviderMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPortalServiceProviderMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.portalArn = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct GetPortalServiceProviderMetadataOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service provider SAML metadata.
    public var serviceProviderSamlMetadata: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct GetPortalServiceProviderMetadataOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let serviceProviderSamlMetadata: Swift.String?
}

extension GetPortalServiceProviderMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case serviceProviderSamlMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let thumbprint = thumbprint else {
                let message = "Creating a URL Query Item failed. thumbprint is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let thumbprintQueryItem = ClientRuntime.URLQueryItem(name: "thumbprint".urlPercentEncoding(), value: Swift.String(thumbprint).urlPercentEncoding())
            items.append(thumbprintQueryItem)
            return items
        }
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn)/certificate"
    }
}

public struct GetTrustStoreCertificateInput: Swift.Equatable {
    /// The thumbprint of the trust store certificate.
    /// This member is required.
    public var thumbprint: Swift.String?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        thumbprint: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.thumbprint = thumbprint
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateInputBody: Swift.Equatable {
}

extension GetTrustStoreCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrustStoreCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTrustStoreCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrustStoreCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTrustStoreCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificate = nil
            self.trustStoreArn = nil
        }
    }
}

public struct GetTrustStoreCertificateOutputResponse: Swift.Equatable {
    /// The certificate of the trust store certificate.
    public var certificate: WorkSpacesWebClientTypes.Certificate?
    /// The ARN of the trust store certificate.
    public var trustStoreArn: Swift.String?

    public init (
        certificate: WorkSpacesWebClientTypes.Certificate? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
    let certificate: WorkSpacesWebClientTypes.Certificate?
}

extension GetTrustStoreCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension GetTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn)"
    }
}

public struct GetTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreInputBody: Swift.Equatable {
}

extension GetTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStore = output.trustStore
        } else {
            self.trustStore = nil
        }
    }
}

public struct GetTrustStoreOutputResponse: Swift.Equatable {
    /// The trust store.
    public var trustStore: WorkSpacesWebClientTypes.TrustStore?

    public init (
        trustStore: WorkSpacesWebClientTypes.TrustStore? = nil
    )
    {
        self.trustStore = trustStore
    }
}

struct GetTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStore: WorkSpacesWebClientTypes.TrustStore?
}

extension GetTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStore
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.TrustStore.self, forKey: .trustStore)
        trustStore = trustStoreDecoded
    }
}

extension GetUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn)"
    }
}

public struct GetUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct GetUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension GetUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct GetUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The user access logging settings.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init (
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct GetUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension GetUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

extension GetUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn)"
    }
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init (
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension GetUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProvider(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The identity provider.
    public struct IdentityProvider: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
        ///
        /// * For Google and Login with Amazon:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For Facebook:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        /// * api_version
        ///
        ///
        ///
        ///
        /// * For Sign in with Apple:
        ///
        /// * client_id
        ///
        /// * team_id
        ///
        /// * key_id
        ///
        /// * private_key
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For OIDC providers:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * attributes_request_method
        ///
        /// * oidc_issuer
        ///
        /// * authorize_scopes
        ///
        /// * authorize_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * token_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * attributes_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
        ///
        ///
        ///
        ///
        /// * For SAML providers:
        ///
        /// * MetadataFile OR MetadataURL
        ///
        /// * IDPSignout optional
        public var identityProviderDetails: [Swift.String:Swift.String]?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init (
            identityProviderArn: Swift.String? = nil,
            identityProviderDetails: [Swift.String:Swift.String]? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderSummary(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The ARN of the identity provider.
        public var identityProviderArn: Swift.String?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init (
            identityProviderArn: Swift.String? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case facebook
        case google
        case loginwithamazon
        case oidc
        case saml
        case signinwithapple
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .facebook,
                .google,
                .loginwithamazon,
                .oidc,
                .saml,
                .signinwithapple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .facebook: return "Facebook"
            case .google: return "Google"
            case .loginwithamazon: return "LoginWithAmazon"
            case .oidc: return "OIDC"
            case .saml: return "SAML"
            case .signinwithapple: return "SignInWithApple"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct ListBrowserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsInputBody: Swift.Equatable {
}

extension ListBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
            self.nextToken = output.nextToken
        } else {
            self.browserSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.browserSettings = browserSettings
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.BrowserSettingsSummary?].self, forKey: .browserSettings)
        var browserSettingsDecoded0:[WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil
        if let browserSettingsContainer = browserSettingsContainer {
            browserSettingsDecoded0 = [WorkSpacesWebClientTypes.BrowserSettingsSummary]()
            for structure0 in browserSettingsContainer {
                if let structure0 = structure0 {
                    browserSettingsDecoded0?.append(structure0)
                }
            }
        }
        browserSettings = browserSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)/identityProviders"
    }
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalArn = portalArn
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
}

extension ListIdentityProvidersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIdentityProvidersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIdentityProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviders = output.identityProviders
            self.nextToken = output.nextToken
        } else {
            self.identityProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutputResponse: Swift.Equatable {
    /// The identity providers.
    public var identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviders = identityProviders
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
}

extension ListIdentityProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviders
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let identityProvidersContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IdentityProviderSummary?].self, forKey: .identityProviders)
        var identityProvidersDecoded0:[WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil
        if let identityProvidersContainer = identityProvidersContainer {
            identityProvidersDecoded0 = [WorkSpacesWebClientTypes.IdentityProviderSummary]()
            for structure0 in identityProvidersContainer {
                if let structure0 = structure0 {
                    identityProvidersDecoded0?.append(structure0)
                }
            }
        }
        identityProviders = identityProvidersDecoded0
    }
}

extension ListNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct ListNetworkSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsInputBody: Swift.Equatable {
}

extension ListNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
            self.nextToken = output.nextToken
        } else {
            self.networkSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSettings = networkSettings
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.NetworkSettingsSummary?].self, forKey: .networkSettings)
        var networkSettingsDecoded0:[WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil
        if let networkSettingsContainer = networkSettingsContainer {
            networkSettingsDecoded0 = [WorkSpacesWebClientTypes.NetworkSettingsSummary]()
            for structure0 in networkSettingsContainer {
                if let structure0 = structure0 {
                    networkSettingsDecoded0?.append(structure0)
                }
            }
        }
        networkSettings = networkSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPortalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPortalsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portals = output.portals
        } else {
            self.nextToken = nil
            self.portals = nil
        }
    }
}

public struct ListPortalsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The portals in the list.
    public var portals: [WorkSpacesWebClientTypes.PortalSummary]?

    public init (
        nextToken: Swift.String? = nil,
        portals: [WorkSpacesWebClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portals = portals
    }
}

struct ListPortalsOutputResponseBody: Swift.Equatable {
    let portals: [WorkSpacesWebClientTypes.PortalSummary]?
    let nextToken: Swift.String?
}

extension ListPortalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.PortalSummary?].self, forKey: .portals)
        var portalsDecoded0:[WorkSpacesWebClientTypes.PortalSummary]? = nil
        if let portalsContainer = portalsContainer {
            portalsDecoded0 = [WorkSpacesWebClientTypes.PortalSummary]()
            for structure0 in portalsContainer {
                if let structure0 = structure0 {
                    portalsDecoded0?.append(structure0)
                }
            }
        }
        portals = portalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn)"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags of the resource.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn)/certificates"
    }
}

public struct ListTrustStoreCertificatesInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the trust store
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesInputBody: Swift.Equatable {
}

extension ListTrustStoreCertificatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoreCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrustStoreCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrustStoreCertificatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrustStoreCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrustStoreCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateList = output.certificateList
            self.nextToken = output.nextToken
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificateList = nil
            self.nextToken = nil
            self.trustStoreArn = nil
        }
    }
}

public struct ListTrustStoreCertificatesOutputResponse: Swift.Equatable {
    /// The certificate list.
    public var certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.>
    public var nextToken: Swift.String?
    /// The ARN of the trust store.
    public var trustStoreArn: Swift.String?

    public init (
        certificateList: [WorkSpacesWebClientTypes.CertificateSummary]? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificateList = certificateList
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesOutputResponseBody: Swift.Equatable {
    let certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    let trustStoreArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTrustStoreCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case nextToken
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CertificateSummary?].self, forKey: .certificateList)
        var certificateListDecoded0:[WorkSpacesWebClientTypes.CertificateSummary]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [WorkSpacesWebClientTypes.CertificateSummary]()
            for structure0 in certificateListContainer {
                if let structure0 = structure0 {
                    certificateListDecoded0?.append(structure0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrustStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct ListTrustStoresInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrustStoresInputBody: Swift.Equatable {
}

extension ListTrustStoresInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrustStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrustStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrustStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrustStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustStores = output.trustStores
        } else {
            self.nextToken = nil
            self.trustStores = nil
        }
    }
}

public struct ListTrustStoresOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The trust stores.
    public var trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?

    public init (
        nextToken: Swift.String? = nil,
        trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustStores = trustStores
    }
}

struct ListTrustStoresOutputResponseBody: Swift.Equatable {
    let trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?
    let nextToken: Swift.String?
}

extension ListTrustStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustStores
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoresContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.TrustStoreSummary?].self, forKey: .trustStores)
        var trustStoresDecoded0:[WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
        if let trustStoresContainer = trustStoresContainer {
            trustStoresDecoded0 = [WorkSpacesWebClientTypes.TrustStoreSummary]()
            for structure0 in trustStoresContainer {
                if let structure0 = structure0 {
                    trustStoresDecoded0?.append(structure0)
                }
            }
        }
        trustStores = trustStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct ListUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension ListUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.nextToken = nil
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct ListUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user access logging settings.
    public var userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct ListUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userAccessLoggingSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary?].self, forKey: .userAccessLoggingSettings)
        var userAccessLoggingSettingsDecoded0:[WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
        if let userAccessLoggingSettingsContainer = userAccessLoggingSettingsContainer {
            userAccessLoggingSettingsDecoded0 = [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]()
            for structure0 in userAccessLoggingSettingsContainer {
                if let structure0 = structure0 {
                    userAccessLoggingSettingsDecoded0?.append(structure0)
                }
            }
        }
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct ListUserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserSettingsInputBody: Swift.Equatable {
}

extension ListUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSettings = output.userSettings
        } else {
            self.nextToken = nil
            self.userSettings = nil
        }
    }
}

public struct ListUserSettingsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user settings.
    public var userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSettings = userSettings
    }
}

struct ListUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserSettingsSummary?].self, forKey: .userSettings)
        var userSettingsDecoded0:[WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [WorkSpacesWebClientTypes.UserSettingsSummary]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case networkSettingsArn
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension WorkSpacesWebClientTypes {
    /// A network settings resource that can be associated with a web portal. Once associated with a web portal, network settings define how streaming instances will connect with your specified VPC.
    public struct NetworkSettings: Swift.Equatable {
        /// A list of web portal ARNs that this network settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public var securityGroupIds: [Swift.String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public var subnetIds: [Swift.String]?
        /// The VPC that streaming instances will connect to.
        public var vpcId: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            networkSettingsArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of network settings.
    public struct NetworkSettingsSummary: Swift.Equatable {
        /// The ARN of the network settings.
        public var networkSettingsArn: Swift.String?
        /// The VPC ID of the network settings.
        public var vpcId: Swift.String?

        public init (
            networkSettingsArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.Portal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case statusReason
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.Portal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Portal(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), statusReason: \(Swift.String(describing: statusReason)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The web portal.
    public struct Portal: Swift.Equatable {
        /// The ARN of the browser settings that is associated with this web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser that users see when using a streaming session.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// A message that explains why the web portal is in its current status.
        public var statusReason: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            statusReason: Swift.String? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum PortalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case incomplete
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalStatus] {
            return [
                .active,
                .incomplete,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .incomplete: return "Incomplete"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalStatus(rawValue: rawValue) ?? PortalStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the portal.
    public struct PortalSummary: Swift.Equatable {
        /// The ARN of the browser settings that is associated with the web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser type of the web portal.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum RendererType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream
        case sdkUnknown(Swift.String)

        public static var allCases: [RendererType] {
            return [
                .appstream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "AppStream"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RendererType(rawValue: rawValue) ?? RendererType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Hypothetical identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Hypothetical type of the resource affected.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The originating quota.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?
    /// The originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {
    /// The tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn)"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a throttling error.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The originating quota.
    public var quotaCode: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int
    /// The originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Name of the resource affected.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A trust store that can be associated with a web portal. A trust store contains certificate authority (CA) certificates. Once associated with a web portal, the browser in a streaming session will recognize certificates that have been issued using any of the CAs in the trust store. If your organization has internal websites that use certificates issued by private CAs, you should add the private CA certificate to the trust store.
    public struct TrustStore: Swift.Equatable {
        /// A list of web portal ARNs that this trust store is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            trustStoreArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension WorkSpacesWebClientTypes.TrustStoreSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the trust store.
    public struct TrustStoreSummary: Swift.Equatable {
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init (
            trustStoreArn: Swift.String? = nil
        )
        {
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn)"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), clientToken: \(Swift.String(describing: clientToken)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension UpdateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn)"
    }
}

public struct UpdateBrowserSettingsInput: Swift.Equatable {
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    public var browserPolicy: Swift.String?
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?

    public init (
        browserPolicy: Swift.String? = nil,
        browserSettingsArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.browserPolicy = browserPolicy
        self.browserSettingsArn = browserSettingsArn
        self.clientToken = clientToken
    }
}

struct UpdateBrowserSettingsInputBody: Swift.Equatable {
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct UpdateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    /// This member is required.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init (
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct UpdateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension UpdateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

extension UpdateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension UpdateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

extension UpdateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn)"
    }
}

public struct UpdateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The name of the identity provider.
    public var identityProviderName: Swift.String?
    /// The type of the identity provider.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

    public init (
        clientToken: Swift.String? = nil,
        identityProviderArn: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderArn = identityProviderArn
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderInputBody: Swift.Equatable {
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct UpdateIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    /// This member is required.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init (
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct UpdateIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension UpdateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

extension UpdateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension UpdateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn)"
    }
}

public struct UpdateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    public var subnetIds: [Swift.String]?
    /// The VPC that streaming instances will connect to.
    public var vpcId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        networkSettingsArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSettingsArn = networkSettingsArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct UpdateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    /// This member is required.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init (
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct UpdateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension UpdateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(portalArn: \(Swift.String(describing: portalArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension UpdatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn)"
    }
}

public struct UpdatePortalInput: Swift.Equatable {
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.portalArn = portalArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init (
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct UpdatePortalOutputResponseBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension UpdatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

extension UpdateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatesToAdd = certificatesToAdd {
            var certificatesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToAdd)
            for certificateauthoritybody0 in certificatesToAdd {
                try certificatesToAddContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let certificatesToDelete = certificatesToDelete {
            var certificatesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToDelete)
            for certificatethumbprint0 in certificatesToDelete {
                try certificatesToDeleteContainer.encode(certificatethumbprint0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn)"
    }
}

public struct UpdateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to add to the trust store.
    public var certificatesToAdd: [ClientRuntime.Data]?
    /// A list of CA certificates to delete from a trust store.
    public var certificatesToDelete: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        certificatesToAdd: [ClientRuntime.Data]? = nil,
        certificatesToDelete: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificatesToAdd = certificatesToAdd
        self.certificatesToDelete = certificatesToDelete
        self.clientToken = clientToken
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreInputBody: Swift.Equatable {
    let certificatesToAdd: [ClientRuntime.Data]?
    let certificatesToDelete: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesToAddContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificatesToAdd)
        var certificatesToAddDecoded0:[ClientRuntime.Data]? = nil
        if let certificatesToAddContainer = certificatesToAddContainer {
            certificatesToAddDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificatesToAddContainer {
                if let blob0 = blob0 {
                    certificatesToAddDecoded0?.append(blob0)
                }
            }
        }
        certificatesToAdd = certificatesToAddDecoded0
        let certificatesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificatesToDelete)
        var certificatesToDeleteDecoded0:[Swift.String]? = nil
        if let certificatesToDeleteContainer = certificatesToDeleteContainer {
            certificatesToDeleteDecoded0 = [Swift.String]()
            for string0 in certificatesToDeleteContainer {
                if let string0 = string0 {
                    certificatesToDeleteDecoded0?.append(string0)
                }
            }
        }
        certificatesToDelete = certificatesToDeleteDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct UpdateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension UpdateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension UpdateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
    }
}

extension UpdateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn)"
    }
}

public struct UpdateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    public var kinesisStreamArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct UpdateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserAccessLoggingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserAccessLoggingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct UpdateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init (
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct UpdateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension UpdateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

extension UpdateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension UpdateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn)"
    }
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.copyAllowed = copyAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.uploadAllowed = uploadAllowed
        self.userSettingsArn = userSettingsArn
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct UpdateUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    /// This member is required.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init (
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension UpdateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A user access logging settings resource that can be associated with a web portal.
    public struct UserAccessLoggingSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of user access logging settings.
    public struct UserAccessLoggingSettingsSummary: Swift.Equatable {
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init (
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A user settings resource that can be associated with a web portal. Once associated with a web portal, user settings control how users can transfer data between a streaming session and the their local devices.
    public struct UserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of user settings.
    public struct UserSettingsSummary: Swift.Equatable {
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        public var userSettingsArn: Swift.String?

        public init (
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a validation error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field that caused the error.
    public var fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: WorkSpacesWebClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: WorkSpacesWebClientTypes.ValidationExceptionReason?
    let fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [WorkSpacesWebClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// Information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
