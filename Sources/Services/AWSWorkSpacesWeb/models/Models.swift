// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let browserSettingsArn = browserSettingsArn else {
                let message = "Creating a URL Query Item failed. browserSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let browserSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "browserSettingsArn".urlPercentEncoding(), value: Swift.String(browserSettingsArn).urlPercentEncoding())
            items.append(browserSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

public struct AssociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsInputBody: Swift.Equatable {
}

extension AssociateBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateBrowserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.browserSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateBrowserSettingsOutput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let browserSettingsArn: Swift.String?
}

extension AssociateBrowserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

enum AssociateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateIpAccessSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let ipAccessSettingsArn = ipAccessSettingsArn else {
                let message = "Creating a URL Query Item failed. ipAccessSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let ipAccessSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "ipAccessSettingsArn".urlPercentEncoding(), value: Swift.String(ipAccessSettingsArn).urlPercentEncoding())
            items.append(ipAccessSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

public struct AssociateIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateIpAccessSettingsInputBody: Swift.Equatable {
}

extension AssociateIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateIpAccessSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettingsArn = output.ipAccessSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.ipAccessSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateIpAccessSettingsOutput: Swift.Equatable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateIpAccessSettingsOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let ipAccessSettingsArn: Swift.String?
}

extension AssociateIpAccessSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

enum AssociateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let networkSettingsArn = networkSettingsArn else {
                let message = "Creating a URL Query Item failed. networkSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let networkSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "networkSettingsArn".urlPercentEncoding(), value: Swift.String(networkSettingsArn).urlPercentEncoding())
            items.append(networkSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

public struct AssociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsInputBody: Swift.Equatable {
}

extension AssociateNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateNetworkSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.networkSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateNetworkSettingsOutput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let networkSettingsArn: Swift.String?
}

extension AssociateNetworkSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

enum AssociateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateTrustStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let trustStoreArn = trustStoreArn else {
                let message = "Creating a URL Query Item failed. trustStoreArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let trustStoreArnQueryItem = ClientRuntime.URLQueryItem(name: "trustStoreArn".urlPercentEncoding(), value: Swift.String(trustStoreArn).urlPercentEncoding())
            items.append(trustStoreArnQueryItem)
            return items
        }
    }
}

extension AssociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

public struct AssociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreInputBody: Swift.Equatable {
}

extension AssociateTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateTrustStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.portalArn = nil
            self.trustStoreArn = nil
        }
    }
}

public struct AssociateTrustStoreOutput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let trustStoreArn: Swift.String?
}

extension AssociateTrustStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

enum AssociateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
                let message = "Creating a URL Query Item failed. userAccessLoggingSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userAccessLoggingSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userAccessLoggingSettingsArn".urlPercentEncoding(), value: Swift.String(userAccessLoggingSettingsArn).urlPercentEncoding())
            items.append(userAccessLoggingSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

public struct AssociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension AssociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateUserAccessLoggingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.portalArn = nil
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct AssociateUserAccessLoggingSettingsOutput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userAccessLoggingSettingsArn: Swift.String?
}

extension AssociateUserAccessLoggingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userAccessLoggingSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

enum AssociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userSettingsArn = userSettingsArn else {
                let message = "Creating a URL Query Item failed. userSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userSettingsArn".urlPercentEncoding(), value: Swift.String(userSettingsArn).urlPercentEncoding())
            items.append(userSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

public struct AssociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsInputBody: Swift.Equatable {
}

extension AssociateUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.portalArn = nil
            self.userSettingsArn = nil
        }
    }
}

public struct AssociateUserSettingsOutput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userSettingsArn: Swift.String?
}

extension AssociateUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

enum AssociateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesWebClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iamIdentityCenter
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .iamIdentityCenter,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iamIdentityCenter: return "IAM_Identity_Center"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case browserPolicy
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The browser settings resource that can be associated with a web portal. Once associated with a web portal, browser settings control how the browser will behave once a user starts a streaming session for the web portal.
    public struct BrowserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this browser settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public var browserPolicy: Swift.String?
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            browserPolicy: Swift.String? = nil,
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary for browser settings.
    public struct BrowserSettingsSummary: Swift.Equatable {
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init(
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum BrowserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chrome
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserType] {
            return [
                .chrome,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrome: return "Chrome"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrowserType(rawValue: rawValue) ?? BrowserType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The certificate.
    public struct Certificate: Swift.Equatable {
        /// The body of the certificate.
        public var body: ClientRuntime.Data?
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            body: ClientRuntime.Data? = nil,
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension WorkSpacesWebClientTypes.CertificateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the certificate.
    public struct CertificateSummary: Swift.Equatable {
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.CookieSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// Specifies a single cookie or set of cookies in an end user's browser.
    public struct CookieSpecification: Swift.Equatable {
        /// The domain of the cookie.
        /// This member is required.
        public var domain: Swift.String?
        /// The name of the cookie.
        public var name: Swift.String?
        /// The path of the cookie.
        public var path: Swift.String?

        public init(
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.path = path
        }
    }

}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowlist
        case blocklist
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowlist = allowlist {
            var allowlistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowlist)
            for cookiespecification0 in allowlist {
                try allowlistContainer.encode(cookiespecification0)
            }
        }
        if let blocklist = blocklist {
            var blocklistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blocklist)
            for cookiespecification0 in blocklist {
                try blocklistContainer.encode(cookiespecification0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowlistContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CookieSpecification?].self, forKey: .allowlist)
        var allowlistDecoded0:[WorkSpacesWebClientTypes.CookieSpecification]? = nil
        if let allowlistContainer = allowlistContainer {
            allowlistDecoded0 = [WorkSpacesWebClientTypes.CookieSpecification]()
            for structure0 in allowlistContainer {
                if let structure0 = structure0 {
                    allowlistDecoded0?.append(structure0)
                }
            }
        }
        allowlist = allowlistDecoded0
        let blocklistContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CookieSpecification?].self, forKey: .blocklist)
        var blocklistDecoded0:[WorkSpacesWebClientTypes.CookieSpecification]? = nil
        if let blocklistContainer = blocklistContainer {
            blocklistDecoded0 = [WorkSpacesWebClientTypes.CookieSpecification]()
            for structure0 in blocklistContainer {
                if let structure0 = structure0 {
                    blocklistDecoded0?.append(structure0)
                }
            }
        }
        blocklist = blocklistDecoded0
    }
}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public struct CookieSynchronizationConfiguration: Swift.Equatable {
        /// The list of cookie specifications that are allowed to be synchronized to the remote browser.
        /// This member is required.
        public var allowlist: [WorkSpacesWebClientTypes.CookieSpecification]?
        /// The list of cookie specifications that are blocked from being synchronized to the remote browser.
        public var blocklist: [WorkSpacesWebClientTypes.CookieSpecification]?

        public init(
            allowlist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil,
            blocklist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil
        )
        {
            self.allowlist = allowlist
            self.blocklist = blocklist
        }
    }

}

extension CreateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension CreateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct CreateBrowserSettingsInput: Swift.Equatable {
    /// Additional encryption context of the browser settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    /// This member is required.
    public var browserPolicy: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the browser settings.
    public var customerManagedKey: Swift.String?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        browserPolicy: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.browserPolicy = browserPolicy
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.tags = tags
    }
}

struct CreateBrowserSettingsInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBrowserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
        } else {
            self.browserSettingsArn = nil
        }
    }
}

public struct CreateBrowserSettingsOutput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct CreateBrowserSettingsOutputBody: Swift.Equatable {
    let browserSettingsArn: Swift.String?
}

extension CreateBrowserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

enum CreateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderType: \(Swift.String(describing: identityProviderType)), portalArn: \(Swift.String(describing: portalArn)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension CreateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
    }
}

extension CreateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identityProviders"
    }
}

public struct CreateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    /// This member is required.
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The identity provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// The identity provider type.
    /// This member is required.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
        self.portalArn = portalArn
    }
}

struct CreateIdentityProviderInputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderArn = output.identityProviderArn
        } else {
            self.identityProviderArn = nil
        }
    }
}

public struct CreateIdentityProviderOutput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct CreateIdentityProviderOutputBody: Swift.Equatable {
    let identityProviderArn: Swift.String?
}

extension CreateIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
    }
}

enum CreateIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIpAccessSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension CreateIpAccessSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case description
        case displayName
        case ipRules
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ipAccessSettings"
    }
}

public struct CreateIpAccessSettingsInput: Swift.Equatable {
    /// Additional encryption context of the IP access settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the IP access settings.
    public var customerManagedKey: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The IP rules of the IP access settings.
    /// This member is required.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.description = description
        self.displayName = displayName
        self.ipRules = ipRules
        self.tags = tags
    }
}

struct CreateIpAccessSettingsInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let ipRules: [WorkSpacesWebClientTypes.IpRule]?
    let clientToken: Swift.String?
}

extension CreateIpAccessSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case description
        case displayName
        case ipRules
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIpAccessSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettingsArn = output.ipAccessSettingsArn
        } else {
            self.ipAccessSettingsArn = nil
        }
    }
}

public struct CreateIpAccessSettingsOutput: Swift.Equatable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct CreateIpAccessSettingsOutputBody: Swift.Equatable {
    let ipAccessSettingsArn: Swift.String?
}

extension CreateIpAccessSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

enum CreateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct CreateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags to add to the network settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// The VPC that streaming instances will connect to.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
        } else {
            self.networkSettingsArn = nil
        }
    }
}

public struct CreateNetworkSettingsOutput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct CreateNetworkSettingsOutputBody: Swift.Equatable {
    let networkSettingsArn: Swift.String?
}

extension CreateNetworkSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

enum CreateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), authenticationType: \(Swift.String(describing: authenticationType)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case authenticationType
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct CreatePortalInput: Swift.Equatable {
    /// The additional encryption context of the portal.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The customer managed key of the web portal.
    public var customerManagedKey: Swift.String?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The tags to add to the web portal. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.authenticationType = authenticationType
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.displayName = displayName
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case authenticationType
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension CreatePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalEndpoint = output.portalEndpoint
        } else {
            self.portalArn = nil
            self.portalEndpoint = nil
        }
    }
}

public struct CreatePortalOutput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The endpoint URL of the web portal that users access in order to start streaming sessions.
    /// This member is required.
    public var portalEndpoint: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        portalEndpoint: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalEndpoint = portalEndpoint
    }
}

struct CreatePortalOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let portalEndpoint: Swift.String?
}

extension CreatePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
    }
}

enum CreatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateList = certificateList {
            var certificateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateList)
            for certificateauthoritybody0 in certificateList {
                try certificateListContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct CreateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to be added to the trust store.
    /// This member is required.
    public var certificateList: [ClientRuntime.Data]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The tags to add to the trust store. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        certificateList: [ClientRuntime.Data]? = nil,
        clientToken: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.certificateList = certificateList
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateTrustStoreInputBody: Swift.Equatable {
    let certificateList: [ClientRuntime.Data]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificateList)
        var certificateListDecoded0:[ClientRuntime.Data]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificateListContainer {
                if let blob0 = blob0 {
                    certificateListDecoded0?.append(blob0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrustStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct CreateTrustStoreOutput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct CreateTrustStoreOutputBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension CreateTrustStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

enum CreateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct CreateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    /// This member is required.
    public var kinesisStreamArn: Swift.String?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.tags = tags
    }
}

struct CreateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserAccessLoggingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct CreateUserAccessLoggingSettingsOutput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct CreateUserAccessLoggingSettingsOutputBody: Swift.Equatable {
    let userAccessLoggingSettingsArn: Swift.String?
}

extension CreateUserAccessLoggingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

enum CreateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), tags: \(Swift.String(describing: tags)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case customerManagedKey
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension CreateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct CreateUserSettingsInput: Swift.Equatable {
    /// The additional encryption context of the user settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    /// This member is required.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The customer managed key used to encrypt sensitive information in the user settings.
    public var customerManagedKey: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    /// This member is required.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    /// This member is required.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    /// This member is required.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    /// This member is required.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        customerManagedKey: Swift.String? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.customerManagedKey = customerManagedKey
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.tags = tags
        self.uploadAllowed = uploadAllowed
    }
}

struct CreateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
    let cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
}

extension CreateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case customerManagedKey
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
    }
}

extension CreateUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.userSettingsArn = nil
        }
    }
}

public struct CreateUserSettingsOutput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct CreateUserSettingsOutputBody: Swift.Equatable {
    let userSettingsArn: Swift.String?
}

extension CreateUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

enum CreateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct DeleteBrowserSettingsInputBody: Swift.Equatable {
}

extension DeleteBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBrowserSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct DeleteIdentityProviderInputBody: Swift.Equatable {
}

extension DeleteIdentityProviderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIdentityProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct DeleteIpAccessSettingsInputBody: Swift.Equatable {
}

extension DeleteIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIpAccessSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct DeleteNetworkSettingsInputBody: Swift.Equatable {
}

extension DeleteNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNetworkSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeletePortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePortalOutput: Swift.Equatable {

    public init() { }
}

enum DeletePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct DeleteTrustStoreInputBody: Swift.Equatable {
}

extension DeleteTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrustStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct DeleteUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DeleteUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserAccessLoggingSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct DeleteUserSettingsInputBody: Swift.Equatable {
}

extension DeleteUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

public struct DisassociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateBrowserSettingsInputBody: Swift.Equatable {
}

extension DisassociateBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateBrowserSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

public struct DisassociateIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateIpAccessSettingsInputBody: Swift.Equatable {
}

extension DisassociateIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateIpAccessSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

public struct DisassociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateNetworkSettingsInputBody: Swift.Equatable {
}

extension DisassociateNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateNetworkSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

public struct DisassociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateTrustStoreInputBody: Swift.Equatable {
}

extension DisassociateTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTrustStoreOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

public struct DisassociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateUserAccessLoggingSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

public struct DisassociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateUserSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesWebClientTypes {
    public enum EnabledType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnabledType] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnabledType(rawValue: rawValue) ?? EnabledType.sdkUnknown(rawValue)
        }
    }
}

extension GetBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct GetBrowserSettingsInputBody: Swift.Equatable {
}

extension GetBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBrowserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct GetBrowserSettingsOutput: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct GetBrowserSettingsOutputBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension GetBrowserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

enum GetBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct GetIdentityProviderInputBody: Swift.Equatable {
}

extension GetIdentityProviderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct GetIdentityProviderOutput: Swift.Equatable {
    /// The identity provider.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct GetIdentityProviderOutputBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension GetIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

enum GetIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct GetIpAccessSettingsInputBody: Swift.Equatable {
}

extension GetIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIpAccessSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
        } else {
            self.ipAccessSettings = nil
        }
    }
}

public struct GetIpAccessSettingsOutput: Swift.Equatable {
    /// The IP access settings.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

struct GetIpAccessSettingsOutputBody: Swift.Equatable {
    let ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?
}

extension GetIpAccessSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IpAccessSettings.self, forKey: .ipAccessSettings)
        ipAccessSettings = ipAccessSettingsDecoded
    }
}

enum GetIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct GetNetworkSettingsInputBody: Swift.Equatable {
}

extension GetNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct GetNetworkSettingsOutput: Swift.Equatable {
    /// The network settings.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct GetNetworkSettingsOutputBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension GetNetworkSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

enum GetNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetPortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalInputBody: Swift.Equatable {
}

extension GetPortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct GetPortalOutput: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct GetPortalOutputBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension GetPortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

enum GetPortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortalServiceProviderMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portalIdp/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetPortalServiceProviderMetadataInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalServiceProviderMetadataInputBody: Swift.Equatable {
}

extension GetPortalServiceProviderMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalServiceProviderMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortalServiceProviderMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.portalArn = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct GetPortalServiceProviderMetadataOutput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service provider SAML metadata.
    public var serviceProviderSamlMetadata: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct GetPortalServiceProviderMetadataOutputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let serviceProviderSamlMetadata: Swift.String?
}

extension GetPortalServiceProviderMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case serviceProviderSamlMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
    }
}

enum GetPortalServiceProviderMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let thumbprint = thumbprint else {
                let message = "Creating a URL Query Item failed. thumbprint is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let thumbprintQueryItem = ClientRuntime.URLQueryItem(name: "thumbprint".urlPercentEncoding(), value: Swift.String(thumbprint).urlPercentEncoding())
            items.append(thumbprintQueryItem)
            return items
        }
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificate"
    }
}

public struct GetTrustStoreCertificateInput: Swift.Equatable {
    /// The thumbprint of the trust store certificate.
    /// This member is required.
    public var thumbprint: Swift.String?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        thumbprint: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.thumbprint = thumbprint
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateInputBody: Swift.Equatable {
}

extension GetTrustStoreCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrustStoreCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificate = nil
            self.trustStoreArn = nil
        }
    }
}

public struct GetTrustStoreCertificateOutput: Swift.Equatable {
    /// The certificate of the trust store certificate.
    public var certificate: WorkSpacesWebClientTypes.Certificate?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificate: WorkSpacesWebClientTypes.Certificate? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateOutputBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
    let certificate: WorkSpacesWebClientTypes.Certificate?
}

extension GetTrustStoreCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum GetTrustStoreCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreInputBody: Swift.Equatable {
}

extension GetTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrustStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustStore = output.trustStore
        } else {
            self.trustStore = nil
        }
    }
}

public struct GetTrustStoreOutput: Swift.Equatable {
    /// The trust store.
    public var trustStore: WorkSpacesWebClientTypes.TrustStore?

    public init(
        trustStore: WorkSpacesWebClientTypes.TrustStore? = nil
    )
    {
        self.trustStore = trustStore
    }
}

struct GetTrustStoreOutputBody: Swift.Equatable {
    let trustStore: WorkSpacesWebClientTypes.TrustStore?
}

extension GetTrustStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStore
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.TrustStore.self, forKey: .trustStore)
        trustStore = trustStoreDecoded
    }
}

enum GetTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct GetUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension GetUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserAccessLoggingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct GetUserAccessLoggingSettingsOutput: Swift.Equatable {
    /// The user access logging settings.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct GetUserAccessLoggingSettingsOutputBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension GetUserAccessLoggingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

enum GetUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutput: Swift.Equatable {
    /// The user settings.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension GetUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

enum GetUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProvider(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The identity provider.
    public struct IdentityProvider: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
        ///
        /// * For Google and Login with Amazon:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For Facebook:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        /// * api_version
        ///
        ///
        ///
        ///
        /// * For Sign in with Apple:
        ///
        /// * client_id
        ///
        /// * team_id
        ///
        /// * key_id
        ///
        /// * private_key
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For OIDC providers:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * attributes_request_method
        ///
        /// * oidc_issuer
        ///
        /// * authorize_scopes
        ///
        /// * authorize_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * token_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * attributes_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
        ///
        ///
        ///
        ///
        /// * For SAML providers:
        ///
        /// * MetadataFile OR MetadataURL
        ///
        /// * IDPSignout optional
        public var identityProviderDetails: [Swift.String:Swift.String]?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderDetails: [Swift.String:Swift.String]? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderSummary(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case facebook
        case google
        case loginwithamazon
        case oidc
        case saml
        case signinwithapple
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .facebook,
                .google,
                .loginwithamazon,
                .oidc,
                .saml,
                .signinwithapple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .facebook: return "Facebook"
            case .google: return "Google"
            case .loginwithamazon: return "LoginWithAmazon"
            case .oidc: return "OIDC"
            case .saml: return "SAML"
            case .signinwithapple: return "SignInWithApple"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case creationDate
        case description
        case displayName
        case ipAccessSettingsArn
        case ipRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The IP access settings resource that can be associated with a web portal.
    public struct IpAccessSettings: Swift.Equatable {
        /// A list of web portal ARNs that this IP access settings resource is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The creation date timestamp of the IP access settings.
        public var creationDate: ClientRuntime.Date?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings resource.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?
        /// The IP rules of the IP access settings.
        public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }
    }

}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case displayName
        case ipAccessSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettingsSummary(creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of IP access settings.
    public struct IpAccessSettingsSummary: Swift.Equatable {
        /// The creation date timestamp of the IP access settings.
        public var creationDate: ClientRuntime.Date?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of IP access settings.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.IpRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ipRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ipRange = self.ipRange {
            try encodeContainer.encode(ipRange, forKey: .ipRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRange)
        ipRange = ipRangeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkSpacesWebClientTypes.IpRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpRule(description: \"CONTENT_REDACTED\", ipRange: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The IP rules of the IP access settings.
    public struct IpRule: Swift.Equatable {
        /// The description of the IP rule.
        public var description: Swift.String?
        /// The IP range of the IP rule.
        /// This member is required.
        public var ipRange: Swift.String?

        public init(
            description: Swift.String? = nil,
            ipRange: Swift.String? = nil
        )
        {
            self.description = description
            self.ipRange = ipRange
        }
    }

}

extension ListBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct ListBrowserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsInputBody: Swift.Equatable {
}

extension ListBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBrowserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
            self.nextToken = output.nextToken
        } else {
            self.browserSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrowserSettingsOutput: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.browserSettings = browserSettings
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsOutputBody: Swift.Equatable {
    let browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListBrowserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.BrowserSettingsSummary?].self, forKey: .browserSettings)
        var browserSettingsDecoded0:[WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil
        if let browserSettingsContainer = browserSettingsContainer {
            browserSettingsDecoded0 = [WorkSpacesWebClientTypes.BrowserSettingsSummary]()
            for structure0 in browserSettingsContainer {
                if let structure0 = structure0 {
                    browserSettingsDecoded0?.append(structure0)
                }
            }
        }
        browserSettings = browserSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/identityProviders"
    }
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalArn = portalArn
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
}

extension ListIdentityProvidersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviders = output.identityProviders
            self.nextToken = output.nextToken
        } else {
            self.identityProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutput: Swift.Equatable {
    /// The identity providers.
    public var identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviders = identityProviders
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
}

extension ListIdentityProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviders
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let identityProvidersContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IdentityProviderSummary?].self, forKey: .identityProviders)
        var identityProvidersDecoded0:[WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil
        if let identityProvidersContainer = identityProvidersContainer {
            identityProvidersDecoded0 = [WorkSpacesWebClientTypes.IdentityProviderSummary]()
            for structure0 in identityProvidersContainer {
                if let structure0 = structure0 {
                    identityProvidersDecoded0?.append(structure0)
                }
            }
        }
        identityProviders = identityProvidersDecoded0
    }
}

enum ListIdentityProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIpAccessSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ipAccessSettings"
    }
}

public struct ListIpAccessSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIpAccessSettingsInputBody: Swift.Equatable {
}

extension ListIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIpAccessSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
            self.nextToken = output.nextToken
        } else {
            self.ipAccessSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListIpAccessSettingsOutput: Swift.Equatable {
    /// The IP access settings.
    public var ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
        self.nextToken = nextToken
    }
}

struct ListIpAccessSettingsOutputBody: Swift.Equatable {
    let ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListIpAccessSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpAccessSettingsSummary?].self, forKey: .ipAccessSettings)
        var ipAccessSettingsDecoded0:[WorkSpacesWebClientTypes.IpAccessSettingsSummary]? = nil
        if let ipAccessSettingsContainer = ipAccessSettingsContainer {
            ipAccessSettingsDecoded0 = [WorkSpacesWebClientTypes.IpAccessSettingsSummary]()
            for structure0 in ipAccessSettingsContainer {
                if let structure0 = structure0 {
                    ipAccessSettingsDecoded0?.append(structure0)
                }
            }
        }
        ipAccessSettings = ipAccessSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct ListNetworkSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsInputBody: Swift.Equatable {
}

extension ListNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworkSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
            self.nextToken = output.nextToken
        } else {
            self.networkSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSettingsOutput: Swift.Equatable {
    /// The network settings.
    public var networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSettings = networkSettings
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsOutputBody: Swift.Equatable {
    let networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListNetworkSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.NetworkSettingsSummary?].self, forKey: .networkSettings)
        var networkSettingsDecoded0:[WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil
        if let networkSettingsContainer = networkSettingsContainer {
            networkSettingsDecoded0 = [WorkSpacesWebClientTypes.NetworkSettingsSummary]()
            for structure0 in networkSettingsContainer {
                if let structure0 = structure0 {
                    networkSettingsDecoded0?.append(structure0)
                }
            }
        }
        networkSettings = networkSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPortalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portals = output.portals
        } else {
            self.nextToken = nil
            self.portals = nil
        }
    }
}

public struct ListPortalsOutput: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The portals in the list.
    public var portals: [WorkSpacesWebClientTypes.PortalSummary]?

    public init(
        nextToken: Swift.String? = nil,
        portals: [WorkSpacesWebClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portals = portals
    }
}

struct ListPortalsOutputBody: Swift.Equatable {
    let portals: [WorkSpacesWebClientTypes.PortalSummary]?
    let nextToken: Swift.String?
}

extension ListPortalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.PortalSummary?].self, forKey: .portals)
        var portalsDecoded0:[WorkSpacesWebClientTypes.PortalSummary]? = nil
        if let portalsContainer = portalsContainer {
            portalsDecoded0 = [WorkSpacesWebClientTypes.PortalSummary]()
            for structure0 in portalsContainer {
                if let structure0 = structure0 {
                    portalsDecoded0?.append(structure0)
                }
            }
        }
        portals = portalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPortalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags of the resource.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificates"
    }
}

public struct ListTrustStoreCertificatesInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the trust store
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesInputBody: Swift.Equatable {
}

extension ListTrustStoreCertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoreCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustStoreCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateList = output.certificateList
            self.nextToken = output.nextToken
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificateList = nil
            self.nextToken = nil
            self.trustStoreArn = nil
        }
    }
}

public struct ListTrustStoreCertificatesOutput: Swift.Equatable {
    /// The certificate list.
    public var certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.>
    public var nextToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificateList: [WorkSpacesWebClientTypes.CertificateSummary]? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificateList = certificateList
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesOutputBody: Swift.Equatable {
    let certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    let trustStoreArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTrustStoreCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case nextToken
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CertificateSummary?].self, forKey: .certificateList)
        var certificateListDecoded0:[WorkSpacesWebClientTypes.CertificateSummary]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [WorkSpacesWebClientTypes.CertificateSummary]()
            for structure0 in certificateListContainer {
                if let structure0 = structure0 {
                    certificateListDecoded0?.append(structure0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrustStoreCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct ListTrustStoresInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrustStoresInputBody: Swift.Equatable {
}

extension ListTrustStoresInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustStores = output.trustStores
        } else {
            self.nextToken = nil
            self.trustStores = nil
        }
    }
}

public struct ListTrustStoresOutput: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The trust stores.
    public var trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustStores = trustStores
    }
}

struct ListTrustStoresOutputBody: Swift.Equatable {
    let trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?
    let nextToken: Swift.String?
}

extension ListTrustStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoresContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.TrustStoreSummary?].self, forKey: .trustStores)
        var trustStoresDecoded0:[WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
        if let trustStoresContainer = trustStoresContainer {
            trustStoresDecoded0 = [WorkSpacesWebClientTypes.TrustStoreSummary]()
            for structure0 in trustStoresContainer {
                if let structure0 = structure0 {
                    trustStoresDecoded0?.append(structure0)
                }
            }
        }
        trustStores = trustStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrustStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct ListUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension ListUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserAccessLoggingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.nextToken = nil
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct ListUserAccessLoggingSettingsOutput: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user access logging settings.
    public var userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct ListUserAccessLoggingSettingsOutputBody: Swift.Equatable {
    let userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserAccessLoggingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary?].self, forKey: .userAccessLoggingSettings)
        var userAccessLoggingSettingsDecoded0:[WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
        if let userAccessLoggingSettingsContainer = userAccessLoggingSettingsContainer {
            userAccessLoggingSettingsDecoded0 = [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]()
            for structure0 in userAccessLoggingSettingsContainer {
                if let structure0 = structure0 {
                    userAccessLoggingSettingsDecoded0?.append(structure0)
                }
            }
        }
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct ListUserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserSettingsInputBody: Swift.Equatable {
}

extension ListUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSettings = output.userSettings
        } else {
            self.nextToken = nil
            self.userSettings = nil
        }
    }
}

public struct ListUserSettingsOutput: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user settings.
    public var userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSettings = userSettings
    }
}

struct ListUserSettingsOutputBody: Swift.Equatable {
    let userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserSettingsSummary?].self, forKey: .userSettings)
        var userSettingsDecoded0:[WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [WorkSpacesWebClientTypes.UserSettingsSummary]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case networkSettingsArn
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension WorkSpacesWebClientTypes {
    /// A network settings resource that can be associated with a web portal. Once associated with a web portal, network settings define how streaming instances will connect with your specified VPC.
    public struct NetworkSettings: Swift.Equatable {
        /// A list of web portal ARNs that this network settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public var securityGroupIds: [Swift.String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public var subnetIds: [Swift.String]?
        /// The VPC that streaming instances will connect to.
        public var vpcId: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            networkSettingsArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of network settings.
    public struct NetworkSettingsSummary: Swift.Equatable {
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// The VPC ID of the network settings.
        public var vpcId: Swift.String?

        public init(
            networkSettingsArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.Portal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case ipAccessSettingsArn
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case statusReason
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.Portal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Portal(authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), statusReason: \(Swift.String(describing: statusReason)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The web portal.
    public struct Portal: Swift.Equatable {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with this web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser that users see when using a streaming session.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// A message that explains why the web portal is in its current status.
        public var statusReason: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            statusReason: Swift.String? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum PortalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case incomplete
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalStatus] {
            return [
                .active,
                .incomplete,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .incomplete: return "Incomplete"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalStatus(rawValue: rawValue) ?? PortalStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case ipAccessSettingsArn
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the portal.
    public struct PortalSummary: Swift.Equatable {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with the web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser type of the web portal.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum RendererType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream
        case sdkUnknown(Swift.String)

        public static var allCases: [RendererType] {
            return [
                .appstream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "AppStream"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RendererType(rawValue: rawValue) ?? RendererType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {
    /// The tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a throttling error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource affected.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A trust store that can be associated with a web portal. A trust store contains certificate authority (CA) certificates. Once associated with a web portal, the browser in a streaming session will recognize certificates that have been issued using any of the CAs in the trust store. If your organization has internal websites that use certificates issued by private CAs, you should add the private CA certificate to the trust store.
    public struct TrustStore: Swift.Equatable {
        /// A list of web portal ARNs that this trust store is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the trust store.
        /// This member is required.
        public var trustStoreArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            trustStoreArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension WorkSpacesWebClientTypes.TrustStoreSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the trust store.
    public struct TrustStoreSummary: Swift.Equatable {
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init(
            trustStoreArn: Swift.String? = nil
        )
        {
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), clientToken: \(Swift.String(describing: clientToken)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension UpdateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateBrowserSettingsInput: Swift.Equatable {
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    public var browserPolicy: Swift.String?
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?

    public init(
        browserPolicy: Swift.String? = nil,
        browserSettingsArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.browserPolicy = browserPolicy
        self.browserSettingsArn = browserSettingsArn
        self.clientToken = clientToken
    }
}

struct UpdateBrowserSettingsInputBody: Swift.Equatable {
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateBrowserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrowserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct UpdateBrowserSettingsOutput: Swift.Equatable {
    /// The browser settings.
    /// This member is required.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct UpdateBrowserSettingsOutputBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension UpdateBrowserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

enum UpdateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension UpdateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

extension UpdateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The name of the identity provider.
    public var identityProviderName: Swift.String?
    /// The type of the identity provider.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderArn: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderArn = identityProviderArn
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderInputBody: Swift.Equatable {
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct UpdateIdentityProviderOutput: Swift.Equatable {
    /// The identity provider.
    /// This member is required.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct UpdateIdentityProviderOutputBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension UpdateIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

enum UpdateIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIpAccessSettingsInput(clientToken: \(Swift.String(describing: clientToken)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension UpdateIpAccessSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case displayName
        case ipRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
    }
}

extension UpdateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateIpAccessSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The updated IP rules of the IP access settings.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipAccessSettingsArn: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.ipRules = ipRules
    }
}

struct UpdateIpAccessSettingsInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let ipRules: [WorkSpacesWebClientTypes.IpRule]?
    let clientToken: Swift.String?
}

extension UpdateIpAccessSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case displayName
        case ipRules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateIpAccessSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIpAccessSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
        } else {
            self.ipAccessSettings = nil
        }
    }
}

public struct UpdateIpAccessSettingsOutput: Swift.Equatable {
    /// The IP access settings.
    /// This member is required.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

struct UpdateIpAccessSettingsOutputBody: Swift.Equatable {
    let ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?
}

extension UpdateIpAccessSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IpAccessSettings.self, forKey: .ipAccessSettings)
        ipAccessSettings = ipAccessSettingsDecoded
    }
}

enum UpdateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension UpdateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    public var subnetIds: [Swift.String]?
    /// The VPC that streaming instances will connect to.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkSettingsArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSettingsArn = networkSettingsArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateNetworkSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNetworkSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct UpdateNetworkSettingsOutput: Swift.Equatable {
    /// The network settings.
    /// This member is required.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct UpdateNetworkSettingsOutputBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension UpdateNetworkSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

enum UpdateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(authenticationType: \(Swift.String(describing: authenticationType)), portalArn: \(Swift.String(describing: portalArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension UpdatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdatePortalInput: Swift.Equatable {
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        displayName: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.displayName = displayName
        self.portalArn = portalArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case displayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension UpdatePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct UpdatePortalOutput: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct UpdatePortalOutputBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension UpdatePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

enum UpdatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatesToAdd = certificatesToAdd {
            var certificatesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToAdd)
            for certificateauthoritybody0 in certificatesToAdd {
                try certificatesToAddContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let certificatesToDelete = certificatesToDelete {
            var certificatesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToDelete)
            for certificatethumbprint0 in certificatesToDelete {
                try certificatesToDeleteContainer.encode(certificatethumbprint0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to add to the trust store.
    public var certificatesToAdd: [ClientRuntime.Data]?
    /// A list of CA certificates to delete from a trust store.
    public var certificatesToDelete: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificatesToAdd: [ClientRuntime.Data]? = nil,
        certificatesToDelete: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificatesToAdd = certificatesToAdd
        self.certificatesToDelete = certificatesToDelete
        self.clientToken = clientToken
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreInputBody: Swift.Equatable {
    let certificatesToAdd: [ClientRuntime.Data]?
    let certificatesToDelete: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesToAddContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificatesToAdd)
        var certificatesToAddDecoded0:[ClientRuntime.Data]? = nil
        if let certificatesToAddContainer = certificatesToAddContainer {
            certificatesToAddDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificatesToAddContainer {
                if let blob0 = blob0 {
                    certificatesToAddDecoded0?.append(blob0)
                }
            }
        }
        certificatesToAdd = certificatesToAddDecoded0
        let certificatesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificatesToDelete)
        var certificatesToDeleteDecoded0:[Swift.String]? = nil
        if let certificatesToDeleteContainer = certificatesToDeleteContainer {
            certificatesToDeleteDecoded0 = [Swift.String]()
            for string0 in certificatesToDeleteContainer {
                if let string0 = string0 {
                    certificatesToDeleteDecoded0?.append(string0)
                }
            }
        }
        certificatesToDelete = certificatesToDeleteDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateTrustStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrustStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct UpdateTrustStoreOutput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreOutputBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension UpdateTrustStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

enum UpdateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
    }
}

extension UpdateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    public var kinesisStreamArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct UpdateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserAccessLoggingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserAccessLoggingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct UpdateUserAccessLoggingSettingsOutput: Swift.Equatable {
    /// The user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct UpdateUserAccessLoggingSettingsOutputBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension UpdateUserAccessLoggingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

enum UpdateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsInput(clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension UpdateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension UpdateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser. If the allowlist and blocklist are empty, the configuration becomes null.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.uploadAllowed = uploadAllowed
        self.userSettingsArn = userSettingsArn
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
    let cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

extension UpdateUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct UpdateUserSettingsOutput: Swift.Equatable {
    /// The user settings.
    /// This member is required.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsOutputBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension UpdateUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

enum UpdateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A user access logging settings resource that can be associated with a web portal.
    public struct UserAccessLoggingSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of user access logging settings.
    public struct UserAccessLoggingSettingsSummary: Swift.Equatable {
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// A user settings resource that can be associated with a web portal. Once associated with a web portal, user settings control how users can transfer data between a streaming session and the their local devices.
    public struct UserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettingsSummary(copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of user settings.
    public struct UserSettingsSummary: Swift.Equatable {
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a validation error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error.
        public internal(set) var fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: WorkSpacesWebClientTypes.ValidationExceptionReason?
    let fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [WorkSpacesWebClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// Information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
