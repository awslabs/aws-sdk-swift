// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let browserSettingsArn = browserSettingsArn else {
                let message = "Creating a URL Query Item failed. browserSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let browserSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "browserSettingsArn".urlPercentEncoding(), value: Swift.String(browserSettingsArn).urlPercentEncoding())
            items.append(browserSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

public struct AssociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsInputBody: Swift.Equatable {
}

extension AssociateBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.browserSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let browserSettingsArn: Swift.String?
}

extension AssociateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension AssociateIpAccessSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let ipAccessSettingsArn = ipAccessSettingsArn else {
                let message = "Creating a URL Query Item failed. ipAccessSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let ipAccessSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "ipAccessSettingsArn".urlPercentEncoding(), value: Swift.String(ipAccessSettingsArn).urlPercentEncoding())
            items.append(ipAccessSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

public struct AssociateIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateIpAccessSettingsInputBody: Swift.Equatable {
}

extension AssociateIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateIpAccessSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettingsArn = output.ipAccessSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.ipAccessSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateIpAccessSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateIpAccessSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let ipAccessSettingsArn: Swift.String?
}

extension AssociateIpAccessSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let networkSettingsArn = networkSettingsArn else {
                let message = "Creating a URL Query Item failed. networkSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let networkSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "networkSettingsArn".urlPercentEncoding(), value: Swift.String(networkSettingsArn).urlPercentEncoding())
            items.append(networkSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

public struct AssociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsInputBody: Swift.Equatable {
}

extension AssociateNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.networkSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let networkSettingsArn: Swift.String?
}

extension AssociateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

extension AssociateTrustStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let trustStoreArn = trustStoreArn else {
                let message = "Creating a URL Query Item failed. trustStoreArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let trustStoreArnQueryItem = ClientRuntime.URLQueryItem(name: "trustStoreArn".urlPercentEncoding(), value: Swift.String(trustStoreArn).urlPercentEncoding())
            items.append(trustStoreArnQueryItem)
            return items
        }
    }
}

extension AssociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

public struct AssociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreInputBody: Swift.Equatable {
}

extension AssociateTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.portalArn = nil
            self.trustStoreArn = nil
        }
    }
}

public struct AssociateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let trustStoreArn: Swift.String?
}

extension AssociateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
                let message = "Creating a URL Query Item failed. userAccessLoggingSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userAccessLoggingSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userAccessLoggingSettingsArn".urlPercentEncoding(), value: Swift.String(userAccessLoggingSettingsArn).urlPercentEncoding())
            items.append(userAccessLoggingSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

public struct AssociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension AssociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.portalArn = nil
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct AssociateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct AssociateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userAccessLoggingSettingsArn: Swift.String?
}

extension AssociateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userAccessLoggingSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension AssociateUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userSettingsArn = userSettingsArn else {
                let message = "Creating a URL Query Item failed. userSettingsArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userSettingsArn".urlPercentEncoding(), value: Swift.String(userSettingsArn).urlPercentEncoding())
            items.append(userSettingsArnQueryItem)
            return items
        }
    }
}

extension AssociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

public struct AssociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsInputBody: Swift.Equatable {
}

extension AssociateUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.portalArn = nil
            self.userSettingsArn = nil
        }
    }
}

public struct AssociateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let userSettingsArn: Swift.String?
}

extension AssociateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iamIdentityCenter
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .iamIdentityCenter,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iamIdentityCenter: return "IAM_Identity_Center"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case browserPolicy
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The browser settings resource that can be associated with a web portal. Once associated with a web portal, browser settings control how the browser will behave once a user starts a streaming session for the web portal.
    public struct BrowserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this browser settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public var browserPolicy: Swift.String?
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            browserPolicy: Swift.String? = nil,
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary for browser settings.
    public struct BrowserSettingsSummary: Swift.Equatable {
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init(
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum BrowserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chrome
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserType] {
            return [
                .chrome,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrome: return "Chrome"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrowserType(rawValue: rawValue) ?? BrowserType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The certificate.
    public struct Certificate: Swift.Equatable {
        /// The body of the certificate.
        public var body: ClientRuntime.Data?
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            body: ClientRuntime.Data? = nil,
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension WorkSpacesWebClientTypes.CertificateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = self.notValidAfter {
            try encodeContainer.encodeTimestamp(notValidAfter, format: .epochSeconds, forKey: .notValidAfter)
        }
        if let notValidBefore = self.notValidBefore {
            try encodeContainer.encodeTimestamp(notValidBefore, format: .epochSeconds, forKey: .notValidBefore)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = self.thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the certificate.
    public struct CertificateSummary: Swift.Equatable {
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init(
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.CookieSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// Specifies a single cookie or set of cookies in an end user's browser.
    public struct CookieSpecification: Swift.Equatable {
        /// The domain of the cookie.
        /// This member is required.
        public var domain: Swift.String?
        /// The name of the cookie.
        public var name: Swift.String?
        /// The path of the cookie.
        public var path: Swift.String?

        public init(
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.path = path
        }
    }

}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowlist
        case blocklist
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowlist = allowlist {
            var allowlistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowlist)
            for cookiespecification0 in allowlist {
                try allowlistContainer.encode(cookiespecification0)
            }
        }
        if let blocklist = blocklist {
            var blocklistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blocklist)
            for cookiespecification0 in blocklist {
                try blocklistContainer.encode(cookiespecification0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowlistContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CookieSpecification?].self, forKey: .allowlist)
        var allowlistDecoded0:[WorkSpacesWebClientTypes.CookieSpecification]? = nil
        if let allowlistContainer = allowlistContainer {
            allowlistDecoded0 = [WorkSpacesWebClientTypes.CookieSpecification]()
            for structure0 in allowlistContainer {
                if let structure0 = structure0 {
                    allowlistDecoded0?.append(structure0)
                }
            }
        }
        allowlist = allowlistDecoded0
        let blocklistContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CookieSpecification?].self, forKey: .blocklist)
        var blocklistDecoded0:[WorkSpacesWebClientTypes.CookieSpecification]? = nil
        if let blocklistContainer = blocklistContainer {
            blocklistDecoded0 = [WorkSpacesWebClientTypes.CookieSpecification]()
            for structure0 in blocklistContainer {
                if let structure0 = structure0 {
                    blocklistDecoded0?.append(structure0)
                }
            }
        }
        blocklist = blocklistDecoded0
    }
}

extension WorkSpacesWebClientTypes.CookieSynchronizationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public struct CookieSynchronizationConfiguration: Swift.Equatable {
        /// The list of cookie specifications that are allowed to be synchronized to the remote browser.
        /// This member is required.
        public var allowlist: [WorkSpacesWebClientTypes.CookieSpecification]?
        /// The list of cookie specifications that are blocked from being synchronized to the remote browser.
        public var blocklist: [WorkSpacesWebClientTypes.CookieSpecification]?

        public init(
            allowlist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil,
            blocklist: [WorkSpacesWebClientTypes.CookieSpecification]? = nil
        )
        {
            self.allowlist = allowlist
            self.blocklist = blocklist
        }
    }

}

extension CreateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension CreateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct CreateBrowserSettingsInput: Swift.Equatable {
    /// Additional encryption context of the browser settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    /// This member is required.
    public var browserPolicy: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the browser settings.
    public var customerManagedKey: Swift.String?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        browserPolicy: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.browserPolicy = browserPolicy
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.tags = tags
    }
}

struct CreateBrowserSettingsInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
        } else {
            self.browserSettingsArn = nil
        }
    }
}

public struct CreateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct CreateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettingsArn: Swift.String?
}

extension CreateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension CreateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderType: \(Swift.String(describing: identityProviderType)), portalArn: \(Swift.String(describing: portalArn)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension CreateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
    }
}

extension CreateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identityProviders"
    }
}

public struct CreateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    /// This member is required.
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The identity provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// The identity provider type.
    /// This member is required.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
        self.portalArn = portalArn
    }
}

struct CreateIdentityProviderInputBody: Swift.Equatable {
    let portalArn: Swift.String?
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderArn = output.identityProviderArn
        } else {
            self.identityProviderArn = nil
        }
    }
}

public struct CreateIdentityProviderOutputResponse: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct CreateIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProviderArn: Swift.String?
}

extension CreateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
    }
}

extension CreateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIpAccessSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension CreateIpAccessSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case description
        case displayName
        case ipRules
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ipAccessSettings"
    }
}

public struct CreateIpAccessSettingsInput: Swift.Equatable {
    /// Additional encryption context of the IP access settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the IP access settings.
    public var customerManagedKey: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The IP rules of the IP access settings.
    /// This member is required.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.description = description
        self.displayName = displayName
        self.ipRules = ipRules
        self.tags = tags
    }
}

struct CreateIpAccessSettingsInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let ipRules: [WorkSpacesWebClientTypes.IpRule]?
    let clientToken: Swift.String?
}

extension CreateIpAccessSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case description
        case displayName
        case ipRules
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIpAccessSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettingsArn = output.ipAccessSettingsArn
        } else {
            self.ipAccessSettingsArn = nil
        }
    }
}

public struct CreateIpAccessSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the IP access settings resource.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct CreateIpAccessSettingsOutputResponseBody: Swift.Equatable {
    let ipAccessSettingsArn: Swift.String?
}

extension CreateIpAccessSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension CreateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct CreateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags to add to the network settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// The VPC that streaming instances will connect to.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
        } else {
            self.networkSettingsArn = nil
        }
    }
}

public struct CreateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct CreateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettingsArn: Swift.String?
}

extension CreateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), authenticationType: \(Swift.String(describing: authenticationType)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case authenticationType
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct CreatePortalInput: Swift.Equatable {
    /// The additional encryption context of the portal.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The customer managed key of the web portal.
    public var customerManagedKey: Swift.String?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The tags to add to the web portal. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.authenticationType = authenticationType
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.displayName = displayName
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case authenticationType
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

public enum CreatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalEndpoint = output.portalEndpoint
        } else {
            self.portalArn = nil
            self.portalEndpoint = nil
        }
    }
}

public struct CreatePortalOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The endpoint URL of the web portal that users access in order to start streaming sessions.
    /// This member is required.
    public var portalEndpoint: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        portalEndpoint: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalEndpoint = portalEndpoint
    }
}

struct CreatePortalOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let portalEndpoint: Swift.String?
}

extension CreatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
    }
}

extension CreateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateList = certificateList {
            var certificateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateList)
            for certificateauthoritybody0 in certificateList {
                try certificateListContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct CreateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to be added to the trust store.
    /// This member is required.
    public var certificateList: [ClientRuntime.Data]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The tags to add to the trust store. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        certificateList: [ClientRuntime.Data]? = nil,
        clientToken: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.certificateList = certificateList
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateTrustStoreInputBody: Swift.Equatable {
    let certificateList: [ClientRuntime.Data]?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificateList)
        var certificateListDecoded0:[ClientRuntime.Data]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificateListContainer {
                if let blob0 = blob0 {
                    certificateListDecoded0?.append(blob0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct CreateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct CreateTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension CreateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension CreateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct CreateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    /// This member is required.
    public var kinesisStreamArn: Swift.String?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.tags = tags
    }
}

struct CreateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettingsArn = output.userAccessLoggingSettingsArn
        } else {
            self.userAccessLoggingSettingsArn = nil
        }
    }
}

public struct CreateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct CreateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettingsArn: Swift.String?
}

extension CreateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
    }
}

extension CreateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), tags: \(Swift.String(describing: tags)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case customerManagedKey
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptionContextMap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let customerManagedKey = self.customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension CreateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct CreateUserSettingsInput: Swift.Equatable {
    /// The additional encryption context of the user settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    /// This member is required.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The customer managed key used to encrypt sensitive information in the user settings.
    public var customerManagedKey: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    /// This member is required.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    /// This member is required.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    /// This member is required.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    /// This member is required.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?

    public init(
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        customerManagedKey: Swift.String? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.customerManagedKey = customerManagedKey
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.tags = tags
        self.uploadAllowed = uploadAllowed
    }
}

struct CreateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
    let cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    let customerManagedKey: Swift.String?
    let additionalEncryptionContext: [Swift.String:Swift.String]?
}

extension CreateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case customerManagedKey
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
    }
}

public enum CreateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.userSettingsArn = nil
        }
    }
}

public struct CreateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct CreateUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettingsArn: Swift.String?
}

extension CreateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettingsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension DeleteBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct DeleteBrowserSettingsInputBody: Swift.Equatable {
}

extension DeleteBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBrowserSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct DeleteIdentityProviderInputBody: Swift.Equatable {
}

extension DeleteIdentityProviderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIdentityProviderOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct DeleteIpAccessSettingsInputBody: Swift.Equatable {
}

extension DeleteIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIpAccessSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct DeleteNetworkSettingsInputBody: Swift.Equatable {
}

extension DeleteNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNetworkSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeletePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeletePortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeletePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePortalOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct DeleteTrustStoreInputBody: Swift.Equatable {
}

extension DeleteTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrustStoreOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct DeleteUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DeleteUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserAccessLoggingSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct DeleteUserSettingsInputBody: Swift.Equatable {
}

extension DeleteUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/browserSettings"
    }
}

public struct DisassociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateBrowserSettingsInputBody: Swift.Equatable {
}

extension DisassociateBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateBrowserSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/ipAccessSettings"
    }
}

public struct DisassociateIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateIpAccessSettingsInputBody: Swift.Equatable {
}

extension DisassociateIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateIpAccessSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/networkSettings"
    }
}

public struct DisassociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateNetworkSettingsInputBody: Swift.Equatable {
}

extension DisassociateNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateNetworkSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/trustStores"
    }
}

public struct DisassociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateTrustStoreInputBody: Swift.Equatable {
}

extension DisassociateTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTrustStoreOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userAccessLoggingSettings"
    }
}

public struct DisassociateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/userSettings"
    }
}

public struct DisassociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateUserSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension WorkSpacesWebClientTypes {
    public enum EnabledType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnabledType] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnabledType(rawValue: rawValue) ?? EnabledType.sdkUnknown(rawValue)
        }
    }
}

extension GetBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init(
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct GetBrowserSettingsInputBody: Swift.Equatable {
}

extension GetBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct GetBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct GetBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension GetBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

extension GetIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct GetIdentityProviderInputBody: Swift.Equatable {
}

extension GetIdentityProviderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct GetIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct GetIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension GetIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

extension GetIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetIpAccessSettingsInput: Swift.Equatable {
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?

    public init(
        ipAccessSettingsArn: Swift.String? = nil
    )
    {
        self.ipAccessSettingsArn = ipAccessSettingsArn
    }
}

struct GetIpAccessSettingsInputBody: Swift.Equatable {
}

extension GetIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIpAccessSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
        } else {
            self.ipAccessSettings = nil
        }
    }
}

public struct GetIpAccessSettingsOutputResponse: Swift.Equatable {
    /// The IP access settings.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

struct GetIpAccessSettingsOutputResponseBody: Swift.Equatable {
    let ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?
}

extension GetIpAccessSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IpAccessSettings.self, forKey: .ipAccessSettings)
        ipAccessSettings = ipAccessSettingsDecoded
    }
}

extension GetNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init(
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct GetNetworkSettingsInputBody: Swift.Equatable {
}

extension GetNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct GetNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct GetNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension GetNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

extension GetPortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetPortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalInputBody: Swift.Equatable {
}

extension GetPortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetPortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct GetPortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct GetPortalOutputResponseBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension GetPortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

extension GetPortalServiceProviderMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portalIdp/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetPortalServiceProviderMetadataInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalServiceProviderMetadataInputBody: Swift.Equatable {
}

extension GetPortalServiceProviderMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetPortalServiceProviderMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortalServiceProviderMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortalServiceProviderMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.portalArn = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct GetPortalServiceProviderMetadataOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service provider SAML metadata.
    public var serviceProviderSamlMetadata: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct GetPortalServiceProviderMetadataOutputResponseBody: Swift.Equatable {
    let portalArn: Swift.String?
    let serviceProviderSamlMetadata: Swift.String?
}

extension GetPortalServiceProviderMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case serviceProviderSamlMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let thumbprint = thumbprint else {
                let message = "Creating a URL Query Item failed. thumbprint is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let thumbprintQueryItem = ClientRuntime.URLQueryItem(name: "thumbprint".urlPercentEncoding(), value: Swift.String(thumbprint).urlPercentEncoding())
            items.append(thumbprintQueryItem)
            return items
        }
    }
}

extension GetTrustStoreCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificate"
    }
}

public struct GetTrustStoreCertificateInput: Swift.Equatable {
    /// The thumbprint of the trust store certificate.
    /// This member is required.
    public var thumbprint: Swift.String?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        thumbprint: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.thumbprint = thumbprint
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateInputBody: Swift.Equatable {
}

extension GetTrustStoreCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetTrustStoreCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrustStoreCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrustStoreCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificate = nil
            self.trustStoreArn = nil
        }
    }
}

public struct GetTrustStoreCertificateOutputResponse: Swift.Equatable {
    /// The certificate of the trust store certificate.
    public var certificate: WorkSpacesWebClientTypes.Certificate?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificate: WorkSpacesWebClientTypes.Certificate? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
    let certificate: WorkSpacesWebClientTypes.Certificate?
}

extension GetTrustStoreCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension GetTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreInputBody: Swift.Equatable {
}

extension GetTrustStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStore = output.trustStore
        } else {
            self.trustStore = nil
        }
    }
}

public struct GetTrustStoreOutputResponse: Swift.Equatable {
    /// The trust store.
    public var trustStore: WorkSpacesWebClientTypes.TrustStore?

    public init(
        trustStore: WorkSpacesWebClientTypes.TrustStore? = nil
    )
    {
        self.trustStore = trustStore
    }
}

struct GetTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStore: WorkSpacesWebClientTypes.TrustStore?
}

extension GetTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStore
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.TrustStore.self, forKey: .trustStore)
        trustStore = trustStoreDecoded
    }
}

extension GetUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct GetUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension GetUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct GetUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The user access logging settings.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct GetUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension GetUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

extension GetUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension GetUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProvider(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The identity provider.
    public struct IdentityProvider: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
        ///
        /// * For Google and Login with Amazon:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For Facebook:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        /// * api_version
        ///
        ///
        ///
        ///
        /// * For Sign in with Apple:
        ///
        /// * client_id
        ///
        /// * team_id
        ///
        /// * key_id
        ///
        /// * private_key
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For OIDC providers:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * attributes_request_method
        ///
        /// * oidc_issuer
        ///
        /// * authorize_scopes
        ///
        /// * authorize_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * token_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * attributes_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
        ///
        ///
        ///
        ///
        /// * For SAML providers:
        ///
        /// * MetadataFile OR MetadataURL
        ///
        /// * IDPSignout optional
        public var identityProviderDetails: [Swift.String:Swift.String]?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderDetails: [Swift.String:Swift.String]? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = self.identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderSummary(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init(
            identityProviderArn: Swift.String? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case facebook
        case google
        case loginwithamazon
        case oidc
        case saml
        case signinwithapple
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .facebook,
                .google,
                .loginwithamazon,
                .oidc,
                .saml,
                .signinwithapple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .facebook: return "Facebook"
            case .google: return "Google"
            case .loginwithamazon: return "LoginWithAmazon"
            case .oidc: return "OIDC"
            case .saml: return "SAML"
            case .signinwithapple: return "SignInWithApple"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case creationDate
        case description
        case displayName
        case ipAccessSettingsArn
        case ipRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The IP access settings resource that can be associated with a web portal.
    public struct IpAccessSettings: Swift.Equatable {
        /// A list of web portal ARNs that this IP access settings resource is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The creation date timestamp of the IP access settings.
        public var creationDate: ClientRuntime.Date?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings resource.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?
        /// The IP rules of the IP access settings.
        public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }
    }

}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case displayName
        case ipAccessSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension WorkSpacesWebClientTypes.IpAccessSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpAccessSettingsSummary(creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of IP access settings.
    public struct IpAccessSettingsSummary: Swift.Equatable {
        /// The creation date timestamp of the IP access settings.
        public var creationDate: ClientRuntime.Date?
        /// The description of the IP access settings.
        public var description: Swift.String?
        /// The display name of the IP access settings.
        public var displayName: Swift.String?
        /// The ARN of IP access settings.
        /// This member is required.
        public var ipAccessSettingsArn: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.IpRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ipRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ipRange = self.ipRange {
            try encodeContainer.encode(ipRange, forKey: .ipRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRange)
        ipRange = ipRangeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkSpacesWebClientTypes.IpRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpRule(description: \"CONTENT_REDACTED\", ipRange: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The IP rules of the IP access settings.
    public struct IpRule: Swift.Equatable {
        /// The description of the IP rule.
        public var description: Swift.String?
        /// The IP range of the IP rule.
        /// This member is required.
        public var ipRange: Swift.String?

        public init(
            description: Swift.String? = nil,
            ipRange: Swift.String? = nil
        )
        {
            self.description = description
            self.ipRange = ipRange
        }
    }

}

extension ListBrowserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/browserSettings"
    }
}

public struct ListBrowserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsInputBody: Swift.Equatable {
}

extension ListBrowserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
            self.nextToken = output.nextToken
        } else {
            self.browserSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.browserSettings = browserSettings
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.BrowserSettingsSummary?].self, forKey: .browserSettings)
        var browserSettingsDecoded0:[WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil
        if let browserSettingsContainer = browserSettingsContainer {
            browserSettingsDecoded0 = [WorkSpacesWebClientTypes.BrowserSettingsSummary]()
            for structure0 in browserSettingsContainer {
                if let structure0 = structure0 {
                    browserSettingsDecoded0?.append(structure0)
                }
            }
        }
        browserSettings = browserSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))/identityProviders"
    }
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalArn = portalArn
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
}

extension ListIdentityProvidersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListIdentityProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentityProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviders = output.identityProviders
            self.nextToken = output.nextToken
        } else {
            self.identityProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutputResponse: Swift.Equatable {
    /// The identity providers.
    public var identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviders = identityProviders
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
}

extension ListIdentityProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviders
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let identityProvidersContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IdentityProviderSummary?].self, forKey: .identityProviders)
        var identityProvidersDecoded0:[WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil
        if let identityProvidersContainer = identityProvidersContainer {
            identityProvidersDecoded0 = [WorkSpacesWebClientTypes.IdentityProviderSummary]()
            for structure0 in identityProvidersContainer {
                if let structure0 = structure0 {
                    identityProvidersDecoded0?.append(structure0)
                }
            }
        }
        identityProviders = identityProvidersDecoded0
    }
}

extension ListIpAccessSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ipAccessSettings"
    }
}

public struct ListIpAccessSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIpAccessSettingsInputBody: Swift.Equatable {
}

extension ListIpAccessSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIpAccessSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
            self.nextToken = output.nextToken
        } else {
            self.ipAccessSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListIpAccessSettingsOutputResponse: Swift.Equatable {
    /// The IP access settings.
    public var ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
        self.nextToken = nextToken
    }
}

struct ListIpAccessSettingsOutputResponseBody: Swift.Equatable {
    let ipAccessSettings: [WorkSpacesWebClientTypes.IpAccessSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListIpAccessSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpAccessSettingsSummary?].self, forKey: .ipAccessSettings)
        var ipAccessSettingsDecoded0:[WorkSpacesWebClientTypes.IpAccessSettingsSummary]? = nil
        if let ipAccessSettingsContainer = ipAccessSettingsContainer {
            ipAccessSettingsDecoded0 = [WorkSpacesWebClientTypes.IpAccessSettingsSummary]()
            for structure0 in ipAccessSettingsContainer {
                if let structure0 = structure0 {
                    ipAccessSettingsDecoded0?.append(structure0)
                }
            }
        }
        ipAccessSettings = ipAccessSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/networkSettings"
    }
}

public struct ListNetworkSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsInputBody: Swift.Equatable {
}

extension ListNetworkSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
            self.nextToken = output.nextToken
        } else {
            self.networkSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSettings = networkSettings
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.NetworkSettingsSummary?].self, forKey: .networkSettings)
        var networkSettingsDecoded0:[WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil
        if let networkSettingsContainer = networkSettingsContainer {
            networkSettingsDecoded0 = [WorkSpacesWebClientTypes.NetworkSettingsSummary]()
            for structure0 in networkSettingsContainer {
                if let structure0 = structure0 {
                    networkSettingsDecoded0?.append(structure0)
                }
            }
        }
        networkSettings = networkSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPortalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListPortalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portals = output.portals
        } else {
            self.nextToken = nil
            self.portals = nil
        }
    }
}

public struct ListPortalsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The portals in the list.
    public var portals: [WorkSpacesWebClientTypes.PortalSummary]?

    public init(
        nextToken: Swift.String? = nil,
        portals: [WorkSpacesWebClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portals = portals
    }
}

struct ListPortalsOutputResponseBody: Swift.Equatable {
    let portals: [WorkSpacesWebClientTypes.PortalSummary]?
    let nextToken: Swift.String?
}

extension ListPortalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.PortalSummary?].self, forKey: .portals)
        var portalsDecoded0:[WorkSpacesWebClientTypes.PortalSummary]? = nil
        if let portalsContainer = portalsContainer {
            portalsDecoded0 = [WorkSpacesWebClientTypes.PortalSummary]()
            for structure0 in portalsContainer {
                if let structure0 = structure0 {
                    portalsDecoded0?.append(structure0)
                }
            }
        }
        portals = portalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags of the resource.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoreCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))/certificates"
    }
}

public struct ListTrustStoreCertificatesInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the trust store
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesInputBody: Swift.Equatable {
}

extension ListTrustStoreCertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListTrustStoreCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustStoreCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustStoreCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateList = output.certificateList
            self.nextToken = output.nextToken
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificateList = nil
            self.nextToken = nil
            self.trustStoreArn = nil
        }
    }
}

public struct ListTrustStoreCertificatesOutputResponse: Swift.Equatable {
    /// The certificate list.
    public var certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.>
    public var nextToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificateList: [WorkSpacesWebClientTypes.CertificateSummary]? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificateList = certificateList
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesOutputResponseBody: Swift.Equatable {
    let certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    let trustStoreArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTrustStoreCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case nextToken
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CertificateSummary?].self, forKey: .certificateList)
        var certificateListDecoded0:[WorkSpacesWebClientTypes.CertificateSummary]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [WorkSpacesWebClientTypes.CertificateSummary]()
            for structure0 in certificateListContainer {
                if let structure0 = structure0 {
                    certificateListDecoded0?.append(structure0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrustStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTrustStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustStores"
    }
}

public struct ListTrustStoresInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrustStoresInputBody: Swift.Equatable {
}

extension ListTrustStoresInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListTrustStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustStores = output.trustStores
        } else {
            self.nextToken = nil
            self.trustStores = nil
        }
    }
}

public struct ListTrustStoresOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The trust stores.
    public var trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?

    public init(
        nextToken: Swift.String? = nil,
        trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustStores = trustStores
    }
}

struct ListTrustStoresOutputResponseBody: Swift.Equatable {
    let trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?
    let nextToken: Swift.String?
}

extension ListTrustStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoresContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.TrustStoreSummary?].self, forKey: .trustStores)
        var trustStoresDecoded0:[WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
        if let trustStoresContainer = trustStoresContainer {
            trustStoresDecoded0 = [WorkSpacesWebClientTypes.TrustStoreSummary]()
            for structure0 in trustStoresContainer {
                if let structure0 = structure0 {
                    trustStoresDecoded0?.append(structure0)
                }
            }
        }
        trustStores = trustStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userAccessLoggingSettings"
    }
}

public struct ListUserAccessLoggingSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserAccessLoggingSettingsInputBody: Swift.Equatable {
}

extension ListUserAccessLoggingSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.nextToken = nil
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct ListUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user access logging settings.
    public var userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct ListUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary?].self, forKey: .userAccessLoggingSettings)
        var userAccessLoggingSettingsDecoded0:[WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]? = nil
        if let userAccessLoggingSettingsContainer = userAccessLoggingSettingsContainer {
            userAccessLoggingSettingsDecoded0 = [WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary]()
            for structure0 in userAccessLoggingSettingsContainer {
                if let structure0 = structure0 {
                    userAccessLoggingSettingsDecoded0?.append(structure0)
                }
            }
        }
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserSettingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userSettings"
    }
}

public struct ListUserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserSettingsInputBody: Swift.Equatable {
}

extension ListUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSettings = output.userSettings
        } else {
            self.nextToken = nil
            self.userSettings = nil
        }
    }
}

public struct ListUserSettingsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user settings.
    public var userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSettings = userSettings
    }
}

struct ListUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?
    let nextToken: Swift.String?
}

extension ListUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserSettingsSummary?].self, forKey: .userSettings)
        var userSettingsDecoded0:[WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [WorkSpacesWebClientTypes.UserSettingsSummary]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case networkSettingsArn
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension WorkSpacesWebClientTypes {
    /// A network settings resource that can be associated with a web portal. Once associated with a web portal, network settings define how streaming instances will connect with your specified VPC.
    public struct NetworkSettings: Swift.Equatable {
        /// A list of web portal ARNs that this network settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public var securityGroupIds: [Swift.String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public var subnetIds: [Swift.String]?
        /// The VPC that streaming instances will connect to.
        public var vpcId: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            networkSettingsArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of network settings.
    public struct NetworkSettingsSummary: Swift.Equatable {
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// The VPC ID of the network settings.
        public var vpcId: Swift.String?

        public init(
            networkSettingsArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.Portal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case ipAccessSettingsArn
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case statusReason
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.Portal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Portal(authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), statusReason: \(Swift.String(describing: statusReason)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The web portal.
    public struct Portal: Swift.Equatable {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with this web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser that users see when using a streaming session.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// A message that explains why the web portal is in its current status.
        public var statusReason: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            statusReason: Swift.String? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum PortalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case incomplete
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalStatus] {
            return [
                .active,
                .incomplete,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .incomplete: return "Incomplete"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalStatus(rawValue: rawValue) ?? PortalStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case ipAccessSettingsArn
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case trustStoreArn
        case userAccessLoggingSettingsArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let browserSettingsArn = self.browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = self.browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipAccessSettingsArn = self.ipAccessSettingsArn {
            try encodeContainer.encode(ipAccessSettingsArn, forKey: .ipAccessSettingsArn)
        }
        if let networkSettingsArn = self.networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = self.portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = self.portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = self.portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = self.rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let ipAccessSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAccessSettingsArn)
        ipAccessSettingsArn = ipAccessSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(authenticationType: \(Swift.String(describing: authenticationType)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userAccessLoggingSettingsArn: \(Swift.String(describing: userAccessLoggingSettingsArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the portal.
    public struct PortalSummary: Swift.Equatable {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
        /// The ARN of the browser settings that is associated with the web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser type of the web portal.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the IP access settings.
        public var ipAccessSettingsArn: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public var userAccessLoggingSettingsArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init(
            authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            ipAccessSettingsArn: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            trustStoreArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum RendererType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream
        case sdkUnknown(Swift.String)

        public static var allCases: [RendererType] {
            return [
                .appstream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "AppStream"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RendererType(rawValue: rawValue) ?? RendererType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesWebClientTypes {
    /// The tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [WorkSpacesWebClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a throttling error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource affected.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A trust store that can be associated with a web portal. A trust store contains certificate authority (CA) certificates. Once associated with a web portal, the browser in a streaming session will recognize certificates that have been issued using any of the CAs in the trust store. If your organization has internal websites that use certificates issued by private CAs, you should add the private CA certificate to the trust store.
    public struct TrustStore: Swift.Equatable {
        /// A list of web portal ARNs that this trust store is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the trust store.
        /// This member is required.
        public var trustStoreArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            trustStoreArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension WorkSpacesWebClientTypes.TrustStoreSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustStoreArn = self.trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of the trust store.
    public struct TrustStoreSummary: Swift.Equatable {
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init(
            trustStoreArn: Swift.String? = nil
        )
        {
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), clientToken: \(Swift.String(describing: clientToken)), browserPolicy: \"CONTENT_REDACTED\")"}
}

extension UpdateBrowserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserPolicy = self.browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateBrowserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let browserSettingsArn = browserSettingsArn else {
            return nil
        }
        return "/browserSettings/\(browserSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateBrowserSettingsInput: Swift.Equatable {
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    public var browserPolicy: Swift.String?
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?

    public init(
        browserPolicy: Swift.String? = nil,
        browserSettingsArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.browserPolicy = browserPolicy
        self.browserSettingsArn = browserSettingsArn
        self.clientToken = clientToken
    }
}

struct UpdateBrowserSettingsInputBody: Swift.Equatable {
    let browserPolicy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateBrowserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct UpdateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    /// This member is required.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init(
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct UpdateBrowserSettingsOutputResponseBody: Swift.Equatable {
    let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension UpdateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

extension UpdateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderType: \(Swift.String(describing: identityProviderType)), identityProviderDetails: \"CONTENT_REDACTED\", identityProviderName: \"CONTENT_REDACTED\")"}
}

extension UpdateIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityProviderDetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityProviderDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

extension UpdateIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityProviderArn = identityProviderArn else {
            return nil
        }
        return "/identityProviders/\(identityProviderArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout (boolean) optional
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The name of the identity provider.
    public var identityProviderName: Swift.String?
    /// The type of the identity provider.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

    public init(
        clientToken: Swift.String? = nil,
        identityProviderArn: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderArn = identityProviderArn
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderInputBody: Swift.Equatable {
    let identityProviderName: Swift.String?
    let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    let identityProviderDetails: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct UpdateIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    /// This member is required.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init(
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct UpdateIdentityProviderOutputResponseBody: Swift.Equatable {
    let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension UpdateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

extension UpdateIpAccessSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIpAccessSettingsInput(clientToken: \(Swift.String(describing: clientToken)), ipAccessSettingsArn: \(Swift.String(describing: ipAccessSettingsArn)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", ipRules: \"CONTENT_REDACTED\")"}
}

extension UpdateIpAccessSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case displayName
        case ipRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let ipRules = ipRules {
            var ipRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRules)
            for iprule0 in ipRules {
                try ipRulesContainer.encode(iprule0)
            }
        }
    }
}

extension UpdateIpAccessSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ipAccessSettingsArn = ipAccessSettingsArn else {
            return nil
        }
        return "/ipAccessSettings/\(ipAccessSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateIpAccessSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The description of the IP access settings.
    public var description: Swift.String?
    /// The display name of the IP access settings.
    public var displayName: Swift.String?
    /// The ARN of the IP access settings.
    /// This member is required.
    public var ipAccessSettingsArn: Swift.String?
    /// The updated IP rules of the IP access settings.
    public var ipRules: [WorkSpacesWebClientTypes.IpRule]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        ipAccessSettingsArn: Swift.String? = nil,
        ipRules: [WorkSpacesWebClientTypes.IpRule]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.ipAccessSettingsArn = ipAccessSettingsArn
        self.ipRules = ipRules
    }
}

struct UpdateIpAccessSettingsInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let ipRules: [WorkSpacesWebClientTypes.IpRule]?
    let clientToken: Swift.String?
}

extension UpdateIpAccessSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case displayName
        case ipRules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRulesContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IpRule?].self, forKey: .ipRules)
        var ipRulesDecoded0:[WorkSpacesWebClientTypes.IpRule]? = nil
        if let ipRulesContainer = ipRulesContainer {
            ipRulesDecoded0 = [WorkSpacesWebClientTypes.IpRule]()
            for structure0 in ipRulesContainer {
                if let structure0 = structure0 {
                    ipRulesDecoded0?.append(structure0)
                }
            }
        }
        ipRules = ipRulesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateIpAccessSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIpAccessSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIpAccessSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAccessSettings = output.ipAccessSettings
        } else {
            self.ipAccessSettings = nil
        }
    }
}

public struct UpdateIpAccessSettingsOutputResponse: Swift.Equatable {
    /// The IP access settings.
    /// This member is required.
    public var ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?

    public init(
        ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings? = nil
    )
    {
        self.ipAccessSettings = ipAccessSettings
    }
}

struct UpdateIpAccessSettingsOutputResponseBody: Swift.Equatable {
    let ipAccessSettings: WorkSpacesWebClientTypes.IpAccessSettings?
}

extension UpdateIpAccessSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAccessSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAccessSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IpAccessSettings.self, forKey: .ipAccessSettings)
        ipAccessSettings = ipAccessSettingsDecoded
    }
}

extension UpdateNetworkSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension UpdateNetworkSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSettingsArn = networkSettingsArn else {
            return nil
        }
        return "/networkSettings/\(networkSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    public var subnetIds: [Swift.String]?
    /// The VPC that streaming instances will connect to.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkSettingsArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSettingsArn = networkSettingsArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateNetworkSettingsInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateNetworkSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct UpdateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    /// This member is required.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init(
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct UpdateNetworkSettingsOutputResponseBody: Swift.Equatable {
    let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension UpdateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(authenticationType: \(Swift.String(describing: authenticationType)), portalArn: \(Swift.String(describing: portalArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension UpdatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalArn = portalArn else {
            return nil
        }
        return "/portals/\(portalArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdatePortalInput: Swift.Equatable {
    /// The type of authentication integration points used when signing into the web portal. Defaults to Standard. Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider. IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
    public var authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init(
        authenticationType: WorkSpacesWebClientTypes.AuthenticationType? = nil,
        displayName: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.displayName = displayName
        self.portalArn = portalArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let authenticationType: WorkSpacesWebClientTypes.AuthenticationType?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case displayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

public enum UpdatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init(
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct UpdatePortalOutputResponseBody: Swift.Equatable {
    let portal: WorkSpacesWebClientTypes.Portal?
}

extension UpdatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

extension UpdateTrustStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatesToAdd = certificatesToAdd {
            var certificatesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToAdd)
            for certificateauthoritybody0 in certificatesToAdd {
                try certificatesToAddContainer.encode(certificateauthoritybody0.base64EncodedString())
            }
        }
        if let certificatesToDelete = certificatesToDelete {
            var certificatesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToDelete)
            for certificatethumbprint0 in certificatesToDelete {
                try certificatesToDeleteContainer.encode(certificatethumbprint0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateTrustStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustStoreArn = trustStoreArn else {
            return nil
        }
        return "/trustStores/\(trustStoreArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to add to the trust store.
    public var certificatesToAdd: [ClientRuntime.Data]?
    /// A list of CA certificates to delete from a trust store.
    public var certificatesToDelete: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        certificatesToAdd: [ClientRuntime.Data]? = nil,
        certificatesToDelete: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificatesToAdd = certificatesToAdd
        self.certificatesToDelete = certificatesToDelete
        self.clientToken = clientToken
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreInputBody: Swift.Equatable {
    let certificatesToAdd: [ClientRuntime.Data]?
    let certificatesToDelete: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesToAddContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificatesToAdd)
        var certificatesToAddDecoded0:[ClientRuntime.Data]? = nil
        if let certificatesToAddContainer = certificatesToAddContainer {
            certificatesToAddDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificatesToAddContainer {
                if let blob0 = blob0 {
                    certificatesToAddDecoded0?.append(blob0)
                }
            }
        }
        certificatesToAdd = certificatesToAddDecoded0
        let certificatesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificatesToDelete)
        var certificatesToDeleteDecoded0:[Swift.String]? = nil
        if let certificatesToDeleteContainer = certificatesToDeleteContainer {
            certificatesToDeleteDecoded0 = [Swift.String]()
            for string0 in certificatesToDeleteContainer {
                if let string0 = string0 {
                    certificatesToDeleteDecoded0?.append(string0)
                }
            }
        }
        certificatesToDelete = certificatesToDeleteDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateTrustStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct UpdateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init(
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreOutputResponseBody: Swift.Equatable {
    let trustStoreArn: Swift.String?
}

extension UpdateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension UpdateUserAccessLoggingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
    }
}

extension UpdateUserAccessLoggingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userAccessLoggingSettingsArn = userAccessLoggingSettingsArn else {
            return nil
        }
        return "/userAccessLoggingSettings/\(userAccessLoggingSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateUserAccessLoggingSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the Kinesis stream.
    public var kinesisStreamArn: Swift.String?
    /// The ARN of the user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        kinesisStreamArn: Swift.String? = nil,
        userAccessLoggingSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.kinesisStreamArn = kinesisStreamArn
        self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
    }
}

struct UpdateUserAccessLoggingSettingsInputBody: Swift.Equatable {
    let kinesisStreamArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateUserAccessLoggingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case kinesisStreamArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateUserAccessLoggingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserAccessLoggingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserAccessLoggingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userAccessLoggingSettings = output.userAccessLoggingSettings
        } else {
            self.userAccessLoggingSettings = nil
        }
    }
}

public struct UpdateUserAccessLoggingSettingsOutputResponse: Swift.Equatable {
    /// The user access logging settings.
    /// This member is required.
    public var userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?

    public init(
        userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings? = nil
    )
    {
        self.userAccessLoggingSettings = userAccessLoggingSettings
    }
}

struct UpdateUserAccessLoggingSettingsOutputResponseBody: Swift.Equatable {
    let userAccessLoggingSettings: WorkSpacesWebClientTypes.UserAccessLoggingSettings?
}

extension UpdateUserAccessLoggingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessLoggingSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserAccessLoggingSettings.self, forKey: .userAccessLoggingSettings)
        userAccessLoggingSettings = userAccessLoggingSettingsDecoded
    }
}

extension UpdateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsInput(clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension UpdateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

extension UpdateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userSettingsArn = userSettingsArn else {
            return nil
        }
        return "/userSettings/\(userSettingsArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser. If the allowlist and blocklist are empty, the configuration becomes null.
    public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that a streaming session remains active after users disconnect.
    public var disconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can download files from the streaming session to the local device.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
    public var idleDisconnectTimeoutInMinutes: Swift.Int?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        disconnectTimeoutInMinutes: Swift.Int? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
        self.copyAllowed = copyAllowed
        self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
        self.downloadAllowed = downloadAllowed
        self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.uploadAllowed = uploadAllowed
        self.userSettingsArn = userSettingsArn
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    let disconnectTimeoutInMinutes: Swift.Int?
    let idleDisconnectTimeoutInMinutes: Swift.Int?
    let clientToken: Swift.String?
    let cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

public enum UpdateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct UpdateUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    /// This member is required.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init(
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsOutputResponseBody: Swift.Equatable {
    let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension UpdateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// A user access logging settings resource that can be associated with a web portal.
    public struct UserAccessLoggingSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserAccessLoggingSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamArn
        case userAccessLoggingSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kinesisStreamArn = self.kinesisStreamArn {
            try encodeContainer.encode(kinesisStreamArn, forKey: .kinesisStreamArn)
        }
        if let userAccessLoggingSettingsArn = self.userAccessLoggingSettingsArn {
            try encodeContainer.encode(userAccessLoggingSettingsArn, forKey: .userAccessLoggingSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessLoggingSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessLoggingSettingsArn)
        userAccessLoggingSettingsArn = userAccessLoggingSettingsArnDecoded
        let kinesisStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamArn)
        kinesisStreamArn = kinesisStreamArnDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// The summary of user access logging settings.
    public struct UserAccessLoggingSettingsSummary: Swift.Equatable {
        /// The ARN of the Kinesis stream.
        public var kinesisStreamArn: Swift.String?
        /// The ARN of the user access logging settings.
        /// This member is required.
        public var userAccessLoggingSettingsArn: Swift.String?

        public init(
            kinesisStreamArn: Swift.String? = nil,
            userAccessLoggingSettingsArn: Swift.String? = nil
        )
        {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arn0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arn0)
            }
        }
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// A user settings resource that can be associated with a web portal. Once associated with a web portal, user settings control how users can transfer data between a streaming session and the their local devices.
    public struct UserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            associatedPortalArns: [Swift.String]? = nil,
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieSynchronizationConfiguration
        case copyAllowed
        case disconnectTimeoutInMinutes
        case downloadAllowed
        case idleDisconnectTimeoutInMinutes
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cookieSynchronizationConfiguration = self.cookieSynchronizationConfiguration {
            try encodeContainer.encode(cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
        }
        if let copyAllowed = self.copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let disconnectTimeoutInMinutes = self.disconnectTimeoutInMinutes {
            try encodeContainer.encode(disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
        }
        if let downloadAllowed = self.downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let idleDisconnectTimeoutInMinutes = self.idleDisconnectTimeoutInMinutes {
            try encodeContainer.encode(idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
        }
        if let pasteAllowed = self.pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = self.printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = self.uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = self.userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let disconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInMinutes)
        disconnectTimeoutInMinutes = disconnectTimeoutInMinutesDecoded
        let idleDisconnectTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInMinutes)
        idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutesDecoded
        let cookieSynchronizationConfigurationDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.CookieSynchronizationConfiguration.self, forKey: .cookieSynchronizationConfiguration)
        cookieSynchronizationConfiguration = cookieSynchronizationConfigurationDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettingsSummary(copyAllowed: \(Swift.String(describing: copyAllowed)), disconnectTimeoutInMinutes: \(Swift.String(describing: disconnectTimeoutInMinutes)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), idleDisconnectTimeoutInMinutes: \(Swift.String(describing: idleDisconnectTimeoutInMinutes)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)), cookieSynchronizationConfiguration: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of user settings.
    public struct UserSettingsSummary: Swift.Equatable {
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public var cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public var disconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public var idleDisconnectTimeoutInMinutes: Swift.Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init(
            cookieSynchronizationConfiguration: WorkSpacesWebClientTypes.CookieSynchronizationConfiguration? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            disconnectTimeoutInMinutes: Swift.Int? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            idleDisconnectTimeoutInMinutes: Swift.Int? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a validation error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error.
        public internal(set) var fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: WorkSpacesWebClientTypes.ValidationExceptionReason?
    let fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [WorkSpacesWebClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes {
    /// Information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
