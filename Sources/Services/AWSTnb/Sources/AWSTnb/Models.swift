//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct CancelSolNetworkOperationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSolFunctionPackageOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSolNetworkInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSolNetworkPackageOutput: Swift.Sendable {

    public init() { }
}

/// Insufficient permissions to make request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unexpected error occurred. Problem on the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception caused by throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unable to process the request because the client provided input failed to satisfy request constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelSolNetworkOperationInput: Swift.Sendable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init(
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

/// Service quotas have been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateSolFunctionPackageInput: Swift.Sendable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension CreateSolFunctionPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    public enum OnboardingState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [OnboardingState] {
            return [
                .created,
                .error,
                .onboarded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    public enum OperationalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationalState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    public enum UsageState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageState] {
            return [
                .inUse,
                .notInUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSolFunctionPackageOutput: Swift.Sendable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the function package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the function package.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// Usage state of the function package.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
    }
}

extension CreateSolFunctionPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateSolNetworkInstanceInput: Swift.Sendable {
    /// Network instance description.
    public var nsDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsName: Swift.String?
    /// ID for network service descriptor.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nsDescription: Swift.String? = nil,
        nsName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nsDescription = nsDescription
        self.nsName = nsName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

extension CreateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceInput(nsDescription: \(Swift.String(describing: nsDescription)), nsName: \(Swift.String(describing: nsName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateSolNetworkInstanceOutput: Swift.Sendable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsInstanceName = nsInstanceName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

extension CreateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateSolNetworkPackageInput: Swift.Sendable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension CreateSolNetworkPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    public enum NsdOnboardingState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOnboardingState] {
            return [
                .created,
                .error,
                .onboarded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    public enum NsdOperationalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOperationalState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    public enum NsdUsageState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdUsageState] {
            return [
                .inUse,
                .notInUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSolNetworkPackageOutput: Swift.Sendable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the network package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Usage state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.tags = tags
    }
}

extension CreateSolNetworkPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeleteSolFunctionPackageInput: Swift.Sendable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

public struct DeleteSolNetworkInstanceInput: Swift.Sendable {
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init(
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

public struct DeleteSolNetworkPackageInput: Swift.Sendable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

extension TnbClientTypes {

    public enum DescriptorContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case textPlain
        case sdkUnknown(Swift.String)

        public static var allCases: [DescriptorContentType] {
            return [
                .textPlain
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .textPlain: return "text/plain"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    /// Provides error information.
    public struct ErrorInfo: Swift.Sendable {
        /// Error cause.
        public var cause: Swift.String?
        /// Error details.
        public var details: Swift.String?

        public init(
            cause: Swift.String? = nil,
            details: Swift.String? = nil
        )
        {
            self.cause = cause
            self.details = details
        }
    }
}

extension TnbClientTypes {

    /// Overrides of the TOSCA node.
    public struct ToscaOverride: Swift.Sendable {
        /// Default value for the override.
        public var defaultValue: Swift.String?
        /// Name of the TOSCA override.
        public var name: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.name = name
        }
    }
}

extension TnbClientTypes {

    /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct FunctionArtifactMeta: Swift.Sendable {
        /// Lists of function package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init(
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }
}

public struct GetSolFunctionInstanceInput: Swift.Sendable {
    /// ID of the network function.
    /// This member is required.
    public var vnfInstanceId: Swift.String?

    public init(
        vnfInstanceId: Swift.String? = nil
    )
    {
        self.vnfInstanceId = vnfInstanceId
    }
}

extension TnbClientTypes {

    /// The metadata of a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfoMetadata: Swift.Sendable {
        /// Information about the cluster.
        public var cluster: Swift.String?
        /// Information about the helm chart.
        public var helmChart: Swift.String?
        /// Information about the node group.
        public var nodeGroup: Swift.String?

        public init(
            cluster: Swift.String? = nil,
            helmChart: Swift.String? = nil,
            nodeGroup: Swift.String? = nil
        )
        {
            self.cluster = cluster
            self.helmChart = helmChart
            self.nodeGroup = nodeGroup
        }
    }
}

extension TnbClientTypes {

    /// Details of resource associated with a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfo: Swift.Sendable {
        /// The metadata of the network function compute.
        public var metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata?

        public init(
            metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata? = nil
        )
        {
            self.metadata = metadata
        }
    }
}

extension TnbClientTypes {

    public enum VnfOperationalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfOperationalState] {
            return [
                .started,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    /// Information about the network function. A network function instance is a function in a function package .
    public struct GetSolVnfInfo: Swift.Sendable {
        /// State of the network function instance.
        public var vnfState: TnbClientTypes.VnfOperationalState?
        /// Compute info used by the network function instance.
        public var vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]?

        public init(
            vnfState: TnbClientTypes.VnfOperationalState? = nil,
            vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]? = nil
        )
        {
            self.vnfState = vnfState
            self.vnfcResourceInfo = vnfcResourceInfo
        }
    }
}

extension TnbClientTypes {

    public enum VnfInstantiationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instantiated
        case notInstantiated
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfInstantiationState] {
            return [
                .instantiated,
                .notInstantiated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instantiated: return "INSTANTIATED"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    /// The metadata of a network function instance. A network function instance is a function in a function package .
    public struct GetSolFunctionInstanceMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

public struct GetSolFunctionInstanceOutput: Swift.Sendable {
    /// Network function instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network function instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the network function. A network function instance is a function in a function package .
    public var instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo?
    /// Network function instantiation state.
    /// This member is required.
    public var instantiationState: TnbClientTypes.VnfInstantiationState?
    /// The metadata of a network function instance. A network function instance is a function in a function package .
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolFunctionInstanceMetadata?
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo? = nil,
        instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
        metadata: TnbClientTypes.GetSolFunctionInstanceMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vnfPkgId: Swift.String? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.instantiatedVnfInfo = instantiatedVnfInfo
        self.instantiationState = instantiationState
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.tags = tags
        self.vnfPkgId = vnfPkgId
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

extension GetSolFunctionInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), instantiatedVnfInfo: \(Swift.String(describing: instantiatedVnfInfo)), instantiationState: \(Swift.String(describing: instantiationState)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), vnfPkgId: \(Swift.String(describing: vnfPkgId)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetSolFunctionPackageInput: Swift.Sendable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

extension TnbClientTypes {

    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct GetSolFunctionPackageMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// Metadata related to the function package descriptor of the function package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil,
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.vnfd = vnfd
        }
    }
}

public struct GetSolFunctionPackageOutput: Swift.Sendable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public var metadata: TnbClientTypes.GetSolFunctionPackageMetadata?
    /// Function package onboarding state.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Function package operational state.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// Function package usage state.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolFunctionPackageMetadata? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

extension GetSolFunctionPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    public enum PackageContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applicationZip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageContentType] {
            return [
                .applicationZip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applicationZip: return "application/zip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSolFunctionPackageContentInput: Swift.Sendable {
    /// The format of the package that you want to download from the function packages.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        accept: TnbClientTypes.PackageContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

public struct GetSolFunctionPackageContentOutput: Swift.Sendable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Contents of the function package.
    public var packageContent: Foundation.Data?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        packageContent: Foundation.Data? = nil
    )
    {
        self.contentType = contentType
        self.packageContent = packageContent
    }
}

public struct GetSolFunctionPackageDescriptorInput: Swift.Sendable {
    /// Indicates which content types, expressed as MIME types, the client is able to understand.
    /// This member is required.
    public var accept: TnbClientTypes.DescriptorContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        accept: TnbClientTypes.DescriptorContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

public struct GetSolFunctionPackageDescriptorOutput: Swift.Sendable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the function package descriptor.
    public var vnfd: Foundation.Data?

    public init(
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        vnfd: Foundation.Data? = nil
    )
    {
        self.contentType = contentType
        self.vnfd = vnfd
    }
}

extension TnbClientTypes {

    /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolInstantiatedVnfInfo: Swift.Sendable {
        /// State of the network function.
        public var vnfState: TnbClientTypes.VnfOperationalState?

        public init(
            vnfState: TnbClientTypes.VnfOperationalState? = nil
        )
        {
            self.vnfState = vnfState
        }
    }
}

public struct GetSolNetworkInstanceInput: Swift.Sendable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init(
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

extension TnbClientTypes {

    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public struct LcmOperationInfo: Swift.Sendable {
        /// The identifier of the network operation.
        /// This member is required.
        public var nsLcmOpOccId: Swift.String?

        public init(
            nsLcmOpOccId: Swift.String? = nil
        )
        {
            self.nsLcmOpOccId = nsLcmOpOccId
        }
    }
}

extension TnbClientTypes {

    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolNetworkInstanceMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

extension TnbClientTypes {

    public enum NsState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case impaired
        case instantiated
        case instantiateInProgress
        case intentToUpdateInProgress
        case notInstantiated
        case stopped
        case terminateInProgress
        case updated
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [NsState] {
            return [
                .deleted,
                .impaired,
                .instantiated,
                .instantiateInProgress,
                .intentToUpdateInProgress,
                .notInstantiated,
                .stopped,
                .terminateInProgress,
                .updated,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .impaired: return "IMPAIRED"
            case .instantiated: return "INSTANTIATED"
            case .instantiateInProgress: return "INSTANTIATE_IN_PROGRESS"
            case .intentToUpdateInProgress: return "INTENT_TO_UPDATE_IN_PROGRESS"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case .stopped: return "STOPPED"
            case .terminateInProgress: return "TERMINATE_IN_PROGRESS"
            case .updated: return "UPDATED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSolNetworkInstanceOutput: Swift.Sendable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public var lcmOpInfo: TnbClientTypes.LcmOperationInfo?
    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkInstanceMetadata?
    /// Network instance description.
    /// This member is required.
    public var nsInstanceDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network instance state.
    public var nsState: TnbClientTypes.NsState?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lcmOpInfo: TnbClientTypes.LcmOperationInfo? = nil,
        metadata: TnbClientTypes.GetSolNetworkInstanceMetadata? = nil,
        nsInstanceDescription: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsState: TnbClientTypes.NsState? = nil,
        nsdId: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lcmOpInfo = lcmOpInfo
        self.metadata = metadata
        self.nsInstanceDescription = nsInstanceDescription
        self.nsInstanceName = nsInstanceName
        self.nsState = nsState
        self.nsdId = nsdId
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

extension GetSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), lcmOpInfo: \(Swift.String(describing: lcmOpInfo)), metadata: \(Swift.String(describing: metadata)), nsInstanceDescription: \(Swift.String(describing: nsInstanceDescription)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsState: \(Swift.String(describing: nsState)), nsdId: \(Swift.String(describing: nsdId)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetSolNetworkOperationInput: Swift.Sendable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init(
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

extension TnbClientTypes {

    /// Details related to problems with AWS TNB resources.
    public struct ProblemDetails: Swift.Sendable {
        /// A human-readable explanation specific to this occurrence of the problem.
        /// This member is required.
        public var detail: Swift.String?
        /// A human-readable title of the problem type.
        public var title: Swift.String?

        public init(
            detail: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.detail = detail
            self.title = title
        }
    }
}

extension TnbClientTypes {

    public enum LcmOperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instantiate
        case terminate
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [LcmOperationType] {
            return [
                .instantiate,
                .terminate,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instantiate: return "INSTANTIATE"
            case .terminate: return "TERMINATE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    /// Metadata related to the configuration properties used during instantiation of the network instance.
    public struct InstantiateMetadata: Swift.Sendable {
        /// The configurable properties used during instantiation.
        public var additionalParamsForNs: Smithy.Document?
        /// The network service descriptor used for instantiating the network instance.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init(
            additionalParamsForNs: Smithy.Document? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }
    }
}

extension TnbClientTypes {

    /// Metadata related to the configuration properties used during update of a specific network function in a network instance.
    public struct ModifyVnfInfoMetadata: Swift.Sendable {
        /// The configurable properties used during update of the network function instance.
        /// This member is required.
        public var vnfConfigurableProperties: Smithy.Document?
        /// The network function instance that was updated in the network instance.
        /// This member is required.
        public var vnfInstanceId: Swift.String?

        public init(
            vnfConfigurableProperties: Smithy.Document? = nil,
            vnfInstanceId: Swift.String? = nil
        )
        {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }
    }
}

extension TnbClientTypes {

    /// Metadata related to the configuration properties used during update of a network instance.
    public struct UpdateNsMetadata: Swift.Sendable {
        /// The configurable properties used during update.
        public var additionalParamsForNs: Smithy.Document?
        /// The network service descriptor used for updating the network instance.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init(
            additionalParamsForNs: Smithy.Document? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }
    }
}

extension TnbClientTypes {

    /// Metadata related to a network operation occurrence. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Metadata related to the network operation occurrence for network instantiation. This is populated only if the lcmOperationType is INSTANTIATE.
        public var instantiateMetadata: TnbClientTypes.InstantiateMetadata?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// Metadata related to the network operation occurrence for network function updates in a network instance. This is populated only if the lcmOperationType is UPDATE and the updateType is MODIFY_VNF_INFORMATION.
        public var modifyVnfInfoMetadata: TnbClientTypes.ModifyVnfInfoMetadata?
        /// Metadata related to the network operation occurrence for network instance updates. This is populated only if the lcmOperationType is UPDATE and the updateType is UPDATE_NS.
        public var updateNsMetadata: TnbClientTypes.UpdateNsMetadata?

        public init(
            createdAt: Foundation.Date? = nil,
            instantiateMetadata: TnbClientTypes.InstantiateMetadata? = nil,
            lastModified: Foundation.Date? = nil,
            modifyVnfInfoMetadata: TnbClientTypes.ModifyVnfInfoMetadata? = nil,
            updateNsMetadata: TnbClientTypes.UpdateNsMetadata? = nil
        )
        {
            self.createdAt = createdAt
            self.instantiateMetadata = instantiateMetadata
            self.lastModified = lastModified
            self.modifyVnfInfoMetadata = modifyVnfInfoMetadata
            self.updateNsMetadata = updateNsMetadata
        }
    }
}

extension TnbClientTypes {

    public enum NsLcmOperationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [NsLcmOperationState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    public enum TaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case inProgress
        case scheduled
        case skipped
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .error,
                .inProgress,
                .scheduled,
                .skipped,
                .started
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case .skipped: return "SKIPPED"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TnbClientTypes {

    /// Gets the details of a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationTaskDetails: Swift.Sendable {
        /// Context for the network operation task.
        public var taskContext: [Swift.String: Swift.String]?
        /// Task end time.
        public var taskEndTime: Foundation.Date?
        /// Task error details.
        public var taskErrorDetails: TnbClientTypes.ErrorInfo?
        /// Task name.
        public var taskName: Swift.String?
        /// Task start time.
        public var taskStartTime: Foundation.Date?
        /// Task status.
        public var taskStatus: TnbClientTypes.TaskStatus?

        public init(
            taskContext: [Swift.String: Swift.String]? = nil,
            taskEndTime: Foundation.Date? = nil,
            taskErrorDetails: TnbClientTypes.ErrorInfo? = nil,
            taskName: Swift.String? = nil,
            taskStartTime: Foundation.Date? = nil,
            taskStatus: TnbClientTypes.TaskStatus? = nil
        )
        {
            self.taskContext = taskContext
            self.taskEndTime = taskEndTime
            self.taskErrorDetails = taskErrorDetails
            self.taskName = taskName
            self.taskStartTime = taskStartTime
            self.taskStatus = taskStatus
        }
    }
}

extension TnbClientTypes {

    public enum UpdateSolNetworkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modifyVnfInformation
        case updateNs
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateSolNetworkType] {
            return [
                .modifyVnfInformation,
                .updateNs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modifyVnfInformation: return "MODIFY_VNF_INFORMATION"
            case .updateNs: return "UPDATE_NS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSolNetworkOperationOutput: Swift.Sendable {
    /// Network operation ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Error related to this specific network operation occurrence.
    public var error: TnbClientTypes.ProblemDetails?
    /// ID of this network operation occurrence.
    public var id: Swift.String?
    /// Type of the operation represented by this occurrence.
    public var lcmOperationType: TnbClientTypes.LcmOperationType?
    /// Metadata of this network operation occurrence.
    public var metadata: TnbClientTypes.GetSolNetworkOperationMetadata?
    /// ID of the network operation instance.
    public var nsInstanceId: Swift.String?
    /// The state of the network operation.
    public var operationState: TnbClientTypes.NsLcmOperationState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// All tasks associated with this operation occurrence.
    public var tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]?
    /// Type of the update. Only present if the network operation lcmOperationType is UPDATE.
    public var updateType: TnbClientTypes.UpdateSolNetworkType?

    public init(
        arn: Swift.String? = nil,
        error: TnbClientTypes.ProblemDetails? = nil,
        id: Swift.String? = nil,
        lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
        metadata: TnbClientTypes.GetSolNetworkOperationMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        operationState: TnbClientTypes.NsLcmOperationState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]? = nil,
        updateType: TnbClientTypes.UpdateSolNetworkType? = nil
    )
    {
        self.arn = arn
        self.error = error
        self.id = id
        self.lcmOperationType = lcmOperationType
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.operationState = operationState
        self.tags = tags
        self.tasks = tasks
        self.updateType = updateType
    }
}

extension GetSolNetworkOperationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkOperationOutput(arn: \(Swift.String(describing: arn)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), lcmOperationType: \(Swift.String(describing: lcmOperationType)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), operationState: \(Swift.String(describing: operationState)), tasks: \(Swift.String(describing: tasks)), updateType: \(Swift.String(describing: updateType)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetSolNetworkPackageInput: Swift.Sendable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

extension TnbClientTypes {

    /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct NetworkArtifactMeta: Swift.Sendable {
        /// Lists network package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init(
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }
}

extension TnbClientTypes {

    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct GetSolNetworkPackageMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// Metadata related to the onboarded network service descriptor in the network package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil,
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsd = nsd
        }
    }
}

public struct GetSolNetworkPackageOutput: Swift.Sendable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkPackageMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor onboarding state.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Network service descriptor operational state.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Network service descriptor usage state.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolNetworkPackageMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        nsdVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.nsdVersion = nsdVersion
        self.tags = tags
        self.vnfPkgIds = vnfPkgIds
    }
}

extension GetSolNetworkPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), nsdId: \(Swift.String(describing: nsdId)), nsdName: \(Swift.String(describing: nsdName)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), nsdVersion: \(Swift.String(describing: nsdVersion)), vnfPkgIds: \(Swift.String(describing: vnfPkgIds)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetSolNetworkPackageContentInput: Swift.Sendable {
    /// The format of the package you want to download from the network package.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        accept: TnbClientTypes.PackageContentType? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.nsdInfoId = nsdInfoId
    }
}

public struct GetSolNetworkPackageContentOutput: Swift.Sendable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Content of the network service descriptor in the network package.
    public var nsdContent: Foundation.Data?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        nsdContent: Foundation.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsdContent = nsdContent
    }
}

public struct GetSolNetworkPackageDescriptorInput: Swift.Sendable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

public struct GetSolNetworkPackageDescriptorOutput: Swift.Sendable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the network service descriptor in the network package.
    public var nsd: Foundation.Data?

    public init(
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        nsd: Foundation.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsd = nsd
    }
}

public struct InstantiateSolNetworkInstanceInput: Swift.Sendable {
    /// Provides values for the configurable properties.
    public var additionalParamsForNs: Smithy.Document?
    /// A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        additionalParamsForNs: Smithy.Document? = nil,
        dryRun: Swift.Bool? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.additionalParamsForNs = additionalParamsForNs
        self.dryRun = dryRun
        self.nsInstanceId = nsInstanceId
        self.tags = tags
    }
}

extension InstantiateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstantiateSolNetworkInstanceInput(additionalParamsForNs: \(Swift.String(describing: additionalParamsForNs)), dryRun: \(Swift.String(describing: dryRun)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), tags: \"CONTENT_REDACTED\")"}
}

public struct InstantiateSolNetworkInstanceOutput: Swift.Sendable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

extension InstantiateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstantiateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    /// Lists network function instance metadata. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceMetadata: Swift.Sendable {
        /// When the network function instance was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// When the network function instance was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

extension TnbClientTypes {

    /// Lists information about a network function instance. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceInfo: Swift.Sendable {
        /// Network function instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Network function instance ID.
        /// This member is required.
        public var id: Swift.String?
        /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
        public var instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo?
        /// Network function instance instantiation state.
        /// This member is required.
        public var instantiationState: TnbClientTypes.VnfInstantiationState?
        /// Network function instance metadata.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolFunctionInstanceMetadata?
        /// Network instance ID.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// Function package ID.
        /// This member is required.
        public var vnfPkgId: Swift.String?
        /// Function package name.
        public var vnfPkgName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo? = nil,
            instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
            metadata: TnbClientTypes.ListSolFunctionInstanceMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            vnfPkgId: Swift.String? = nil,
            vnfPkgName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.instantiatedVnfInfo = instantiatedVnfInfo
            self.instantiationState = instantiationState
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.vnfPkgId = vnfPkgId
            self.vnfPkgName = vnfPkgName
        }
    }
}

public struct ListSolFunctionInstancesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSolFunctionInstancesOutput: Swift.Sendable {
    /// Network function instances.
    public var functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionInstances = functionInstances
        self.nextToken = nextToken
    }
}

extension TnbClientTypes {

    /// Details for the function package metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

extension TnbClientTypes {

    /// Information about a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageInfo: Swift.Sendable {
        /// Function package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the function package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the function package.
        public var metadata: TnbClientTypes.ListSolFunctionPackageMetadata?
        /// Onboarding state of the function package.
        /// This member is required.
        public var onboardingState: TnbClientTypes.OnboardingState?
        /// Operational state of the function package.
        /// This member is required.
        public var operationalState: TnbClientTypes.OperationalState?
        /// Usage state of the function package.
        /// This member is required.
        public var usageState: TnbClientTypes.UsageState?
        /// The product name for the network function.
        public var vnfProductName: Swift.String?
        /// Provider of the function package and the function package descriptor.
        public var vnfProvider: Swift.String?
        /// Identifies the function package and the function package descriptor.
        public var vnfdId: Swift.String?
        /// Identifies the version of the function package descriptor.
        public var vnfdVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolFunctionPackageMetadata? = nil,
            onboardingState: TnbClientTypes.OnboardingState? = nil,
            operationalState: TnbClientTypes.OperationalState? = nil,
            usageState: TnbClientTypes.UsageState? = nil,
            vnfProductName: Swift.String? = nil,
            vnfProvider: Swift.String? = nil,
            vnfdId: Swift.String? = nil,
            vnfdVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.usageState = usageState
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
        }
    }
}

public struct ListSolFunctionPackagesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSolFunctionPackagesOutput: Swift.Sendable {
    /// Function packages. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    /// This member is required.
    public var functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionPackages = functionPackages
        self.nextToken = nextToken
    }
}

extension TnbClientTypes {

    /// Metadata details for a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

extension TnbClientTypes {

    /// Info about the specific network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceInfo: Swift.Sendable {
        /// Network instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the network instance.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network instance.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkInstanceMetadata?
        /// Human-readable description of the network instance.
        /// This member is required.
        public var nsInstanceDescription: Swift.String?
        /// Human-readable name of the network instance.
        /// This member is required.
        public var nsInstanceName: Swift.String?
        /// The state of the network instance.
        /// This member is required.
        public var nsState: TnbClientTypes.NsState?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdId: Swift.String?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkInstanceMetadata? = nil,
            nsInstanceDescription: Swift.String? = nil,
            nsInstanceName: Swift.String? = nil,
            nsState: TnbClientTypes.NsState? = nil,
            nsdId: Swift.String? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsInstanceDescription = nsInstanceDescription
            self.nsInstanceName = nsInstanceName
            self.nsState = nsState
            self.nsdId = nsdId
            self.nsdInfoId = nsdInfoId
        }
    }
}

public struct ListSolNetworkInstancesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSolNetworkInstancesOutput: Swift.Sendable {
    /// Lists network instances.
    public var networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInstances = networkInstances
        self.nextToken = nextToken
    }
}

public struct ListSolNetworkOperationsInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Network instance id filter, to retrieve network operations associated to a network instance.
    public var nsInstanceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        nsInstanceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.nsInstanceId = nsInstanceId
    }
}

extension TnbClientTypes {

    /// Metadata related to a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct ListSolNetworkOperationsMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// The network service descriptor id used for the operation. Only present if the updateType is UPDATE_NS.
        public var nsdInfoId: Swift.String?
        /// The network function id used for the operation. Only present if the updateType is MODIFY_VNF_INFO.
        public var vnfInstanceId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil,
            nsdInfoId: Swift.String? = nil,
            vnfInstanceId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsdInfoId = nsdInfoId
            self.vnfInstanceId = vnfInstanceId
        }
    }
}

extension TnbClientTypes {

    /// Information parameters for a network operation.
    public struct ListSolNetworkOperationsInfo: Swift.Sendable {
        /// Network operation ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Error related to this specific network operation.
        public var error: TnbClientTypes.ProblemDetails?
        /// ID of this network operation.
        /// This member is required.
        public var id: Swift.String?
        /// Type of lifecycle management network operation.
        /// This member is required.
        public var lcmOperationType: TnbClientTypes.LcmOperationType?
        /// Metadata related to this network operation.
        public var metadata: TnbClientTypes.ListSolNetworkOperationsMetadata?
        /// ID of the network instance related to this operation.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// The state of the network operation.
        /// This member is required.
        public var operationState: TnbClientTypes.NsLcmOperationState?
        /// Type of the update. Only present if the network operation lcmOperationType is UPDATE.
        public var updateType: TnbClientTypes.UpdateSolNetworkType?

        public init(
            arn: Swift.String? = nil,
            error: TnbClientTypes.ProblemDetails? = nil,
            id: Swift.String? = nil,
            lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
            metadata: TnbClientTypes.ListSolNetworkOperationsMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            operationState: TnbClientTypes.NsLcmOperationState? = nil,
            updateType: TnbClientTypes.UpdateSolNetworkType? = nil
        )
        {
            self.arn = arn
            self.error = error
            self.id = id
            self.lcmOperationType = lcmOperationType
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.operationState = operationState
            self.updateType = updateType
        }
    }
}

public struct ListSolNetworkOperationsOutput: Swift.Sendable {
    /// Lists network operation occurrences. Lifecycle management operations are deploy, update, or delete operations.
    public var networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkOperations = networkOperations
        self.nextToken = nextToken
    }
}

extension TnbClientTypes {

    /// Metadata related to a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageMetadata: Swift.Sendable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            lastModified: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }
}

extension TnbClientTypes {

    /// Details of a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageInfo: Swift.Sendable {
        /// Network package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the individual network package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network package.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkPackageMetadata?
        /// Designer of the onboarded network service descriptor in the network package.
        public var nsdDesigner: Swift.String?
        /// ID of the network service descriptor on which the network package is based.
        public var nsdId: Swift.String?
        /// Identifies a network service descriptor in a version independent manner.
        public var nsdInvariantId: Swift.String?
        /// Name of the onboarded network service descriptor in the network package.
        public var nsdName: Swift.String?
        /// Onboarding state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
        /// Operational state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
        /// Usage state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdUsageState: TnbClientTypes.NsdUsageState?
        /// Version of the onboarded network service descriptor in the network package.
        public var nsdVersion: Swift.String?
        /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
        public var vnfPkgIds: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkPackageMetadata? = nil,
            nsdDesigner: Swift.String? = nil,
            nsdId: Swift.String? = nil,
            nsdInvariantId: Swift.String? = nil,
            nsdName: Swift.String? = nil,
            nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
            nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
            nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
            nsdVersion: Swift.String? = nil,
            vnfPkgIds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdDesigner = nsdDesigner
            self.nsdId = nsdId
            self.nsdInvariantId = nsdInvariantId
            self.nsdName = nsdName
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }
    }
}

public struct ListSolNetworkPackagesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSolNetworkPackagesOutput: Swift.Sendable {
    /// Network packages. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkPackages = networkPackages
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct PutSolFunctionPackageContentInput: Swift.Sendable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: Foundation.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: Foundation.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

extension PutSolFunctionPackageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSolFunctionPackageContentInput(contentType: \(Swift.String(describing: contentType)), vnfPkgId: \(Swift.String(describing: vnfPkgId)), file: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    /// Update metadata in a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct PutSolFunctionPackageContentMetadata: Swift.Sendable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }
}

public struct PutSolFunctionPackageContentOutput: Swift.Sendable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata?
    /// Function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init(
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

public struct PutSolNetworkPackageContentInput: Swift.Sendable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: Foundation.Data?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: Foundation.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

extension PutSolNetworkPackageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSolNetworkPackageContentInput(contentType: \(Swift.String(describing: contentType)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), file: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    /// Update metadata in a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct PutSolNetworkPackageContentMetadata: Swift.Sendable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }
}

public struct PutSolNetworkPackageContentOutput: Swift.Sendable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateSolNetworkInstanceInput: Swift.Sendable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
        self.tags = tags
    }
}

extension TerminateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSolNetworkInstanceInput(nsInstanceId: \(Swift.String(describing: nsInstanceId)), tags: \"CONTENT_REDACTED\")"}
}

public struct TerminateSolNetworkInstanceOutput: Swift.Sendable {
    /// The identifier of the network operation.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

extension TerminateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceInput: Swift.Sendable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateSolFunctionPackageInput: Swift.Sendable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        operationalState: TnbClientTypes.OperationalState? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.operationalState = operationalState
        self.vnfPkgId = vnfPkgId
    }
}

public struct UpdateSolFunctionPackageOutput: Swift.Sendable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?

    public init(
        operationalState: TnbClientTypes.OperationalState? = nil
    )
    {
        self.operationalState = operationalState
    }
}

extension TnbClientTypes {

    /// Information parameters and/or the configurable properties for a network function. A network function instance is a function in a function package .
    public struct UpdateSolNetworkModify: Swift.Sendable {
        /// Provides values for the configurable properties declared in the function package descriptor.
        /// This member is required.
        public var vnfConfigurableProperties: Smithy.Document?
        /// ID of the network function instance. A network function instance is a function in a function package .
        /// This member is required.
        public var vnfInstanceId: Swift.String?

        public init(
            vnfConfigurableProperties: Smithy.Document? = nil,
            vnfInstanceId: Swift.String? = nil
        )
        {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }
    }
}

extension TnbClientTypes {

    /// Information parameters and/or the configurable properties for a network descriptor used for update.
    public struct UpdateSolNetworkServiceData: Swift.Sendable {
        /// Values for the configurable properties declared in the network service descriptor.
        public var additionalParamsForNs: Smithy.Document?
        /// ID of the network service descriptor.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init(
            additionalParamsForNs: Smithy.Document? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }
    }
}

public struct UpdateSolNetworkInstanceInput: Swift.Sendable {
    /// Identifies the network function information parameters and/or the configurable properties of the network function to be modified. Include this property only if the update type is MODIFY_VNF_INFORMATION.
    public var modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?
    /// Identifies the network service descriptor and the configurable properties of the descriptor, to be used for the update. Include this property only if the update type is UPDATE_NS.
    public var updateNs: TnbClientTypes.UpdateSolNetworkServiceData?
    /// The type of update.
    ///
    /// * Use the MODIFY_VNF_INFORMATION update type, to update a specific network function configuration, in the network instance.
    ///
    /// * Use the UPDATE_NS update type, to update the network instance to a new network service descriptor.
    /// This member is required.
    public var updateType: TnbClientTypes.UpdateSolNetworkType?

    public init(
        modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateNs: TnbClientTypes.UpdateSolNetworkServiceData? = nil,
        updateType: TnbClientTypes.UpdateSolNetworkType? = nil
    )
    {
        self.modifyVnfInfoData = modifyVnfInfoData
        self.nsInstanceId = nsInstanceId
        self.tags = tags
        self.updateNs = updateNs
        self.updateType = updateType
    }
}

extension UpdateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSolNetworkInstanceInput(modifyVnfInfoData: \(Swift.String(describing: modifyVnfInfoData)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), updateNs: \(Swift.String(describing: updateNs)), updateType: \(Swift.String(describing: updateType)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateSolNetworkInstanceOutput: Swift.Sendable {
    /// The identifier of the network operation.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

extension UpdateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateSolNetworkPackageInput: Swift.Sendable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init(
        nsdInfoId: Swift.String? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
        self.nsdOperationalState = nsdOperationalState
    }
}

public struct UpdateSolNetworkPackageOutput: Swift.Sendable {
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init(
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdOperationalState = nsdOperationalState
    }
}

public struct ValidateSolFunctionPackageContentInput: Swift.Sendable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: Foundation.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: Foundation.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

extension ValidateSolFunctionPackageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateSolFunctionPackageContentInput(contentType: \(Swift.String(describing: contentType)), vnfPkgId: \(Swift.String(describing: vnfPkgId)), file: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    /// Validates function package content metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ValidateSolFunctionPackageContentMetadata: Swift.Sendable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }
}

public struct ValidateSolFunctionPackageContentOutput: Swift.Sendable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata?
    /// Network function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init(
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

public struct ValidateSolNetworkPackageContentInput: Swift.Sendable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: Foundation.Data?
    /// Network service descriptor file.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: Foundation.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

extension ValidateSolNetworkPackageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateSolNetworkPackageContentInput(contentType: \(Swift.String(describing: contentType)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), file: \"CONTENT_REDACTED\")"}
}

extension TnbClientTypes {

    /// Validates network package content metadata. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ValidateSolNetworkPackageContentMetadata: Swift.Sendable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }
}

public struct ValidateSolNetworkPackageContentOutput: Swift.Sendable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

extension CancelSolNetworkOperationInput {

    static func urlPathProvider(_ value: CancelSolNetworkOperationInput) -> Swift.String? {
        guard let nsLcmOpOccId = value.nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())/cancel"
    }
}

extension CreateSolFunctionPackageInput {

    static func urlPathProvider(_ value: CreateSolFunctionPackageInput) -> Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

extension CreateSolNetworkInstanceInput {

    static func urlPathProvider(_ value: CreateSolNetworkInstanceInput) -> Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

extension CreateSolNetworkPackageInput {

    static func urlPathProvider(_ value: CreateSolNetworkPackageInput) -> Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

extension DeleteSolFunctionPackageInput {

    static func urlPathProvider(_ value: DeleteSolFunctionPackageInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

extension DeleteSolNetworkInstanceInput {

    static func urlPathProvider(_ value: DeleteSolNetworkInstanceInput) -> Swift.String? {
        guard let nsInstanceId = value.nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

extension DeleteSolNetworkPackageInput {

    static func urlPathProvider(_ value: DeleteSolNetworkPackageInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

extension GetSolFunctionInstanceInput {

    static func urlPathProvider(_ value: GetSolFunctionInstanceInput) -> Swift.String? {
        guard let vnfInstanceId = value.vnfInstanceId else {
            return nil
        }
        return "/sol/vnflcm/v1/vnf_instances/\(vnfInstanceId.urlPercentEncoding())"
    }
}

extension GetSolFunctionPackageInput {

    static func urlPathProvider(_ value: GetSolFunctionPackageInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

extension GetSolFunctionPackageContentInput {

    static func urlPathProvider(_ value: GetSolFunctionPackageContentInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

extension GetSolFunctionPackageContentInput {

    static func headerProvider(_ value: GetSolFunctionPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolFunctionPackageDescriptorInput {

    static func urlPathProvider(_ value: GetSolFunctionPackageDescriptorInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/vnfd"
    }
}

extension GetSolFunctionPackageDescriptorInput {

    static func headerProvider(_ value: GetSolFunctionPackageDescriptorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolNetworkInstanceInput {

    static func urlPathProvider(_ value: GetSolNetworkInstanceInput) -> Swift.String? {
        guard let nsInstanceId = value.nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

extension GetSolNetworkOperationInput {

    static func urlPathProvider(_ value: GetSolNetworkOperationInput) -> Swift.String? {
        guard let nsLcmOpOccId = value.nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())"
    }
}

extension GetSolNetworkPackageInput {

    static func urlPathProvider(_ value: GetSolNetworkPackageInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

extension GetSolNetworkPackageContentInput {

    static func urlPathProvider(_ value: GetSolNetworkPackageContentInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

extension GetSolNetworkPackageContentInput {

    static func headerProvider(_ value: GetSolNetworkPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolNetworkPackageDescriptorInput {

    static func urlPathProvider(_ value: GetSolNetworkPackageDescriptorInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd"
    }
}

extension InstantiateSolNetworkInstanceInput {

    static func urlPathProvider(_ value: InstantiateSolNetworkInstanceInput) -> Swift.String? {
        guard let nsInstanceId = value.nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/instantiate"
    }
}

extension InstantiateSolNetworkInstanceInput {

    static func queryItemProvider(_ value: InstantiateSolNetworkInstanceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let dryRun = value.dryRun {
            let dryRunQueryItem = Smithy.URIQueryItem(name: "dry_run".urlPercentEncoding(), value: Swift.String(dryRun).urlPercentEncoding())
            items.append(dryRunQueryItem)
        }
        return items
    }
}

extension ListSolFunctionInstancesInput {

    static func urlPathProvider(_ value: ListSolFunctionInstancesInput) -> Swift.String? {
        return "/sol/vnflcm/v1/vnf_instances"
    }
}

extension ListSolFunctionInstancesInput {

    static func queryItemProvider(_ value: ListSolFunctionInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSolFunctionPackagesInput {

    static func urlPathProvider(_ value: ListSolFunctionPackagesInput) -> Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

extension ListSolFunctionPackagesInput {

    static func queryItemProvider(_ value: ListSolFunctionPackagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSolNetworkInstancesInput {

    static func urlPathProvider(_ value: ListSolNetworkInstancesInput) -> Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

extension ListSolNetworkInstancesInput {

    static func queryItemProvider(_ value: ListSolNetworkInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSolNetworkOperationsInput {

    static func urlPathProvider(_ value: ListSolNetworkOperationsInput) -> Swift.String? {
        return "/sol/nslcm/v1/ns_lcm_op_occs"
    }
}

extension ListSolNetworkOperationsInput {

    static func queryItemProvider(_ value: ListSolNetworkOperationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nsInstanceId = value.nsInstanceId {
            let nsInstanceIdQueryItem = Smithy.URIQueryItem(name: "nsInstanceId".urlPercentEncoding(), value: Swift.String(nsInstanceId).urlPercentEncoding())
            items.append(nsInstanceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSolNetworkPackagesInput {

    static func urlPathProvider(_ value: ListSolNetworkPackagesInput) -> Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

extension ListSolNetworkPackagesInput {

    static func queryItemProvider(_ value: ListSolNetworkPackagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutSolFunctionPackageContentInput {

    static func urlPathProvider(_ value: PutSolFunctionPackageContentInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

extension PutSolFunctionPackageContentInput {

    static func headerProvider(_ value: PutSolFunctionPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension PutSolNetworkPackageContentInput {

    static func urlPathProvider(_ value: PutSolNetworkPackageContentInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

extension PutSolNetworkPackageContentInput {

    static func headerProvider(_ value: PutSolNetworkPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TerminateSolNetworkInstanceInput {

    static func urlPathProvider(_ value: TerminateSolNetworkInstanceInput) -> Swift.String? {
        guard let nsInstanceId = value.nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/terminate"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateSolFunctionPackageInput {

    static func urlPathProvider(_ value: UpdateSolFunctionPackageInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

extension UpdateSolNetworkInstanceInput {

    static func urlPathProvider(_ value: UpdateSolNetworkInstanceInput) -> Swift.String? {
        guard let nsInstanceId = value.nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/update"
    }
}

extension UpdateSolNetworkPackageInput {

    static func urlPathProvider(_ value: UpdateSolNetworkPackageInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

extension ValidateSolFunctionPackageContentInput {

    static func urlPathProvider(_ value: ValidateSolFunctionPackageContentInput) -> Swift.String? {
        guard let vnfPkgId = value.vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content/validate"
    }
}

extension ValidateSolFunctionPackageContentInput {

    static func headerProvider(_ value: ValidateSolFunctionPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension ValidateSolNetworkPackageContentInput {

    static func urlPathProvider(_ value: ValidateSolNetworkPackageContentInput) -> Swift.String? {
        guard let nsdInfoId = value.nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content/validate"
    }
}

extension ValidateSolNetworkPackageContentInput {

    static func headerProvider(_ value: ValidateSolNetworkPackageContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension CreateSolFunctionPackageInput {

    static func write(value: CreateSolFunctionPackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSolNetworkInstanceInput {

    static func write(value: CreateSolNetworkInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nsDescription"].write(value.nsDescription)
        try writer["nsName"].write(value.nsName)
        try writer["nsdInfoId"].write(value.nsdInfoId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSolNetworkPackageInput {

    static func write(value: CreateSolNetworkPackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension InstantiateSolNetworkInstanceInput {

    static func write(value: InstantiateSolNetworkInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalParamsForNs"].write(value.additionalParamsForNs)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutSolFunctionPackageContentInput {

    static func write(value: PutSolFunctionPackageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file)
    }
}

extension PutSolNetworkPackageContentInput {

    static func write(value: PutSolNetworkPackageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TerminateSolNetworkInstanceInput {

    static func write(value: TerminateSolNetworkInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSolFunctionPackageInput {

    static func write(value: UpdateSolFunctionPackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["operationalState"].write(value.operationalState)
    }
}

extension UpdateSolNetworkInstanceInput {

    static func write(value: UpdateSolNetworkInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modifyVnfInfoData"].write(value.modifyVnfInfoData, with: TnbClientTypes.UpdateSolNetworkModify.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["updateNs"].write(value.updateNs, with: TnbClientTypes.UpdateSolNetworkServiceData.write(value:to:))
        try writer["updateType"].write(value.updateType)
    }
}

extension UpdateSolNetworkPackageInput {

    static func write(value: UpdateSolNetworkPackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nsdOperationalState"].write(value.nsdOperationalState)
    }
}

extension ValidateSolFunctionPackageContentInput {

    static func write(value: ValidateSolFunctionPackageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file)
    }
}

extension ValidateSolNetworkPackageContentInput {

    static func write(value: ValidateSolNetworkPackageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file)
    }
}

extension CancelSolNetworkOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSolNetworkOperationOutput {
        return CancelSolNetworkOperationOutput()
    }
}

extension CreateSolFunctionPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSolFunctionPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSolFunctionPackageOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.onboardingState = try reader["onboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.operationalState = try reader["operationalState"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.usageState = try reader["usageState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSolNetworkInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSolNetworkInstanceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.nsInstanceName = try reader["nsInstanceName"].readIfPresent() ?? ""
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateSolNetworkPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSolNetworkPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSolNetworkPackageOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.nsdOnboardingState = try reader["nsdOnboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdOperationalState = try reader["nsdOperationalState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdUsageState = try reader["nsdUsageState"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DeleteSolFunctionPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSolFunctionPackageOutput {
        return DeleteSolFunctionPackageOutput()
    }
}

extension DeleteSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSolNetworkInstanceOutput {
        return DeleteSolNetworkInstanceOutput()
    }
}

extension DeleteSolNetworkPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSolNetworkPackageOutput {
        return DeleteSolNetworkPackageOutput()
    }
}

extension GetSolFunctionInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolFunctionInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolFunctionInstanceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.instantiatedVnfInfo = try reader["instantiatedVnfInfo"].readIfPresent(with: TnbClientTypes.GetSolVnfInfo.read(from:))
        value.instantiationState = try reader["instantiationState"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolFunctionInstanceMetadata.read(from:))
        value.nsInstanceId = try reader["nsInstanceId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vnfPkgId = try reader["vnfPkgId"].readIfPresent() ?? ""
        value.vnfProductName = try reader["vnfProductName"].readIfPresent()
        value.vnfProvider = try reader["vnfProvider"].readIfPresent()
        value.vnfdId = try reader["vnfdId"].readIfPresent() ?? ""
        value.vnfdVersion = try reader["vnfdVersion"].readIfPresent()
        return value
    }
}

extension GetSolFunctionPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolFunctionPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolFunctionPackageOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolFunctionPackageMetadata.read(from:))
        value.onboardingState = try reader["onboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.operationalState = try reader["operationalState"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.usageState = try reader["usageState"].readIfPresent() ?? .sdkUnknown("")
        value.vnfProductName = try reader["vnfProductName"].readIfPresent()
        value.vnfProvider = try reader["vnfProvider"].readIfPresent()
        value.vnfdId = try reader["vnfdId"].readIfPresent()
        value.vnfdVersion = try reader["vnfdVersion"].readIfPresent()
        return value
    }
}

extension GetSolFunctionPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolFunctionPackageContentOutput {
        var value = GetSolFunctionPackageContentOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        }
        switch httpResponse.body {
        case .data(let data):
            value.packageContent = data
        case .stream(let stream):
            value.packageContent = try stream.readToEnd()
        case .noStream:
            value.packageContent = nil
        }
        return value
    }
}

extension GetSolFunctionPackageDescriptorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolFunctionPackageDescriptorOutput {
        var value = GetSolFunctionPackageDescriptorOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        }
        switch httpResponse.body {
        case .data(let data):
            value.vnfd = data
        case .stream(let stream):
            value.vnfd = try stream.readToEnd()
        case .noStream:
            value.vnfd = nil
        }
        return value
    }
}

extension GetSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolNetworkInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolNetworkInstanceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lcmOpInfo = try reader["lcmOpInfo"].readIfPresent(with: TnbClientTypes.LcmOperationInfo.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolNetworkInstanceMetadata.read(from:))
        value.nsInstanceDescription = try reader["nsInstanceDescription"].readIfPresent() ?? ""
        value.nsInstanceName = try reader["nsInstanceName"].readIfPresent() ?? ""
        value.nsState = try reader["nsState"].readIfPresent()
        value.nsdId = try reader["nsdId"].readIfPresent() ?? ""
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSolNetworkOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolNetworkOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolNetworkOperationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent(with: TnbClientTypes.ProblemDetails.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lcmOperationType = try reader["lcmOperationType"].readIfPresent()
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolNetworkOperationMetadata.read(from:))
        value.nsInstanceId = try reader["nsInstanceId"].readIfPresent()
        value.operationState = try reader["operationState"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: TnbClientTypes.GetSolNetworkOperationTaskDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updateType = try reader["updateType"].readIfPresent()
        return value
    }
}

extension GetSolNetworkPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolNetworkPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolNetworkPackageOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolNetworkPackageMetadata.read(from:))
        value.nsdId = try reader["nsdId"].readIfPresent() ?? ""
        value.nsdName = try reader["nsdName"].readIfPresent() ?? ""
        value.nsdOnboardingState = try reader["nsdOnboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdOperationalState = try reader["nsdOperationalState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdUsageState = try reader["nsdUsageState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdVersion = try reader["nsdVersion"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vnfPkgIds = try reader["vnfPkgIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetSolNetworkPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolNetworkPackageContentOutput {
        var value = GetSolNetworkPackageContentOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        }
        switch httpResponse.body {
        case .data(let data):
            value.nsdContent = data
        case .stream(let stream):
            value.nsdContent = try stream.readToEnd()
        case .noStream:
            value.nsdContent = nil
        }
        return value
    }
}

extension GetSolNetworkPackageDescriptorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolNetworkPackageDescriptorOutput {
        var value = GetSolNetworkPackageDescriptorOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        }
        switch httpResponse.body {
        case .data(let data):
            value.nsd = data
        case .stream(let stream):
            value.nsd = try stream.readToEnd()
        case .noStream:
            value.nsd = nil
        }
        return value
    }
}

extension InstantiateSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InstantiateSolNetworkInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InstantiateSolNetworkInstanceOutput()
        value.nsLcmOpOccId = try reader["nsLcmOpOccId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListSolFunctionInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolFunctionInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolFunctionInstancesOutput()
        value.functionInstances = try reader["functionInstances"].readListIfPresent(memberReadingClosure: TnbClientTypes.ListSolFunctionInstanceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSolFunctionPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolFunctionPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolFunctionPackagesOutput()
        value.functionPackages = try reader["functionPackages"].readListIfPresent(memberReadingClosure: TnbClientTypes.ListSolFunctionPackageInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSolNetworkInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolNetworkInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolNetworkInstancesOutput()
        value.networkInstances = try reader["networkInstances"].readListIfPresent(memberReadingClosure: TnbClientTypes.ListSolNetworkInstanceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSolNetworkOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolNetworkOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolNetworkOperationsOutput()
        value.networkOperations = try reader["networkOperations"].readListIfPresent(memberReadingClosure: TnbClientTypes.ListSolNetworkOperationsInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSolNetworkPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolNetworkPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolNetworkPackagesOutput()
        value.networkPackages = try reader["networkPackages"].readListIfPresent(memberReadingClosure: TnbClientTypes.ListSolNetworkPackageInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PutSolFunctionPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSolFunctionPackageContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSolFunctionPackageContentOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.PutSolFunctionPackageContentMetadata.read(from:))
        value.vnfProductName = try reader["vnfProductName"].readIfPresent() ?? ""
        value.vnfProvider = try reader["vnfProvider"].readIfPresent() ?? ""
        value.vnfdId = try reader["vnfdId"].readIfPresent() ?? ""
        value.vnfdVersion = try reader["vnfdVersion"].readIfPresent() ?? ""
        return value
    }
}

extension PutSolNetworkPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSolNetworkPackageContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSolNetworkPackageContentOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.PutSolNetworkPackageContentMetadata.read(from:))
        value.nsdId = try reader["nsdId"].readIfPresent() ?? ""
        value.nsdName = try reader["nsdName"].readIfPresent() ?? ""
        value.nsdVersion = try reader["nsdVersion"].readIfPresent() ?? ""
        value.vnfPkgIds = try reader["vnfPkgIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TerminateSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateSolNetworkInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateSolNetworkInstanceOutput()
        value.nsLcmOpOccId = try reader["nsLcmOpOccId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateSolFunctionPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSolFunctionPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSolFunctionPackageOutput()
        value.operationalState = try reader["operationalState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateSolNetworkInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSolNetworkInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSolNetworkInstanceOutput()
        value.nsLcmOpOccId = try reader["nsLcmOpOccId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateSolNetworkPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSolNetworkPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSolNetworkPackageOutput()
        value.nsdOperationalState = try reader["nsdOperationalState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ValidateSolFunctionPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateSolFunctionPackageContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateSolFunctionPackageContentOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ValidateSolFunctionPackageContentMetadata.read(from:))
        value.vnfProductName = try reader["vnfProductName"].readIfPresent() ?? ""
        value.vnfProvider = try reader["vnfProvider"].readIfPresent() ?? ""
        value.vnfdId = try reader["vnfdId"].readIfPresent() ?? ""
        value.vnfdVersion = try reader["vnfdVersion"].readIfPresent() ?? ""
        return value
    }
}

extension ValidateSolNetworkPackageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateSolNetworkPackageContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateSolNetworkPackageContentOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ValidateSolNetworkPackageContentMetadata.read(from:))
        value.nsdId = try reader["nsdId"].readIfPresent() ?? ""
        value.nsdName = try reader["nsdName"].readIfPresent() ?? ""
        value.nsdVersion = try reader["nsdVersion"].readIfPresent() ?? ""
        value.vnfPkgIds = try reader["vnfPkgIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum CancelSolNetworkOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSolFunctionPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSolNetworkPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSolFunctionPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSolNetworkPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolFunctionInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolFunctionPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolFunctionPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolFunctionPackageDescriptorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolNetworkOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolNetworkPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolNetworkPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolNetworkPackageDescriptorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InstantiateSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolFunctionInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolFunctionPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolNetworkInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolNetworkOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolNetworkPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSolFunctionPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSolNetworkPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSolFunctionPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSolNetworkInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSolNetworkPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateSolFunctionPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateSolNetworkPackageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TnbClientTypes.GetSolVnfInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolVnfInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolVnfInfo()
        value.vnfState = try reader["vnfState"].readIfPresent()
        value.vnfcResourceInfo = try reader["vnfcResourceInfo"].readListIfPresent(memberReadingClosure: TnbClientTypes.GetSolVnfcResourceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TnbClientTypes.GetSolVnfcResourceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolVnfcResourceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolVnfcResourceInfo()
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.GetSolVnfcResourceInfoMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.GetSolVnfcResourceInfoMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolVnfcResourceInfoMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolVnfcResourceInfoMetadata()
        value.nodeGroup = try reader["nodeGroup"].readIfPresent()
        value.cluster = try reader["cluster"].readIfPresent()
        value.helmChart = try reader["helmChart"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.GetSolFunctionInstanceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolFunctionInstanceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolFunctionInstanceMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.GetSolFunctionPackageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolFunctionPackageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolFunctionPackageMetadata()
        value.vnfd = try reader["vnfd"].readIfPresent(with: TnbClientTypes.FunctionArtifactMeta.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.FunctionArtifactMeta {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.FunctionArtifactMeta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.FunctionArtifactMeta()
        value.overrides = try reader["overrides"].readListIfPresent(memberReadingClosure: TnbClientTypes.ToscaOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TnbClientTypes.ToscaOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ToscaOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ToscaOverride()
        value.name = try reader["name"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.LcmOperationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.LcmOperationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.LcmOperationInfo()
        value.nsLcmOpOccId = try reader["nsLcmOpOccId"].readIfPresent() ?? ""
        return value
    }
}

extension TnbClientTypes.GetSolNetworkInstanceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolNetworkInstanceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolNetworkInstanceMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.ProblemDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ProblemDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ProblemDetails()
        value.detail = try reader["detail"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.GetSolNetworkOperationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolNetworkOperationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolNetworkOperationMetadata()
        value.updateNsMetadata = try reader["updateNsMetadata"].readIfPresent(with: TnbClientTypes.UpdateNsMetadata.read(from:))
        value.modifyVnfInfoMetadata = try reader["modifyVnfInfoMetadata"].readIfPresent(with: TnbClientTypes.ModifyVnfInfoMetadata.read(from:))
        value.instantiateMetadata = try reader["instantiateMetadata"].readIfPresent(with: TnbClientTypes.InstantiateMetadata.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.InstantiateMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.InstantiateMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.InstantiateMetadata()
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent() ?? ""
        value.additionalParamsForNs = try reader["additionalParamsForNs"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.ModifyVnfInfoMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ModifyVnfInfoMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ModifyVnfInfoMetadata()
        value.vnfInstanceId = try reader["vnfInstanceId"].readIfPresent() ?? ""
        value.vnfConfigurableProperties = try reader["vnfConfigurableProperties"].readIfPresent() ?? [:]
        return value
    }
}

extension TnbClientTypes.UpdateNsMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.UpdateNsMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.UpdateNsMetadata()
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent() ?? ""
        value.additionalParamsForNs = try reader["additionalParamsForNs"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.GetSolNetworkOperationTaskDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolNetworkOperationTaskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolNetworkOperationTaskDetails()
        value.taskName = try reader["taskName"].readIfPresent()
        value.taskContext = try reader["taskContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.taskErrorDetails = try reader["taskErrorDetails"].readIfPresent(with: TnbClientTypes.ErrorInfo.read(from:))
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.taskStartTime = try reader["taskStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskEndTime = try reader["taskEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension TnbClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ErrorInfo()
        value.cause = try reader["cause"].readIfPresent()
        value.details = try reader["details"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.GetSolNetworkPackageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolNetworkPackageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolNetworkPackageMetadata()
        value.nsd = try reader["nsd"].readIfPresent(with: TnbClientTypes.NetworkArtifactMeta.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.NetworkArtifactMeta {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.NetworkArtifactMeta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.NetworkArtifactMeta()
        value.overrides = try reader["overrides"].readListIfPresent(memberReadingClosure: TnbClientTypes.ToscaOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TnbClientTypes.ListSolFunctionInstanceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolFunctionInstanceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolFunctionInstanceInfo()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.nsInstanceId = try reader["nsInstanceId"].readIfPresent() ?? ""
        value.vnfPkgId = try reader["vnfPkgId"].readIfPresent() ?? ""
        value.vnfPkgName = try reader["vnfPkgName"].readIfPresent()
        value.instantiationState = try reader["instantiationState"].readIfPresent() ?? .sdkUnknown("")
        value.instantiatedVnfInfo = try reader["instantiatedVnfInfo"].readIfPresent(with: TnbClientTypes.GetSolInstantiatedVnfInfo.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ListSolFunctionInstanceMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.ListSolFunctionInstanceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolFunctionInstanceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolFunctionInstanceMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.GetSolInstantiatedVnfInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.GetSolInstantiatedVnfInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.GetSolInstantiatedVnfInfo()
        value.vnfState = try reader["vnfState"].readIfPresent()
        return value
    }
}

extension TnbClientTypes.ListSolFunctionPackageInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolFunctionPackageInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolFunctionPackageInfo()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.onboardingState = try reader["onboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.operationalState = try reader["operationalState"].readIfPresent() ?? .sdkUnknown("")
        value.usageState = try reader["usageState"].readIfPresent() ?? .sdkUnknown("")
        value.vnfdId = try reader["vnfdId"].readIfPresent()
        value.vnfProvider = try reader["vnfProvider"].readIfPresent()
        value.vnfProductName = try reader["vnfProductName"].readIfPresent()
        value.vnfdVersion = try reader["vnfdVersion"].readIfPresent()
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ListSolFunctionPackageMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.ListSolFunctionPackageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolFunctionPackageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolFunctionPackageMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.ListSolNetworkInstanceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkInstanceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkInstanceInfo()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.nsInstanceName = try reader["nsInstanceName"].readIfPresent() ?? ""
        value.nsInstanceDescription = try reader["nsInstanceDescription"].readIfPresent() ?? ""
        value.nsdId = try reader["nsdId"].readIfPresent() ?? ""
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent() ?? ""
        value.nsState = try reader["nsState"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ListSolNetworkInstanceMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.ListSolNetworkInstanceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkInstanceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkInstanceMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.ListSolNetworkOperationsInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkOperationsInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkOperationsInfo()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.operationState = try reader["operationState"].readIfPresent() ?? .sdkUnknown("")
        value.nsInstanceId = try reader["nsInstanceId"].readIfPresent() ?? ""
        value.lcmOperationType = try reader["lcmOperationType"].readIfPresent() ?? .sdkUnknown("")
        value.updateType = try reader["updateType"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: TnbClientTypes.ProblemDetails.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ListSolNetworkOperationsMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.ListSolNetworkOperationsMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkOperationsMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkOperationsMetadata()
        value.nsdInfoId = try reader["nsdInfoId"].readIfPresent()
        value.vnfInstanceId = try reader["vnfInstanceId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.ListSolNetworkPackageInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkPackageInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkPackageInfo()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.nsdOnboardingState = try reader["nsdOnboardingState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdOperationalState = try reader["nsdOperationalState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdUsageState = try reader["nsdUsageState"].readIfPresent() ?? .sdkUnknown("")
        value.nsdId = try reader["nsdId"].readIfPresent()
        value.nsdName = try reader["nsdName"].readIfPresent()
        value.nsdVersion = try reader["nsdVersion"].readIfPresent()
        value.nsdDesigner = try reader["nsdDesigner"].readIfPresent()
        value.nsdInvariantId = try reader["nsdInvariantId"].readIfPresent()
        value.vnfPkgIds = try reader["vnfPkgIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.metadata = try reader["metadata"].readIfPresent(with: TnbClientTypes.ListSolNetworkPackageMetadata.read(from:))
        return value
    }
}

extension TnbClientTypes.ListSolNetworkPackageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ListSolNetworkPackageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ListSolNetworkPackageMetadata()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TnbClientTypes.PutSolFunctionPackageContentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.PutSolFunctionPackageContentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.PutSolFunctionPackageContentMetadata()
        value.vnfd = try reader["vnfd"].readIfPresent(with: TnbClientTypes.FunctionArtifactMeta.read(from:))
        return value
    }
}

extension TnbClientTypes.PutSolNetworkPackageContentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.PutSolNetworkPackageContentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.PutSolNetworkPackageContentMetadata()
        value.nsd = try reader["nsd"].readIfPresent(with: TnbClientTypes.NetworkArtifactMeta.read(from:))
        return value
    }
}

extension TnbClientTypes.ValidateSolFunctionPackageContentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ValidateSolFunctionPackageContentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ValidateSolFunctionPackageContentMetadata()
        value.vnfd = try reader["vnfd"].readIfPresent(with: TnbClientTypes.FunctionArtifactMeta.read(from:))
        return value
    }
}

extension TnbClientTypes.ValidateSolNetworkPackageContentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> TnbClientTypes.ValidateSolNetworkPackageContentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TnbClientTypes.ValidateSolNetworkPackageContentMetadata()
        value.nsd = try reader["nsd"].readIfPresent(with: TnbClientTypes.NetworkArtifactMeta.read(from:))
        return value
    }
}

extension TnbClientTypes.UpdateSolNetworkModify {

    static func write(value: TnbClientTypes.UpdateSolNetworkModify?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vnfConfigurableProperties"].write(value.vnfConfigurableProperties)
        try writer["vnfInstanceId"].write(value.vnfInstanceId)
    }
}

extension TnbClientTypes.UpdateSolNetworkServiceData {

    static func write(value: TnbClientTypes.UpdateSolNetworkServiceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalParamsForNs"].write(value.additionalParamsForNs)
        try writer["nsdInfoId"].write(value.nsdInfoId)
    }
}

public enum TnbClientTypes {}
