// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TnbClient {
    /// Paginate over `[ListSolFunctionInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolFunctionInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolFunctionInstancesOutputResponse`
    public func listSolFunctionInstancesPaginated(input: ListSolFunctionInstancesInput) -> ClientRuntime.PaginatorSequence<ListSolFunctionInstancesInput, ListSolFunctionInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolFunctionInstancesInput, ListSolFunctionInstancesOutputResponse>(input: input, inputKey: \ListSolFunctionInstancesInput.nextToken, outputKey: \ListSolFunctionInstancesOutputResponse.nextToken, paginationFunction: self.listSolFunctionInstances(input:))
    }
}

extension ListSolFunctionInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolFunctionInstancesInput {
        return ListSolFunctionInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolFunctionInstancesInput, Output == ListSolFunctionInstancesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolFunctionInstancesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolFunctionInstanceInfo]`
    /// - Returns: `[TnbClientTypes.ListSolFunctionInstanceInfo]`
    public func functionInstances() async throws -> [TnbClientTypes.ListSolFunctionInstanceInfo] {
        return try await self.asyncCompactMap { item in item.functionInstances }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolFunctionPackagesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolFunctionPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolFunctionPackagesOutputResponse`
    public func listSolFunctionPackagesPaginated(input: ListSolFunctionPackagesInput) -> ClientRuntime.PaginatorSequence<ListSolFunctionPackagesInput, ListSolFunctionPackagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolFunctionPackagesInput, ListSolFunctionPackagesOutputResponse>(input: input, inputKey: \ListSolFunctionPackagesInput.nextToken, outputKey: \ListSolFunctionPackagesOutputResponse.nextToken, paginationFunction: self.listSolFunctionPackages(input:))
    }
}

extension ListSolFunctionPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolFunctionPackagesInput {
        return ListSolFunctionPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolFunctionPackagesInput, Output == ListSolFunctionPackagesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolFunctionPackagesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolFunctionPackageInfo]`
    /// - Returns: `[TnbClientTypes.ListSolFunctionPackageInfo]`
    public func functionPackages() async throws -> [TnbClientTypes.ListSolFunctionPackageInfo] {
        return try await self.asyncCompactMap { item in item.functionPackages }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkInstancesOutputResponse`
    public func listSolNetworkInstancesPaginated(input: ListSolNetworkInstancesInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkInstancesInput, ListSolNetworkInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkInstancesInput, ListSolNetworkInstancesOutputResponse>(input: input, inputKey: \ListSolNetworkInstancesInput.nextToken, outputKey: \ListSolNetworkInstancesOutputResponse.nextToken, paginationFunction: self.listSolNetworkInstances(input:))
    }
}

extension ListSolNetworkInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkInstancesInput {
        return ListSolNetworkInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolNetworkInstancesInput, Output == ListSolNetworkInstancesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkInstancesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkInstanceInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkInstanceInfo]`
    public func networkInstances() async throws -> [TnbClientTypes.ListSolNetworkInstanceInfo] {
        return try await self.asyncCompactMap { item in item.networkInstances }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkOperationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkOperationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkOperationsOutputResponse`
    public func listSolNetworkOperationsPaginated(input: ListSolNetworkOperationsInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkOperationsInput, ListSolNetworkOperationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkOperationsInput, ListSolNetworkOperationsOutputResponse>(input: input, inputKey: \ListSolNetworkOperationsInput.nextToken, outputKey: \ListSolNetworkOperationsOutputResponse.nextToken, paginationFunction: self.listSolNetworkOperations(input:))
    }
}

extension ListSolNetworkOperationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkOperationsInput {
        return ListSolNetworkOperationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolNetworkOperationsInput, Output == ListSolNetworkOperationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkOperationsPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkOperationsInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkOperationsInfo]`
    public func networkOperations() async throws -> [TnbClientTypes.ListSolNetworkOperationsInfo] {
        return try await self.asyncCompactMap { item in item.networkOperations }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkPackagesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkPackagesOutputResponse`
    public func listSolNetworkPackagesPaginated(input: ListSolNetworkPackagesInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkPackagesInput, ListSolNetworkPackagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkPackagesInput, ListSolNetworkPackagesOutputResponse>(input: input, inputKey: \ListSolNetworkPackagesInput.nextToken, outputKey: \ListSolNetworkPackagesOutputResponse.nextToken, paginationFunction: self.listSolNetworkPackages(input:))
    }
}

extension ListSolNetworkPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkPackagesInput {
        return ListSolNetworkPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolNetworkPackagesInput, Output == ListSolNetworkPackagesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkPackagesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkPackageInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkPackageInfo]`
    public func networkPackages() async throws -> [TnbClientTypes.ListSolNetworkPackageInfo] {
        return try await self.asyncCompactMap { item in item.networkPackages }
    }
}
