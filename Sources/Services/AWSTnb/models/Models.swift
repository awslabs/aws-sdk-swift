// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Insufficient permissions to make request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelSolNetworkOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsLcmOpOccId = nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())/cancel"
    }
}

public struct CancelSolNetworkOperationInput: Swift.Equatable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init(
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct CancelSolNetworkOperationInputBody: Swift.Equatable {
}

extension CancelSolNetworkOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelSolNetworkOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelSolNetworkOperationOutput: Swift.Equatable {

    public init() { }
}

enum CancelSolNetworkOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSolFunctionPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolFunctionPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

public struct CreateSolFunctionPackageInput: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateSolFunctionPackageInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolFunctionPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolFunctionPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolFunctionPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSolFunctionPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.onboardingState = output.onboardingState
            self.operationalState = output.operationalState
            self.tags = output.tags
            self.usageState = output.usageState
        } else {
            self.arn = nil
            self.id = nil
            self.onboardingState = nil
            self.operationalState = nil
            self.tags = nil
            self.usageState = nil
        }
    }
}

public struct CreateSolFunctionPackageOutput: Swift.Equatable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the function package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the function package.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Usage state of the function package.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
    }
}

struct CreateSolFunctionPackageOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let onboardingState: TnbClientTypes.OnboardingState?
    let operationalState: TnbClientTypes.OperationalState?
    let usageState: TnbClientTypes.UsageState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolFunctionPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case onboardingState
        case operationalState
        case tags
        case usageState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateSolFunctionPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceInput(nsDescription: \(Swift.String(describing: nsDescription)), nsName: \(Swift.String(describing: nsName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsDescription
        case nsName
        case nsdInfoId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsDescription = self.nsDescription {
            try encodeContainer.encode(nsDescription, forKey: .nsDescription)
        }
        if let nsName = self.nsName {
            try encodeContainer.encode(nsName, forKey: .nsName)
        }
        if let nsdInfoId = self.nsdInfoId {
            try encodeContainer.encode(nsdInfoId, forKey: .nsdInfoId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

public struct CreateSolNetworkInstanceInput: Swift.Equatable {
    /// Network instance description.
    public var nsDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsName: Swift.String?
    /// ID for network service descriptor.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nsDescription: Swift.String? = nil,
        nsName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsDescription = nsDescription
        self.nsName = nsName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct CreateSolNetworkInstanceInputBody: Swift.Equatable {
    let nsdInfoId: Swift.String?
    let nsName: Swift.String?
    let nsDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsDescription
        case nsName
        case nsdInfoId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsName)
        nsName = nsNameDecoded
        let nsDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsDescription)
        nsDescription = nsDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSolNetworkInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.nsInstanceName = output.nsInstanceName
            self.nsdInfoId = output.nsdInfoId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.nsInstanceName = nil
            self.nsdInfoId = nil
            self.tags = nil
        }
    }
}

public struct CreateSolNetworkInstanceOutput: Swift.Equatable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsInstanceName = nsInstanceName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct CreateSolNetworkInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdInfoId: Swift.String?
    let nsInstanceName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case nsInstanceName
        case nsdInfoId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSolNetworkPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

public struct CreateSolNetworkPackageInput: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateSolNetworkPackageInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSolNetworkPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.nsdOnboardingState = output.nsdOnboardingState
            self.nsdOperationalState = output.nsdOperationalState
            self.nsdUsageState = output.nsdUsageState
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.nsdOnboardingState = nil
            self.nsdOperationalState = nil
            self.nsdUsageState = nil
            self.tags = nil
        }
    }
}

public struct CreateSolNetworkPackageOutput: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the network package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Usage state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.tags = tags
    }
}

struct CreateSolNetworkPackageOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
    let nsdUsageState: TnbClientTypes.NsdUsageState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateSolNetworkPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct DeleteSolFunctionPackageInput: Swift.Equatable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

struct DeleteSolFunctionPackageInputBody: Swift.Equatable {
}

extension DeleteSolFunctionPackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolFunctionPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSolFunctionPackageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSolFunctionPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

public struct DeleteSolNetworkInstanceInput: Swift.Equatable {
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init(
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

struct DeleteSolNetworkInstanceInputBody: Swift.Equatable {
}

extension DeleteSolNetworkInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSolNetworkInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct DeleteSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct DeleteSolNetworkPackageInputBody: Swift.Equatable {
}

extension DeleteSolNetworkPackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolNetworkPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSolNetworkPackageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSolNetworkPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes {
    public enum DescriptorContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textPlain
        case sdkUnknown(Swift.String)

        public static var allCases: [DescriptorContentType] {
            return [
                .textPlain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textPlain: return "text/plain"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescriptorContentType(rawValue: rawValue) ?? DescriptorContentType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case details
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = self.cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension TnbClientTypes {
    /// Provides error information.
    public struct ErrorInfo: Swift.Equatable {
        /// Error cause.
        public var cause: Swift.String?
        /// Error details.
        public var details: Swift.String?

        public init(
            cause: Swift.String? = nil,
            details: Swift.String? = nil
        )
        {
            self.cause = cause
            self.details = details
        }
    }

}

extension TnbClientTypes.FunctionArtifactMeta: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for toscaoverride0 in overrides {
                try overridesContainer.encode(toscaoverride0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ToscaOverride?].self, forKey: .overrides)
        var overridesDecoded0:[TnbClientTypes.ToscaOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [TnbClientTypes.ToscaOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension TnbClientTypes {
    /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct FunctionArtifactMeta: Swift.Equatable {
        /// Lists of function package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init(
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }

}

extension GetSolFunctionInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfInstanceId = vnfInstanceId else {
            return nil
        }
        return "/sol/vnflcm/v1/vnf_instances/\(vnfInstanceId.urlPercentEncoding())"
    }
}

public struct GetSolFunctionInstanceInput: Swift.Equatable {
    /// ID of the network function.
    /// This member is required.
    public var vnfInstanceId: Swift.String?

    public init(
        vnfInstanceId: Swift.String? = nil
    )
    {
        self.vnfInstanceId = vnfInstanceId
    }
}

struct GetSolFunctionInstanceInputBody: Swift.Equatable {
}

extension GetSolFunctionInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolFunctionInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network function instance. A network function instance is a function in a function package .
    public struct GetSolFunctionInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolFunctionInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), instantiatedVnfInfo: \(Swift.String(describing: instantiatedVnfInfo)), instantiationState: \(Swift.String(describing: instantiationState)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), vnfPkgId: \(Swift.String(describing: vnfPkgId)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolFunctionInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolFunctionInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.instantiatedVnfInfo = output.instantiatedVnfInfo
            self.instantiationState = output.instantiationState
            self.metadata = output.metadata
            self.nsInstanceId = output.nsInstanceId
            self.tags = output.tags
            self.vnfPkgId = output.vnfPkgId
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.arn = nil
            self.id = nil
            self.instantiatedVnfInfo = nil
            self.instantiationState = nil
            self.metadata = nil
            self.nsInstanceId = nil
            self.tags = nil
            self.vnfPkgId = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct GetSolFunctionInstanceOutput: Swift.Equatable {
    /// Network function instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network function instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the network function. A network function instance is a function in a function package .
    public var instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo?
    /// Network function instantiation state.
    /// This member is required.
    public var instantiationState: TnbClientTypes.VnfInstantiationState?
    /// The metadata of a network function instance. A network function instance is a function in a function package .
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolFunctionInstanceMetadata?
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo? = nil,
        instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
        metadata: TnbClientTypes.GetSolFunctionInstanceMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vnfPkgId: Swift.String? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.instantiatedVnfInfo = instantiatedVnfInfo
        self.instantiationState = instantiationState
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.tags = tags
        self.vnfPkgId = vnfPkgId
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct GetSolFunctionInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsInstanceId: Swift.String?
    let vnfPkgId: Swift.String?
    let vnfdId: Swift.String?
    let vnfProvider: Swift.String?
    let vnfProductName: Swift.String?
    let vnfdVersion: Swift.String?
    let instantiationState: TnbClientTypes.VnfInstantiationState?
    let instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo?
    let metadata: TnbClientTypes.GetSolFunctionInstanceMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolFunctionInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case instantiatedVnfInfo
        case instantiationState
        case metadata
        case nsInstanceId
        case tags
        case vnfPkgId
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let vnfPkgIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgId)
        vnfPkgId = vnfPkgIdDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let instantiationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfInstantiationState.self, forKey: .instantiationState)
        instantiationState = instantiationStateDecoded
        let instantiatedVnfInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolVnfInfo.self, forKey: .instantiatedVnfInfo)
        instantiatedVnfInfo = instantiatedVnfInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolFunctionInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSolFunctionInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

public struct GetSolFunctionPackageContentInput: Swift.Equatable {
    /// The format of the package that you want to download from the function packages.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        accept: TnbClientTypes.PackageContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageContentInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageContentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSolFunctionPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.packageContent = data
        case .stream(let stream):
            self.packageContent = try stream.readToEnd()
        case .none:
            self.packageContent = nil
        }
    }
}

public struct GetSolFunctionPackageContentOutput: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Contents of the function package.
    public var packageContent: ClientRuntime.Data?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        packageContent: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.packageContent = packageContent
    }
}

struct GetSolFunctionPackageContentOutputBody: Swift.Equatable {
    let packageContent: ClientRuntime.Data?
}

extension GetSolFunctionPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .packageContent)
        packageContent = packageContentDecoded
    }
}

enum GetSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolFunctionPackageDescriptorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolFunctionPackageDescriptorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/vnfd"
    }
}

public struct GetSolFunctionPackageDescriptorInput: Swift.Equatable {
    /// Indicates which content types, expressed as MIME types, the client is able to understand.
    /// This member is required.
    public var accept: TnbClientTypes.DescriptorContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        accept: TnbClientTypes.DescriptorContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageDescriptorInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageDescriptorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSolFunctionPackageDescriptorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.vnfd = data
        case .stream(let stream):
            self.vnfd = try stream.readToEnd()
        case .none:
            self.vnfd = nil
        }
    }
}

public struct GetSolFunctionPackageDescriptorOutput: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the function package descriptor.
    public var vnfd: ClientRuntime.Data?

    public init(
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        vnfd: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.vnfd = vnfd
    }
}

struct GetSolFunctionPackageDescriptorOutputBody: Swift.Equatable {
    let vnfd: ClientRuntime.Data?
}

extension GetSolFunctionPackageDescriptorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

enum GetSolFunctionPackageDescriptorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct GetSolFunctionPackageInput: Swift.Equatable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolFunctionPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct GetSolFunctionPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?
        /// Metadata related to the function package descriptor of the function package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil,
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.vnfd = vnfd
        }
    }

}

extension GetSolFunctionPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolFunctionPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolFunctionPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.onboardingState = output.onboardingState
            self.operationalState = output.operationalState
            self.tags = output.tags
            self.usageState = output.usageState
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.onboardingState = nil
            self.operationalState = nil
            self.tags = nil
            self.usageState = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct GetSolFunctionPackageOutput: Swift.Equatable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public var metadata: TnbClientTypes.GetSolFunctionPackageMetadata?
    /// Function package onboarding state.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Function package operational state.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Function package usage state.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolFunctionPackageMetadata? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct GetSolFunctionPackageOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let onboardingState: TnbClientTypes.OnboardingState?
    let operationalState: TnbClientTypes.OperationalState?
    let usageState: TnbClientTypes.UsageState?
    let vnfdId: Swift.String?
    let vnfProvider: Swift.String?
    let vnfProductName: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.GetSolFunctionPackageMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolFunctionPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case onboardingState
        case operationalState
        case tags
        case usageState
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolFunctionPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSolFunctionPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.GetSolInstantiatedVnfInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfState = self.vnfState {
            try encodeContainer.encode(vnfState.rawValue, forKey: .vnfState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfOperationalState.self, forKey: .vnfState)
        vnfState = vnfStateDecoded
    }
}

extension TnbClientTypes {
    /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolInstantiatedVnfInfo: Swift.Equatable {
        /// State of the network function.
        public var vnfState: TnbClientTypes.VnfOperationalState?

        public init(
            vnfState: TnbClientTypes.VnfOperationalState? = nil
        )
        {
            self.vnfState = vnfState
        }
    }

}

extension GetSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkInstanceInput: Swift.Equatable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init(
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

struct GetSolNetworkInstanceInputBody: Swift.Equatable {
}

extension GetSolNetworkInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolNetworkInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkInstanceOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), lcmOpInfo: \(Swift.String(describing: lcmOpInfo)), metadata: \(Swift.String(describing: metadata)), nsInstanceDescription: \(Swift.String(describing: nsInstanceDescription)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsState: \(Swift.String(describing: nsState)), nsdId: \(Swift.String(describing: nsdId)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolNetworkInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lcmOpInfo = output.lcmOpInfo
            self.metadata = output.metadata
            self.nsInstanceDescription = output.nsInstanceDescription
            self.nsInstanceName = output.nsInstanceName
            self.nsState = output.nsState
            self.nsdId = output.nsdId
            self.nsdInfoId = output.nsdInfoId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.lcmOpInfo = nil
            self.metadata = nil
            self.nsInstanceDescription = nil
            self.nsInstanceName = nil
            self.nsState = nil
            self.nsdId = nil
            self.nsdInfoId = nil
            self.tags = nil
        }
    }
}

public struct GetSolNetworkInstanceOutput: Swift.Equatable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public var lcmOpInfo: TnbClientTypes.LcmOperationInfo?
    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkInstanceMetadata?
    /// Network instance description.
    /// This member is required.
    public var nsInstanceDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network instance state.
    public var nsState: TnbClientTypes.NsState?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lcmOpInfo: TnbClientTypes.LcmOperationInfo? = nil,
        metadata: TnbClientTypes.GetSolNetworkInstanceMetadata? = nil,
        nsInstanceDescription: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsState: TnbClientTypes.NsState? = nil,
        nsdId: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lcmOpInfo = lcmOpInfo
        self.metadata = metadata
        self.nsInstanceDescription = nsInstanceDescription
        self.nsInstanceName = nsInstanceName
        self.nsState = nsState
        self.nsdId = nsdId
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct GetSolNetworkInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsInstanceName: Swift.String?
    let nsInstanceDescription: Swift.String?
    let nsdId: Swift.String?
    let nsdInfoId: Swift.String?
    let nsState: TnbClientTypes.NsState?
    let lcmOpInfo: TnbClientTypes.LcmOperationInfo?
    let metadata: TnbClientTypes.GetSolNetworkInstanceMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lcmOpInfo
        case metadata
        case nsInstanceDescription
        case nsInstanceName
        case nsState
        case nsdId
        case nsdInfoId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let nsInstanceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceDescription)
        nsInstanceDescription = nsInstanceDescriptionDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsState.self, forKey: .nsState)
        nsState = nsStateDecoded
        let lcmOpInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationInfo.self, forKey: .lcmOpInfo)
        lcmOpInfo = lcmOpInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolNetworkOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsLcmOpOccId = nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkOperationInput: Swift.Equatable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init(
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct GetSolNetworkOperationInputBody: Swift.Equatable {
}

extension GetSolNetworkOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkOperationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network operation occurrence. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolNetworkOperationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkOperationOutput(arn: \(Swift.String(describing: arn)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), lcmOperationType: \(Swift.String(describing: lcmOperationType)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), operationState: \(Swift.String(describing: operationState)), tasks: \(Swift.String(describing: tasks)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolNetworkOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.error = output.error
            self.id = output.id
            self.lcmOperationType = output.lcmOperationType
            self.metadata = output.metadata
            self.nsInstanceId = output.nsInstanceId
            self.operationState = output.operationState
            self.tags = output.tags
            self.tasks = output.tasks
        } else {
            self.arn = nil
            self.error = nil
            self.id = nil
            self.lcmOperationType = nil
            self.metadata = nil
            self.nsInstanceId = nil
            self.operationState = nil
            self.tags = nil
            self.tasks = nil
        }
    }
}

public struct GetSolNetworkOperationOutput: Swift.Equatable {
    /// Network operation ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Error related to this specific network operation occurrence.
    public var error: TnbClientTypes.ProblemDetails?
    /// ID of this network operation occurrence.
    public var id: Swift.String?
    /// Type of the operation represented by this occurrence.
    public var lcmOperationType: TnbClientTypes.LcmOperationType?
    /// Metadata of this network operation occurrence.
    public var metadata: TnbClientTypes.GetSolNetworkOperationMetadata?
    /// ID of the network operation instance.
    public var nsInstanceId: Swift.String?
    /// The state of the network operation.
    public var operationState: TnbClientTypes.NsLcmOperationState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// All tasks associated with this operation occurrence.
    public var tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]?

    public init(
        arn: Swift.String? = nil,
        error: TnbClientTypes.ProblemDetails? = nil,
        id: Swift.String? = nil,
        lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
        metadata: TnbClientTypes.GetSolNetworkOperationMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        operationState: TnbClientTypes.NsLcmOperationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]? = nil
    )
    {
        self.arn = arn
        self.error = error
        self.id = id
        self.lcmOperationType = lcmOperationType
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.operationState = operationState
        self.tags = tags
        self.tasks = tasks
    }
}

struct GetSolNetworkOperationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let operationState: TnbClientTypes.NsLcmOperationState?
    let nsInstanceId: Swift.String?
    let lcmOperationType: TnbClientTypes.LcmOperationType?
    let error: TnbClientTypes.ProblemDetails?
    let metadata: TnbClientTypes.GetSolNetworkOperationMetadata?
    let tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case error
        case id
        case lcmOperationType
        case metadata
        case nsInstanceId
        case operationState
        case tags
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsLcmOperationState.self, forKey: .operationState)
        operationState = operationStateDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let lcmOperationTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationType.self, forKey: .lcmOperationType)
        lcmOperationType = lcmOperationTypeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ProblemDetails.self, forKey: .error)
        error = errorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkOperationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tasksContainer = try containerValues.decodeIfPresent([TnbClientTypes.GetSolNetworkOperationTaskDetails?].self, forKey: .tasks)
        var tasksDecoded0:[TnbClientTypes.GetSolNetworkOperationTaskDetails]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [TnbClientTypes.GetSolNetworkOperationTaskDetails]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSolNetworkOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.GetSolNetworkOperationTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskContext
        case taskEndTime
        case taskErrorDetails
        case taskName
        case taskStartTime
        case taskStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskContext = taskContext {
            var taskContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskContext)
            for (dictKey0, stringMap0) in taskContext {
                try taskContextContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskEndTime = self.taskEndTime {
            try encodeContainer.encodeTimestamp(taskEndTime, format: .dateTime, forKey: .taskEndTime)
        }
        if let taskErrorDetails = self.taskErrorDetails {
            try encodeContainer.encode(taskErrorDetails, forKey: .taskErrorDetails)
        }
        if let taskName = self.taskName {
            try encodeContainer.encode(taskName, forKey: .taskName)
        }
        if let taskStartTime = self.taskStartTime {
            try encodeContainer.encodeTimestamp(taskStartTime, format: .dateTime, forKey: .taskStartTime)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskName)
        taskName = taskNameDecoded
        let taskContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskContext)
        var taskContextDecoded0: [Swift.String:Swift.String]? = nil
        if let taskContextContainer = taskContextContainer {
            taskContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in taskContextContainer {
                if let string0 = string0 {
                    taskContextDecoded0?[key0] = string0
                }
            }
        }
        taskContext = taskContextDecoded0
        let taskErrorDetailsDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ErrorInfo.self, forKey: .taskErrorDetails)
        taskErrorDetails = taskErrorDetailsDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TnbClientTypes.TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .taskEndTime)
        taskEndTime = taskEndTimeDecoded
    }
}

extension TnbClientTypes {
    /// Gets the details of a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationTaskDetails: Swift.Equatable {
        /// Context for the network operation task.
        public var taskContext: [Swift.String:Swift.String]?
        /// Task end time.
        public var taskEndTime: ClientRuntime.Date?
        /// Task error details.
        public var taskErrorDetails: TnbClientTypes.ErrorInfo?
        /// Task name.
        public var taskName: Swift.String?
        /// Task start time.
        public var taskStartTime: ClientRuntime.Date?
        /// Task status.
        public var taskStatus: TnbClientTypes.TaskStatus?

        public init(
            taskContext: [Swift.String:Swift.String]? = nil,
            taskEndTime: ClientRuntime.Date? = nil,
            taskErrorDetails: TnbClientTypes.ErrorInfo? = nil,
            taskName: Swift.String? = nil,
            taskStartTime: ClientRuntime.Date? = nil,
            taskStatus: TnbClientTypes.TaskStatus? = nil
        )
        {
            self.taskContext = taskContext
            self.taskEndTime = taskEndTime
            self.taskErrorDetails = taskErrorDetails
            self.taskName = taskName
            self.taskStartTime = taskStartTime
            self.taskStatus = taskStatus
        }
    }

}

extension GetSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

public struct GetSolNetworkPackageContentInput: Swift.Equatable {
    /// The format of the package you want to download from the network package.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        accept: TnbClientTypes.PackageContentType? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageContentInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageContentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSolNetworkPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.nsdContent = data
        case .stream(let stream):
            self.nsdContent = try stream.readToEnd()
        case .none:
            self.nsdContent = nil
        }
    }
}

public struct GetSolNetworkPackageContentOutput: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Content of the network service descriptor in the network package.
    public var nsdContent: ClientRuntime.Data?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        nsdContent: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsdContent = nsdContent
    }
}

struct GetSolNetworkPackageContentOutputBody: Swift.Equatable {
    let nsdContent: ClientRuntime.Data?
}

extension GetSolNetworkPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .nsdContent)
        nsdContent = nsdContentDecoded
    }
}

enum GetSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolNetworkPackageDescriptorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd"
    }
}

public struct GetSolNetworkPackageDescriptorInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageDescriptorInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageDescriptorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSolNetworkPackageDescriptorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.nsd = data
        case .stream(let stream):
            self.nsd = try stream.readToEnd()
        case .none:
            self.nsd = nil
        }
    }
}

public struct GetSolNetworkPackageDescriptorOutput: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the network service descriptor in the network package.
    public var nsd: ClientRuntime.Data?

    public init(
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        nsd: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsd = nsd
    }
}

struct GetSolNetworkPackageDescriptorOutputBody: Swift.Equatable {
    let nsd: ClientRuntime.Data?
}

extension GetSolNetworkPackageDescriptorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

enum GetSolNetworkPackageDescriptorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct GetSolNetworkPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?
        /// Metadata related to the onboarded network service descriptor in the network package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil,
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsd = nsd
        }
    }

}

extension GetSolNetworkPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkPackageOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), nsdId: \(Swift.String(describing: nsdId)), nsdName: \(Swift.String(describing: nsdName)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), nsdVersion: \(Swift.String(describing: nsdVersion)), vnfPkgIds: \(Swift.String(describing: vnfPkgIds)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolNetworkPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdOnboardingState = output.nsdOnboardingState
            self.nsdOperationalState = output.nsdOperationalState
            self.nsdUsageState = output.nsdUsageState
            self.nsdVersion = output.nsdVersion
            self.tags = output.tags
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdOnboardingState = nil
            self.nsdOperationalState = nil
            self.nsdUsageState = nil
            self.nsdVersion = nil
            self.tags = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct GetSolNetworkPackageOutput: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkPackageMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor onboarding state.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Network service descriptor operational state.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Network service descriptor usage state.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolNetworkPackageMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        nsdVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.nsdVersion = nsdVersion
        self.tags = tags
        self.vnfPkgIds = vnfPkgIds
    }
}

struct GetSolNetworkPackageOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
    let nsdUsageState: TnbClientTypes.NsdUsageState?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.GetSolNetworkPackageMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case nsdVersion
        case tags
        case vnfPkgIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSolNetworkPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.GetSolVnfInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfState
        case vnfcResourceInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfState = self.vnfState {
            try encodeContainer.encode(vnfState.rawValue, forKey: .vnfState)
        }
        if let vnfcResourceInfo = vnfcResourceInfo {
            var vnfcResourceInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vnfcResourceInfo)
            for getsolvnfcresourceinfo0 in vnfcResourceInfo {
                try vnfcResourceInfoContainer.encode(getsolvnfcresourceinfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfOperationalState.self, forKey: .vnfState)
        vnfState = vnfStateDecoded
        let vnfcResourceInfoContainer = try containerValues.decodeIfPresent([TnbClientTypes.GetSolVnfcResourceInfo?].self, forKey: .vnfcResourceInfo)
        var vnfcResourceInfoDecoded0:[TnbClientTypes.GetSolVnfcResourceInfo]? = nil
        if let vnfcResourceInfoContainer = vnfcResourceInfoContainer {
            vnfcResourceInfoDecoded0 = [TnbClientTypes.GetSolVnfcResourceInfo]()
            for structure0 in vnfcResourceInfoContainer {
                if let structure0 = structure0 {
                    vnfcResourceInfoDecoded0?.append(structure0)
                }
            }
        }
        vnfcResourceInfo = vnfcResourceInfoDecoded0
    }
}

extension TnbClientTypes {
    /// Information about the network function. A network function instance is a function in a function package .
    public struct GetSolVnfInfo: Swift.Equatable {
        /// State of the network function instance.
        public var vnfState: TnbClientTypes.VnfOperationalState?
        /// Compute info used by the network function instance.
        public var vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]?

        public init(
            vnfState: TnbClientTypes.VnfOperationalState? = nil,
            vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]? = nil
        )
        {
            self.vnfState = vnfState
            self.vnfcResourceInfo = vnfcResourceInfo
        }
    }

}

extension TnbClientTypes.GetSolVnfcResourceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolVnfcResourceInfoMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Details of resource associated with a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfo: Swift.Equatable {
        /// The metadata of the network function compute.
        public var metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata?

        public init(
            metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata? = nil
        )
        {
            self.metadata = metadata
        }
    }

}

extension TnbClientTypes.GetSolVnfcResourceInfoMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
        case helmChart
        case nodeGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cluster = self.cluster {
            try encodeContainer.encode(cluster, forKey: .cluster)
        }
        if let helmChart = self.helmChart {
            try encodeContainer.encode(helmChart, forKey: .helmChart)
        }
        if let nodeGroup = self.nodeGroup {
            try encodeContainer.encode(nodeGroup, forKey: .nodeGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeGroup)
        nodeGroup = nodeGroupDecoded
        let clusterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cluster)
        cluster = clusterDecoded
        let helmChartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helmChart)
        helmChart = helmChartDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfoMetadata: Swift.Equatable {
        /// Information about the cluster.
        public var cluster: Swift.String?
        /// Information about the helm chart.
        public var helmChart: Swift.String?
        /// Information about the node group.
        public var nodeGroup: Swift.String?

        public init(
            cluster: Swift.String? = nil,
            helmChart: Swift.String? = nil,
            nodeGroup: Swift.String? = nil
        )
        {
            self.cluster = cluster
            self.helmChart = helmChart
            self.nodeGroup = nodeGroup
        }
    }

}

extension InstantiateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstantiateSolNetworkInstanceInput(additionalParamsForNs: \(Swift.String(describing: additionalParamsForNs)), dryRun: \(Swift.String(describing: dryRun)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), tags: \"CONTENT_REDACTED\")"}
}

extension InstantiateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParamsForNs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParamsForNs = self.additionalParamsForNs {
            try encodeContainer.encode(additionalParamsForNs, forKey: .additionalParamsForNs)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension InstantiateSolNetworkInstanceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let dryRun = dryRun {
                let dryRunQueryItem = ClientRuntime.URLQueryItem(name: "dry_run".urlPercentEncoding(), value: Swift.String(dryRun).urlPercentEncoding())
                items.append(dryRunQueryItem)
            }
            return items
        }
    }
}

extension InstantiateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/instantiate"
    }
}

public struct InstantiateSolNetworkInstanceInput: Swift.Equatable {
    /// Provides values for the configurable properties.
    public var additionalParamsForNs: ClientRuntime.Document?
    /// A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        additionalParamsForNs: ClientRuntime.Document? = nil,
        dryRun: Swift.Bool? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.additionalParamsForNs = additionalParamsForNs
        self.dryRun = dryRun
        self.nsInstanceId = nsInstanceId
        self.tags = tags
    }
}

struct InstantiateSolNetworkInstanceInputBody: Swift.Equatable {
    let additionalParamsForNs: ClientRuntime.Document?
    let tags: [Swift.String:Swift.String]?
}

extension InstantiateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParamsForNs
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalParamsForNsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .additionalParamsForNs)
        additionalParamsForNs = additionalParamsForNsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InstantiateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstantiateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

extension InstantiateSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InstantiateSolNetworkInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
            self.tags = output.tags
        } else {
            self.nsLcmOpOccId = nil
            self.tags = nil
        }
    }
}

public struct InstantiateSolNetworkInstanceOutput: Swift.Equatable {
    /// The identifier of the network operation.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

struct InstantiateSolNetworkInstanceOutputBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension InstantiateSolNetworkInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum InstantiateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error occurred. Problem on the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes.LcmOperationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsLcmOpOccId = self.nsLcmOpOccId {
            try encodeContainer.encode(nsLcmOpOccId, forKey: .nsLcmOpOccId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
    }
}

extension TnbClientTypes {
    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public struct LcmOperationInfo: Swift.Equatable {
        /// The identifier of the network operation.
        /// This member is required.
        public var nsLcmOpOccId: Swift.String?

        public init(
            nsLcmOpOccId: Swift.String? = nil
        )
        {
            self.nsLcmOpOccId = nsLcmOpOccId
        }
    }

}

extension TnbClientTypes {
    public enum LcmOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instantiate
        case terminate
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [LcmOperationType] {
            return [
                .instantiate,
                .terminate,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instantiate: return "INSTANTIATE"
            case .terminate: return "TERMINATE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LcmOperationType(rawValue: rawValue) ?? LcmOperationType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ListSolFunctionInstanceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case instantiatedVnfInfo
        case instantiationState
        case metadata
        case nsInstanceId
        case vnfPkgId
        case vnfPkgName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instantiatedVnfInfo = self.instantiatedVnfInfo {
            try encodeContainer.encode(instantiatedVnfInfo, forKey: .instantiatedVnfInfo)
        }
        if let instantiationState = self.instantiationState {
            try encodeContainer.encode(instantiationState.rawValue, forKey: .instantiationState)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceId = self.nsInstanceId {
            try encodeContainer.encode(nsInstanceId, forKey: .nsInstanceId)
        }
        if let vnfPkgId = self.vnfPkgId {
            try encodeContainer.encode(vnfPkgId, forKey: .vnfPkgId)
        }
        if let vnfPkgName = self.vnfPkgName {
            try encodeContainer.encode(vnfPkgName, forKey: .vnfPkgName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let vnfPkgIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgId)
        vnfPkgId = vnfPkgIdDecoded
        let vnfPkgNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgName)
        vnfPkgName = vnfPkgNameDecoded
        let instantiationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfInstantiationState.self, forKey: .instantiationState)
        instantiationState = instantiationStateDecoded
        let instantiatedVnfInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolInstantiatedVnfInfo.self, forKey: .instantiatedVnfInfo)
        instantiatedVnfInfo = instantiatedVnfInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolFunctionInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Lists information about a network function instance. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceInfo: Swift.Equatable {
        /// Network function instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Network function instance ID.
        /// This member is required.
        public var id: Swift.String?
        /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
        public var instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo?
        /// Network function instance instantiation state.
        /// This member is required.
        public var instantiationState: TnbClientTypes.VnfInstantiationState?
        /// Network function instance metadata.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolFunctionInstanceMetadata?
        /// Network instance ID.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// Function package ID.
        /// This member is required.
        public var vnfPkgId: Swift.String?
        /// Function package name.
        public var vnfPkgName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo? = nil,
            instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
            metadata: TnbClientTypes.ListSolFunctionInstanceMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            vnfPkgId: Swift.String? = nil,
            vnfPkgName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.instantiatedVnfInfo = instantiatedVnfInfo
            self.instantiationState = instantiationState
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.vnfPkgId = vnfPkgId
            self.vnfPkgName = vnfPkgName
        }
    }

}

extension TnbClientTypes.ListSolFunctionInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Lists network function instance metadata. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceMetadata: Swift.Equatable {
        /// When the network function instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// When the network function instance was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolFunctionInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolFunctionInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnflcm/v1/vnf_instances"
    }
}

public struct ListSolFunctionInstancesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolFunctionInstancesInputBody: Swift.Equatable {
}

extension ListSolFunctionInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSolFunctionInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolFunctionInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionInstances = output.functionInstances
            self.nextToken = output.nextToken
        } else {
            self.functionInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolFunctionInstancesOutput: Swift.Equatable {
    /// Network function instances.
    public var functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionInstances = functionInstances
        self.nextToken = nextToken
    }
}

struct ListSolFunctionInstancesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]?
}

extension ListSolFunctionInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionInstances
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let functionInstancesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolFunctionInstanceInfo?].self, forKey: .functionInstances)
        var functionInstancesDecoded0:[TnbClientTypes.ListSolFunctionInstanceInfo]? = nil
        if let functionInstancesContainer = functionInstancesContainer {
            functionInstancesDecoded0 = [TnbClientTypes.ListSolFunctionInstanceInfo]()
            for structure0 in functionInstancesContainer {
                if let structure0 = structure0 {
                    functionInstancesDecoded0?.append(structure0)
                }
            }
        }
        functionInstances = functionInstancesDecoded0
    }
}

enum ListSolFunctionInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.ListSolFunctionPackageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case onboardingState
        case operationalState
        case usageState
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let onboardingState = self.onboardingState {
            try encodeContainer.encode(onboardingState.rawValue, forKey: .onboardingState)
        }
        if let operationalState = self.operationalState {
            try encodeContainer.encode(operationalState.rawValue, forKey: .operationalState)
        }
        if let usageState = self.usageState {
            try encodeContainer.encode(usageState.rawValue, forKey: .usageState)
        }
        if let vnfProductName = self.vnfProductName {
            try encodeContainer.encode(vnfProductName, forKey: .vnfProductName)
        }
        if let vnfProvider = self.vnfProvider {
            try encodeContainer.encode(vnfProvider, forKey: .vnfProvider)
        }
        if let vnfdId = self.vnfdId {
            try encodeContainer.encode(vnfdId, forKey: .vnfdId)
        }
        if let vnfdVersion = self.vnfdVersion {
            try encodeContainer.encode(vnfdVersion, forKey: .vnfdVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolFunctionPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Information about a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageInfo: Swift.Equatable {
        /// Function package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the function package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the function package.
        public var metadata: TnbClientTypes.ListSolFunctionPackageMetadata?
        /// Onboarding state of the function package.
        /// This member is required.
        public var onboardingState: TnbClientTypes.OnboardingState?
        /// Operational state of the function package.
        /// This member is required.
        public var operationalState: TnbClientTypes.OperationalState?
        /// Usage state of the function package.
        /// This member is required.
        public var usageState: TnbClientTypes.UsageState?
        /// The product name for the network function.
        public var vnfProductName: Swift.String?
        /// Provider of the function package and the function package descriptor.
        public var vnfProvider: Swift.String?
        /// Identifies the function package and the function package descriptor.
        public var vnfdId: Swift.String?
        /// Identifies the version of the function package descriptor.
        public var vnfdVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolFunctionPackageMetadata? = nil,
            onboardingState: TnbClientTypes.OnboardingState? = nil,
            operationalState: TnbClientTypes.OperationalState? = nil,
            usageState: TnbClientTypes.UsageState? = nil,
            vnfProductName: Swift.String? = nil,
            vnfProvider: Swift.String? = nil,
            vnfdId: Swift.String? = nil,
            vnfdVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.usageState = usageState
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
        }
    }

}

extension TnbClientTypes.ListSolFunctionPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Details for the function package metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolFunctionPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolFunctionPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

public struct ListSolFunctionPackagesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolFunctionPackagesInputBody: Swift.Equatable {
}

extension ListSolFunctionPackagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSolFunctionPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolFunctionPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionPackages = output.functionPackages
            self.nextToken = output.nextToken
        } else {
            self.functionPackages = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolFunctionPackagesOutput: Swift.Equatable {
    /// Function packages. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    /// This member is required.
    public var functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionPackages = functionPackages
        self.nextToken = nextToken
    }
}

struct ListSolFunctionPackagesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]?
}

extension ListSolFunctionPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionPackages
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let functionPackagesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolFunctionPackageInfo?].self, forKey: .functionPackages)
        var functionPackagesDecoded0:[TnbClientTypes.ListSolFunctionPackageInfo]? = nil
        if let functionPackagesContainer = functionPackagesContainer {
            functionPackagesDecoded0 = [TnbClientTypes.ListSolFunctionPackageInfo]()
            for structure0 in functionPackagesContainer {
                if let structure0 = structure0 {
                    functionPackagesDecoded0?.append(structure0)
                }
            }
        }
        functionPackages = functionPackagesDecoded0
    }
}

enum ListSolFunctionPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.ListSolNetworkInstanceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsInstanceDescription
        case nsInstanceName
        case nsState
        case nsdId
        case nsdInfoId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceDescription = self.nsInstanceDescription {
            try encodeContainer.encode(nsInstanceDescription, forKey: .nsInstanceDescription)
        }
        if let nsInstanceName = self.nsInstanceName {
            try encodeContainer.encode(nsInstanceName, forKey: .nsInstanceName)
        }
        if let nsState = self.nsState {
            try encodeContainer.encode(nsState.rawValue, forKey: .nsState)
        }
        if let nsdId = self.nsdId {
            try encodeContainer.encode(nsdId, forKey: .nsdId)
        }
        if let nsdInfoId = self.nsdInfoId {
            try encodeContainer.encode(nsdInfoId, forKey: .nsdInfoId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let nsInstanceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceDescription)
        nsInstanceDescription = nsInstanceDescriptionDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsState.self, forKey: .nsState)
        nsState = nsStateDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Info about the specific network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceInfo: Swift.Equatable {
        /// Network instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the network instance.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network instance.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkInstanceMetadata?
        /// Human-readable description of the network instance.
        /// This member is required.
        public var nsInstanceDescription: Swift.String?
        /// Human-readable name of the network instance.
        /// This member is required.
        public var nsInstanceName: Swift.String?
        /// The state of the network instance.
        /// This member is required.
        public var nsState: TnbClientTypes.NsState?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdId: Swift.String?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkInstanceMetadata? = nil,
            nsInstanceDescription: Swift.String? = nil,
            nsInstanceName: Swift.String? = nil,
            nsState: TnbClientTypes.NsState? = nil,
            nsdId: Swift.String? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsInstanceDescription = nsInstanceDescription
            self.nsInstanceName = nsInstanceName
            self.nsState = nsState
            self.nsdId = nsdId
            self.nsdInfoId = nsdInfoId
        }
    }

}

extension TnbClientTypes.ListSolNetworkInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata details for a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

public struct ListSolNetworkInstancesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkInstancesInputBody: Swift.Equatable {
}

extension ListSolNetworkInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSolNetworkInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolNetworkInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkInstances = output.networkInstances
            self.nextToken = output.nextToken
        } else {
            self.networkInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkInstancesOutput: Swift.Equatable {
    /// Lists network instances.
    public var networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInstances = networkInstances
        self.nextToken = nextToken
    }
}

struct ListSolNetworkInstancesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]?
}

extension ListSolNetworkInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInstances
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkInstancesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkInstanceInfo?].self, forKey: .networkInstances)
        var networkInstancesDecoded0:[TnbClientTypes.ListSolNetworkInstanceInfo]? = nil
        if let networkInstancesContainer = networkInstancesContainer {
            networkInstancesDecoded0 = [TnbClientTypes.ListSolNetworkInstanceInfo]()
            for structure0 in networkInstancesContainer {
                if let structure0 = structure0 {
                    networkInstancesDecoded0?.append(structure0)
                }
            }
        }
        networkInstances = networkInstancesDecoded0
    }
}

enum ListSolNetworkInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.ListSolNetworkOperationsInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case error
        case id
        case lcmOperationType
        case metadata
        case nsInstanceId
        case operationState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lcmOperationType = self.lcmOperationType {
            try encodeContainer.encode(lcmOperationType.rawValue, forKey: .lcmOperationType)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceId = self.nsInstanceId {
            try encodeContainer.encode(nsInstanceId, forKey: .nsInstanceId)
        }
        if let operationState = self.operationState {
            try encodeContainer.encode(operationState.rawValue, forKey: .operationState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsLcmOperationState.self, forKey: .operationState)
        operationState = operationStateDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let lcmOperationTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationType.self, forKey: .lcmOperationType)
        lcmOperationType = lcmOperationTypeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ProblemDetails.self, forKey: .error)
        error = errorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkOperationsMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Information parameters for a network operation.
    public struct ListSolNetworkOperationsInfo: Swift.Equatable {
        /// Network operation ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Error related to this specific network operation.
        public var error: TnbClientTypes.ProblemDetails?
        /// ID of this network operation.
        /// This member is required.
        public var id: Swift.String?
        /// Type of lifecycle management network operation.
        /// This member is required.
        public var lcmOperationType: TnbClientTypes.LcmOperationType?
        /// Metadata related to this network operation.
        public var metadata: TnbClientTypes.ListSolNetworkOperationsMetadata?
        /// ID of the network instance related to this operation.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// The state of the network operation.
        /// This member is required.
        public var operationState: TnbClientTypes.NsLcmOperationState?

        public init(
            arn: Swift.String? = nil,
            error: TnbClientTypes.ProblemDetails? = nil,
            id: Swift.String? = nil,
            lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
            metadata: TnbClientTypes.ListSolNetworkOperationsMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            operationState: TnbClientTypes.NsLcmOperationState? = nil
        )
        {
            self.arn = arn
            self.error = error
            self.id = id
            self.lcmOperationType = lcmOperationType
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.operationState = operationState
        }
    }

}

extension ListSolNetworkOperationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_lcm_op_occs"
    }
}

public struct ListSolNetworkOperationsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkOperationsInputBody: Swift.Equatable {
}

extension ListSolNetworkOperationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.ListSolNetworkOperationsMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct ListSolNetworkOperationsMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolNetworkOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkOperations = output.networkOperations
            self.nextToken = output.nextToken
        } else {
            self.networkOperations = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkOperationsOutput: Swift.Equatable {
    /// Lists network operation occurrences. Lifecycle management operations are deploy, update, or delete operations.
    public var networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkOperations = networkOperations
        self.nextToken = nextToken
    }
}

struct ListSolNetworkOperationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]?
}

extension ListSolNetworkOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkOperations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkOperationsContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkOperationsInfo?].self, forKey: .networkOperations)
        var networkOperationsDecoded0:[TnbClientTypes.ListSolNetworkOperationsInfo]? = nil
        if let networkOperationsContainer = networkOperationsContainer {
            networkOperationsDecoded0 = [TnbClientTypes.ListSolNetworkOperationsInfo]()
            for structure0 in networkOperationsContainer {
                if let structure0 = structure0 {
                    networkOperationsDecoded0?.append(structure0)
                }
            }
        }
        networkOperations = networkOperationsDecoded0
    }
}

enum ListSolNetworkOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.ListSolNetworkPackageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdDesigner
        case nsdId
        case nsdInvariantId
        case nsdName
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case nsdVersion
        case vnfPkgIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsdDesigner = self.nsdDesigner {
            try encodeContainer.encode(nsdDesigner, forKey: .nsdDesigner)
        }
        if let nsdId = self.nsdId {
            try encodeContainer.encode(nsdId, forKey: .nsdId)
        }
        if let nsdInvariantId = self.nsdInvariantId {
            try encodeContainer.encode(nsdInvariantId, forKey: .nsdInvariantId)
        }
        if let nsdName = self.nsdName {
            try encodeContainer.encode(nsdName, forKey: .nsdName)
        }
        if let nsdOnboardingState = self.nsdOnboardingState {
            try encodeContainer.encode(nsdOnboardingState.rawValue, forKey: .nsdOnboardingState)
        }
        if let nsdOperationalState = self.nsdOperationalState {
            try encodeContainer.encode(nsdOperationalState.rawValue, forKey: .nsdOperationalState)
        }
        if let nsdUsageState = self.nsdUsageState {
            try encodeContainer.encode(nsdUsageState.rawValue, forKey: .nsdUsageState)
        }
        if let nsdVersion = self.nsdVersion {
            try encodeContainer.encode(nsdVersion, forKey: .nsdVersion)
        }
        if let vnfPkgIds = vnfPkgIds {
            var vnfPkgIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vnfPkgIds)
            for vnfpkgid0 in vnfPkgIds {
                try vnfPkgIdsContainer.encode(vnfpkgid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let nsdDesignerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdDesigner)
        nsdDesigner = nsdDesignerDecoded
        let nsdInvariantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInvariantId)
        nsdInvariantId = nsdInvariantIdDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Details of a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageInfo: Swift.Equatable {
        /// Network package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the individual network package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network package.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkPackageMetadata?
        /// Designer of the onboarded network service descriptor in the network package.
        public var nsdDesigner: Swift.String?
        /// ID of the network service descriptor on which the network package is based.
        public var nsdId: Swift.String?
        /// Identifies a network service descriptor in a version independent manner.
        public var nsdInvariantId: Swift.String?
        /// Name of the onboarded network service descriptor in the network package.
        public var nsdName: Swift.String?
        /// Onboarding state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
        /// Operational state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
        /// Usage state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdUsageState: TnbClientTypes.NsdUsageState?
        /// Version of the onboarded network service descriptor in the network package.
        public var nsdVersion: Swift.String?
        /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
        public var vnfPkgIds: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkPackageMetadata? = nil,
            nsdDesigner: Swift.String? = nil,
            nsdId: Swift.String? = nil,
            nsdInvariantId: Swift.String? = nil,
            nsdName: Swift.String? = nil,
            nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
            nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
            nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
            nsdVersion: Swift.String? = nil,
            vnfPkgIds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdDesigner = nsdDesigner
            self.nsdId = nsdId
            self.nsdInvariantId = nsdInvariantId
            self.nsdName = nsdName
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }
    }

}

extension TnbClientTypes.ListSolNetworkPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

public struct ListSolNetworkPackagesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkPackagesInputBody: Swift.Equatable {
}

extension ListSolNetworkPackagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSolNetworkPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolNetworkPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkPackages = output.networkPackages
            self.nextToken = output.nextToken
        } else {
            self.networkPackages = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkPackagesOutput: Swift.Equatable {
    /// Network packages. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkPackages = networkPackages
        self.nextToken = nextToken
    }
}

struct ListSolNetworkPackagesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]?
}

extension ListSolNetworkPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkPackages
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkPackagesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkPackageInfo?].self, forKey: .networkPackages)
        var networkPackagesDecoded0:[TnbClientTypes.ListSolNetworkPackageInfo]? = nil
        if let networkPackagesContainer = networkPackagesContainer {
            networkPackagesDecoded0 = [TnbClientTypes.ListSolNetworkPackageInfo]()
            for structure0 in networkPackagesContainer {
                if let structure0 = structure0 {
                    networkPackagesDecoded0?.append(structure0)
                }
            }
        }
        networkPackages = networkPackagesDecoded0
    }
}

enum ListSolNetworkPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.NetworkArtifactMeta: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for toscaoverride0 in overrides {
                try overridesContainer.encode(toscaoverride0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ToscaOverride?].self, forKey: .overrides)
        var overridesDecoded0:[TnbClientTypes.ToscaOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [TnbClientTypes.ToscaOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension TnbClientTypes {
    /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct NetworkArtifactMeta: Swift.Equatable {
        /// Lists network package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init(
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }

}

extension TnbClientTypes {
    public enum NsLcmOperationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [NsLcmOperationState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsLcmOperationState(rawValue: rawValue) ?? NsLcmOperationState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case impaired
        case instantiated
        case instantiateInProgress
        case notInstantiated
        case stopped
        case terminateInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [NsState] {
            return [
                .deleted,
                .impaired,
                .instantiated,
                .instantiateInProgress,
                .notInstantiated,
                .stopped,
                .terminateInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .impaired: return "IMPAIRED"
            case .instantiated: return "INSTANTIATED"
            case .instantiateInProgress: return "INSTANTIATE_IN_PROGRESS"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case .stopped: return "STOPPED"
            case .terminateInProgress: return "TERMINATE_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsState(rawValue: rawValue) ?? NsState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdOnboardingState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOnboardingState] {
            return [
                .created,
                .error,
                .onboarded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdOnboardingState(rawValue: rawValue) ?? NsdOnboardingState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdOperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOperationalState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdOperationalState(rawValue: rawValue) ?? NsdOperationalState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdUsageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdUsageState] {
            return [
                .inUse,
                .notInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdUsageState(rawValue: rawValue) ?? NsdUsageState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum OnboardingState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [OnboardingState] {
            return [
                .created,
                .error,
                .onboarded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OnboardingState(rawValue: rawValue) ?? OnboardingState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum OperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationalState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationalState(rawValue: rawValue) ?? OperationalState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum PackageContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationZip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageContentType] {
            return [
                .applicationZip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationZip: return "application/zip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageContentType(rawValue: rawValue) ?? PackageContentType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ProblemDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
    }
}

extension TnbClientTypes {
    /// Details related to problems with AWS TNB resources.
    public struct ProblemDetails: Swift.Equatable {
        /// A human-readable explanation specific to this occurrence of the problem.
        /// This member is required.
        public var detail: Swift.String?
        /// A human-readable title of the problem type.
        public var title: Swift.String?

        public init(
            detail: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.detail = detail
            self.title = title
        }
    }

}

public struct PutSolFunctionPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSolFunctionPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSolFunctionPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutSolFunctionPackageContentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let fileData = file
            let fileBody = ClientRuntime.HttpBody.data(fileData)
            input.builder.withBody(fileBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSolFunctionPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSolFunctionPackageContentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutSolFunctionPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension PutSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension PutSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

public struct PutSolFunctionPackageContentInput: Swift.Equatable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

struct PutSolFunctionPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension PutSolFunctionPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.PutSolFunctionPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

extension TnbClientTypes {
    /// Update metadata in a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct PutSolFunctionPackageContentMetadata: Swift.Equatable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }

}

extension PutSolFunctionPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSolFunctionPackageContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.metadata = output.metadata
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.id = nil
            self.metadata = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct PutSolFunctionPackageContentOutput: Swift.Equatable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata?
    /// Function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init(
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct PutSolFunctionPackageContentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let vnfdId: Swift.String?
    let vnfProductName: Swift.String?
    let vnfProvider: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata?
}

extension PutSolFunctionPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case metadata
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.PutSolFunctionPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

enum PutSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct PutSolNetworkPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSolNetworkPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSolNetworkPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutSolNetworkPackageContentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let fileData = file
            let fileBody = ClientRuntime.HttpBody.data(fileData)
            input.builder.withBody(fileBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSolNetworkPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSolNetworkPackageContentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutSolNetworkPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension PutSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension PutSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

public struct PutSolNetworkPackageContentInput: Swift.Equatable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

struct PutSolNetworkPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension PutSolNetworkPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.PutSolNetworkPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

extension TnbClientTypes {
    /// Update metadata in a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct PutSolNetworkPackageContentMetadata: Swift.Equatable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }

}

extension PutSolNetworkPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSolNetworkPackageContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdVersion = output.nsdVersion
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdVersion = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct PutSolNetworkPackageContentOutput: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

struct PutSolNetworkPackageContentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata?
}

extension PutSolNetworkPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdVersion
        case vnfPkgIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.PutSolNetworkPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

enum PutSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Service quotas have been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case inProgress
        case scheduled
        case skipped
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .error,
                .inProgress,
                .scheduled,
                .skipped,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case .skipped: return "SKIPPED"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension TerminateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSolNetworkInstanceInput(nsInstanceId: \(Swift.String(describing: nsInstanceId)), tags: \"CONTENT_REDACTED\")"}
}

extension TerminateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TerminateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/terminate"
    }
}

public struct TerminateSolNetworkInstanceInput: Swift.Equatable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
        self.tags = tags
    }
}

struct TerminateSolNetworkInstanceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TerminateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TerminateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

extension TerminateSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateSolNetworkInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
            self.tags = output.tags
        } else {
            self.nsLcmOpOccId = nil
            self.tags = nil
        }
    }
}

public struct TerminateSolNetworkInstanceOutput: Swift.Equatable {
    /// The identifier of the network operation.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

struct TerminateSolNetworkInstanceOutputBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TerminateSolNetworkInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum TerminateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception caused by throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes.ToscaOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension TnbClientTypes {
    /// Overrides of the TOSCA node.
    public struct ToscaOverride: Swift.Equatable {
        /// Default value for the override.
        public var defaultValue: Swift.String?
        /// Name of the TOSCA override.
        public var name: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.name = name
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSolFunctionPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationalState = self.operationalState {
            try encodeContainer.encode(operationalState.rawValue, forKey: .operationalState)
        }
    }
}

extension UpdateSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct UpdateSolFunctionPackageInput: Swift.Equatable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        operationalState: TnbClientTypes.OperationalState? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.operationalState = operationalState
        self.vnfPkgId = vnfPkgId
    }
}

struct UpdateSolFunctionPackageInputBody: Swift.Equatable {
    let operationalState: TnbClientTypes.OperationalState?
}

extension UpdateSolFunctionPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
    }
}

extension UpdateSolFunctionPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSolFunctionPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationalState = output.operationalState
        } else {
            self.operationalState = nil
        }
    }
}

public struct UpdateSolFunctionPackageOutput: Swift.Equatable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?

    public init(
        operationalState: TnbClientTypes.OperationalState? = nil
    )
    {
        self.operationalState = operationalState
    }
}

struct UpdateSolFunctionPackageOutputBody: Swift.Equatable {
    let operationalState: TnbClientTypes.OperationalState?
}

extension UpdateSolFunctionPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
    }
}

enum UpdateSolFunctionPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSolNetworkInstanceInput(modifyVnfInfoData: \(Swift.String(describing: modifyVnfInfoData)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), updateType: \(Swift.String(describing: updateType)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifyVnfInfoData
        case tags
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modifyVnfInfoData = self.modifyVnfInfoData {
            try encodeContainer.encode(modifyVnfInfoData, forKey: .modifyVnfInfoData)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension UpdateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/update"
    }
}

public struct UpdateSolNetworkInstanceInput: Swift.Equatable {
    /// Identifies the network function information parameters and/or the configurable properties of the network function to be modified.
    public var modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// The type of update.
    /// This member is required.
    public var updateType: TnbClientTypes.UpdateSolNetworkType?

    public init(
        modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateType: TnbClientTypes.UpdateSolNetworkType? = nil
    )
    {
        self.modifyVnfInfoData = modifyVnfInfoData
        self.nsInstanceId = nsInstanceId
        self.tags = tags
        self.updateType = updateType
    }
}

struct UpdateSolNetworkInstanceInputBody: Swift.Equatable {
    let updateType: TnbClientTypes.UpdateSolNetworkType?
    let modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifyVnfInfoData
        case tags
        case updateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UpdateSolNetworkType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let modifyVnfInfoDataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UpdateSolNetworkModify.self, forKey: .modifyVnfInfoData)
        modifyVnfInfoData = modifyVnfInfoDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSolNetworkInstanceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSolNetworkInstanceOutput(nsLcmOpOccId: \(Swift.String(describing: nsLcmOpOccId)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateSolNetworkInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSolNetworkInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
            self.tags = output.tags
        } else {
            self.nsLcmOpOccId = nil
            self.tags = nil
        }
    }
}

public struct UpdateSolNetworkInstanceOutput: Swift.Equatable {
    /// The identifier of the network operation.
    public var nsLcmOpOccId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are transferred to the network operation that is created. Use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nsLcmOpOccId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
        self.tags = tags
    }
}

struct UpdateSolNetworkInstanceOutputBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateSolNetworkInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes.UpdateSolNetworkModify: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfConfigurableProperties
        case vnfInstanceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfConfigurableProperties = self.vnfConfigurableProperties {
            try encodeContainer.encode(vnfConfigurableProperties, forKey: .vnfConfigurableProperties)
        }
        if let vnfInstanceId = self.vnfInstanceId {
            try encodeContainer.encode(vnfInstanceId, forKey: .vnfInstanceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfInstanceId)
        vnfInstanceId = vnfInstanceIdDecoded
        let vnfConfigurablePropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .vnfConfigurableProperties)
        vnfConfigurableProperties = vnfConfigurablePropertiesDecoded
    }
}

extension TnbClientTypes {
    /// Information parameters and/or the configurable properties for a network function. A network function instance is a function in a function package .
    public struct UpdateSolNetworkModify: Swift.Equatable {
        /// Provides values for the configurable properties declared in the function package descriptor.
        /// This member is required.
        public var vnfConfigurableProperties: ClientRuntime.Document?
        /// ID of the network function instance. A network function instance is a function in a function package .
        /// This member is required.
        public var vnfInstanceId: Swift.String?

        public init(
            vnfConfigurableProperties: ClientRuntime.Document? = nil,
            vnfInstanceId: Swift.String? = nil
        )
        {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }
    }

}

extension UpdateSolNetworkPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsdOperationalState = self.nsdOperationalState {
            try encodeContainer.encode(nsdOperationalState.rawValue, forKey: .nsdOperationalState)
        }
    }
}

extension UpdateSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct UpdateSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init(
        nsdInfoId: Swift.String? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
        self.nsdOperationalState = nsdOperationalState
    }
}

struct UpdateSolNetworkPackageInputBody: Swift.Equatable {
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
}

extension UpdateSolNetworkPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
    }
}

extension UpdateSolNetworkPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSolNetworkPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.nsdOperationalState = output.nsdOperationalState
        } else {
            self.nsdOperationalState = nil
        }
    }
}

public struct UpdateSolNetworkPackageOutput: Swift.Equatable {
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init(
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdOperationalState = nsdOperationalState
    }
}

struct UpdateSolNetworkPackageOutputBody: Swift.Equatable {
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
}

extension UpdateSolNetworkPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
    }
}

enum UpdateSolNetworkPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TnbClientTypes {
    public enum UpdateSolNetworkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modifyVnfInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateSolNetworkType] {
            return [
                .modifyVnfInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modifyVnfInformation: return "MODIFY_VNF_INFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateSolNetworkType(rawValue: rawValue) ?? UpdateSolNetworkType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum UsageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageState] {
            return [
                .inUse,
                .notInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageState(rawValue: rawValue) ?? UsageState.sdkUnknown(rawValue)
        }
    }
}

public struct ValidateSolFunctionPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateSolFunctionPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateSolFunctionPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ValidateSolFunctionPackageContentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let fileData = file
            let fileBody = ClientRuntime.HttpBody.data(fileData)
            input.builder.withBody(fileBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateSolFunctionPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateSolFunctionPackageContentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ValidateSolFunctionPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension ValidateSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension ValidateSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content/validate"
    }
}

public struct ValidateSolFunctionPackageContentInput: Swift.Equatable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

struct ValidateSolFunctionPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension ValidateSolFunctionPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.ValidateSolFunctionPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

extension TnbClientTypes {
    /// Validates function package content metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ValidateSolFunctionPackageContentMetadata: Swift.Equatable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init(
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }

}

extension ValidateSolFunctionPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateSolFunctionPackageContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.metadata = output.metadata
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.id = nil
            self.metadata = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct ValidateSolFunctionPackageContentOutput: Swift.Equatable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata?
    /// Network function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init(
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct ValidateSolFunctionPackageContentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let vnfdId: Swift.String?
    let vnfProductName: Swift.String?
    let vnfProvider: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata?
}

extension ValidateSolFunctionPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case metadata
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ValidateSolFunctionPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

enum ValidateSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct ValidateSolNetworkPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateSolNetworkPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateSolNetworkPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ValidateSolNetworkPackageContentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let fileData = file
            let fileBody = ClientRuntime.HttpBody.data(fileData)
            input.builder.withBody(fileBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateSolNetworkPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateSolNetworkPackageContentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ValidateSolNetworkPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension ValidateSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension ValidateSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content/validate"
    }
}

public struct ValidateSolNetworkPackageContentInput: Swift.Equatable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Network service descriptor file.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init(
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

struct ValidateSolNetworkPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension ValidateSolNetworkPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.ValidateSolNetworkPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

extension TnbClientTypes {
    /// Validates network package content metadata. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ValidateSolNetworkPackageContentMetadata: Swift.Equatable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init(
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }

}

extension ValidateSolNetworkPackageContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateSolNetworkPackageContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdVersion = output.nsdVersion
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdVersion = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct ValidateSolNetworkPackageContentOutput: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

struct ValidateSolNetworkPackageContentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata?
}

extension ValidateSolNetworkPackageContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdVersion
        case vnfPkgIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ValidateSolNetworkPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

enum ValidateSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unable to process the request because the client provided input failed to satisfy request constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes {
    public enum VnfInstantiationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instantiated
        case notInstantiated
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfInstantiationState] {
            return [
                .instantiated,
                .notInstantiated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instantiated: return "INSTANTIATED"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VnfInstantiationState(rawValue: rawValue) ?? VnfInstantiationState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum VnfOperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfOperationalState] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VnfOperationalState(rawValue: rawValue) ?? VnfOperationalState.sdkUnknown(rawValue)
        }
    }
}
