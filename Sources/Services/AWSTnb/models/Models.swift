// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Insufficient permissions to make request.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelSolNetworkOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsLcmOpOccId = nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())/cancel"
    }
}

public struct CancelSolNetworkOperationInput: Swift.Equatable {
    /// The ID of a network operation occurrence.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init (
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct CancelSolNetworkOperationInputBody: Swift.Equatable {
}

extension CancelSolNetworkOperationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelSolNetworkOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSolNetworkOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelSolNetworkOperationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSolNetworkOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSolNetworkOperationOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateSolFunctionPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolFunctionPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

public struct CreateSolFunctionPackageInput: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateSolFunctionPackageInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolFunctionPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolFunctionPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolFunctionPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSolFunctionPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolFunctionPackageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolFunctionPackageOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolFunctionPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSolFunctionPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.onboardingState = output.onboardingState
            self.operationalState = output.operationalState
            self.tags = output.tags
            self.usageState = output.usageState
        } else {
            self.arn = nil
            self.id = nil
            self.onboardingState = nil
            self.operationalState = nil
            self.tags = nil
            self.usageState = nil
        }
    }
}

public struct CreateSolFunctionPackageOutputResponse: Swift.Equatable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the function package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the function package.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Usage state of the function package.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
    }
}

struct CreateSolFunctionPackageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let onboardingState: TnbClientTypes.OnboardingState?
    let operationalState: TnbClientTypes.OperationalState?
    let usageState: TnbClientTypes.UsageState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolFunctionPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case onboardingState
        case operationalState
        case tags
        case usageState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceInput(nsDescription: \(Swift.String(describing: nsDescription)), nsName: \(Swift.String(describing: nsName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsDescription
        case nsName
        case nsdInfoId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsDescription = self.nsDescription {
            try encodeContainer.encode(nsDescription, forKey: .nsDescription)
        }
        if let nsName = self.nsName {
            try encodeContainer.encode(nsName, forKey: .nsName)
        }
        if let nsdInfoId = self.nsdInfoId {
            try encodeContainer.encode(nsdInfoId, forKey: .nsdInfoId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

public struct CreateSolNetworkInstanceInput: Swift.Equatable {
    /// Network instance description.
    public var nsDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsName: Swift.String?
    /// ID for network service descriptor.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nsDescription: Swift.String? = nil,
        nsName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nsDescription = nsDescription
        self.nsName = nsName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct CreateSolNetworkInstanceInputBody: Swift.Equatable {
    let nsdInfoId: Swift.String?
    let nsName: Swift.String?
    let nsDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsDescription
        case nsName
        case nsdInfoId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsName)
        nsName = nsNameDecoded
        let nsDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsDescription)
        nsDescription = nsDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolNetworkInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkInstanceOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSolNetworkInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.nsInstanceName = output.nsInstanceName
            self.nsdInfoId = output.nsdInfoId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.nsInstanceName = nil
            self.nsdInfoId = nil
            self.tags = nil
        }
    }
}

public struct CreateSolNetworkInstanceOutputResponse: Swift.Equatable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsInstanceName = nsInstanceName
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct CreateSolNetworkInstanceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdInfoId: Swift.String?
    let nsInstanceName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case nsInstanceName
        case nsdInfoId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkPackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageInput(tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

public struct CreateSolNetworkPackageInput: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateSolNetworkPackageInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolNetworkPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolNetworkPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSolNetworkPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolNetworkPackageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolNetworkPackageOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSolNetworkPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSolNetworkPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.nsdOnboardingState = output.nsdOnboardingState
            self.nsdOperationalState = output.nsdOperationalState
            self.nsdUsageState = output.nsdUsageState
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.nsdOnboardingState = nil
            self.nsdOperationalState = nil
            self.nsdUsageState = nil
            self.tags = nil
        }
    }
}

public struct CreateSolNetworkPackageOutputResponse: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// ID of the network package.
    /// This member is required.
    public var id: Swift.String?
    /// Onboarding state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Usage state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.tags = tags
    }
}

struct CreateSolNetworkPackageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
    let nsdUsageState: TnbClientTypes.NsdUsageState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSolNetworkPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct DeleteSolFunctionPackageInput: Swift.Equatable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

struct DeleteSolFunctionPackageInputBody: Swift.Equatable {
}

extension DeleteSolFunctionPackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolFunctionPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolFunctionPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSolFunctionPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolFunctionPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolFunctionPackageOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

public struct DeleteSolNetworkInstanceInput: Swift.Equatable {
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init (
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

struct DeleteSolNetworkInstanceInputBody: Swift.Equatable {
}

extension DeleteSolNetworkInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolNetworkInstanceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct DeleteSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct DeleteSolNetworkPackageInputBody: Swift.Equatable {
}

extension DeleteSolNetworkPackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSolNetworkPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolNetworkPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSolNetworkPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolNetworkPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolNetworkPackageOutputResponse: Swift.Equatable {

    public init () { }
}

extension TnbClientTypes {
    public enum DescriptorContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textPlain
        case sdkUnknown(Swift.String)

        public static var allCases: [DescriptorContentType] {
            return [
                .textPlain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textPlain: return "text/plain"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescriptorContentType(rawValue: rawValue) ?? DescriptorContentType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case details
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = self.cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension TnbClientTypes {
    /// Provides error information.
    public struct ErrorInfo: Swift.Equatable {
        /// Error cause.
        public var cause: Swift.String?
        /// Error details.
        public var details: Swift.String?

        public init (
            cause: Swift.String? = nil,
            details: Swift.String? = nil
        )
        {
            self.cause = cause
            self.details = details
        }
    }

}

extension TnbClientTypes.FunctionArtifactMeta: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for toscaoverride0 in overrides {
                try overridesContainer.encode(toscaoverride0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ToscaOverride?].self, forKey: .overrides)
        var overridesDecoded0:[TnbClientTypes.ToscaOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [TnbClientTypes.ToscaOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension TnbClientTypes {
    /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct FunctionArtifactMeta: Swift.Equatable {
        /// Lists of function package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init (
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }

}

extension GetSolFunctionInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfInstanceId = vnfInstanceId else {
            return nil
        }
        return "/sol/vnflcm/v1/vnf_instances/\(vnfInstanceId.urlPercentEncoding())"
    }
}

public struct GetSolFunctionInstanceInput: Swift.Equatable {
    /// ID of the network function.
    /// This member is required.
    public var vnfInstanceId: Swift.String?

    public init (
        vnfInstanceId: Swift.String? = nil
    )
    {
        self.vnfInstanceId = vnfInstanceId
    }
}

struct GetSolFunctionInstanceInputBody: Swift.Equatable {
}

extension GetSolFunctionInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolFunctionInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network function instance. A network function instance is a function in a function package .
    public struct GetSolFunctionInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolFunctionInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolFunctionInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolFunctionInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolFunctionInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionInstanceOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), instantiatedVnfInfo: \(Swift.String(describing: instantiatedVnfInfo)), instantiationState: \(Swift.String(describing: instantiationState)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), vnfPkgId: \(Swift.String(describing: vnfPkgId)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolFunctionInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolFunctionInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.instantiatedVnfInfo = output.instantiatedVnfInfo
            self.instantiationState = output.instantiationState
            self.metadata = output.metadata
            self.nsInstanceId = output.nsInstanceId
            self.tags = output.tags
            self.vnfPkgId = output.vnfPkgId
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.arn = nil
            self.id = nil
            self.instantiatedVnfInfo = nil
            self.instantiationState = nil
            self.metadata = nil
            self.nsInstanceId = nil
            self.tags = nil
            self.vnfPkgId = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct GetSolFunctionInstanceOutputResponse: Swift.Equatable {
    /// Network function instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network function instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the network function. A network function instance is a function in a function package .
    public var instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo?
    /// Network function instantiation state.
    /// This member is required.
    public var instantiationState: TnbClientTypes.VnfInstantiationState?
    /// The metadata of a network function instance. A network function instance is a function in a function package .
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolFunctionInstanceMetadata?
    /// Network instance ID.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo? = nil,
        instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
        metadata: TnbClientTypes.GetSolFunctionInstanceMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vnfPkgId: Swift.String? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.instantiatedVnfInfo = instantiatedVnfInfo
        self.instantiationState = instantiationState
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.tags = tags
        self.vnfPkgId = vnfPkgId
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct GetSolFunctionInstanceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsInstanceId: Swift.String?
    let vnfPkgId: Swift.String?
    let vnfdId: Swift.String?
    let vnfProvider: Swift.String?
    let vnfProductName: Swift.String?
    let vnfdVersion: Swift.String?
    let instantiationState: TnbClientTypes.VnfInstantiationState?
    let instantiatedVnfInfo: TnbClientTypes.GetSolVnfInfo?
    let metadata: TnbClientTypes.GetSolFunctionInstanceMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolFunctionInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case instantiatedVnfInfo
        case instantiationState
        case metadata
        case nsInstanceId
        case tags
        case vnfPkgId
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let vnfPkgIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgId)
        vnfPkgId = vnfPkgIdDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let instantiationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfInstantiationState.self, forKey: .instantiationState)
        instantiationState = instantiationStateDecoded
        let instantiatedVnfInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolVnfInfo.self, forKey: .instantiatedVnfInfo)
        instantiatedVnfInfo = instantiatedVnfInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolFunctionInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

public struct GetSolFunctionPackageContentInput: Swift.Equatable {
    /// The format of the package that you want to download from the function packages.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        accept: TnbClientTypes.PackageContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageContentInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolFunctionPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolFunctionPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolFunctionPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.packageContent = data
        } else {
            self.packageContent = nil
        }
    }
}

public struct GetSolFunctionPackageContentOutputResponse: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Contents of the function package.
    public var packageContent: ClientRuntime.Data?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        packageContent: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.packageContent = packageContent
    }
}

struct GetSolFunctionPackageContentOutputResponseBody: Swift.Equatable {
    let packageContent: ClientRuntime.Data?
}

extension GetSolFunctionPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageContent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .packageContent)
        packageContent = packageContentDecoded
    }
}

extension GetSolFunctionPackageDescriptorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolFunctionPackageDescriptorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/vnfd"
    }
}

public struct GetSolFunctionPackageDescriptorInput: Swift.Equatable {
    /// Indicates which content types, expressed as MIME types, the client is able to understand.
    /// This member is required.
    public var accept: TnbClientTypes.DescriptorContentType?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        accept: TnbClientTypes.DescriptorContentType? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageDescriptorInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageDescriptorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSolFunctionPackageDescriptorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolFunctionPackageDescriptorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolFunctionPackageDescriptorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolFunctionPackageDescriptorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.vnfd = data
        } else {
            self.vnfd = nil
        }
    }
}

public struct GetSolFunctionPackageDescriptorOutputResponse: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the function package descriptor.
    public var vnfd: ClientRuntime.Data?

    public init (
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        vnfd: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.vnfd = vnfd
    }
}

struct GetSolFunctionPackageDescriptorOutputResponseBody: Swift.Equatable {
    let vnfd: ClientRuntime.Data?
}

extension GetSolFunctionPackageDescriptorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

extension GetSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct GetSolFunctionPackageInput: Swift.Equatable {
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        vnfPkgId: Swift.String? = nil
    )
    {
        self.vnfPkgId = vnfPkgId
    }
}

struct GetSolFunctionPackageInputBody: Swift.Equatable {
}

extension GetSolFunctionPackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolFunctionPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct GetSolFunctionPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?
        /// Metadata related to the function package descriptor of the function package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil,
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.vnfd = vnfd
        }
    }

}

extension GetSolFunctionPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolFunctionPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolFunctionPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolFunctionPackageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolFunctionPackageOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), onboardingState: \(Swift.String(describing: onboardingState)), operationalState: \(Swift.String(describing: operationalState)), usageState: \(Swift.String(describing: usageState)), vnfProductName: \(Swift.String(describing: vnfProductName)), vnfProvider: \(Swift.String(describing: vnfProvider)), vnfdId: \(Swift.String(describing: vnfdId)), vnfdVersion: \(Swift.String(describing: vnfdVersion)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolFunctionPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolFunctionPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.onboardingState = output.onboardingState
            self.operationalState = output.operationalState
            self.tags = output.tags
            self.usageState = output.usageState
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.onboardingState = nil
            self.operationalState = nil
            self.tags = nil
            self.usageState = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct GetSolFunctionPackageOutputResponse: Swift.Equatable {
    /// Function package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata related to the function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public var metadata: TnbClientTypes.GetSolFunctionPackageMetadata?
    /// Function package onboarding state.
    /// This member is required.
    public var onboardingState: TnbClientTypes.OnboardingState?
    /// Function package operational state.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Function package usage state.
    /// This member is required.
    public var usageState: TnbClientTypes.UsageState?
    /// Network function product name.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    public var vnfdVersion: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolFunctionPackageMetadata? = nil,
        onboardingState: TnbClientTypes.OnboardingState? = nil,
        operationalState: TnbClientTypes.OperationalState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usageState: TnbClientTypes.UsageState? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.onboardingState = onboardingState
        self.operationalState = operationalState
        self.tags = tags
        self.usageState = usageState
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct GetSolFunctionPackageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let onboardingState: TnbClientTypes.OnboardingState?
    let operationalState: TnbClientTypes.OperationalState?
    let usageState: TnbClientTypes.UsageState?
    let vnfdId: Swift.String?
    let vnfProvider: Swift.String?
    let vnfProductName: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.GetSolFunctionPackageMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolFunctionPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case onboardingState
        case operationalState
        case tags
        case usageState
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolFunctionPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TnbClientTypes.GetSolInstantiatedVnfInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfState = self.vnfState {
            try encodeContainer.encode(vnfState.rawValue, forKey: .vnfState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfOperationalState.self, forKey: .vnfState)
        vnfState = vnfStateDecoded
    }
}

extension TnbClientTypes {
    /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolInstantiatedVnfInfo: Swift.Equatable {
        /// State of the network function.
        public var vnfState: TnbClientTypes.VnfOperationalState?

        public init (
            vnfState: TnbClientTypes.VnfOperationalState? = nil
        )
        {
            self.vnfState = vnfState
        }
    }

}

extension GetSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkInstanceInput: Swift.Equatable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init (
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

struct GetSolNetworkInstanceInputBody: Swift.Equatable {
}

extension GetSolNetworkInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolNetworkInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolNetworkInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkInstanceOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), lcmOpInfo: \(Swift.String(describing: lcmOpInfo)), metadata: \(Swift.String(describing: metadata)), nsInstanceDescription: \(Swift.String(describing: nsInstanceDescription)), nsInstanceName: \(Swift.String(describing: nsInstanceName)), nsState: \(Swift.String(describing: nsState)), nsdId: \(Swift.String(describing: nsdId)), nsdInfoId: \(Swift.String(describing: nsdInfoId)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolNetworkInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lcmOpInfo = output.lcmOpInfo
            self.metadata = output.metadata
            self.nsInstanceDescription = output.nsInstanceDescription
            self.nsInstanceName = output.nsInstanceName
            self.nsState = output.nsState
            self.nsdId = output.nsdId
            self.nsdInfoId = output.nsdInfoId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.lcmOpInfo = nil
            self.metadata = nil
            self.nsInstanceDescription = nil
            self.nsInstanceName = nil
            self.nsState = nil
            self.nsdId = nil
            self.nsdInfoId = nil
            self.tags = nil
        }
    }
}

public struct GetSolNetworkInstanceOutputResponse: Swift.Equatable {
    /// Network instance ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network instance ID.
    /// This member is required.
    public var id: Swift.String?
    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public var lcmOpInfo: TnbClientTypes.LcmOperationInfo?
    /// The metadata of a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkInstanceMetadata?
    /// Network instance description.
    /// This member is required.
    public var nsInstanceDescription: Swift.String?
    /// Network instance name.
    /// This member is required.
    public var nsInstanceName: Swift.String?
    /// Network instance state.
    public var nsState: TnbClientTypes.NsState?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lcmOpInfo: TnbClientTypes.LcmOperationInfo? = nil,
        metadata: TnbClientTypes.GetSolNetworkInstanceMetadata? = nil,
        nsInstanceDescription: Swift.String? = nil,
        nsInstanceName: Swift.String? = nil,
        nsState: TnbClientTypes.NsState? = nil,
        nsdId: Swift.String? = nil,
        nsdInfoId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lcmOpInfo = lcmOpInfo
        self.metadata = metadata
        self.nsInstanceDescription = nsInstanceDescription
        self.nsInstanceName = nsInstanceName
        self.nsState = nsState
        self.nsdId = nsdId
        self.nsdInfoId = nsdInfoId
        self.tags = tags
    }
}

struct GetSolNetworkInstanceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsInstanceName: Swift.String?
    let nsInstanceDescription: Swift.String?
    let nsdId: Swift.String?
    let nsdInfoId: Swift.String?
    let nsState: TnbClientTypes.NsState?
    let lcmOpInfo: TnbClientTypes.LcmOperationInfo?
    let metadata: TnbClientTypes.GetSolNetworkInstanceMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lcmOpInfo
        case metadata
        case nsInstanceDescription
        case nsInstanceName
        case nsState
        case nsdId
        case nsdInfoId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let nsInstanceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceDescription)
        nsInstanceDescription = nsInstanceDescriptionDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsState.self, forKey: .nsState)
        nsState = nsStateDecoded
        let lcmOpInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationInfo.self, forKey: .lcmOpInfo)
        lcmOpInfo = lcmOpInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSolNetworkOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsLcmOpOccId = nsLcmOpOccId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_lcm_op_occs/\(nsLcmOpOccId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkOperationInput: Swift.Equatable {
    /// The identifier of the operation occurrence.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init (
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct GetSolNetworkOperationInputBody: Swift.Equatable {
}

extension GetSolNetworkOperationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkOperationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network operation occurence. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension GetSolNetworkOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolNetworkOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolNetworkOperationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolNetworkOperationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkOperationOutputResponse(arn: \(Swift.String(describing: arn)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), lcmOperationType: \(Swift.String(describing: lcmOperationType)), metadata: \(Swift.String(describing: metadata)), nsInstanceId: \(Swift.String(describing: nsInstanceId)), operationState: \(Swift.String(describing: operationState)), tasks: \(Swift.String(describing: tasks)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolNetworkOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.error = output.error
            self.id = output.id
            self.lcmOperationType = output.lcmOperationType
            self.metadata = output.metadata
            self.nsInstanceId = output.nsInstanceId
            self.operationState = output.operationState
            self.tags = output.tags
            self.tasks = output.tasks
        } else {
            self.arn = nil
            self.error = nil
            self.id = nil
            self.lcmOperationType = nil
            self.metadata = nil
            self.nsInstanceId = nil
            self.operationState = nil
            self.tags = nil
            self.tasks = nil
        }
    }
}

public struct GetSolNetworkOperationOutputResponse: Swift.Equatable {
    /// Network operation ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Error related to this specific network operation occurence.
    public var error: TnbClientTypes.ProblemDetails?
    /// ID of this network operation occurrence.
    public var id: Swift.String?
    /// Type of the operation represented by this occurrence.
    public var lcmOperationType: TnbClientTypes.LcmOperationType?
    /// Metadata of this network operation occurrence.
    public var metadata: TnbClientTypes.GetSolNetworkOperationMetadata?
    /// ID of the network operation instance.
    public var nsInstanceId: Swift.String?
    /// The state of the network operation.
    public var operationState: TnbClientTypes.NsLcmOperationState?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// All tasks associated with this operation occurrence.
    public var tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]?

    public init (
        arn: Swift.String? = nil,
        error: TnbClientTypes.ProblemDetails? = nil,
        id: Swift.String? = nil,
        lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
        metadata: TnbClientTypes.GetSolNetworkOperationMetadata? = nil,
        nsInstanceId: Swift.String? = nil,
        operationState: TnbClientTypes.NsLcmOperationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]? = nil
    )
    {
        self.arn = arn
        self.error = error
        self.id = id
        self.lcmOperationType = lcmOperationType
        self.metadata = metadata
        self.nsInstanceId = nsInstanceId
        self.operationState = operationState
        self.tags = tags
        self.tasks = tasks
    }
}

struct GetSolNetworkOperationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let operationState: TnbClientTypes.NsLcmOperationState?
    let nsInstanceId: Swift.String?
    let lcmOperationType: TnbClientTypes.LcmOperationType?
    let error: TnbClientTypes.ProblemDetails?
    let metadata: TnbClientTypes.GetSolNetworkOperationMetadata?
    let tasks: [TnbClientTypes.GetSolNetworkOperationTaskDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case error
        case id
        case lcmOperationType
        case metadata
        case nsInstanceId
        case operationState
        case tags
        case tasks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsLcmOperationState.self, forKey: .operationState)
        operationState = operationStateDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let lcmOperationTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationType.self, forKey: .lcmOperationType)
        lcmOperationType = lcmOperationTypeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ProblemDetails.self, forKey: .error)
        error = errorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkOperationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tasksContainer = try containerValues.decodeIfPresent([TnbClientTypes.GetSolNetworkOperationTaskDetails?].self, forKey: .tasks)
        var tasksDecoded0:[TnbClientTypes.GetSolNetworkOperationTaskDetails]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [TnbClientTypes.GetSolNetworkOperationTaskDetails]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TnbClientTypes.GetSolNetworkOperationTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskContext
        case taskEndTime
        case taskErrorDetails
        case taskName
        case taskStartTime
        case taskStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskContext = taskContext {
            var taskContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskContext)
            for (dictKey0, stringMap0) in taskContext {
                try taskContextContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskEndTime = self.taskEndTime {
            try encodeContainer.encodeTimestamp(taskEndTime, format: .dateTime, forKey: .taskEndTime)
        }
        if let taskErrorDetails = self.taskErrorDetails {
            try encodeContainer.encode(taskErrorDetails, forKey: .taskErrorDetails)
        }
        if let taskName = self.taskName {
            try encodeContainer.encode(taskName, forKey: .taskName)
        }
        if let taskStartTime = self.taskStartTime {
            try encodeContainer.encodeTimestamp(taskStartTime, format: .dateTime, forKey: .taskStartTime)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskName)
        taskName = taskNameDecoded
        let taskContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskContext)
        var taskContextDecoded0: [Swift.String:Swift.String]? = nil
        if let taskContextContainer = taskContextContainer {
            taskContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in taskContextContainer {
                if let string0 = string0 {
                    taskContextDecoded0?[key0] = string0
                }
            }
        }
        taskContext = taskContextDecoded0
        let taskErrorDetailsDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ErrorInfo.self, forKey: .taskErrorDetails)
        taskErrorDetails = taskErrorDetailsDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TnbClientTypes.TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .taskEndTime)
        taskEndTime = taskEndTimeDecoded
    }
}

extension TnbClientTypes {
    /// Gets the details of a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct GetSolNetworkOperationTaskDetails: Swift.Equatable {
        /// Context for the network operation task.
        public var taskContext: [Swift.String:Swift.String]?
        /// Task end time.
        public var taskEndTime: ClientRuntime.Date?
        /// Task error details.
        public var taskErrorDetails: TnbClientTypes.ErrorInfo?
        /// Task name.
        public var taskName: Swift.String?
        /// Task start time.
        public var taskStartTime: ClientRuntime.Date?
        /// Task status.
        public var taskStatus: TnbClientTypes.TaskStatus?

        public init (
            taskContext: [Swift.String:Swift.String]? = nil,
            taskEndTime: ClientRuntime.Date? = nil,
            taskErrorDetails: TnbClientTypes.ErrorInfo? = nil,
            taskName: Swift.String? = nil,
            taskStartTime: ClientRuntime.Date? = nil,
            taskStatus: TnbClientTypes.TaskStatus? = nil
        )
        {
            self.taskContext = taskContext
            self.taskEndTime = taskEndTime
            self.taskErrorDetails = taskErrorDetails
            self.taskName = taskName
            self.taskStartTime = taskStartTime
            self.taskStatus = taskStatus
        }
    }

}

extension GetSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept.rawValue)))
        }
        return items
    }
}

extension GetSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

public struct GetSolNetworkPackageContentInput: Swift.Equatable {
    /// The format of the package you want to download from the network package.
    /// This member is required.
    public var accept: TnbClientTypes.PackageContentType?
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        accept: TnbClientTypes.PackageContentType? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageContentInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolNetworkPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolNetworkPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolNetworkPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.PackageContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.nsdContent = data
        } else {
            self.nsdContent = nil
        }
    }
}

public struct GetSolNetworkPackageContentOutputResponse: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Content of the network service descriptor in the network package.
    public var nsdContent: ClientRuntime.Data?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        nsdContent: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsdContent = nsdContent
    }
}

struct GetSolNetworkPackageContentOutputResponseBody: Swift.Equatable {
    let nsdContent: ClientRuntime.Data?
}

extension GetSolNetworkPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdContent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .nsdContent)
        nsdContent = nsdContentDecoded
    }
}

extension GetSolNetworkPackageDescriptorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd"
    }
}

public struct GetSolNetworkPackageDescriptorInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageDescriptorInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageDescriptorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSolNetworkPackageDescriptorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolNetworkPackageDescriptorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolNetworkPackageDescriptorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolNetworkPackageDescriptorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = TnbClientTypes.DescriptorContentType(rawValue: contentTypeHeaderValue)
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.nsd = data
        } else {
            self.nsd = nil
        }
    }
}

public struct GetSolNetworkPackageDescriptorOutputResponse: Swift.Equatable {
    /// Indicates the media type of the resource.
    public var contentType: TnbClientTypes.DescriptorContentType?
    /// Contents of the network service descriptor in the network package.
    public var nsd: ClientRuntime.Data?

    public init (
        contentType: TnbClientTypes.DescriptorContentType? = nil,
        nsd: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.nsd = nsd
    }
}

struct GetSolNetworkPackageDescriptorOutputResponseBody: Swift.Equatable {
    let nsd: ClientRuntime.Data?
}

extension GetSolNetworkPackageDescriptorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

extension GetSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct GetSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        nsdInfoId: Swift.String? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
    }
}

struct GetSolNetworkPackageInputBody: Swift.Equatable {
}

extension GetSolNetworkPackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.GetSolNetworkPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct GetSolNetworkPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?
        /// Metadata related to the onboarded network service descriptor in the network package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil,
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsd = nsd
        }
    }

}

extension GetSolNetworkPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolNetworkPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolNetworkPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolNetworkPackageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolNetworkPackageOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), nsdId: \(Swift.String(describing: nsdId)), nsdName: \(Swift.String(describing: nsdName)), nsdOnboardingState: \(Swift.String(describing: nsdOnboardingState)), nsdOperationalState: \(Swift.String(describing: nsdOperationalState)), nsdUsageState: \(Swift.String(describing: nsdUsageState)), nsdVersion: \(Swift.String(describing: nsdVersion)), vnfPkgIds: \(Swift.String(describing: vnfPkgIds)), tags: \"CONTENT_REDACTED\")"}
}

extension GetSolNetworkPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolNetworkPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdOnboardingState = output.nsdOnboardingState
            self.nsdOperationalState = output.nsdOperationalState
            self.nsdUsageState = output.nsdUsageState
            self.nsdVersion = output.nsdVersion
            self.tags = output.tags
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdOnboardingState = nil
            self.nsdOperationalState = nil
            self.nsdUsageState = nil
            self.nsdVersion = nil
            self.tags = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct GetSolNetworkPackageOutputResponse: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Metadata associated with a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var metadata: TnbClientTypes.GetSolNetworkPackageMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor onboarding state.
    /// This member is required.
    public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    /// Network service descriptor operational state.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
    /// Network service descriptor usage state.
    /// This member is required.
    public var nsdUsageState: TnbClientTypes.NsdUsageState?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    public var tags: [Swift.String:Swift.String]?
    /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.GetSolNetworkPackageMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
        nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
        nsdVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdOnboardingState = nsdOnboardingState
        self.nsdOperationalState = nsdOperationalState
        self.nsdUsageState = nsdUsageState
        self.nsdVersion = nsdVersion
        self.tags = tags
        self.vnfPkgIds = vnfPkgIds
    }
}

struct GetSolNetworkPackageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
    let nsdUsageState: TnbClientTypes.NsdUsageState?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.GetSolNetworkPackageMetadata?
    let tags: [Swift.String:Swift.String]?
}

extension GetSolNetworkPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case nsdVersion
        case tags
        case vnfPkgIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolNetworkPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TnbClientTypes.GetSolVnfInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfState
        case vnfcResourceInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfState = self.vnfState {
            try encodeContainer.encode(vnfState.rawValue, forKey: .vnfState)
        }
        if let vnfcResourceInfo = vnfcResourceInfo {
            var vnfcResourceInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vnfcResourceInfo)
            for getsolvnfcresourceinfo0 in vnfcResourceInfo {
                try vnfcResourceInfoContainer.encode(getsolvnfcresourceinfo0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfOperationalState.self, forKey: .vnfState)
        vnfState = vnfStateDecoded
        let vnfcResourceInfoContainer = try containerValues.decodeIfPresent([TnbClientTypes.GetSolVnfcResourceInfo?].self, forKey: .vnfcResourceInfo)
        var vnfcResourceInfoDecoded0:[TnbClientTypes.GetSolVnfcResourceInfo]? = nil
        if let vnfcResourceInfoContainer = vnfcResourceInfoContainer {
            vnfcResourceInfoDecoded0 = [TnbClientTypes.GetSolVnfcResourceInfo]()
            for structure0 in vnfcResourceInfoContainer {
                if let structure0 = structure0 {
                    vnfcResourceInfoDecoded0?.append(structure0)
                }
            }
        }
        vnfcResourceInfo = vnfcResourceInfoDecoded0
    }
}

extension TnbClientTypes {
    /// Information about the network function. A network function instance is a function in a function package .
    public struct GetSolVnfInfo: Swift.Equatable {
        /// State of the network function instance.
        public var vnfState: TnbClientTypes.VnfOperationalState?
        /// Compute info used by the network function instance.
        public var vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]?

        public init (
            vnfState: TnbClientTypes.VnfOperationalState? = nil,
            vnfcResourceInfo: [TnbClientTypes.GetSolVnfcResourceInfo]? = nil
        )
        {
            self.vnfState = vnfState
            self.vnfcResourceInfo = vnfcResourceInfo
        }
    }

}

extension TnbClientTypes.GetSolVnfcResourceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolVnfcResourceInfoMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Details of resource associated with a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfo: Swift.Equatable {
        /// The metadata of the network function compute.
        public var metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata?

        public init (
            metadata: TnbClientTypes.GetSolVnfcResourceInfoMetadata? = nil
        )
        {
            self.metadata = metadata
        }
    }

}

extension TnbClientTypes.GetSolVnfcResourceInfoMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
        case helmChart
        case nodeGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cluster = self.cluster {
            try encodeContainer.encode(cluster, forKey: .cluster)
        }
        if let helmChart = self.helmChart {
            try encodeContainer.encode(helmChart, forKey: .helmChart)
        }
        if let nodeGroup = self.nodeGroup {
            try encodeContainer.encode(nodeGroup, forKey: .nodeGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeGroup)
        nodeGroup = nodeGroupDecoded
        let clusterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cluster)
        cluster = clusterDecoded
        let helmChartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helmChart)
        helmChart = helmChartDecoded
    }
}

extension TnbClientTypes {
    /// The metadata of a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct GetSolVnfcResourceInfoMetadata: Swift.Equatable {
        /// Information about the cluster.
        public var cluster: Swift.String?
        /// Information about the helm chart.
        public var helmChart: Swift.String?
        /// Information about the node group.
        public var nodeGroup: Swift.String?

        public init (
            cluster: Swift.String? = nil,
            helmChart: Swift.String? = nil,
            nodeGroup: Swift.String? = nil
        )
        {
            self.cluster = cluster
            self.helmChart = helmChart
            self.nodeGroup = nodeGroup
        }
    }

}

extension InstantiateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParamsForNs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParamsForNs = self.additionalParamsForNs {
            try encodeContainer.encode(additionalParamsForNs, forKey: .additionalParamsForNs)
        }
    }
}

extension InstantiateSolNetworkInstanceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let dryRun = dryRun {
                let dryRunQueryItem = ClientRuntime.URLQueryItem(name: "dry_run".urlPercentEncoding(), value: Swift.String(dryRun).urlPercentEncoding())
                items.append(dryRunQueryItem)
            }
            return items
        }
    }
}

extension InstantiateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/instantiate"
    }
}

public struct InstantiateSolNetworkInstanceInput: Swift.Equatable {
    /// Provides values for the configurable properties.
    public var additionalParamsForNs: ClientRuntime.Document?
    /// A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init (
        additionalParamsForNs: ClientRuntime.Document? = nil,
        dryRun: Swift.Bool? = nil,
        nsInstanceId: Swift.String? = nil
    )
    {
        self.additionalParamsForNs = additionalParamsForNs
        self.dryRun = dryRun
        self.nsInstanceId = nsInstanceId
    }
}

struct InstantiateSolNetworkInstanceInputBody: Swift.Equatable {
    let additionalParamsForNs: ClientRuntime.Document?
}

extension InstantiateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParamsForNs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalParamsForNsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .additionalParamsForNs)
        additionalParamsForNs = additionalParamsForNsDecoded
    }
}

extension InstantiateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InstantiateSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InstantiateSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InstantiateSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InstantiateSolNetworkInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
        } else {
            self.nsLcmOpOccId = nil
        }
    }
}

public struct InstantiateSolNetworkInstanceOutputResponse: Swift.Equatable {
    /// The identifier of the network instance.
    /// This member is required.
    public var nsLcmOpOccId: Swift.String?

    public init (
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct InstantiateSolNetworkInstanceOutputResponseBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
}

extension InstantiateSolNetworkInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error occurred. Problem on the server.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes.LcmOperationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsLcmOpOccId = self.nsLcmOpOccId {
            try encodeContainer.encode(nsLcmOpOccId, forKey: .nsLcmOpOccId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
    }
}

extension TnbClientTypes {
    /// Lifecycle management operation details on the network instance. Lifecycle management operations are deploy, update, or delete operations.
    public struct LcmOperationInfo: Swift.Equatable {
        /// The identifier of the latest network lifecycle management operation occurrence.
        /// This member is required.
        public var nsLcmOpOccId: Swift.String?

        public init (
            nsLcmOpOccId: Swift.String? = nil
        )
        {
            self.nsLcmOpOccId = nsLcmOpOccId
        }
    }

}

extension TnbClientTypes {
    public enum LcmOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instantiate
        case terminate
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [LcmOperationType] {
            return [
                .instantiate,
                .terminate,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instantiate: return "INSTANTIATE"
            case .terminate: return "TERMINATE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LcmOperationType(rawValue: rawValue) ?? LcmOperationType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ListSolFunctionInstanceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case instantiatedVnfInfo
        case instantiationState
        case metadata
        case nsInstanceId
        case vnfPkgId
        case vnfPkgName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instantiatedVnfInfo = self.instantiatedVnfInfo {
            try encodeContainer.encode(instantiatedVnfInfo, forKey: .instantiatedVnfInfo)
        }
        if let instantiationState = self.instantiationState {
            try encodeContainer.encode(instantiationState.rawValue, forKey: .instantiationState)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceId = self.nsInstanceId {
            try encodeContainer.encode(nsInstanceId, forKey: .nsInstanceId)
        }
        if let vnfPkgId = self.vnfPkgId {
            try encodeContainer.encode(vnfPkgId, forKey: .vnfPkgId)
        }
        if let vnfPkgName = self.vnfPkgName {
            try encodeContainer.encode(vnfPkgName, forKey: .vnfPkgName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let vnfPkgIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgId)
        vnfPkgId = vnfPkgIdDecoded
        let vnfPkgNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfPkgName)
        vnfPkgName = vnfPkgNameDecoded
        let instantiationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.VnfInstantiationState.self, forKey: .instantiationState)
        instantiationState = instantiationStateDecoded
        let instantiatedVnfInfoDecoded = try containerValues.decodeIfPresent(TnbClientTypes.GetSolInstantiatedVnfInfo.self, forKey: .instantiatedVnfInfo)
        instantiatedVnfInfo = instantiatedVnfInfoDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolFunctionInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Lists information about a network function instance. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceInfo: Swift.Equatable {
        /// Network function instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Network function instance ID.
        /// This member is required.
        public var id: Swift.String?
        /// Information about a network function. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
        public var instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo?
        /// Network function instance instantiation state.
        /// This member is required.
        public var instantiationState: TnbClientTypes.VnfInstantiationState?
        /// Network function instance metadata.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolFunctionInstanceMetadata?
        /// Network instance ID.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// Function package ID.
        /// This member is required.
        public var vnfPkgId: Swift.String?
        /// Function package name.
        public var vnfPkgName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            instantiatedVnfInfo: TnbClientTypes.GetSolInstantiatedVnfInfo? = nil,
            instantiationState: TnbClientTypes.VnfInstantiationState? = nil,
            metadata: TnbClientTypes.ListSolFunctionInstanceMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            vnfPkgId: Swift.String? = nil,
            vnfPkgName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.instantiatedVnfInfo = instantiatedVnfInfo
            self.instantiationState = instantiationState
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.vnfPkgId = vnfPkgId
            self.vnfPkgName = vnfPkgName
        }
    }

}

extension TnbClientTypes.ListSolFunctionInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Lists network function instance metadata. A network function instance is a function in a function package .
    public struct ListSolFunctionInstanceMetadata: Swift.Equatable {
        /// When the network function instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// When the network function instance was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolFunctionInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolFunctionInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnflcm/v1/vnf_instances"
    }
}

public struct ListSolFunctionInstancesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolFunctionInstancesInputBody: Swift.Equatable {
}

extension ListSolFunctionInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSolFunctionInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolFunctionInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolFunctionInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolFunctionInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolFunctionInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionInstances = output.functionInstances
            self.nextToken = output.nextToken
        } else {
            self.functionInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolFunctionInstancesOutputResponse: Swift.Equatable {
    /// Network function instances.
    public var functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionInstances = functionInstances
        self.nextToken = nextToken
    }
}

struct ListSolFunctionInstancesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let functionInstances: [TnbClientTypes.ListSolFunctionInstanceInfo]?
}

extension ListSolFunctionInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionInstances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let functionInstancesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolFunctionInstanceInfo?].self, forKey: .functionInstances)
        var functionInstancesDecoded0:[TnbClientTypes.ListSolFunctionInstanceInfo]? = nil
        if let functionInstancesContainer = functionInstancesContainer {
            functionInstancesDecoded0 = [TnbClientTypes.ListSolFunctionInstanceInfo]()
            for structure0 in functionInstancesContainer {
                if let structure0 = structure0 {
                    functionInstancesDecoded0?.append(structure0)
                }
            }
        }
        functionInstances = functionInstancesDecoded0
    }
}

extension TnbClientTypes.ListSolFunctionPackageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case onboardingState
        case operationalState
        case usageState
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let onboardingState = self.onboardingState {
            try encodeContainer.encode(onboardingState.rawValue, forKey: .onboardingState)
        }
        if let operationalState = self.operationalState {
            try encodeContainer.encode(operationalState.rawValue, forKey: .operationalState)
        }
        if let usageState = self.usageState {
            try encodeContainer.encode(usageState.rawValue, forKey: .usageState)
        }
        if let vnfProductName = self.vnfProductName {
            try encodeContainer.encode(vnfProductName, forKey: .vnfProductName)
        }
        if let vnfProvider = self.vnfProvider {
            try encodeContainer.encode(vnfProvider, forKey: .vnfProvider)
        }
        if let vnfdId = self.vnfdId {
            try encodeContainer.encode(vnfdId, forKey: .vnfdId)
        }
        if let vnfdVersion = self.vnfdVersion {
            try encodeContainer.encode(vnfdVersion, forKey: .vnfdVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let onboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OnboardingState.self, forKey: .onboardingState)
        onboardingState = onboardingStateDecoded
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
        let usageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UsageState.self, forKey: .usageState)
        usageState = usageStateDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolFunctionPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Information about a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageInfo: Swift.Equatable {
        /// Function package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the function package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the function package.
        public var metadata: TnbClientTypes.ListSolFunctionPackageMetadata?
        /// Onboarding state of the function package.
        /// This member is required.
        public var onboardingState: TnbClientTypes.OnboardingState?
        /// Operational state of the function package.
        /// This member is required.
        public var operationalState: TnbClientTypes.OperationalState?
        /// Usage state of the function package.
        /// This member is required.
        public var usageState: TnbClientTypes.UsageState?
        /// The product name for the network function.
        public var vnfProductName: Swift.String?
        /// Provider of the function package and the function package descriptor.
        public var vnfProvider: Swift.String?
        /// Identifies the function package and the function package descriptor.
        public var vnfdId: Swift.String?
        /// Identifies the version of the function package descriptor.
        public var vnfdVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolFunctionPackageMetadata? = nil,
            onboardingState: TnbClientTypes.OnboardingState? = nil,
            operationalState: TnbClientTypes.OperationalState? = nil,
            usageState: TnbClientTypes.UsageState? = nil,
            vnfProductName: Swift.String? = nil,
            vnfProvider: Swift.String? = nil,
            vnfdId: Swift.String? = nil,
            vnfdVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.usageState = usageState
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
        }
    }

}

extension TnbClientTypes.ListSolFunctionPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Details for the function package metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ListSolFunctionPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolFunctionPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolFunctionPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/vnfpkgm/v1/vnf_packages"
    }
}

public struct ListSolFunctionPackagesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolFunctionPackagesInputBody: Swift.Equatable {
}

extension ListSolFunctionPackagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSolFunctionPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolFunctionPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolFunctionPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolFunctionPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolFunctionPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionPackages = output.functionPackages
            self.nextToken = output.nextToken
        } else {
            self.functionPackages = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolFunctionPackagesOutputResponse: Swift.Equatable {
    /// Function packages. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    /// This member is required.
    public var functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionPackages = functionPackages
        self.nextToken = nextToken
    }
}

struct ListSolFunctionPackagesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let functionPackages: [TnbClientTypes.ListSolFunctionPackageInfo]?
}

extension ListSolFunctionPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionPackages
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let functionPackagesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolFunctionPackageInfo?].self, forKey: .functionPackages)
        var functionPackagesDecoded0:[TnbClientTypes.ListSolFunctionPackageInfo]? = nil
        if let functionPackagesContainer = functionPackagesContainer {
            functionPackagesDecoded0 = [TnbClientTypes.ListSolFunctionPackageInfo]()
            for structure0 in functionPackagesContainer {
                if let structure0 = structure0 {
                    functionPackagesDecoded0?.append(structure0)
                }
            }
        }
        functionPackages = functionPackagesDecoded0
    }
}

extension TnbClientTypes.ListSolNetworkInstanceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsInstanceDescription
        case nsInstanceName
        case nsState
        case nsdId
        case nsdInfoId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceDescription = self.nsInstanceDescription {
            try encodeContainer.encode(nsInstanceDescription, forKey: .nsInstanceDescription)
        }
        if let nsInstanceName = self.nsInstanceName {
            try encodeContainer.encode(nsInstanceName, forKey: .nsInstanceName)
        }
        if let nsState = self.nsState {
            try encodeContainer.encode(nsState.rawValue, forKey: .nsState)
        }
        if let nsdId = self.nsdId {
            try encodeContainer.encode(nsdId, forKey: .nsdId)
        }
        if let nsdInfoId = self.nsdInfoId {
            try encodeContainer.encode(nsdInfoId, forKey: .nsdInfoId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceName)
        nsInstanceName = nsInstanceNameDecoded
        let nsInstanceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceDescription)
        nsInstanceDescription = nsInstanceDescriptionDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdInfoIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInfoId)
        nsdInfoId = nsdInfoIdDecoded
        let nsStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsState.self, forKey: .nsState)
        nsState = nsStateDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkInstanceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Info about the specific network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceInfo: Swift.Equatable {
        /// Network instance ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the network instance.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network instance.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkInstanceMetadata?
        /// Human-readable description of the network instance.
        /// This member is required.
        public var nsInstanceDescription: Swift.String?
        /// Human-readable name of the network instance.
        /// This member is required.
        public var nsInstanceName: Swift.String?
        /// The state of the network instance.
        /// This member is required.
        public var nsState: TnbClientTypes.NsState?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdId: Swift.String?
        /// ID of the network service descriptor in the network package.
        /// This member is required.
        public var nsdInfoId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkInstanceMetadata? = nil,
            nsInstanceDescription: Swift.String? = nil,
            nsInstanceName: Swift.String? = nil,
            nsState: TnbClientTypes.NsState? = nil,
            nsdId: Swift.String? = nil,
            nsdInfoId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsInstanceDescription = nsInstanceDescription
            self.nsInstanceName = nsInstanceName
            self.nsState = nsState
            self.nsdId = nsdId
            self.nsdInfoId = nsdInfoId
        }
    }

}

extension TnbClientTypes.ListSolNetworkInstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata details for a network instance. A network instance is a single network created in Amazon Web Services TNB that can be deployed and on which life-cycle operations (like terminate, update, and delete) can be performed.
    public struct ListSolNetworkInstanceMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_instances"
    }
}

public struct ListSolNetworkInstancesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkInstancesInputBody: Swift.Equatable {
}

extension ListSolNetworkInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSolNetworkInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolNetworkInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolNetworkInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolNetworkInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolNetworkInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkInstances = output.networkInstances
            self.nextToken = output.nextToken
        } else {
            self.networkInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkInstancesOutputResponse: Swift.Equatable {
    /// Lists network instances.
    public var networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInstances = networkInstances
        self.nextToken = nextToken
    }
}

struct ListSolNetworkInstancesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkInstances: [TnbClientTypes.ListSolNetworkInstanceInfo]?
}

extension ListSolNetworkInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInstances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkInstancesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkInstanceInfo?].self, forKey: .networkInstances)
        var networkInstancesDecoded0:[TnbClientTypes.ListSolNetworkInstanceInfo]? = nil
        if let networkInstancesContainer = networkInstancesContainer {
            networkInstancesDecoded0 = [TnbClientTypes.ListSolNetworkInstanceInfo]()
            for structure0 in networkInstancesContainer {
                if let structure0 = structure0 {
                    networkInstancesDecoded0?.append(structure0)
                }
            }
        }
        networkInstances = networkInstancesDecoded0
    }
}

extension TnbClientTypes.ListSolNetworkOperationsInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case error
        case id
        case lcmOperationType
        case metadata
        case nsInstanceId
        case operationState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lcmOperationType = self.lcmOperationType {
            try encodeContainer.encode(lcmOperationType.rawValue, forKey: .lcmOperationType)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsInstanceId = self.nsInstanceId {
            try encodeContainer.encode(nsInstanceId, forKey: .nsInstanceId)
        }
        if let operationState = self.operationState {
            try encodeContainer.encode(operationState.rawValue, forKey: .operationState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsLcmOperationState.self, forKey: .operationState)
        operationState = operationStateDecoded
        let nsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsInstanceId)
        nsInstanceId = nsInstanceIdDecoded
        let lcmOperationTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.LcmOperationType.self, forKey: .lcmOperationType)
        lcmOperationType = lcmOperationTypeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ProblemDetails.self, forKey: .error)
        error = errorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkOperationsMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Information parameters for a network operation.
    public struct ListSolNetworkOperationsInfo: Swift.Equatable {
        /// Network operation ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Error related to this specific network operation.
        public var error: TnbClientTypes.ProblemDetails?
        /// ID of this network operation.
        /// This member is required.
        public var id: Swift.String?
        /// Type of lifecycle management network operation.
        /// This member is required.
        public var lcmOperationType: TnbClientTypes.LcmOperationType?
        /// Metadata related to this network operation.
        public var metadata: TnbClientTypes.ListSolNetworkOperationsMetadata?
        /// ID of the network instance related to this operation.
        /// This member is required.
        public var nsInstanceId: Swift.String?
        /// The state of the network operation.
        /// This member is required.
        public var operationState: TnbClientTypes.NsLcmOperationState?

        public init (
            arn: Swift.String? = nil,
            error: TnbClientTypes.ProblemDetails? = nil,
            id: Swift.String? = nil,
            lcmOperationType: TnbClientTypes.LcmOperationType? = nil,
            metadata: TnbClientTypes.ListSolNetworkOperationsMetadata? = nil,
            nsInstanceId: Swift.String? = nil,
            operationState: TnbClientTypes.NsLcmOperationState? = nil
        )
        {
            self.arn = arn
            self.error = error
            self.id = id
            self.lcmOperationType = lcmOperationType
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.operationState = operationState
        }
    }

}

extension ListSolNetworkOperationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nslcm/v1/ns_lcm_op_occs"
    }
}

public struct ListSolNetworkOperationsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkOperationsInputBody: Swift.Equatable {
}

extension ListSolNetworkOperationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TnbClientTypes.ListSolNetworkOperationsMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network operation. A network operation is any operation that is done to your network, such as network instance instantiation or termination.
    public struct ListSolNetworkOperationsMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolNetworkOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolNetworkOperationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolNetworkOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolNetworkOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkOperations = output.networkOperations
            self.nextToken = output.nextToken
        } else {
            self.networkOperations = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkOperationsOutputResponse: Swift.Equatable {
    /// Lists network operation occurrences. Lifecycle management operations are deploy, update, or delete operations.
    public var networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkOperations = networkOperations
        self.nextToken = nextToken
    }
}

struct ListSolNetworkOperationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkOperations: [TnbClientTypes.ListSolNetworkOperationsInfo]?
}

extension ListSolNetworkOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkOperations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkOperationsContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkOperationsInfo?].self, forKey: .networkOperations)
        var networkOperationsDecoded0:[TnbClientTypes.ListSolNetworkOperationsInfo]? = nil
        if let networkOperationsContainer = networkOperationsContainer {
            networkOperationsDecoded0 = [TnbClientTypes.ListSolNetworkOperationsInfo]()
            for structure0 in networkOperationsContainer {
                if let structure0 = structure0 {
                    networkOperationsDecoded0?.append(structure0)
                }
            }
        }
        networkOperations = networkOperationsDecoded0
    }
}

extension TnbClientTypes.ListSolNetworkPackageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdDesigner
        case nsdId
        case nsdInvariantId
        case nsdName
        case nsdOnboardingState
        case nsdOperationalState
        case nsdUsageState
        case nsdVersion
        case vnfPkgIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let nsdDesigner = self.nsdDesigner {
            try encodeContainer.encode(nsdDesigner, forKey: .nsdDesigner)
        }
        if let nsdId = self.nsdId {
            try encodeContainer.encode(nsdId, forKey: .nsdId)
        }
        if let nsdInvariantId = self.nsdInvariantId {
            try encodeContainer.encode(nsdInvariantId, forKey: .nsdInvariantId)
        }
        if let nsdName = self.nsdName {
            try encodeContainer.encode(nsdName, forKey: .nsdName)
        }
        if let nsdOnboardingState = self.nsdOnboardingState {
            try encodeContainer.encode(nsdOnboardingState.rawValue, forKey: .nsdOnboardingState)
        }
        if let nsdOperationalState = self.nsdOperationalState {
            try encodeContainer.encode(nsdOperationalState.rawValue, forKey: .nsdOperationalState)
        }
        if let nsdUsageState = self.nsdUsageState {
            try encodeContainer.encode(nsdUsageState.rawValue, forKey: .nsdUsageState)
        }
        if let nsdVersion = self.nsdVersion {
            try encodeContainer.encode(nsdVersion, forKey: .nsdVersion)
        }
        if let vnfPkgIds = vnfPkgIds {
            var vnfPkgIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vnfPkgIds)
            for vnfpkgid0 in vnfPkgIds {
                try vnfPkgIdsContainer.encode(vnfpkgid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdOnboardingStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOnboardingState.self, forKey: .nsdOnboardingState)
        nsdOnboardingState = nsdOnboardingStateDecoded
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
        let nsdUsageStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdUsageState.self, forKey: .nsdUsageState)
        nsdUsageState = nsdUsageStateDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let nsdDesignerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdDesigner)
        nsdDesigner = nsdDesignerDecoded
        let nsdInvariantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdInvariantId)
        nsdInvariantId = nsdInvariantIdDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ListSolNetworkPackageMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension TnbClientTypes {
    /// Details of a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageInfo: Swift.Equatable {
        /// Network package ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// ID of the individual network package.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata of the network package.
        /// This member is required.
        public var metadata: TnbClientTypes.ListSolNetworkPackageMetadata?
        /// Designer of the onboarded network service descriptor in the network package.
        public var nsdDesigner: Swift.String?
        /// ID of the network service descriptor on which the network package is based.
        public var nsdId: Swift.String?
        /// Identifies a network service descriptor in a version independent manner.
        public var nsdInvariantId: Swift.String?
        /// Name of the onboarded network service descriptor in the network package.
        public var nsdName: Swift.String?
        /// Onboarding state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOnboardingState: TnbClientTypes.NsdOnboardingState?
        /// Operational state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdOperationalState: TnbClientTypes.NsdOperationalState?
        /// Usage state of the network service descriptor in the network package.
        /// This member is required.
        public var nsdUsageState: TnbClientTypes.NsdUsageState?
        /// Version of the onboarded network service descriptor in the network package.
        public var nsdVersion: Swift.String?
        /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
        public var vnfPkgIds: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: TnbClientTypes.ListSolNetworkPackageMetadata? = nil,
            nsdDesigner: Swift.String? = nil,
            nsdId: Swift.String? = nil,
            nsdInvariantId: Swift.String? = nil,
            nsdName: Swift.String? = nil,
            nsdOnboardingState: TnbClientTypes.NsdOnboardingState? = nil,
            nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil,
            nsdUsageState: TnbClientTypes.NsdUsageState? = nil,
            nsdVersion: Swift.String? = nil,
            vnfPkgIds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdDesigner = nsdDesigner
            self.nsdId = nsdId
            self.nsdInvariantId = nsdInvariantId
            self.nsdName = nsdName
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }
    }

}

extension TnbClientTypes.ListSolNetworkPackageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension TnbClientTypes {
    /// Metadata related to a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ListSolNetworkPackageMetadata: Swift.Equatable {
        /// The date that the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date that the resource was last modified.
        /// This member is required.
        public var lastModified: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            lastModified: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }
    }

}

extension ListSolNetworkPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextpage_opaque_marker".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSolNetworkPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sol/nsd/v1/ns_descriptors"
    }
}

public struct ListSolNetworkPackagesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolNetworkPackagesInputBody: Swift.Equatable {
}

extension ListSolNetworkPackagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSolNetworkPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolNetworkPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolNetworkPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolNetworkPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolNetworkPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkPackages = output.networkPackages
            self.nextToken = output.nextToken
        } else {
            self.networkPackages = nil
            self.nextToken = nil
        }
    }
}

public struct ListSolNetworkPackagesOutputResponse: Swift.Equatable {
    /// Network packages. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    /// This member is required.
    public var networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkPackages = networkPackages
        self.nextToken = nextToken
    }
}

struct ListSolNetworkPackagesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkPackages: [TnbClientTypes.ListSolNetworkPackageInfo]?
}

extension ListSolNetworkPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkPackages
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkPackagesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ListSolNetworkPackageInfo?].self, forKey: .networkPackages)
        var networkPackagesDecoded0:[TnbClientTypes.ListSolNetworkPackageInfo]? = nil
        if let networkPackagesContainer = networkPackagesContainer {
            networkPackagesDecoded0 = [TnbClientTypes.ListSolNetworkPackageInfo]()
            for structure0 in networkPackagesContainer {
                if let structure0 = structure0 {
                    networkPackagesDecoded0?.append(structure0)
                }
            }
        }
        networkPackages = networkPackagesDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TnbClientTypes.NetworkArtifactMeta: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for toscaoverride0 in overrides {
                try overridesContainer.encode(toscaoverride0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([TnbClientTypes.ToscaOverride?].self, forKey: .overrides)
        var overridesDecoded0:[TnbClientTypes.ToscaOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [TnbClientTypes.ToscaOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension TnbClientTypes {
    /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
    public struct NetworkArtifactMeta: Swift.Equatable {
        /// Lists network package overrides.
        public var overrides: [TnbClientTypes.ToscaOverride]?

        public init (
            overrides: [TnbClientTypes.ToscaOverride]? = nil
        )
        {
            self.overrides = overrides
        }
    }

}

extension TnbClientTypes {
    public enum NsLcmOperationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [NsLcmOperationState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsLcmOperationState(rawValue: rawValue) ?? NsLcmOperationState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case impaired
        case instantiated
        case instantiateInProgress
        case notInstantiated
        case stopped
        case terminateInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [NsState] {
            return [
                .deleted,
                .impaired,
                .instantiated,
                .instantiateInProgress,
                .notInstantiated,
                .stopped,
                .terminateInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .impaired: return "IMPAIRED"
            case .instantiated: return "INSTANTIATED"
            case .instantiateInProgress: return "INSTANTIATE_IN_PROGRESS"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case .stopped: return "STOPPED"
            case .terminateInProgress: return "TERMINATE_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsState(rawValue: rawValue) ?? NsState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdOnboardingState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOnboardingState] {
            return [
                .created,
                .error,
                .onboarded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdOnboardingState(rawValue: rawValue) ?? NsdOnboardingState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdOperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdOperationalState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdOperationalState(rawValue: rawValue) ?? NsdOperationalState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum NsdUsageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [NsdUsageState] {
            return [
                .inUse,
                .notInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NsdUsageState(rawValue: rawValue) ?? NsdUsageState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum OnboardingState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case error
        case onboarded
        case sdkUnknown(Swift.String)

        public static var allCases: [OnboardingState] {
            return [
                .created,
                .error,
                .onboarded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .error: return "ERROR"
            case .onboarded: return "ONBOARDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OnboardingState(rawValue: rawValue) ?? OnboardingState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum OperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationalState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationalState(rawValue: rawValue) ?? OperationalState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum PackageContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationZip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageContentType] {
            return [
                .applicationZip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationZip: return "application/zip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageContentType(rawValue: rawValue) ?? PackageContentType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes.ProblemDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
    }
}

extension TnbClientTypes {
    /// Details related to problems with AWS TNB resources.
    public struct ProblemDetails: Swift.Equatable {
        /// A human-readable explanation specific to this occurrence of the problem.
        /// This member is required.
        public var detail: Swift.String?
        /// A human-readable title of the problem type.
        public var title: Swift.String?

        public init (
            detail: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.detail = detail
            self.title = title
        }
    }

}

public struct PutSolFunctionPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSolFunctionPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSolFunctionPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutSolFunctionPackageContentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let filedata = file
            let filebody = ClientRuntime.HttpBody.data(filedata)
            input.builder.withBody(filebody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSolFunctionPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSolFunctionPackageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutSolFunctionPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension PutSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension PutSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content"
    }
}

public struct PutSolFunctionPackageContentInput: Swift.Equatable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

struct PutSolFunctionPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension PutSolFunctionPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.PutSolFunctionPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

extension TnbClientTypes {
    /// Update metadata in a function package. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct PutSolFunctionPackageContentMetadata: Swift.Equatable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init (
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }

}

extension PutSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSolFunctionPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSolFunctionPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSolFunctionPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutSolFunctionPackageContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.metadata = output.metadata
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.id = nil
            self.metadata = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct PutSolFunctionPackageContentOutputResponse: Swift.Equatable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata?
    /// Function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init (
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct PutSolFunctionPackageContentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let vnfdId: Swift.String?
    let vnfProductName: Swift.String?
    let vnfProvider: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.PutSolFunctionPackageContentMetadata?
}

extension PutSolFunctionPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case metadata
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.PutSolFunctionPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct PutSolNetworkPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSolNetworkPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSolNetworkPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutSolNetworkPackageContentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let filedata = file
            let filebody = ClientRuntime.HttpBody.data(filedata)
            input.builder.withBody(filebody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSolNetworkPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSolNetworkPackageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutSolNetworkPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension PutSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension PutSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content"
    }
}

public struct PutSolNetworkPackageContentInput: Swift.Equatable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Network service descriptor info ID.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

struct PutSolNetworkPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension PutSolNetworkPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.PutSolNetworkPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

extension TnbClientTypes {
    /// Update metadata in a network package. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct PutSolNetworkPackageContentMetadata: Swift.Equatable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init (
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }

}

extension PutSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSolNetworkPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSolNetworkPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSolNetworkPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutSolNetworkPackageContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdVersion = output.nsdVersion
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdVersion = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct PutSolNetworkPackageContentOutputResponse: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

struct PutSolNetworkPackageContentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.PutSolNetworkPackageContentMetadata?
}

extension PutSolNetworkPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdVersion
        case vnfPkgIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.PutSolNetworkPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Service quotas have been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TnbClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case inProgress
        case scheduled
        case skipped
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .error,
                .inProgress,
                .scheduled,
                .skipped,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case .skipped: return "SKIPPED"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension TerminateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/terminate"
    }
}

public struct TerminateSolNetworkInstanceInput: Swift.Equatable {
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?

    public init (
        nsInstanceId: Swift.String? = nil
    )
    {
        self.nsInstanceId = nsInstanceId
    }
}

struct TerminateSolNetworkInstanceInputBody: Swift.Equatable {
}

extension TerminateSolNetworkInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TerminateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TerminateSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TerminateSolNetworkInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
        } else {
            self.nsLcmOpOccId = nil
        }
    }
}

public struct TerminateSolNetworkInstanceOutputResponse: Swift.Equatable {
    /// The identifier of the operation occurrence.
    public var nsLcmOpOccId: Swift.String?

    public init (
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct TerminateSolNetworkInstanceOutputResponseBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
}

extension TerminateSolNetworkInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception caused by throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes.ToscaOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension TnbClientTypes {
    /// Overrides of the TOSCA node.
    public struct ToscaOverride: Swift.Equatable {
        /// Default value for the override.
        public var defaultValue: Swift.String?
        /// Name of the TOSCA override.
        public var name: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.name = name
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSolFunctionPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationalState = self.operationalState {
            try encodeContainer.encode(operationalState.rawValue, forKey: .operationalState)
        }
    }
}

extension UpdateSolFunctionPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())"
    }
}

public struct UpdateSolFunctionPackageInput: Swift.Equatable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?
    /// ID of the function package.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        operationalState: TnbClientTypes.OperationalState? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.operationalState = operationalState
        self.vnfPkgId = vnfPkgId
    }
}

struct UpdateSolFunctionPackageInputBody: Swift.Equatable {
    let operationalState: TnbClientTypes.OperationalState?
}

extension UpdateSolFunctionPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
    }
}

extension UpdateSolFunctionPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSolFunctionPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSolFunctionPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSolFunctionPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSolFunctionPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationalState = output.operationalState
        } else {
            self.operationalState = nil
        }
    }
}

public struct UpdateSolFunctionPackageOutputResponse: Swift.Equatable {
    /// Operational state of the function package.
    /// This member is required.
    public var operationalState: TnbClientTypes.OperationalState?

    public init (
        operationalState: TnbClientTypes.OperationalState? = nil
    )
    {
        self.operationalState = operationalState
    }
}

struct UpdateSolFunctionPackageOutputResponseBody: Swift.Equatable {
    let operationalState: TnbClientTypes.OperationalState?
}

extension UpdateSolFunctionPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationalState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.OperationalState.self, forKey: .operationalState)
        operationalState = operationalStateDecoded
    }
}

extension UpdateSolNetworkInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifyVnfInfoData
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modifyVnfInfoData = self.modifyVnfInfoData {
            try encodeContainer.encode(modifyVnfInfoData, forKey: .modifyVnfInfoData)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension UpdateSolNetworkInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsInstanceId = nsInstanceId else {
            return nil
        }
        return "/sol/nslcm/v1/ns_instances/\(nsInstanceId.urlPercentEncoding())/update"
    }
}

public struct UpdateSolNetworkInstanceInput: Swift.Equatable {
    /// Identifies the network function information parameters and/or the configurable properties of the network function to be modified.
    public var modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify?
    /// ID of the network instance.
    /// This member is required.
    public var nsInstanceId: Swift.String?
    /// The type of update.
    /// This member is required.
    public var updateType: TnbClientTypes.UpdateSolNetworkType?

    public init (
        modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify? = nil,
        nsInstanceId: Swift.String? = nil,
        updateType: TnbClientTypes.UpdateSolNetworkType? = nil
    )
    {
        self.modifyVnfInfoData = modifyVnfInfoData
        self.nsInstanceId = nsInstanceId
        self.updateType = updateType
    }
}

struct UpdateSolNetworkInstanceInputBody: Swift.Equatable {
    let updateType: TnbClientTypes.UpdateSolNetworkType?
    let modifyVnfInfoData: TnbClientTypes.UpdateSolNetworkModify?
}

extension UpdateSolNetworkInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifyVnfInfoData
        case updateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UpdateSolNetworkType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let modifyVnfInfoDataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.UpdateSolNetworkModify.self, forKey: .modifyVnfInfoData)
        modifyVnfInfoData = modifyVnfInfoDataDecoded
    }
}

extension UpdateSolNetworkInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSolNetworkInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSolNetworkInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSolNetworkInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSolNetworkInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nsLcmOpOccId = output.nsLcmOpOccId
        } else {
            self.nsLcmOpOccId = nil
        }
    }
}

public struct UpdateSolNetworkInstanceOutputResponse: Swift.Equatable {
    /// The identifier of the network instance operation occurrence.
    public var nsLcmOpOccId: Swift.String?

    public init (
        nsLcmOpOccId: Swift.String? = nil
    )
    {
        self.nsLcmOpOccId = nsLcmOpOccId
    }
}

struct UpdateSolNetworkInstanceOutputResponseBody: Swift.Equatable {
    let nsLcmOpOccId: Swift.String?
}

extension UpdateSolNetworkInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsLcmOpOccId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsLcmOpOccIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsLcmOpOccId)
        nsLcmOpOccId = nsLcmOpOccIdDecoded
    }
}

extension TnbClientTypes.UpdateSolNetworkModify: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfConfigurableProperties
        case vnfInstanceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfConfigurableProperties = self.vnfConfigurableProperties {
            try encodeContainer.encode(vnfConfigurableProperties, forKey: .vnfConfigurableProperties)
        }
        if let vnfInstanceId = self.vnfInstanceId {
            try encodeContainer.encode(vnfInstanceId, forKey: .vnfInstanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfInstanceId)
        vnfInstanceId = vnfInstanceIdDecoded
        let vnfConfigurablePropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .vnfConfigurableProperties)
        vnfConfigurableProperties = vnfConfigurablePropertiesDecoded
    }
}

extension TnbClientTypes {
    /// Information parameters and/or the configurable properties for a network function. A network function instance is a function in a function package .
    public struct UpdateSolNetworkModify: Swift.Equatable {
        /// Provides values for the configurable properties declared in the function package descriptor.
        /// This member is required.
        public var vnfConfigurableProperties: ClientRuntime.Document?
        /// ID of the network function instance. A network function instance is a function in a function package .
        /// This member is required.
        public var vnfInstanceId: Swift.String?

        public init (
            vnfConfigurableProperties: ClientRuntime.Document? = nil,
            vnfInstanceId: Swift.String? = nil
        )
        {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }
    }

}

extension UpdateSolNetworkPackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsdOperationalState = self.nsdOperationalState {
            try encodeContainer.encode(nsdOperationalState.rawValue, forKey: .nsdOperationalState)
        }
    }
}

extension UpdateSolNetworkPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())"
    }
}

public struct UpdateSolNetworkPackageInput: Swift.Equatable {
    /// ID of the network service descriptor in the network package.
    /// This member is required.
    public var nsdInfoId: Swift.String?
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init (
        nsdInfoId: Swift.String? = nil,
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdInfoId = nsdInfoId
        self.nsdOperationalState = nsdOperationalState
    }
}

struct UpdateSolNetworkPackageInputBody: Swift.Equatable {
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
}

extension UpdateSolNetworkPackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
    }
}

extension UpdateSolNetworkPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSolNetworkPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSolNetworkPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSolNetworkPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSolNetworkPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nsdOperationalState = output.nsdOperationalState
        } else {
            self.nsdOperationalState = nil
        }
    }
}

public struct UpdateSolNetworkPackageOutputResponse: Swift.Equatable {
    /// Operational state of the network service descriptor in the network package.
    /// This member is required.
    public var nsdOperationalState: TnbClientTypes.NsdOperationalState?

    public init (
        nsdOperationalState: TnbClientTypes.NsdOperationalState? = nil
    )
    {
        self.nsdOperationalState = nsdOperationalState
    }
}

struct UpdateSolNetworkPackageOutputResponseBody: Swift.Equatable {
    let nsdOperationalState: TnbClientTypes.NsdOperationalState?
}

extension UpdateSolNetworkPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsdOperationalState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdOperationalStateDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NsdOperationalState.self, forKey: .nsdOperationalState)
        nsdOperationalState = nsdOperationalStateDecoded
    }
}

extension TnbClientTypes {
    public enum UpdateSolNetworkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modifyVnfInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateSolNetworkType] {
            return [
                .modifyVnfInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modifyVnfInformation: return "MODIFY_VNF_INFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateSolNetworkType(rawValue: rawValue) ?? UpdateSolNetworkType.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum UsageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inUse
        case notInUse
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageState] {
            return [
                .inUse,
                .notInUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inUse: return "IN_USE"
            case .notInUse: return "NOT_IN_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageState(rawValue: rawValue) ?? UsageState.sdkUnknown(rawValue)
        }
    }
}

public struct ValidateSolFunctionPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateSolFunctionPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateSolFunctionPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ValidateSolFunctionPackageContentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let filedata = file
            let filebody = ClientRuntime.HttpBody.data(filedata)
            input.builder.withBody(filebody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateSolFunctionPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateSolFunctionPackageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ValidateSolFunctionPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension ValidateSolFunctionPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension ValidateSolFunctionPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vnfPkgId = vnfPkgId else {
            return nil
        }
        return "/sol/vnfpkgm/v1/vnf_packages/\(vnfPkgId.urlPercentEncoding())/package_content/validate"
    }
}

public struct ValidateSolFunctionPackageContentInput: Swift.Equatable {
    /// Function package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Function package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Function package ID.
    /// This member is required.
    public var vnfPkgId: Swift.String?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        vnfPkgId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.vnfPkgId = vnfPkgId
    }
}

struct ValidateSolFunctionPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension ValidateSolFunctionPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.ValidateSolFunctionPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vnfd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vnfd = self.vnfd {
            try encodeContainer.encode(vnfd, forKey: .vnfd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vnfdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.FunctionArtifactMeta.self, forKey: .vnfd)
        vnfd = vnfdDecoded
    }
}

extension TnbClientTypes {
    /// Validates function package content metadata. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
    public struct ValidateSolFunctionPackageContentMetadata: Swift.Equatable {
        /// Metadata for function package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var vnfd: TnbClientTypes.FunctionArtifactMeta?

        public init (
            vnfd: TnbClientTypes.FunctionArtifactMeta? = nil
        )
        {
            self.vnfd = vnfd
        }
    }

}

extension ValidateSolFunctionPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateSolFunctionPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ValidateSolFunctionPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateSolFunctionPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidateSolFunctionPackageContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.metadata = output.metadata
            self.vnfProductName = output.vnfProductName
            self.vnfProvider = output.vnfProvider
            self.vnfdId = output.vnfdId
            self.vnfdVersion = output.vnfdVersion
        } else {
            self.id = nil
            self.metadata = nil
            self.vnfProductName = nil
            self.vnfProvider = nil
            self.vnfdId = nil
            self.vnfdVersion = nil
        }
    }
}

public struct ValidateSolFunctionPackageContentOutputResponse: Swift.Equatable {
    /// Function package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Function package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata?
    /// Network function product name.
    /// This member is required.
    public var vnfProductName: Swift.String?
    /// Network function provider.
    /// This member is required.
    public var vnfProvider: Swift.String?
    /// Function package descriptor ID.
    /// This member is required.
    public var vnfdId: Swift.String?
    /// Function package descriptor version.
    /// This member is required.
    public var vnfdVersion: Swift.String?

    public init (
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata? = nil,
        vnfProductName: Swift.String? = nil,
        vnfProvider: Swift.String? = nil,
        vnfdId: Swift.String? = nil,
        vnfdVersion: Swift.String? = nil
    )
    {
        self.id = id
        self.metadata = metadata
        self.vnfProductName = vnfProductName
        self.vnfProvider = vnfProvider
        self.vnfdId = vnfdId
        self.vnfdVersion = vnfdVersion
    }
}

struct ValidateSolFunctionPackageContentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let vnfdId: Swift.String?
    let vnfProductName: Swift.String?
    let vnfProvider: Swift.String?
    let vnfdVersion: Swift.String?
    let metadata: TnbClientTypes.ValidateSolFunctionPackageContentMetadata?
}

extension ValidateSolFunctionPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case metadata
        case vnfProductName
        case vnfProvider
        case vnfdId
        case vnfdVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vnfdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdId)
        vnfdId = vnfdIdDecoded
        let vnfProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProductName)
        vnfProductName = vnfProductNameDecoded
        let vnfProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfProvider)
        vnfProvider = vnfProviderDecoded
        let vnfdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vnfdVersion)
        vnfdVersion = vnfdVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ValidateSolFunctionPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct ValidateSolNetworkPackageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateSolNetworkPackageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateSolNetworkPackageContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ValidateSolNetworkPackageContentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let file = input.operationInput.file {
            let filedata = file
            let filebody = ClientRuntime.HttpBody.data(filedata)
            input.builder.withBody(filebody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateSolNetworkPackageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateSolNetworkPackageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ValidateSolNetworkPackageContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }
}

extension ValidateSolNetworkPackageContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType.rawValue)))
        }
        return items
    }
}

extension ValidateSolNetworkPackageContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nsdInfoId = nsdInfoId else {
            return nil
        }
        return "/sol/nsd/v1/ns_descriptors/\(nsdInfoId.urlPercentEncoding())/nsd_content/validate"
    }
}

public struct ValidateSolNetworkPackageContentInput: Swift.Equatable {
    /// Network package content type.
    public var contentType: TnbClientTypes.PackageContentType?
    /// Network package file.
    /// This member is required.
    public var file: ClientRuntime.Data?
    /// Network service descriptor file.
    /// This member is required.
    public var nsdInfoId: Swift.String?

    public init (
        contentType: TnbClientTypes.PackageContentType? = nil,
        file: ClientRuntime.Data? = nil,
        nsdInfoId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.file = file
        self.nsdInfoId = nsdInfoId
    }
}

struct ValidateSolNetworkPackageContentInputBody: Swift.Equatable {
    let file: ClientRuntime.Data?
}

extension ValidateSolNetworkPackageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension TnbClientTypes.ValidateSolNetworkPackageContentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nsd
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nsd = self.nsd {
            try encodeContainer.encode(nsd, forKey: .nsd)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nsdDecoded = try containerValues.decodeIfPresent(TnbClientTypes.NetworkArtifactMeta.self, forKey: .nsd)
        nsd = nsdDecoded
    }
}

extension TnbClientTypes {
    /// Validates network package content metadata. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
    public struct ValidateSolNetworkPackageContentMetadata: Swift.Equatable {
        /// Metadata for network package artifacts. Artifacts are the contents of the package descriptor file and the state of the package.
        public var nsd: TnbClientTypes.NetworkArtifactMeta?

        public init (
            nsd: TnbClientTypes.NetworkArtifactMeta? = nil
        )
        {
            self.nsd = nsd
        }
    }

}

extension ValidateSolNetworkPackageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateSolNetworkPackageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ValidateSolNetworkPackageContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateSolNetworkPackageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidateSolNetworkPackageContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.metadata = output.metadata
            self.nsdId = output.nsdId
            self.nsdName = output.nsdName
            self.nsdVersion = output.nsdVersion
            self.vnfPkgIds = output.vnfPkgIds
        } else {
            self.arn = nil
            self.id = nil
            self.metadata = nil
            self.nsdId = nil
            self.nsdName = nil
            self.nsdVersion = nil
            self.vnfPkgIds = nil
        }
    }
}

public struct ValidateSolNetworkPackageContentOutputResponse: Swift.Equatable {
    /// Network package ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Network package ID.
    /// This member is required.
    public var id: Swift.String?
    /// Network package metadata.
    /// This member is required.
    public var metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata?
    /// Network service descriptor ID.
    /// This member is required.
    public var nsdId: Swift.String?
    /// Network service descriptor name.
    /// This member is required.
    public var nsdName: Swift.String?
    /// Network service descriptor version.
    /// This member is required.
    public var nsdVersion: Swift.String?
    /// Function package IDs.
    /// This member is required.
    public var vnfPkgIds: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata? = nil,
        nsdId: Swift.String? = nil,
        nsdName: Swift.String? = nil,
        nsdVersion: Swift.String? = nil,
        vnfPkgIds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.metadata = metadata
        self.nsdId = nsdId
        self.nsdName = nsdName
        self.nsdVersion = nsdVersion
        self.vnfPkgIds = vnfPkgIds
    }
}

struct ValidateSolNetworkPackageContentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let nsdId: Swift.String?
    let nsdName: Swift.String?
    let nsdVersion: Swift.String?
    let vnfPkgIds: [Swift.String]?
    let metadata: TnbClientTypes.ValidateSolNetworkPackageContentMetadata?
}

extension ValidateSolNetworkPackageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case metadata
        case nsdId
        case nsdName
        case nsdVersion
        case vnfPkgIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nsdIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdId)
        nsdId = nsdIdDecoded
        let nsdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdName)
        nsdName = nsdNameDecoded
        let nsdVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nsdVersion)
        nsdVersion = nsdVersionDecoded
        let vnfPkgIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vnfPkgIds)
        var vnfPkgIdsDecoded0:[Swift.String]? = nil
        if let vnfPkgIdsContainer = vnfPkgIdsContainer {
            vnfPkgIdsDecoded0 = [Swift.String]()
            for string0 in vnfPkgIdsContainer {
                if let string0 = string0 {
                    vnfPkgIdsDecoded0?.append(string0)
                }
            }
        }
        vnfPkgIds = vnfPkgIdsDecoded0
        let metadataDecoded = try containerValues.decodeIfPresent(TnbClientTypes.ValidateSolNetworkPackageContentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unable to process the request because the client provided input failed to satisfy request constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TnbClientTypes {
    public enum VnfInstantiationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instantiated
        case notInstantiated
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfInstantiationState] {
            return [
                .instantiated,
                .notInstantiated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instantiated: return "INSTANTIATED"
            case .notInstantiated: return "NOT_INSTANTIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VnfInstantiationState(rawValue: rawValue) ?? VnfInstantiationState.sdkUnknown(rawValue)
        }
    }
}

extension TnbClientTypes {
    public enum VnfOperationalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [VnfOperationalState] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VnfOperationalState(rawValue: rawValue) ?? VnfOperationalState.sdkUnknown(rawValue)
        }
    }
}
