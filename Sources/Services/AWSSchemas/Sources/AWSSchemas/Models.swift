//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct DeleteDiscovererOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRegistryOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSchemaOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSchemaVersionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension SchemasClientTypes {

    public enum DiscovererState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscovererState] {
            return [
                .started,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SchemasClientTypes {

    public struct DiscovererSummary: Swift.Sendable {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public var crossAccount: Swift.Bool?
        /// The ARN of the discoverer.
        public var discovererArn: Swift.String?
        /// The ID of the discoverer.
        public var discovererId: Swift.String?
        /// The ARN of the event bus.
        public var sourceArn: Swift.String?
        /// The state of the discoverer.
        public var state: SchemasClientTypes.DiscovererState?
        /// Tags associated with the resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            crossAccount: Swift.Bool? = nil,
            discovererArn: Swift.String? = nil,
            discovererId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            state: SchemasClientTypes.DiscovererState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }
    }
}

extension SchemasClientTypes {

    public struct RegistrySummary: Swift.Sendable {
        /// The ARN of the registry.
        public var registryArn: Swift.String?
        /// The name of the registry.
        public var registryName: Swift.String?
        /// Tags associated with the registry.
        public var tags: [Swift.String: Swift.String]?

        public init(
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }
    }
}

extension SchemasClientTypes {

    /// A summary of schema details.
    public struct SchemaSummary: Swift.Sendable {
        /// The date and time that schema was modified.
        public var lastModified: Foundation.Date?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// Tags associated with the schema.
        public var tags: [Swift.String: Swift.String]?
        /// The number of versions available for the schema.
        public var versionCount: Swift.Int?

        public init(
            lastModified: Foundation.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            versionCount: Swift.Int? = nil
        )
        {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }
    }
}

extension SchemasClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonschemadraft4
        case openapi3
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .jsonschemadraft4,
                .openapi3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonschemadraft4: return "JSONSchemaDraft4"
            case .openapi3: return "OpenApi3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SchemasClientTypes {

    public struct SchemaVersionSummary: Swift.Sendable {
        /// The ARN of the schema version.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// The version number of the schema.
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }
}

extension SchemasClientTypes {

    public struct SearchSchemaVersionSummary: Swift.Sendable {
        /// The date the schema version was created.
        public var createdDate: Foundation.Date?
        /// The version number of the schema
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            createdDate: Foundation.Date? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }
}

extension SchemasClientTypes {

    public struct SearchSchemaSummary: Swift.Sendable {
        /// The name of the registry.
        public var registryName: Swift.String?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// An array of schema version summaries.
        public var schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]?

        public init(
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }
    }
}

public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension SchemasClientTypes {

    public enum CodeGenerationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeGenerationStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct CreateDiscovererInput: Swift.Sendable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true).
    public var crossAccount: Swift.Bool?
    /// A description for the discoverer.
    public var description: Swift.String?
    /// The ARN of the event bus.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

public struct CreateDiscovererOutput: Swift.Sendable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

public struct CreateRegistryInput: Swift.Sendable {
    /// A description of the registry to be created.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Tags to associate with the registry.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

public struct CreateRegistryOutput: Swift.Sendable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

public struct CreateSchemaInput: Swift.Sendable {
    /// The source of the schema definition.
    /// This member is required.
    public var content: Swift.String?
    /// A description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Tags associated with the schema.
    public var tags: [Swift.String: Swift.String]?
    /// The type of schema.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

public struct CreateSchemaOutput: Swift.Sendable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: Foundation.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: Foundation.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct DeleteDiscovererInput: Swift.Sendable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

public struct DeleteRegistryInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

public struct DeleteSchemaInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

public struct DeleteSchemaVersionInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The version number of the schema
    /// This member is required.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct DescribeCodeBindingInput: Swift.Sendable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

public struct DescribeCodeBindingOutput: Swift.Sendable {
    /// The time and date that the code binding was created.
    public var creationDate: Foundation.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: Foundation.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: Foundation.Date? = nil,
        lastModified: Foundation.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

public struct DescribeDiscovererInput: Swift.Sendable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

public struct DescribeDiscovererOutput: Swift.Sendable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

public struct DescribeRegistryInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

public struct DescribeRegistryOutput: Swift.Sendable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

public struct DescribeSchemaInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

public struct DescribeSchemaOutput: Swift.Sendable {
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: Foundation.Date?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: Foundation.Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

public struct ExportSchemaInput: Swift.Sendable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?
    /// This member is required.
    public var type: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

public struct ExportSchemaOutput: Swift.Sendable {
    public var content: Swift.String?
    public var schemaArn: Swift.String?
    public var schemaName: Swift.String?
    public var schemaVersion: Swift.String?
    public var type: Swift.String?

    public init(
        content: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

public struct GetCodeBindingSourceInput: Swift.Sendable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

public struct GetCodeBindingSourceOutput: Swift.Sendable {
    public var body: Foundation.Data?

    public init(
        body: Foundation.Data? = nil
    )
    {
        self.body = body
    }
}

public struct GetDiscoveredSchemaInput: Swift.Sendable {
    /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
    /// This member is required.
    public var events: [Swift.String]?
    /// The type of event.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        events: [Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

public struct GetDiscoveredSchemaOutput: Swift.Sendable {
    /// The source of the schema definition.
    public var content: Swift.String?

    public init(
        content: Swift.String? = nil
    )
    {
        self.content = content
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

public struct GoneException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GoneException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ListDiscoverersInput: Swift.Sendable {
    /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
    public var discovererIdPrefix: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those ARNs that start with the specified prefix.
    public var sourceArnPrefix: Swift.String?

    public init(
        discovererIdPrefix: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceArnPrefix: Swift.String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

public struct ListDiscoverersOutput: Swift.Sendable {
    /// An array of DiscovererSummary information.
    public var discoverers: [SchemasClientTypes.DiscovererSummary]?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?

    public init(
        discoverers: [SchemasClientTypes.DiscovererSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

public struct ListRegistriesInput: Swift.Sendable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those registry names that start with the specified prefix.
    public var registryNamePrefix: Swift.String?
    /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
    public var scope: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryNamePrefix: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

public struct ListRegistriesOutput: Swift.Sendable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of registry summaries.
    public var registries: [SchemasClientTypes.RegistrySummary]?

    public init(
        nextToken: Swift.String? = nil,
        registries: [SchemasClientTypes.RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

public struct ListSchemasInput: Swift.Sendable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Specifying this limits the results to only those schema names that start with the specified prefix.
    public var schemaNamePrefix: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaNamePrefix: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

public struct ListSchemasOutput: Swift.Sendable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema summaries.
    public var schemas: [SchemasClientTypes.SchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct ListSchemaVersionsInput: Swift.Sendable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

public struct ListSchemaVersionsOutput: Swift.Sendable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema version summaries.
    public var schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaVersions: [SchemasClientTypes.SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct PutCodeBindingInput: Swift.Sendable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

public struct PutCodeBindingOutput: Swift.Sendable {
    /// The time and date that the code binding was created.
    public var creationDate: Foundation.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: Foundation.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: Foundation.Date? = nil,
        lastModified: Foundation.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

/// The name of the policy.
public struct PutResourcePolicyInput: Swift.Sendable {
    /// The resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        registryName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

public struct SearchSchemasInput: Swift.Sendable {
    /// Specifying this limits the results to only schemas that include the provided keywords.
    /// This member is required.
    public var keywords: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        keywords: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

public struct SearchSchemasOutput: Swift.Sendable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of SearchSchemaSummary information.
    public var schemas: [SchemasClientTypes.SearchSchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct StartDiscovererInput: Swift.Sendable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

public struct StartDiscovererOutput: Swift.Sendable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

public struct StopDiscovererInput: Swift.Sendable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

public struct StopDiscovererOutput: Swift.Sendable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

///
public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags associated with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateDiscovererInput: Swift.Sendable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true)
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer to update.
    public var description: Swift.String?
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererId: Swift.String? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererId = discovererId
    }
}

public struct UpdateDiscovererOutput: Swift.Sendable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

/// Updates the registry.
public struct UpdateRegistryInput: Swift.Sendable {
    /// The description of the registry to update.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

public struct UpdateRegistryOutput: Swift.Sendable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

public struct UpdateSchemaInput: Swift.Sendable {
    /// The ID of the client token.
    public var clientTokenId: Swift.String?
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The schema type for the events schema.
    public var type: SchemasClientTypes.ModelType?

    public init(
        clientTokenId: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

public struct UpdateSchemaOutput: Swift.Sendable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: Foundation.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: Foundation.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

extension CreateDiscovererInput {

    static func urlPathProvider(_ value: CreateDiscovererInput) -> Swift.String? {
        return "/v1/discoverers"
    }
}

extension CreateRegistryInput {

    static func urlPathProvider(_ value: CreateRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension CreateSchemaInput {

    static func urlPathProvider(_ value: CreateSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension DeleteDiscovererInput {

    static func urlPathProvider(_ value: DeleteDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

extension DeleteRegistryInput {

    static func urlPathProvider(_ value: DeleteRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

extension DeleteResourcePolicyInput {

    static func queryItemProvider(_ value: DeleteResourcePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = Smithy.URIQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension DeleteSchemaInput {

    static func urlPathProvider(_ value: DeleteSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension DeleteSchemaVersionInput {

    static func urlPathProvider(_ value: DeleteSchemaVersionInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let schemaVersion = value.schemaVersion else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/version/\(schemaVersion.urlPercentEncoding())"
    }
}

extension DescribeCodeBindingInput {

    static func urlPathProvider(_ value: DescribeCodeBindingInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

extension DescribeCodeBindingInput {

    static func queryItemProvider(_ value: DescribeCodeBindingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = Smithy.URIQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension DescribeDiscovererInput {

    static func urlPathProvider(_ value: DescribeDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

extension DescribeRegistryInput {

    static func urlPathProvider(_ value: DescribeRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension DescribeSchemaInput {

    static func urlPathProvider(_ value: DescribeSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension DescribeSchemaInput {

    static func queryItemProvider(_ value: DescribeSchemaInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = Smithy.URIQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension ExportSchemaInput {

    static func urlPathProvider(_ value: ExportSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/export"
    }
}

extension ExportSchemaInput {

    static func queryItemProvider(_ value: ExportSchemaInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
        items.append(typeQueryItem)
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = Smithy.URIQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension GetCodeBindingSourceInput {

    static func urlPathProvider(_ value: GetCodeBindingSourceInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())/source"
    }
}

extension GetCodeBindingSourceInput {

    static func queryItemProvider(_ value: GetCodeBindingSourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = Smithy.URIQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension GetDiscoveredSchemaInput {

    static func urlPathProvider(_ value: GetDiscoveredSchemaInput) -> Swift.String? {
        return "/v1/discover"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

extension GetResourcePolicyInput {

    static func queryItemProvider(_ value: GetResourcePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = Smithy.URIQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension ListDiscoverersInput {

    static func urlPathProvider(_ value: ListDiscoverersInput) -> Swift.String? {
        return "/v1/discoverers"
    }
}

extension ListDiscoverersInput {

    static func queryItemProvider(_ value: ListDiscoverersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sourceArnPrefix = value.sourceArnPrefix {
            let sourceArnPrefixQueryItem = Smithy.URIQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: Swift.String(sourceArnPrefix).urlPercentEncoding())
            items.append(sourceArnPrefixQueryItem)
        }
        if let discovererIdPrefix = value.discovererIdPrefix {
            let discovererIdPrefixQueryItem = Smithy.URIQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: Swift.String(discovererIdPrefix).urlPercentEncoding())
            items.append(discovererIdPrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListRegistriesInput {

    static func urlPathProvider(_ value: ListRegistriesInput) -> Swift.String? {
        return "/v1/registries"
    }
}

extension ListRegistriesInput {

    static func queryItemProvider(_ value: ListRegistriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let scope = value.scope {
            let scopeQueryItem = Smithy.URIQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope).urlPercentEncoding())
            items.append(scopeQueryItem)
        }
        if let registryNamePrefix = value.registryNamePrefix {
            let registryNamePrefixQueryItem = Smithy.URIQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: Swift.String(registryNamePrefix).urlPercentEncoding())
            items.append(registryNamePrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas"
    }
}

extension ListSchemasInput {

    static func queryItemProvider(_ value: ListSchemasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let schemaNamePrefix = value.schemaNamePrefix {
            let schemaNamePrefixQueryItem = Smithy.URIQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: Swift.String(schemaNamePrefix).urlPercentEncoding())
            items.append(schemaNamePrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemaVersionsInput {

    static func urlPathProvider(_ value: ListSchemaVersionsInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/versions"
    }
}

extension ListSchemaVersionsInput {

    static func queryItemProvider(_ value: ListSchemaVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutCodeBindingInput {

    static func urlPathProvider(_ value: PutCodeBindingInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

extension PutCodeBindingInput {

    static func queryItemProvider(_ value: PutCodeBindingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = Smithy.URIQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

extension PutResourcePolicyInput {

    static func queryItemProvider(_ value: PutResourcePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = Smithy.URIQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension SearchSchemasInput {

    static func urlPathProvider(_ value: SearchSchemasInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/search"
    }
}

extension SearchSchemasInput {

    static func queryItemProvider(_ value: SearchSchemasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let keywords = value.keywords else {
            let message = "Creating a URL Query Item failed. keywords is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let keywordsQueryItem = Smithy.URIQueryItem(name: "keywords".urlPercentEncoding(), value: Swift.String(keywords).urlPercentEncoding())
        items.append(keywordsQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension StartDiscovererInput {

    static func urlPathProvider(_ value: StartDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/start"
    }
}

extension StopDiscovererInput {

    static func urlPathProvider(_ value: StopDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDiscovererInput {

    static func urlPathProvider(_ value: UpdateDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

extension UpdateRegistryInput {

    static func urlPathProvider(_ value: UpdateRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension UpdateSchemaInput {

    static func urlPathProvider(_ value: UpdateSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension CreateDiscovererInput {

    static func write(value: CreateDiscovererInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossAccount"].write(value.crossAccount)
        try writer["Description"].write(value.description)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRegistryInput {

    static func write(value: CreateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSchemaInput {

    static func write(value: CreateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension GetDiscoveredSchemaInput {

    static func write(value: GetDiscoveredSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["RevisionId"].write(value.revisionId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDiscovererInput {

    static func write(value: UpdateDiscovererInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossAccount"].write(value.crossAccount)
        try writer["Description"].write(value.description)
    }
}

extension UpdateRegistryInput {

    static func write(value: UpdateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension UpdateSchemaInput {

    static func write(value: UpdateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientTokenId"].write(value.clientTokenId)
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["Type"].write(value.type)
    }
}

extension CreateDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaOutput()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeleteDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDiscovererOutput {
        return DeleteDiscovererOutput()
    }
}

extension DeleteRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistryOutput {
        return DeleteRegistryOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaOutput {
        return DeleteSchemaOutput()
    }
}

extension DeleteSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaVersionOutput {
        return DeleteSchemaVersionOutput()
    }
}

extension DescribeCodeBindingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCodeBindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCodeBindingOutput()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ExportSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetCodeBindingSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeBindingSourceOutput {
        var value = GetCodeBindingSourceOutput()
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension GetDiscoveredSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDiscoveredSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDiscoveredSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension ListDiscoverersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDiscoverersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDiscoverersOutput()
        value.discoverers = try reader["Discoverers"].readListIfPresent(memberReadingClosure: SchemasClientTypes.DiscovererSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRegistriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegistriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegistriesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registries = try reader["Registries"].readListIfPresent(memberReadingClosure: SchemasClientTypes.RegistrySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemaVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaVersions = try reader["SchemaVersions"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SchemaVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutCodeBindingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutCodeBindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutCodeBindingOutput()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension SearchSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SearchSchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDiscovererOutput()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension StopDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopDiscovererOutput()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDiscovererOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSchemaOutput()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

enum CreateDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCodeBindingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeBindingSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDiscoveredSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDiscoverersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegistriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemaVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutCodeBindingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "GoneException": return try GoneException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDiscovererOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GoneException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GoneException {
        let reader = baseError.errorBodyReader
        var value = GoneException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.code = try reader["Code"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchemasClientTypes.DiscovererSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.DiscovererSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.DiscovererSummary()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes.RegistrySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.RegistrySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.RegistrySummary()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes.SchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SchemaSummary()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.versionCount = try reader["VersionCount"].readIfPresent()
        return value
    }
}

extension SchemasClientTypes.SchemaVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SchemaVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SchemaVersionSummary()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SchemasClientTypes.SearchSchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SearchSchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SearchSchemaSummary()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersions = try reader["SchemaVersions"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SearchSchemaVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes.SearchSchemaVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SearchSchemaVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SearchSchemaVersionSummary()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

public enum SchemasClientTypes {}
