// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum CodeGenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeGenerationStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeGenerationStatus(rawValue: rawValue) ?? CodeGenerationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDiscovererInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct CreateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true).
    public var crossAccount: Swift.Bool?
    /// A description for the discoverer.
    public var description: Swift.String?
    /// The ARN of the event bus.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

struct CreateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let sourceArn: Swift.String?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct CreateDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct CreateRegistryInput: Swift.Equatable {
    /// A description of the registry to be created.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Tags to associate with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The source of the schema definition.
    /// This member is required.
    public var content: Swift.String?
    /// A description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Tags associated with the schema.
    public var tags: [Swift.String:Swift.String]?
    /// The type of schema.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init (
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Swift.Equatable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init (
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct CreateSchemaOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension CreateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

extension DeleteDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DeleteDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DeleteDiscovererInputBody: Swift.Equatable {
}

extension DeleteDiscovererInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDiscovererOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DeleteRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteRegistryInputBody: Swift.Equatable {
}

extension DeleteRegistryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRegistryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
}

extension DeleteSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSchemaVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let schemaVersion = schemaVersion else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/version/\(schemaVersion.urlPercentEncoding())"
    }
}

public struct DeleteSchemaVersionInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The version number of the schema
    /// This member is required.
    public var schemaVersion: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DeleteSchemaVersionInputBody: Swift.Equatable {
}

extension DeleteSchemaVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSchemaVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaVersionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct DescribeCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeCodeBindingInputBody: Swift.Equatable {
}

extension DescribeCodeBindingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCodeBindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeBindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeCodeBindingOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .badRequestException: return "BadRequestException"
        case .forbiddenException: return "ForbiddenException"
        case .internalServerErrorException: return "InternalServerErrorException"
        case .notFoundException: return "NotFoundException"
        case .tooManyRequestsException: return "TooManyRequestsException"
        case .unauthorizedException: return "UnauthorizedException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeCodeBindingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeBindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct DescribeCodeBindingOutputResponse: Swift.Equatable {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct DescribeCodeBindingOutputResponseBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension DescribeCodeBindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DescribeDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DescribeDiscovererInputBody: Swift.Equatable {
}

extension DescribeDiscovererInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct DescribeDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct DescribeDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DescribeRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DescribeRegistryInputBody: Swift.Equatable {
}

extension DescribeRegistryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct DescribeRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct DescribeRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeSchemaInputBody: Swift.Equatable {
}

extension DescribeSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.content = nil
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Swift.Equatable {
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init (
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct DescribeSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension DescribeSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

extension SchemasClientTypes {
    public enum DiscovererState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscovererState] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscovererState(rawValue: rawValue) ?? DiscovererState.sdkUnknown(rawValue)
        }
    }
}

extension SchemasClientTypes.DiscovererSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let discovererArn = self.discovererArn {
            try encodeContainer.encode(discovererArn, forKey: .discovererArn)
        }
        if let discovererId = self.discovererId {
            try encodeContainer.encode(discovererId, forKey: .discovererId)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct DiscovererSummary: Swift.Equatable {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public var crossAccount: Swift.Bool?
        /// The ARN of the discoverer.
        public var discovererArn: Swift.String?
        /// The ID of the discoverer.
        public var discovererId: Swift.String?
        /// The ARN of the event bus.
        public var sourceArn: Swift.String?
        /// The state of the discoverer.
        public var state: SchemasClientTypes.DiscovererState?
        /// Tags associated with the resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            crossAccount: Swift.Bool? = nil,
            discovererArn: Swift.String? = nil,
            discovererId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            state: SchemasClientTypes.DiscovererState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension ExportSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension ExportSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/export"
    }
}

public struct ExportSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?
    /// This member is required.
    public var type: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaInputBody: Swift.Equatable {
}

extension ExportSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.type = output.type
        } else {
            self.content = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.type = nil
        }
    }
}

public struct ExportSchemaOutputResponse: Swift.Equatable {
    public var content: Swift.String?
    public var schemaArn: Swift.String?
    public var schemaName: Swift.String?
    public var schemaVersion: Swift.String?
    public var type: Swift.String?

    public init (
        content: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let type: Swift.String?
}

extension ExportSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())/source"
    }
}

public struct GetCodeBindingSourceInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct GetCodeBindingSourceInputBody: Swift.Equatable {
}

extension GetCodeBindingSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCodeBindingSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeBindingSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCodeBindingSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeBindingSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct GetCodeBindingSourceOutputResponse: Swift.Equatable {
    public var body: ClientRuntime.Data?

    public init (
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

struct GetCodeBindingSourceOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetCodeBindingSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetDiscoveredSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for getdiscoveredschemaversioniteminput0 in events {
                try eventsContainer.encode(getdiscoveredschemaversioniteminput0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetDiscoveredSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discover"
    }
}

public struct GetDiscoveredSchemaInput: Swift.Equatable {
    /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
    /// This member is required.
    public var events: [Swift.String]?
    /// The type of event.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init (
        events: [Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

struct GetDiscoveredSchemaInputBody: Swift.Equatable {
    let events: [Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension GetDiscoveredSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GetDiscoveredSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoveredSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDiscoveredSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoveredSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDiscoveredSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetDiscoveredSchemaOutputResponse: Swift.Equatable {
    /// The source of the schema definition.
    public var content: Swift.String?

    public init (
        content: Swift.String? = nil
    )
    {
        self.content = content
    }
}

struct GetDiscoveredSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
}

extension GetDiscoveredSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GoneException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct GoneException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct GoneExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension GoneExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDiscoverersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sourceArnPrefix = sourceArnPrefix {
                let sourceArnPrefixQueryItem = ClientRuntime.URLQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: Swift.String(sourceArnPrefix).urlPercentEncoding())
                items.append(sourceArnPrefixQueryItem)
            }
            if let discovererIdPrefix = discovererIdPrefix {
                let discovererIdPrefixQueryItem = ClientRuntime.URLQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: Swift.String(discovererIdPrefix).urlPercentEncoding())
                items.append(discovererIdPrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListDiscoverersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct ListDiscoverersInput: Swift.Equatable {
    /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
    public var discovererIdPrefix: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those ARNs that start with the specified prefix.
    public var sourceArnPrefix: Swift.String?

    public init (
        discovererIdPrefix: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceArnPrefix: Swift.String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

struct ListDiscoverersInputBody: Swift.Equatable {
}

extension ListDiscoverersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDiscoverersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoverersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDiscoverersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoverersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDiscoverersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discoverers = output.discoverers
            self.nextToken = output.nextToken
        } else {
            self.discoverers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoverersOutputResponse: Swift.Equatable {
    /// An array of DiscovererSummary information.
    public var discoverers: [SchemasClientTypes.DiscovererSummary]?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?

    public init (
        discoverers: [SchemasClientTypes.DiscovererSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

struct ListDiscoverersOutputResponseBody: Swift.Equatable {
    let discoverers: [SchemasClientTypes.DiscovererSummary]?
    let nextToken: Swift.String?
}

extension ListDiscoverersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoverers = "Discoverers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoverersContainer = try containerValues.decodeIfPresent([SchemasClientTypes.DiscovererSummary?].self, forKey: .discoverers)
        var discoverersDecoded0:[SchemasClientTypes.DiscovererSummary]? = nil
        if let discoverersContainer = discoverersContainer {
            discoverersDecoded0 = [SchemasClientTypes.DiscovererSummary]()
            for structure0 in discoverersContainer {
                if let structure0 = structure0 {
                    discoverersDecoded0?.append(structure0)
                }
            }
        }
        discoverers = discoverersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRegistriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let scope = scope {
                let scopeQueryItem = ClientRuntime.URLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope).urlPercentEncoding())
                items.append(scopeQueryItem)
            }
            if let registryNamePrefix = registryNamePrefix {
                let registryNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: Swift.String(registryNamePrefix).urlPercentEncoding())
                items.append(registryNamePrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListRegistriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/registries"
    }
}

public struct ListRegistriesInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those registry names that start with the specified prefix.
    public var registryNamePrefix: Swift.String?
    /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
    public var scope: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryNamePrefix: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

struct ListRegistriesInputBody: Swift.Equatable {
}

extension ListRegistriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRegistriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegistriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRegistriesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegistriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct ListRegistriesOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of registry summaries.
    public var registries: [SchemasClientTypes.RegistrySummary]?

    public init (
        nextToken: Swift.String? = nil,
        registries: [SchemasClientTypes.RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct ListRegistriesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let registries: [SchemasClientTypes.RegistrySummary]?
}

extension ListRegistriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registries = "Registries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let registriesContainer = try containerValues.decodeIfPresent([SchemasClientTypes.RegistrySummary?].self, forKey: .registries)
        var registriesDecoded0:[SchemasClientTypes.RegistrySummary]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [SchemasClientTypes.RegistrySummary]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
    }
}

extension ListSchemaVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListSchemaVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/versions"
    }
}

public struct ListSchemaVersionsInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct ListSchemaVersionsInputBody: Swift.Equatable {
}

extension ListSchemaVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemaVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemaVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSchemaVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemaVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSchemaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaVersions = output.schemaVersions
        } else {
            self.nextToken = nil
            self.schemaVersions = nil
        }
    }
}

public struct ListSchemaVersionsOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema version summaries.
    public var schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemaVersions: [SchemasClientTypes.SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

struct ListSchemaVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?
}

extension ListSchemaVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaVersions = "SchemaVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension ListSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let schemaNamePrefix = schemaNamePrefix {
                let schemaNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: Swift.String(schemaNamePrefix).urlPercentEncoding())
                items.append(schemaNamePrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Specifying this limits the results to only those schema names that start with the specified prefix.
    public var schemaNamePrefix: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaNamePrefix: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

struct ListSchemasInputBody: Swift.Equatable {
}

extension ListSchemasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSchemasOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema summaries.
    public var schemas: [SchemasClientTypes.SchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SchemaSummary]?
}

extension ListSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension PutCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct PutCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct PutCodeBindingInputBody: Swift.Equatable {
}

extension PutCodeBindingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PutCodeBindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCodeBindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GoneException" : self = .goneException(try GoneException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutCodeBindingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case goneException(GoneException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCodeBindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct PutCodeBindingOutputResponse: Swift.Equatable {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct PutCodeBindingOutputResponseBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension PutCodeBindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

/// The name of the policy.
public struct PutResourcePolicyInput: Swift.Equatable {
    /// The resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        registryName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension SchemasClientTypes.RegistrySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryArn = self.registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = self.registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct RegistrySummary: Swift.Equatable {
        /// The ARN of the registry.
        public var registryArn: Swift.String?
        /// The name of the registry.
        public var registryName: Swift.String?
        /// Tags associated with the registry.
        public var tags: [Swift.String:Swift.String]?

        public init (
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }
    }

}

extension SchemasClientTypes.SchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case tags = "tags"
        case versionCount = "VersionCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionCount = self.versionCount {
            try encodeContainer.encode(versionCount, forKey: .versionCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let versionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionCount)
        versionCount = versionCountDecoded
    }
}

extension SchemasClientTypes {
    /// A summary of schema details.
    public struct SchemaSummary: Swift.Equatable {
        /// The date and time that schema was modified.
        public var lastModified: ClientRuntime.Date?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// Tags associated with the schema.
        public var tags: [Swift.String:Swift.String]?
        /// The number of versions available for the schema.
        public var versionCount: Swift.Int?

        public init (
            lastModified: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            versionCount: Swift.Int? = nil
        )
        {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }
    }

}

extension SchemasClientTypes.SchemaVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SchemaVersionSummary: Swift.Equatable {
        /// The ARN of the schema version.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// The version number of the schema.
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init (
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SchemasClientTypes.SearchSchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersions = "SchemaVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryName = self.registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersions = schemaVersions {
            var schemaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaVersions)
            for searchschemaversionsummary0 in schemaVersions {
                try schemaVersionsContainer.encode(searchschemaversionsummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SearchSchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaSummary: Swift.Equatable {
        /// The name of the registry.
        public var registryName: Swift.String?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// An array of schema version summaries.
        public var schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]?

        public init (
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }
    }

}

extension SchemasClientTypes.SearchSchemaVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaVersionSummary: Swift.Equatable {
        /// The date the schema version was created.
        public var createdDate: ClientRuntime.Date?
        /// The version number of the schema
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SearchSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let keywords = keywords else {
                let message = "Creating a URL Query Item failed. keywords is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let keywordsQueryItem = ClientRuntime.URLQueryItem(name: "keywords".urlPercentEncoding(), value: Swift.String(keywords).urlPercentEncoding())
            items.append(keywordsQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension SearchSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/search"
    }
}

public struct SearchSchemasInput: Swift.Equatable {
    /// Specifying this limits the results to only schemas that include the provided keywords.
    /// This member is required.
    public var keywords: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init (
        keywords: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

struct SearchSchemasInputBody: Swift.Equatable {
}

extension SearchSchemasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SearchSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchSchemasOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct SearchSchemasOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of SearchSchemaSummary information.
    public var schemas: [SchemasClientTypes.SearchSchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct SearchSchemasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SearchSchemaSummary]?
}

extension SearchSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SearchSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SearchSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/start"
    }
}

public struct StartDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StartDiscovererInputBody: Swift.Equatable {
}

extension StartDiscovererInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StartDiscovererOutputResponse: Swift.Equatable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init (
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StartDiscovererOutputResponseBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StartDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

extension StopDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/stop"
    }
}

public struct StopDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StopDiscovererInputBody: Swift.Equatable {
}

extension StopDiscovererInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StopDiscovererOutputResponse: Swift.Equatable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init (
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StopDiscovererOutputResponseBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StopDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonschemadraft4
        case openapi3
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .jsonschemadraft4,
                .openapi3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonschemadraft4: return "JSONSchemaDraft4"
            case .openapi3: return "OpenApi3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDiscovererInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct UpdateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true)
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer to update.
    public var description: Swift.String?
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererId: Swift.String? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererId = discovererId
    }
}

struct UpdateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let crossAccount: Swift.Bool?
}

extension UpdateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
    }
}

extension UpdateDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct UpdateDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct UpdateDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRegistryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

/// Updates the registry.
public struct UpdateRegistryInput: Swift.Equatable {
    /// The description of the registry to update.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init (
        description: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

struct UpdateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct UpdateRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientTokenId = self.clientTokenId {
            try encodeContainer.encode(clientTokenId, forKey: .clientTokenId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct UpdateSchemaInput: Swift.Equatable {
    /// The ID of the client token.
    public var clientTokenId: Swift.String?
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The schema type for the events schema.
    public var type: SchemasClientTypes.ModelType?

    public init (
        clientTokenId: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

struct UpdateSchemaInputBody: Swift.Equatable {
    let clientTokenId: Swift.String?
    let content: Swift.String?
    let description: Swift.String?
    let type: SchemasClientTypes.ModelType?
}

extension UpdateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientTokenId)
        clientTokenId = clientTokenIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Swift.Equatable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init (
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct UpdateSchemaOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension UpdateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}
