// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension SchemasClientTypes {

    public enum CodeGenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeGenerationStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CreateDiscovererInput {

    static func urlPathProvider(_ value: CreateDiscovererInput) -> Swift.String? {
        return "/v1/discoverers"
    }
}

extension CreateDiscovererInput {

    static func write(value: CreateDiscovererInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossAccount"].write(value.crossAccount)
        try writer["Description"].write(value.description)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateDiscovererInput {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true).
    public var crossAccount: Swift.Bool?
    /// A description for the discoverer.
    public var description: Swift.String?
    /// The ARN of the event bus.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

extension CreateDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateDiscovererOutput {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

enum CreateDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateRegistryInput {

    static func urlPathProvider(_ value: CreateRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension CreateRegistryInput {

    static func write(value: CreateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateRegistryInput {
    /// A description of the registry to be created.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Tags to associate with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

extension CreateRegistryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateRegistryOutput {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

enum CreateRegistryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSchemaInput {

    static func urlPathProvider(_ value: CreateSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension CreateSchemaInput {

    static func write(value: CreateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

public struct CreateSchemaInput {
    /// The source of the schema definition.
    /// This member is required.
    public var content: Swift.String?
    /// A description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Tags associated with the schema.
    public var tags: [Swift.String:Swift.String]?
    /// The type of schema.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

extension CreateSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaOutput()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct CreateSchemaOutput {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

enum CreateSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDiscovererInput {

    static func urlPathProvider(_ value: DeleteDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DeleteDiscovererInput {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension DeleteDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDiscovererOutput {
        return DeleteDiscovererOutput()
    }
}

public struct DeleteDiscovererOutput {

    public init() { }
}

enum DeleteDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRegistryInput {

    static func urlPathProvider(_ value: DeleteRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DeleteRegistryInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DeleteRegistryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRegistryOutput {
        return DeleteRegistryOutput()
    }
}

public struct DeleteRegistryOutput {

    public init() { }
}

enum DeleteRegistryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteResourcePolicyInput {

    static func queryItemProvider(_ value: DeleteResourcePolicyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

public struct DeleteResourcePolicyInput {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSchemaInput {

    static func urlPathProvider(_ value: DeleteSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

extension DeleteSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSchemaOutput {
        return DeleteSchemaOutput()
    }
}

public struct DeleteSchemaOutput {

    public init() { }
}

enum DeleteSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSchemaVersionInput {

    static func urlPathProvider(_ value: DeleteSchemaVersionInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let schemaVersion = value.schemaVersion else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/version/\(schemaVersion.urlPercentEncoding())"
    }
}

public struct DeleteSchemaVersionInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The version number of the schema
    /// This member is required.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DeleteSchemaVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSchemaVersionOutput {
        return DeleteSchemaVersionOutput()
    }
}

public struct DeleteSchemaVersionOutput {

    public init() { }
}

enum DeleteSchemaVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeCodeBindingInput {

    static func queryItemProvider(_ value: DescribeCodeBindingInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension DescribeCodeBindingInput {

    static func urlPathProvider(_ value: DescribeCodeBindingInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct DescribeCodeBindingInput {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DescribeCodeBindingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeCodeBindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCodeBindingOutput()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

public struct DescribeCodeBindingOutput {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

enum DescribeCodeBindingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeDiscovererInput {

    static func urlPathProvider(_ value: DescribeDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DescribeDiscovererInput {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension DescribeDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct DescribeDiscovererOutput {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

enum DescribeDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeRegistryInput {

    static func urlPathProvider(_ value: DescribeRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DescribeRegistryInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DescribeRegistryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct DescribeRegistryOutput {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

enum DescribeRegistryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeSchemaInput {

    static func queryItemProvider(_ value: DescribeSchemaInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension DescribeSchemaInput {

    static func urlPathProvider(_ value: DescribeSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DescribeSchemaInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DescribeSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeSchemaOutput {
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

enum DescribeSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SchemasClientTypes {

    public enum DiscovererState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscovererState] {
            return [
                .started,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SchemasClientTypes.DiscovererSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.DiscovererSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.DiscovererSummary()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes {
    public struct DiscovererSummary {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public var crossAccount: Swift.Bool?
        /// The ARN of the discoverer.
        public var discovererArn: Swift.String?
        /// The ID of the discoverer.
        public var discovererId: Swift.String?
        /// The ARN of the event bus.
        public var sourceArn: Swift.String?
        /// The state of the discoverer.
        public var state: SchemasClientTypes.DiscovererState?
        /// Tags associated with the resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            crossAccount: Swift.Bool? = nil,
            discovererArn: Swift.String? = nil,
            discovererId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            state: SchemasClientTypes.DiscovererState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension ExportSchemaInput {

    static func queryItemProvider(_ value: ExportSchemaInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
        items.append(typeQueryItem)
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension ExportSchemaInput {

    static func urlPathProvider(_ value: ExportSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/export"
    }
}

public struct ExportSchemaInput {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?
    /// This member is required.
    public var type: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

extension ExportSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ExportSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

public struct ExportSchemaOutput {
    public var content: Swift.String?
    public var schemaArn: Swift.String?
    public var schemaName: Swift.String?
    public var schemaVersion: Swift.String?
    public var type: Swift.String?

    public init(
        content: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

enum ExportSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension GetCodeBindingSourceInput {

    static func queryItemProvider(_ value: GetCodeBindingSourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension GetCodeBindingSourceInput {

    static func urlPathProvider(_ value: GetCodeBindingSourceInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())/source"
    }
}

public struct GetCodeBindingSourceInput {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension GetCodeBindingSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCodeBindingSourceOutput {
        var value = GetCodeBindingSourceOutput()
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

public struct GetCodeBindingSourceOutput {
    public var body: ClientRuntime.Data?

    public init(
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

enum GetCodeBindingSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDiscoveredSchemaInput {

    static func urlPathProvider(_ value: GetDiscoveredSchemaInput) -> Swift.String? {
        return "/v1/discover"
    }
}

extension GetDiscoveredSchemaInput {

    static func write(value: GetDiscoveredSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Events"].writeList(value.events, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

public struct GetDiscoveredSchemaInput {
    /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
    /// This member is required.
    public var events: [Swift.String]?
    /// The type of event.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        events: [Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

extension GetDiscoveredSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDiscoveredSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDiscoveredSchemaOutput()
        value.content = try reader["Content"].readIfPresent()
        return value
    }
}

public struct GetDiscoveredSchemaOutput {
    /// The source of the schema definition.
    public var content: Swift.String?

    public init(
        content: Swift.String? = nil
    )
    {
        self.content = content
    }
}

enum GetDiscoveredSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetResourcePolicyInput {

    static func queryItemProvider(_ value: GetResourcePolicyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

public struct GetResourcePolicyInput {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

public struct GetResourcePolicyOutput {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GoneException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GoneException {
        let reader = baseError.errorBodyReader
        var value = GoneException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct GoneException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GoneException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension ListDiscoverersInput {

    static func queryItemProvider(_ value: ListDiscoverersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sourceArnPrefix = value.sourceArnPrefix {
            let sourceArnPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: Swift.String(sourceArnPrefix).urlPercentEncoding())
            items.append(sourceArnPrefixQueryItem)
        }
        if let discovererIdPrefix = value.discovererIdPrefix {
            let discovererIdPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: Swift.String(discovererIdPrefix).urlPercentEncoding())
            items.append(discovererIdPrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = ClientRuntime.SDKURLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListDiscoverersInput {

    static func urlPathProvider(_ value: ListDiscoverersInput) -> Swift.String? {
        return "/v1/discoverers"
    }
}

public struct ListDiscoverersInput {
    /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
    public var discovererIdPrefix: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those ARNs that start with the specified prefix.
    public var sourceArnPrefix: Swift.String?

    public init(
        discovererIdPrefix: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceArnPrefix: Swift.String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

extension ListDiscoverersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDiscoverersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDiscoverersOutput()
        value.discoverers = try reader["Discoverers"].readListIfPresent(memberReadingClosure: SchemasClientTypes.DiscovererSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDiscoverersOutput {
    /// An array of DiscovererSummary information.
    public var discoverers: [SchemasClientTypes.DiscovererSummary]?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?

    public init(
        discoverers: [SchemasClientTypes.DiscovererSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

enum ListDiscoverersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRegistriesInput {

    static func queryItemProvider(_ value: ListRegistriesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let scope = value.scope {
            let scopeQueryItem = ClientRuntime.SDKURLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope).urlPercentEncoding())
            items.append(scopeQueryItem)
        }
        if let registryNamePrefix = value.registryNamePrefix {
            let registryNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: Swift.String(registryNamePrefix).urlPercentEncoding())
            items.append(registryNamePrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = ClientRuntime.SDKURLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListRegistriesInput {

    static func urlPathProvider(_ value: ListRegistriesInput) -> Swift.String? {
        return "/v1/registries"
    }
}

public struct ListRegistriesInput {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those registry names that start with the specified prefix.
    public var registryNamePrefix: Swift.String?
    /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
    public var scope: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryNamePrefix: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

extension ListRegistriesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRegistriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegistriesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registries = try reader["Registries"].readListIfPresent(memberReadingClosure: SchemasClientTypes.RegistrySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListRegistriesOutput {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of registry summaries.
    public var registries: [SchemasClientTypes.RegistrySummary]?

    public init(
        nextToken: Swift.String? = nil,
        registries: [SchemasClientTypes.RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

enum ListRegistriesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSchemaVersionsInput {

    static func queryItemProvider(_ value: ListSchemaVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = ClientRuntime.SDKURLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemaVersionsInput {

    static func urlPathProvider(_ value: ListSchemaVersionsInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/versions"
    }
}

public struct ListSchemaVersionsInput {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

extension ListSchemaVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaVersions = try reader["SchemaVersions"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SchemaVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSchemaVersionsOutput {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema version summaries.
    public var schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaVersions: [SchemasClientTypes.SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

enum ListSchemaVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSchemasInput {

    static func queryItemProvider(_ value: ListSchemasInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let schemaNamePrefix = value.schemaNamePrefix {
            let schemaNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: Swift.String(schemaNamePrefix).urlPercentEncoding())
            items.append(schemaNamePrefixQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = ClientRuntime.SDKURLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas"
    }
}

public struct ListSchemasInput {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Specifying this limits the results to only those schema names that start with the specified prefix.
    public var schemaNamePrefix: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaNamePrefix: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSchemasOutput {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema summaries.
    public var schemas: [SchemasClientTypes.SchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension PutCodeBindingInput {

    static func queryItemProvider(_ value: PutCodeBindingInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let schemaVersion = value.schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension PutCodeBindingInput {

    static func urlPathProvider(_ value: PutCodeBindingInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        guard let language = value.language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct PutCodeBindingInput {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension PutCodeBindingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutCodeBindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutCodeBindingOutput()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

public struct PutCodeBindingOutput {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

enum PutCodeBindingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "GoneException": return try GoneException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutResourcePolicyInput {

    static func queryItemProvider(_ value: PutResourcePolicyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let registryName = value.registryName {
            let registryNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/v1/policy"
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["RevisionId"].write(value.revisionId)
    }
}

/// The name of the policy.
public struct PutResourcePolicyInput {
    /// The resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        registryName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

public struct PutResourcePolicyOutput {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SchemasClientTypes.RegistrySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.RegistrySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.RegistrySummary()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes {
    public struct RegistrySummary {
        /// The ARN of the registry.
        public var registryArn: Swift.String?
        /// The name of the registry.
        public var registryName: Swift.String?
        /// Tags associated with the registry.
        public var tags: [Swift.String:Swift.String]?

        public init(
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }
    }

}

extension SchemasClientTypes.SchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SchemaSummary()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.versionCount = try reader["VersionCount"].readIfPresent()
        return value
    }
}

extension SchemasClientTypes {
    /// A summary of schema details.
    public struct SchemaSummary {
        /// The date and time that schema was modified.
        public var lastModified: ClientRuntime.Date?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// Tags associated with the schema.
        public var tags: [Swift.String:Swift.String]?
        /// The number of versions available for the schema.
        public var versionCount: Swift.Int?

        public init(
            lastModified: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            versionCount: Swift.Int? = nil
        )
        {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }
    }

}

extension SchemasClientTypes.SchemaVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SchemaVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SchemaVersionSummary()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SchemasClientTypes {
    public struct SchemaVersionSummary {
        /// The ARN of the schema version.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// The version number of the schema.
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

public enum SchemasClientTypes {}

extension SchemasClientTypes.SearchSchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SearchSchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SearchSchemaSummary()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersions = try reader["SchemaVersions"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SearchSchemaVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaSummary {
        /// The name of the registry.
        public var registryName: Swift.String?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// An array of schema version summaries.
        public var schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]?

        public init(
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }
    }

}

extension SchemasClientTypes.SearchSchemaVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SchemasClientTypes.SearchSchemaVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SchemasClientTypes.SearchSchemaVersionSummary()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: .dateTime)
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaVersionSummary {
        /// The date the schema version was created.
        public var createdDate: ClientRuntime.Date?
        /// The version number of the schema
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SearchSchemasInput {

    static func queryItemProvider(_ value: SearchSchemasInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let keywords = value.keywords else {
            let message = "Creating a URL Query Item failed. keywords is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let keywordsQueryItem = ClientRuntime.SDKURLQueryItem(name: "keywords".urlPercentEncoding(), value: Swift.String(keywords).urlPercentEncoding())
        items.append(keywordsQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = ClientRuntime.SDKURLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension SearchSchemasInput {

    static func urlPathProvider(_ value: SearchSchemasInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/search"
    }
}

public struct SearchSchemasInput {
    /// Specifying this limits the results to only schemas that include the provided keywords.
    /// This member is required.
    public var keywords: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        keywords: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

extension SearchSchemasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SchemasClientTypes.SearchSchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct SearchSchemasOutput {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of SearchSchemaSummary information.
    public var schemas: [SchemasClientTypes.SearchSchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

enum SearchSchemasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension StartDiscovererInput {

    static func urlPathProvider(_ value: StartDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/start"
    }
}

public struct StartDiscovererInput {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension StartDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDiscovererOutput()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct StartDiscovererOutput {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

enum StartDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopDiscovererInput {

    static func urlPathProvider(_ value: StopDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/stop"
    }
}

public struct StopDiscovererInput {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension StopDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopDiscovererOutput()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct StopDiscovererOutput {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

enum StopDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

///
public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension SchemasClientTypes {

    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonschemadraft4
        case openapi3
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .jsonschemadraft4,
                .openapi3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonschemadraft4: return "JSONSchemaDraft4"
            case .openapi3: return "OpenApi3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDiscovererInput {

    static func urlPathProvider(_ value: UpdateDiscovererInput) -> Swift.String? {
        guard let discovererId = value.discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

extension UpdateDiscovererInput {

    static func write(value: UpdateDiscovererInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossAccount"].write(value.crossAccount)
        try writer["Description"].write(value.description)
    }
}

public struct UpdateDiscovererInput {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true)
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer to update.
    public var description: Swift.String?
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererId: Swift.String? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererId = discovererId
    }
}

extension UpdateDiscovererOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDiscovererOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDiscovererOutput()
        value.crossAccount = try reader["CrossAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.discovererArn = try reader["DiscovererArn"].readIfPresent()
        value.discovererId = try reader["DiscovererId"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct UpdateDiscovererOutput {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

enum UpdateDiscovererOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRegistryInput {

    static func urlPathProvider(_ value: UpdateRegistryInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

extension UpdateRegistryInput {

    static func write(value: UpdateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

/// Updates the registry.
public struct UpdateRegistryInput {
    /// The description of the registry to update.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

extension UpdateRegistryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct UpdateRegistryOutput {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

enum UpdateRegistryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSchemaInput {

    static func urlPathProvider(_ value: UpdateSchemaInput) -> Swift.String? {
        guard let registryName = value.registryName else {
            return nil
        }
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

extension UpdateSchemaInput {

    static func write(value: UpdateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientTokenId"].write(value.clientTokenId)
        try writer["Content"].write(value.content)
        try writer["Description"].write(value.description)
        try writer["Type"].write(value.type)
    }
}

public struct UpdateSchemaInput {
    /// The ID of the client token.
    public var clientTokenId: Swift.String?
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The schema type for the events schema.
    public var type: SchemasClientTypes.ModelType?

    public init(
        clientTokenId: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

extension UpdateSchemaOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSchemaOutput()
        value.description = try reader["Description"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: .dateTime)
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.versionCreatedDate = try reader["VersionCreatedDate"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateSchemaOutput {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

enum UpdateSchemaOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}
