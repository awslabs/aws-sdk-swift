// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum CodeGenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeGenerationStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeGenerationStatus(rawValue: rawValue) ?? CodeGenerationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDiscovererInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct CreateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true).
    public var crossAccount: Swift.Bool?
    /// A description for the discoverer.
    public var description: Swift.String?
    /// The ARN of the event bus.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

struct CreateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let sourceArn: Swift.String?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDiscovererOutputBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateDiscovererOutput: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct CreateDiscovererOutputBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRegistryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct CreateRegistryInput: Swift.Equatable {
    /// A description of the registry to be created.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Tags to associate with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRegistryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistryOutput: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryOutputBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateRegistryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The source of the schema definition.
    /// This member is required.
    public var content: Swift.String?
    /// A description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Tags associated with the schema.
    public var tags: [Swift.String:Swift.String]?
    /// The type of schema.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct CreateSchemaOutput: Swift.Equatable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct CreateSchemaOutputBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension CreateSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

enum CreateSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DeleteDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DeleteDiscovererInputBody: Swift.Equatable {
}

extension DeleteDiscovererInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDiscovererOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DeleteRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteRegistryInputBody: Swift.Equatable {
}

extension DeleteRegistryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRegistryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRegistryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRegistryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
}

extension DeleteSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSchemaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let schemaVersion = schemaVersion else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/version/\(schemaVersion.urlPercentEncoding())"
    }
}

public struct DeleteSchemaVersionInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The version number of the schema
    /// This member is required.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DeleteSchemaVersionInputBody: Swift.Equatable {
}

extension DeleteSchemaVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSchemaVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSchemaVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct DescribeCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeCodeBindingInputBody: Swift.Equatable {
}

extension DescribeCodeBindingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCodeBindingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCodeBindingOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct DescribeCodeBindingOutput: Swift.Equatable {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct DescribeCodeBindingOutputBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension DescribeCodeBindingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeCodeBindingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DescribeDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct DescribeDiscovererInputBody: Swift.Equatable {
}

extension DescribeDiscovererInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDiscovererOutputBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct DescribeDiscovererOutput: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct DescribeDiscovererOutputBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeDiscovererOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DescribeRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct DescribeRegistryInputBody: Swift.Equatable {
}

extension DescribeRegistryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegistryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct DescribeRegistryOutput: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct DescribeRegistryOutputBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRegistryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeRegistryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct DescribeSchemaInputBody: Swift.Equatable {
}

extension DescribeSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.content = nil
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct DescribeSchemaOutput: Swift.Equatable {
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct DescribeSchemaOutputBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension DescribeSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

enum DescribeSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SchemasClientTypes {
    public enum DiscovererState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscovererState] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscovererState(rawValue: rawValue) ?? DiscovererState.sdkUnknown(rawValue)
        }
    }
}

extension SchemasClientTypes.DiscovererSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let discovererArn = self.discovererArn {
            try encodeContainer.encode(discovererArn, forKey: .discovererArn)
        }
        if let discovererId = self.discovererId {
            try encodeContainer.encode(discovererId, forKey: .discovererId)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct DiscovererSummary: Swift.Equatable {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        public var crossAccount: Swift.Bool?
        /// The ARN of the discoverer.
        public var discovererArn: Swift.String?
        /// The ID of the discoverer.
        public var discovererId: Swift.String?
        /// The ARN of the event bus.
        public var sourceArn: Swift.String?
        /// The state of the discoverer.
        public var state: SchemasClientTypes.DiscovererState?
        /// Tags associated with the resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            crossAccount: Swift.Bool? = nil,
            discovererArn: Swift.String? = nil,
            discovererId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            state: SchemasClientTypes.DiscovererState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension ExportSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension ExportSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/export"
    }
}

public struct ExportSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?
    /// This member is required.
    public var type: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaInputBody: Swift.Equatable {
}

extension ExportSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.type = output.type
        } else {
            self.content = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.type = nil
        }
    }
}

public struct ExportSchemaOutput: Swift.Equatable {
    public var content: Swift.String?
    public var schemaArn: Swift.String?
    public var schemaName: Swift.String?
    public var schemaVersion: Swift.String?
    public var type: Swift.String?

    public init(
        content: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaOutputBody: Swift.Equatable {
    let content: Swift.String?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let type: Swift.String?
}

extension ExportSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

enum ExportSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())/source"
    }
}

public struct GetCodeBindingSourceInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct GetCodeBindingSourceInputBody: Swift.Equatable {
}

extension GetCodeBindingSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCodeBindingSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.body = data
        case .stream(let stream):
            self.body = try stream.readToEnd()
        case .none:
            self.body = nil
        }
    }
}

public struct GetCodeBindingSourceOutput: Swift.Equatable {
    public var body: ClientRuntime.Data?

    public init(
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

struct GetCodeBindingSourceOutputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetCodeBindingSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

enum GetCodeBindingSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDiscoveredSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for getdiscoveredschemaversioniteminput0 in events {
                try eventsContainer.encode(getdiscoveredschemaversioniteminput0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetDiscoveredSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discover"
    }
}

public struct GetDiscoveredSchemaInput: Swift.Equatable {
    /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
    /// This member is required.
    public var events: [Swift.String]?
    /// The type of event.
    /// This member is required.
    public var type: SchemasClientTypes.ModelType?

    public init(
        events: [Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

struct GetDiscoveredSchemaInputBody: Swift.Equatable {
    let events: [Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension GetDiscoveredSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GetDiscoveredSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDiscoveredSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetDiscoveredSchemaOutput: Swift.Equatable {
    /// The source of the schema definition.
    public var content: Swift.String?

    public init(
        content: Swift.String? = nil
    )
    {
        self.content = content
    }
}

struct GetDiscoveredSchemaOutputBody: Swift.Equatable {
    let content: Swift.String?
}

extension GetDiscoveredSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

enum GetDiscoveredSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    public var registryName: Swift.String?

    public init(
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GoneException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct GoneException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GoneException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct GoneExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension GoneExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDiscoverersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sourceArnPrefix = sourceArnPrefix {
                let sourceArnPrefixQueryItem = ClientRuntime.URLQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: Swift.String(sourceArnPrefix).urlPercentEncoding())
                items.append(sourceArnPrefixQueryItem)
            }
            if let discovererIdPrefix = discovererIdPrefix {
                let discovererIdPrefixQueryItem = ClientRuntime.URLQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: Swift.String(discovererIdPrefix).urlPercentEncoding())
                items.append(discovererIdPrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListDiscoverersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct ListDiscoverersInput: Swift.Equatable {
    /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
    public var discovererIdPrefix: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those ARNs that start with the specified prefix.
    public var sourceArnPrefix: Swift.String?

    public init(
        discovererIdPrefix: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceArnPrefix: Swift.String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

struct ListDiscoverersInputBody: Swift.Equatable {
}

extension ListDiscoverersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDiscoverersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDiscoverersOutputBody = try responseDecoder.decode(responseBody: data)
            self.discoverers = output.discoverers
            self.nextToken = output.nextToken
        } else {
            self.discoverers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoverersOutput: Swift.Equatable {
    /// An array of DiscovererSummary information.
    public var discoverers: [SchemasClientTypes.DiscovererSummary]?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?

    public init(
        discoverers: [SchemasClientTypes.DiscovererSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

struct ListDiscoverersOutputBody: Swift.Equatable {
    let discoverers: [SchemasClientTypes.DiscovererSummary]?
    let nextToken: Swift.String?
}

extension ListDiscoverersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoverers = "Discoverers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoverersContainer = try containerValues.decodeIfPresent([SchemasClientTypes.DiscovererSummary?].self, forKey: .discoverers)
        var discoverersDecoded0:[SchemasClientTypes.DiscovererSummary]? = nil
        if let discoverersContainer = discoverersContainer {
            discoverersDecoded0 = [SchemasClientTypes.DiscovererSummary]()
            for structure0 in discoverersContainer {
                if let structure0 = structure0 {
                    discoverersDecoded0?.append(structure0)
                }
            }
        }
        discoverers = discoverersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDiscoverersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRegistriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let scope = scope {
                let scopeQueryItem = ClientRuntime.URLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope).urlPercentEncoding())
                items.append(scopeQueryItem)
            }
            if let registryNamePrefix = registryNamePrefix {
                let registryNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: Swift.String(registryNamePrefix).urlPercentEncoding())
                items.append(registryNamePrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListRegistriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/registries"
    }
}

public struct ListRegistriesInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// Specifying this limits the results to only those registry names that start with the specified prefix.
    public var registryNamePrefix: Swift.String?
    /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
    public var scope: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryNamePrefix: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

struct ListRegistriesInputBody: Swift.Equatable {
}

extension ListRegistriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRegistriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRegistriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct ListRegistriesOutput: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of registry summaries.
    public var registries: [SchemasClientTypes.RegistrySummary]?

    public init(
        nextToken: Swift.String? = nil,
        registries: [SchemasClientTypes.RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct ListRegistriesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let registries: [SchemasClientTypes.RegistrySummary]?
}

extension ListRegistriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registries = "Registries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let registriesContainer = try containerValues.decodeIfPresent([SchemasClientTypes.RegistrySummary?].self, forKey: .registries)
        var registriesDecoded0:[SchemasClientTypes.RegistrySummary]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [SchemasClientTypes.RegistrySummary]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
    }
}

enum ListRegistriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemaVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListSchemaVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/versions"
    }
}

public struct ListSchemaVersionsInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

struct ListSchemaVersionsInputBody: Swift.Equatable {
}

extension ListSchemaVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemaVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemaVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaVersions = output.schemaVersions
        } else {
            self.nextToken = nil
            self.schemaVersions = nil
        }
    }
}

public struct ListSchemaVersionsOutput: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema version summaries.
    public var schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaVersions: [SchemasClientTypes.SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

struct ListSchemaVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?
}

extension ListSchemaVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaVersions = "SchemaVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

enum ListSchemaVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let schemaNamePrefix = schemaNamePrefix {
                let schemaNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: Swift.String(schemaNamePrefix).urlPercentEncoding())
                items.append(schemaNamePrefixQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// Specifying this limits the results to only those schema names that start with the specified prefix.
    public var schemaNamePrefix: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaNamePrefix: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

struct ListSchemasInputBody: Swift.Equatable {
}

extension ListSchemasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutput: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of schema summaries.
    public var schemas: [SchemasClientTypes.SchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SchemaSummary]?
}

extension ListSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

enum ListSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let schemaVersion = schemaVersion {
                let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
                items.append(schemaVersionQueryItem)
            }
            return items
        }
    }
}

extension PutCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct PutCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    public var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    public var schemaVersion: Swift.String?

    public init(
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

struct PutCodeBindingInputBody: Swift.Equatable {
}

extension PutCodeBindingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PutCodeBindingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutCodeBindingOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct PutCodeBindingOutput: Swift.Equatable {
    /// The time and date that the code binding was created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    public var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    public var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    public var status: SchemasClientTypes.CodeGenerationStatus?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct PutCodeBindingOutputBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension PutCodeBindingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum PutCodeBindingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let registryName = registryName {
                let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
                items.append(registryNameQueryItem)
            }
            return items
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

/// The name of the policy.
public struct PutResourcePolicyInput: Swift.Equatable {
    /// The resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        registryName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// The revision ID of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SchemasClientTypes.RegistrySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryArn = self.registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = self.registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct RegistrySummary: Swift.Equatable {
        /// The ARN of the registry.
        public var registryArn: Swift.String?
        /// The name of the registry.
        public var registryName: Swift.String?
        /// Tags associated with the registry.
        public var tags: [Swift.String:Swift.String]?

        public init(
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }
    }

}

extension SchemasClientTypes.SchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case tags = "tags"
        case versionCount = "VersionCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionCount = self.versionCount {
            try encodeContainer.encode(versionCount, forKey: .versionCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let versionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionCount)
        versionCount = versionCountDecoded
    }
}

extension SchemasClientTypes {
    /// A summary of schema details.
    public struct SchemaSummary: Swift.Equatable {
        /// The date and time that schema was modified.
        public var lastModified: ClientRuntime.Date?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// Tags associated with the schema.
        public var tags: [Swift.String:Swift.String]?
        /// The number of versions available for the schema.
        public var versionCount: Swift.Int?

        public init(
            lastModified: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            versionCount: Swift.Int? = nil
        )
        {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }
    }

}

extension SchemasClientTypes.SchemaVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SchemaVersionSummary: Swift.Equatable {
        /// The ARN of the schema version.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// The version number of the schema.
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SchemasClientTypes.SearchSchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersions = "SchemaVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryName = self.registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersions = schemaVersions {
            var schemaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaVersions)
            for searchschemaversionsummary0 in schemaVersions {
                try schemaVersionsContainer.encode(searchschemaversionsummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SearchSchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaSummary: Swift.Equatable {
        /// The name of the registry.
        public var registryName: Swift.String?
        /// The ARN of the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// An array of schema version summaries.
        public var schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]?

        public init(
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }
    }

}

extension SchemasClientTypes.SearchSchemaVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaVersionSummary: Swift.Equatable {
        /// The date the schema version was created.
        public var createdDate: ClientRuntime.Date?
        /// The version number of the schema
        public var schemaVersion: Swift.String?
        /// The type of schema.
        public var type: SchemasClientTypes.ModelType?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SearchSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let keywords = keywords else {
                let message = "Creating a URL Query Item failed. keywords is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let keywordsQueryItem = ClientRuntime.URLQueryItem(name: "keywords".urlPercentEncoding(), value: Swift.String(keywords).urlPercentEncoding())
            items.append(keywordsQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension SearchSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/search"
    }
}

public struct SearchSchemasInput: Swift.Equatable {
    /// Specifying this limits the results to only schemas that include the provided keywords.
    /// This member is required.
    public var keywords: Swift.String?
    public var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        keywords: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

struct SearchSchemasInputBody: Swift.Equatable {
}

extension SearchSchemasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SearchSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct SearchSchemasOutput: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    public var nextToken: Swift.String?
    /// An array of SearchSchemaSummary information.
    public var schemas: [SchemasClientTypes.SearchSchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct SearchSchemasOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SearchSchemaSummary]?
}

extension SearchSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SearchSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SearchSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

enum SearchSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/start"
    }
}

public struct StartDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StartDiscovererInputBody: Swift.Equatable {
}

extension StartDiscovererInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDiscovererOutputBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StartDiscovererOutput: Swift.Equatable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StartDiscovererOutputBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StartDiscovererOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

enum StartDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/stop"
    }
}

public struct StopDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

struct StopDiscovererInputBody: Swift.Equatable {
}

extension StopDiscovererInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopDiscovererOutputBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StopDiscovererOutput: Swift.Equatable {
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?

    public init(
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StopDiscovererOutputBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StopDiscovererOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

enum StopDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonschemadraft4
        case openapi3
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .jsonschemadraft4,
                .openapi3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonschemadraft4: return "JSONSchemaDraft4"
            case .openapi3: return "OpenApi3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// The message string of the error output.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDiscovererInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = self.crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct UpdateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true)
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer to update.
    public var description: Swift.String?
    /// The ID of the discoverer.
    /// This member is required.
    public var discovererId: Swift.String?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererId: Swift.String? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererId = discovererId
    }
}

struct UpdateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let crossAccount: Swift.Bool?
}

extension UpdateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
    }
}

extension UpdateDiscovererOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDiscovererOutputBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct UpdateDiscovererOutput: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    public var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    public var description: Swift.String?
    /// The ARN of the discoverer.
    public var discovererArn: Swift.String?
    /// The ID of the discoverer.
    public var discovererId: Swift.String?
    /// The ARN of the event bus.
    public var sourceArn: Swift.String?
    /// The state of the discoverer.
    public var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct UpdateDiscovererOutputBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDiscovererOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateDiscovererOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRegistryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

/// Updates the registry.
public struct UpdateRegistryInput: Swift.Equatable {
    /// The description of the registry to update.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

struct UpdateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRegistryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRegistryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRegistryOutput: Swift.Equatable {
    /// The description of the registry.
    public var description: Swift.String?
    /// The ARN of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// Tags associated with the registry.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct UpdateRegistryOutputBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRegistryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateRegistryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientTokenId = self.clientTokenId {
            try encodeContainer.encode(clientTokenId, forKey: .clientTokenId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct UpdateSchemaInput: Swift.Equatable {
    /// The ID of the client token.
    public var clientTokenId: Swift.String?
    /// The source of the schema definition.
    public var content: Swift.String?
    /// The description of the schema.
    public var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    public var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The schema type for the events schema.
    public var type: SchemasClientTypes.ModelType?

    public init(
        clientTokenId: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

struct UpdateSchemaInputBody: Swift.Equatable {
    let clientTokenId: Swift.String?
    let content: Swift.String?
    let description: Swift.String?
    let type: SchemasClientTypes.ModelType?
}

extension UpdateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientTokenId)
        clientTokenId = clientTokenIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct UpdateSchemaOutput: Swift.Equatable {
    /// The description of the schema.
    public var description: Swift.String?
    /// The date and time that schema was modified.
    public var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version number of the schema
    public var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    public var type: Swift.String?
    /// The date the schema version was created.
    public var versionCreatedDate: ClientRuntime.Date?

    public init(
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct UpdateSchemaOutputBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension UpdateSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

enum UpdateSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
