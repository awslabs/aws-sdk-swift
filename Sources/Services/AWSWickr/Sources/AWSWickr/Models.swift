//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension WickrClientTypes {

    public enum AccessLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case premium
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessLevel] {
            return [
                .premium,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .premium: return "PREMIUM"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was invalid or malformed. This error occurs when the request parameters do not meet the API requirements, such as invalid field values, missing required parameters, or improperly formatted data.
public struct BadRequestError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A detailed message explaining what was wrong with the request and how to correct it.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension WickrClientTypes {

    /// Represents a device where a user has logged into Wickr, containing information about the device's type, status, and login history.
    public struct BasicDeviceObject: Swift.Sendable {
        /// The unique application ID for the Wickr app on this device.
        public var appId: Swift.String?
        /// The timestamp when the device first appeared in the Wickr database.
        public var created: Swift.String?
        /// The timestamp when the device last successfully logged into Wickr. This is also used to determine SSO idle time.
        public var lastLogin: Swift.String?
        /// The current status of the device, either 'Active' or 'Reset' depending on whether the device is currently active or has been marked for reset.
        public var statusText: Swift.String?
        /// Indicates whether the device is suspended.
        public var suspend: Swift.Bool?
        /// The operating system of the device (e.g., 'MacOSX', 'Windows', 'iOS', 'Android').
        public var type: Swift.String?

        public init(
            appId: Swift.String? = nil,
            created: Swift.String? = nil,
            lastLogin: Swift.String? = nil,
            statusText: Swift.String? = nil,
            suspend: Swift.Bool? = nil,
            type: Swift.String? = nil
        ) {
            self.appId = appId
            self.created = created
            self.lastLogin = lastLogin
            self.statusText = statusText
            self.suspend = suspend
            self.type = type
        }
    }
}

/// Access to the requested resource is forbidden. This error occurs when the authenticated user does not have the necessary permissions to perform the requested operation, even though they are authenticated.
public struct ForbiddenError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message explaining why access was denied and what permissions are required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An unexpected error occurred on the server while processing the request. This indicates a problem with the Wickr service itself rather than with the request. If this error persists, contact Amazon Web Services Support.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the internal server error that occurred.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was throttled because too many requests were sent in a short period of time. Wait a moment and retry the request. Consider implementing exponential backoff in your application.
public struct RateLimitError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message indicating that the rate limit was exceeded and suggesting when to retry.
        public internal(set) var message: Swift.String? = "Too many requests sent"
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RateLimitError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = "Too many requests sent"
    ) {
        self.properties.message = message
    }
}

/// The requested resource could not be found. This error occurs when you try to access or modify a network, user, bot, security group, or other resource that doesn't exist or has been deleted.
public struct ResourceNotFoundError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message identifying which resource was not found.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was not authenticated or the authentication credentials were invalid. This error occurs when the request lacks valid authentication credentials or the credentials have expired.
public struct UnauthorizedError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message explaining why the authentication failed.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension WickrClientTypes {

    /// Contains detailed error information explaining why an operation failed, including which field caused the error and the reason for the failure.
    public struct ErrorDetail: Swift.Sendable {
        /// The name of the field that contains an error or warning.
        public var field: Swift.String?
        /// A detailed description of the error or warning.
        public var reason: Swift.String?

        public init(
            field: Swift.String? = nil,
            reason: Swift.String? = nil
        ) {
            self.field = field
            self.reason = reason
        }
    }
}

/// One or more fields in the request failed validation. This error provides detailed information about which fields were invalid and why, allowing you to correct the request and retry.
public struct ValidationError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of validation error details, where each item identifies a specific field that failed validation and explains the reason for the failure.
        public internal(set) var reasons: [WickrClientTypes.ErrorDetail]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        reasons: [WickrClientTypes.ErrorDetail]? = nil
    ) {
        self.properties.reasons = reasons
    }
}

extension WickrClientTypes {

    /// Contains the details for a single user to be created in a batch user creation request. A user can only be assigned to a single security group. Attempting to add a user to multiple security groups is not supported and will result in an error. codeValidation, inviteCode, and inviteCodeTtl are restricted to networks under preview only.
    public struct BatchCreateUserRequestItem: Swift.Sendable {
        /// Indicates whether the user can be verified through a custom invite code.
        public var codeValidation: Swift.Bool?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// A custom invite code for the user. If not provided, one will be generated automatically.
        public var inviteCode: Swift.String?
        /// The time-to-live for the invite code in days. After this period, the invite code will expire.
        public var inviteCodeTtl: Swift.Int?
        /// The last name of the user.
        public var lastName: Swift.String?
        /// A list of security group IDs to which the user should be assigned.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The email address or username for the user. Must be unique within the network.
        /// This member is required.
        public var username: Swift.String?

        public init(
            codeValidation: Swift.Bool? = nil,
            firstName: Swift.String? = nil,
            inviteCode: Swift.String? = nil,
            inviteCodeTtl: Swift.Int? = nil,
            lastName: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            username: Swift.String? = nil
        ) {
            self.codeValidation = codeValidation
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.inviteCodeTtl = inviteCodeTtl
            self.lastName = lastName
            self.securityGroupIds = securityGroupIds
            self.username = username
        }
    }
}

extension WickrClientTypes.BatchCreateUserRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateUserRequestItem(codeValidation: \(Swift.String(describing: codeValidation)), inviteCode: \(Swift.String(describing: inviteCode)), inviteCodeTtl: \(Swift.String(describing: inviteCodeTtl)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), username: \(Swift.String(describing: username)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateUserInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without creating duplicate users.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network where users will be created.
    /// This member is required.
    public var networkId: Swift.String?
    /// A list of user objects containing the details for each user to be created, including username, name, security groups, and optional invite codes. Maximum 50 users per batch request.
    /// This member is required.
    public var users: [WickrClientTypes.BatchCreateUserRequestItem]?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        users: [WickrClientTypes.BatchCreateUserRequestItem]? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
        self.users = users
    }
}

extension WickrClientTypes {

    /// Contains error information for a user operation that failed in a batch user request.
    public struct BatchUserErrorResponseItem: Swift.Sendable {
        /// The field that caused the error.
        public var field: Swift.String?
        /// A description of why the user operation failed.
        public var reason: Swift.String?
        /// The user ID associated with the failed operation.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            field: Swift.String? = nil,
            reason: Swift.String? = nil,
            userId: Swift.String? = nil
        ) {
            self.field = field
            self.reason = reason
            self.userId = userId
        }
    }
}

extension WickrClientTypes {

    /// Represents a user account in a Wickr network with detailed profile information, status, security settings, and authentication details. codeValidation, inviteCode and inviteCodeTtl are restricted to networks under preview only.
    public struct User: Swift.Sendable {
        /// The phone number minus country code, used for cloud deployments.
        public var cell: Swift.String?
        /// The number of failed password attempts for enterprise deployments, used for account lockout policies.
        public var challengeFailures: Swift.Int?
        /// Indicates whether the user can be verified through a custom invite code.
        public var codeValidation: Swift.Bool?
        /// The country code for the user's phone number, used for cloud deployments.
        public var countryCode: Swift.String?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// The invitation code for this user, used during registration to join the network.
        public var inviteCode: Swift.String?
        /// Indicates whether the user has administrator privileges in the network.
        public var isAdmin: Swift.Bool?
        /// Indicates whether the user's email invitation code has expired, applicable to cloud deployments.
        public var isInviteExpired: Swift.Bool?
        /// Indicates whether this account is a user (as opposed to a bot or other account type).
        public var isUser: Swift.Bool?
        /// The last name of the user.
        public var lastName: Swift.String?
        /// Indicates whether one-time password (OTP) authentication is enabled for the user.
        public var otpEnabled: Swift.Bool?
        /// The SCIM (System for Cross-domain Identity Management) identifier for the user, used for identity synchronization. Currently not used.
        public var scimId: Swift.String?
        /// A list of security group IDs to which the user is assigned, determining their permissions and feature access.
        public var securityGroups: [Swift.String]?
        /// The current status of the user (1 for pending invitation, 2 for active).
        public var status: Swift.Int?
        /// Indicates whether the user is currently suspended and unable to access the network.
        public var suspended: Swift.Bool?
        /// The descriptive type of the user account (e.g., 'user').
        public var type: Swift.String?
        /// The unique identifier for the user.
        public var uname: Swift.String?
        /// The unique identifier for the user within the network.
        public var userId: Swift.String?
        /// The email address or username of the user. For bots, this must end in 'bot'.
        public var username: Swift.String?

        public init(
            cell: Swift.String? = nil,
            challengeFailures: Swift.Int? = nil,
            codeValidation: Swift.Bool? = nil,
            countryCode: Swift.String? = nil,
            firstName: Swift.String? = nil,
            inviteCode: Swift.String? = nil,
            isAdmin: Swift.Bool? = nil,
            isInviteExpired: Swift.Bool? = nil,
            isUser: Swift.Bool? = nil,
            lastName: Swift.String? = nil,
            otpEnabled: Swift.Bool? = nil,
            scimId: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            status: Swift.Int? = nil,
            suspended: Swift.Bool? = nil,
            type: Swift.String? = nil,
            uname: Swift.String? = nil,
            userId: Swift.String? = nil,
            username: Swift.String? = nil
        ) {
            self.cell = cell
            self.challengeFailures = challengeFailures
            self.codeValidation = codeValidation
            self.countryCode = countryCode
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.isAdmin = isAdmin
            self.isInviteExpired = isInviteExpired
            self.isUser = isUser
            self.lastName = lastName
            self.otpEnabled = otpEnabled
            self.scimId = scimId
            self.securityGroups = securityGroups
            self.status = status
            self.suspended = suspended
            self.type = type
            self.uname = uname
            self.userId = userId
            self.username = username
        }
    }
}

extension WickrClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(cell: \(Swift.String(describing: cell)), challengeFailures: \(Swift.String(describing: challengeFailures)), codeValidation: \(Swift.String(describing: codeValidation)), countryCode: \(Swift.String(describing: countryCode)), inviteCode: \(Swift.String(describing: inviteCode)), isAdmin: \(Swift.String(describing: isAdmin)), isInviteExpired: \(Swift.String(describing: isInviteExpired)), isUser: \(Swift.String(describing: isUser)), otpEnabled: \(Swift.String(describing: otpEnabled)), scimId: \(Swift.String(describing: scimId)), securityGroups: \(Swift.String(describing: securityGroups)), status: \(Swift.String(describing: status)), suspended: \(Swift.String(describing: suspended)), type: \(Swift.String(describing: type)), uname: \(Swift.String(describing: uname)), userId: \(Swift.String(describing: userId)), username: \(Swift.String(describing: username)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateUserOutput: Swift.Sendable {
    /// A list of user creation attempts that failed, including error details explaining why each user could not be created.
    public var failed: [WickrClientTypes.BatchUserErrorResponseItem]?
    /// A message indicating the overall result of the batch operation.
    public var message: Swift.String?
    /// A list of user objects that were successfully created, including their assigned user IDs and invite codes.
    public var successful: [WickrClientTypes.User]?

    public init(
        failed: [WickrClientTypes.BatchUserErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.User]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

public struct BatchDeleteUserInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without attempting to delete users again.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network from which users will be deleted.
    /// This member is required.
    public var networkId: Swift.String?
    /// A list of user IDs identifying the users to be deleted from the network. Maximum 50 users per batch request.
    /// This member is required.
    public var userIds: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
        self.userIds = userIds
    }
}

extension WickrClientTypes {

    /// Contains information about a user that was successfully processed in a batch user operation.
    public struct BatchUserSuccessResponseItem: Swift.Sendable {
        /// The user ID that was successfully processed.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        ) {
            self.userId = userId
        }
    }
}

public struct BatchDeleteUserOutput: Swift.Sendable {
    /// A list of user deletion attempts that failed, including error details explaining why each user could not be deleted.
    public var failed: [WickrClientTypes.BatchUserErrorResponseItem]?
    /// A message indicating the overall result of the batch deletion operation.
    public var message: Swift.String?
    /// A list of user IDs that were successfully deleted from the network.
    public var successful: [WickrClientTypes.BatchUserSuccessResponseItem]?

    public init(
        failed: [WickrClientTypes.BatchUserErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.BatchUserSuccessResponseItem]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

extension WickrClientTypes {

    /// Contains error information for a device operation that failed in a batch device request.
    public struct BatchDeviceErrorResponseItem: Swift.Sendable {
        /// The application ID of the device that failed to be processed.
        /// This member is required.
        public var appId: Swift.String?
        /// The field that caused the error.
        public var field: Swift.String?
        /// A description of why the device operation failed.
        public var reason: Swift.String?

        public init(
            appId: Swift.String? = nil,
            field: Swift.String? = nil,
            reason: Swift.String? = nil
        ) {
            self.appId = appId
            self.field = field
            self.reason = reason
        }
    }
}

extension WickrClientTypes {

    /// Contains information about a device that was successfully processed in a batch device operation.
    public struct BatchDeviceSuccessResponseItem: Swift.Sendable {
        /// The application ID of the device that was successfully processed.
        /// This member is required.
        public var appId: Swift.String?

        public init(
            appId: Swift.String? = nil
        ) {
            self.appId = appId
        }
    }
}

public struct BatchLookupUserUnameInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network where the users will be looked up.
    /// This member is required.
    public var networkId: Swift.String?
    /// A list of username hashes (unames) to look up. Each uname is a unique identifier for a user's username. Maximum 50 unames per batch request.
    /// This member is required.
    public var unames: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        unames: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
        self.unames = unames
    }
}

extension WickrClientTypes {

    /// Contains error information for a username hash lookup that failed in a batch uname lookup request.
    public struct BatchUnameErrorResponseItem: Swift.Sendable {
        /// The field that caused the error.
        public var field: Swift.String?
        /// A description of why the username hash lookup failed.
        public var reason: Swift.String?
        /// The username hash that failed to be looked up.
        /// This member is required.
        public var uname: Swift.String?

        public init(
            field: Swift.String? = nil,
            reason: Swift.String? = nil,
            uname: Swift.String? = nil
        ) {
            self.field = field
            self.reason = reason
            self.uname = uname
        }
    }
}

extension WickrClientTypes {

    /// Contains information about a username hash that was successfully resolved in a batch uname lookup operation.
    public struct BatchUnameSuccessResponseItem: Swift.Sendable {
        /// The username hash that was successfully resolved.
        /// This member is required.
        public var uname: Swift.String?
        /// The email address or username corresponding to the username hash.
        /// This member is required.
        public var username: Swift.String?

        public init(
            uname: Swift.String? = nil,
            username: Swift.String? = nil
        ) {
            self.uname = uname
            self.username = username
        }
    }
}

public struct BatchLookupUserUnameOutput: Swift.Sendable {
    /// A list of username hash lookup attempts that failed, including error details explaining why each lookup failed.
    public var failed: [WickrClientTypes.BatchUnameErrorResponseItem]?
    /// A message indicating the overall result of the batch lookup operation.
    public var message: Swift.String?
    /// A list of successfully resolved username hashes with their corresponding email addresses.
    public var successful: [WickrClientTypes.BatchUnameSuccessResponseItem]?

    public init(
        failed: [WickrClientTypes.BatchUnameErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.BatchUnameSuccessResponseItem]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

public struct BatchReinviteUserInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network where users will be reinvited.
    /// This member is required.
    public var networkId: Swift.String?
    /// A list of user IDs identifying the users to be reinvited to the network. Maximum 50 users per batch request.
    /// This member is required.
    public var userIds: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
        self.userIds = userIds
    }
}

public struct BatchReinviteUserOutput: Swift.Sendable {
    /// A list of reinvitation attempts that failed, including error details explaining why each user could not be reinvited.
    public var failed: [WickrClientTypes.BatchUserErrorResponseItem]?
    /// A message indicating the overall result of the batch reinvitation operation.
    public var message: Swift.String?
    /// A list of user IDs that were successfully reinvited.
    public var successful: [WickrClientTypes.BatchUserSuccessResponseItem]?

    public init(
        failed: [WickrClientTypes.BatchUserErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.BatchUserSuccessResponseItem]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

public struct BatchResetDevicesForUserInput: Swift.Sendable {
    /// A list of application IDs identifying the specific devices to be reset for the user. Maximum 50 devices per batch request.
    /// This member is required.
    public var appIds: [Swift.String]?
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network containing the user whose devices will be reset.
    /// This member is required.
    public var networkId: Swift.String?
    /// The ID of the user whose devices will be reset.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        appIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        userId: Swift.String? = nil
    ) {
        self.appIds = appIds
        self.clientToken = clientToken
        self.networkId = networkId
        self.userId = userId
    }
}

public struct BatchResetDevicesForUserOutput: Swift.Sendable {
    /// A list of device reset attempts that failed, including error details explaining why each device could not be reset.
    public var failed: [WickrClientTypes.BatchDeviceErrorResponseItem]?
    /// A message indicating the overall result of the batch device reset operation.
    public var message: Swift.String?
    /// A list of application IDs that were successfully reset.
    public var successful: [WickrClientTypes.BatchDeviceSuccessResponseItem]?

    public init(
        failed: [WickrClientTypes.BatchDeviceErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.BatchDeviceSuccessResponseItem]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

public struct BatchToggleUserSuspendStatusInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network where users will be suspended or unsuspended.
    /// This member is required.
    public var networkId: Swift.String?
    /// A boolean value indicating whether to suspend (true) or unsuspend (false) the specified users.
    /// This member is required.
    public var suspend: Swift.Bool?
    /// A list of user IDs identifying the users whose suspend status will be toggled. Maximum 50 users per batch request.
    /// This member is required.
    public var userIds: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil,
        suspend: Swift.Bool? = nil,
        userIds: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
        self.suspend = suspend
        self.userIds = userIds
    }
}

public struct BatchToggleUserSuspendStatusOutput: Swift.Sendable {
    /// A list of suspend status toggle attempts that failed, including error details explaining why each user's status could not be changed.
    public var failed: [WickrClientTypes.BatchUserErrorResponseItem]?
    /// A message indicating the overall result of the batch suspend status toggle operation.
    public var message: Swift.String?
    /// A list of user IDs whose suspend status was successfully toggled.
    public var successful: [WickrClientTypes.BatchUserSuccessResponseItem]?

    public init(
        failed: [WickrClientTypes.BatchUserErrorResponseItem]? = nil,
        message: Swift.String? = nil,
        successful: [WickrClientTypes.BatchUserSuccessResponseItem]? = nil
    ) {
        self.failed = failed
        self.message = message
        self.successful = successful
    }
}

extension WickrClientTypes {

    /// Represents a guest user who has been blocked from accessing a Wickr network.
    public struct BlockedGuestUser: Swift.Sendable {
        /// The username of the administrator who blocked this guest user.
        /// This member is required.
        public var admin: Swift.String?
        /// The timestamp when the guest user was blocked or last modified.
        /// This member is required.
        public var modified: Swift.String?
        /// The username of the blocked guest user.
        /// This member is required.
        public var username: Swift.String?
        /// The unique username hash identifier for the blocked guest user.
        /// This member is required.
        public var usernameHash: Swift.String?

        public init(
            admin: Swift.String? = nil,
            modified: Swift.String? = nil,
            username: Swift.String? = nil,
            usernameHash: Swift.String? = nil
        ) {
            self.admin = admin
            self.modified = modified
            self.username = username
            self.usernameHash = usernameHash
        }
    }
}

public enum BotStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
    /// The bot is active and operational, able to send and receive messages.
    case active
    /// The bot has been created but is not yet active, pending initial setup or activation.
    case pending
    case sdkUnknown(Swift.Int)

    public static var allCases: [BotStatus] {
        return [
            .active,
            .pending
        ]
    }

    public init(rawValue: Swift.Int) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }

    public var rawValue: Swift.Int {
        switch self {
        case .active: return 2
        case .pending: return 1
        case let .sdkUnknown(s): return s
        }
    }
}

extension WickrClientTypes {

    /// Represents a bot account in a Wickr network with all its informational fields.
    public struct Bot: Swift.Sendable {
        /// The unique identifier of the bot.
        public var botId: Swift.String?
        /// The display name of the bot that is visible to users.
        public var displayName: Swift.String?
        /// The ID of the security group to which the bot belongs.
        public var groupId: Swift.String?
        /// Indicates whether the bot has a password set.
        public var hasChallenge: Swift.Bool?
        /// The timestamp of the bot's last login.
        public var lastLogin: Swift.String?
        /// The public key of the bot used for encryption.
        public var pubkey: Swift.String?
        /// The current status of the bot (1 for pending, 2 for active).
        public var status: BotStatus?
        /// Indicates whether the bot is currently suspended.
        public var suspended: Swift.Bool?
        /// The unique username hash identifier for the bot.
        public var uname: Swift.String?
        /// The username of the bot.
        public var username: Swift.String?

        public init(
            botId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            groupId: Swift.String? = nil,
            hasChallenge: Swift.Bool? = nil,
            lastLogin: Swift.String? = nil,
            pubkey: Swift.String? = nil,
            status: BotStatus? = nil,
            suspended: Swift.Bool? = nil,
            uname: Swift.String? = nil,
            username: Swift.String? = nil
        ) {
            self.botId = botId
            self.displayName = displayName
            self.groupId = groupId
            self.hasChallenge = hasChallenge
            self.lastLogin = lastLogin
            self.pubkey = pubkey
            self.status = status
            self.suspended = suspended
            self.uname = uname
            self.username = username
        }
    }
}

extension WickrClientTypes {

    /// Defines the calling feature permissions and settings for users in a security group, controlling what types of calls users can initiate and participate in.
    public struct CallingSettings: Swift.Sendable {
        /// Specifies whether users can start one-to-one calls.
        public var canStart11Call: Swift.Bool?
        /// Specifies whether users can make video calls (as opposed to audio-only calls). Valid only when audio call(canStart11Call) is enabled.
        public var canVideoCall: Swift.Bool?
        /// When enabled, forces all calls to use TCP protocol instead of UDP for network traversal.
        public var forceTcpCall: Swift.Bool?

        public init(
            canStart11Call: Swift.Bool? = nil,
            canVideoCall: Swift.Bool? = nil,
            forceTcpCall: Swift.Bool? = nil
        ) {
            self.canStart11Call = canStart11Call
            self.canVideoCall = canVideoCall
            self.forceTcpCall = forceTcpCall
        }
    }
}

public struct CreateBotInput: Swift.Sendable {
    /// The password for the bot account.
    /// This member is required.
    public var challenge: Swift.String?
    /// The display name for the bot that will be visible to users in the network.
    public var displayName: Swift.String?
    /// The ID of the security group to which the bot will be assigned.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the Wickr network where the bot will be created.
    /// This member is required.
    public var networkId: Swift.String?
    /// The username for the bot. This must be unique within the network and follow the network's naming conventions.
    /// This member is required.
    public var username: Swift.String?

    public init(
        challenge: Swift.String? = nil,
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        networkId: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.challenge = challenge
        self.displayName = displayName
        self.groupId = groupId
        self.networkId = networkId
        self.username = username
    }
}

extension CreateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBotInput(displayName: \(Swift.String(describing: displayName)), groupId: \(Swift.String(describing: groupId)), networkId: \(Swift.String(describing: networkId)), username: \(Swift.String(describing: username)), challenge: \"CONTENT_REDACTED\")"}
}

public struct CreateBotOutput: Swift.Sendable {
    /// The unique identifier assigned to the newly created bot.
    /// This member is required.
    public var botId: Swift.String?
    /// The display name of the newly created bot.
    public var displayName: Swift.String?
    /// The ID of the security group to which the bot was assigned.
    public var groupId: Swift.String?
    /// A message indicating the result of the bot creation operation.
    public var message: Swift.String?
    /// The ID of the network where the bot was created.
    public var networkId: Swift.String?
    /// The username of the newly created bot.
    public var username: Swift.String?

    public init(
        botId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        message: Swift.String? = nil,
        networkId: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.botId = botId
        self.displayName = displayName
        self.groupId = groupId
        self.message = message
        self.networkId = networkId
        self.username = username
    }
}

public struct CreateDataRetentionBotInput: Swift.Sendable {
    /// The ID of the Wickr network where the data retention bot will be created.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct CreateDataRetentionBotOutput: Swift.Sendable {
    /// A message indicating that the data retention bot was successfully provisioned.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct CreateDataRetentionBotChallengeInput: Swift.Sendable {
    /// The ID of the Wickr network containing the data retention bot.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct CreateDataRetentionBotChallengeOutput: Swift.Sendable {
    /// The newly generated challenge password for the data retention bot.
    /// This member is required.
    public var challenge: Swift.String?

    public init(
        challenge: Swift.String? = nil
    ) {
        self.challenge = challenge
    }
}

extension CreateDataRetentionBotChallengeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataRetentionBotChallengeOutput(challenge: \"CONTENT_REDACTED\")"}
}

public struct CreateNetworkInput: Swift.Sendable {
    /// The access level for the network. Valid values are STANDARD or PREMIUM, which determine the features and capabilities available to network members.
    /// This member is required.
    public var accessLevel: WickrClientTypes.AccessLevel?
    /// Specifies whether to enable a premium free trial for the network. It is optional and has a default value as false. When set to true, the network starts with premium features for a limited trial period.
    public var enablePremiumFreeTrial: Swift.Bool?
    /// The ARN of the Amazon Web Services KMS customer managed key to use for encrypting sensitive data in the network.
    public var encryptionKeyArn: Swift.String?
    /// The name for the new network. Must be between 1 and 20 characters.
    /// This member is required.
    public var networkName: Swift.String?

    public init(
        accessLevel: WickrClientTypes.AccessLevel? = nil,
        enablePremiumFreeTrial: Swift.Bool? = nil,
        encryptionKeyArn: Swift.String? = nil,
        networkName: Swift.String? = nil
    ) {
        self.accessLevel = accessLevel
        self.enablePremiumFreeTrial = enablePremiumFreeTrial
        self.encryptionKeyArn = encryptionKeyArn
        self.networkName = networkName
    }
}

public struct CreateNetworkOutput: Swift.Sendable {
    /// The ARN of the KMS key being used to encrypt sensitive data in the network.
    public var encryptionKeyArn: Swift.String?
    /// The unique identifier assigned to the newly created network.
    public var networkId: Swift.String?
    /// The name of the newly created network.
    public var networkName: Swift.String?

    public init(
        encryptionKeyArn: Swift.String? = nil,
        networkId: Swift.String? = nil,
        networkName: Swift.String? = nil
    ) {
        self.encryptionKeyArn = encryptionKeyArn
        self.networkId = networkId
        self.networkName = networkName
    }
}

extension WickrClientTypes {

    /// Identifies a Amazon Web Services Wickr network by region and network ID, used for configuring permitted networks for global federation.
    public struct WickrAwsNetworks: Swift.Sendable {
        /// The network ID of the Wickr Amazon Web Services network.
        /// This member is required.
        public var networkId: Swift.String?
        /// The Amazon Web Services region identifier where the network is hosted (e.g., 'us-east-1').
        /// This member is required.
        public var region: Swift.String?

        public init(
            networkId: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.networkId = networkId
            self.region = region
        }
    }
}

extension WickrClientTypes {

    /// Identifies a Wickr enterprise network that is permitted for global federation, allowing users to communicate with members of the specified network.
    public struct PermittedWickrEnterpriseNetwork: Swift.Sendable {
        /// The domain identifier for the permitted Wickr enterprise network.
        /// This member is required.
        public var domain: Swift.String?
        /// The network ID of the permitted Wickr enterprise network.
        /// This member is required.
        public var networkId: Swift.String?

        public init(
            domain: Swift.String? = nil,
            networkId: Swift.String? = nil
        ) {
            self.domain = domain
            self.networkId = networkId
        }
    }
}

extension WickrClientTypes {

    /// Contains the security group configuration settings that can be specified when creating or updating a security group. This is a subset of SecurityGroupSettings containing only the modifiable federation and security settings.
    public struct SecurityGroupSettingsRequest: Swift.Sendable {
        /// Guest users let you work with people outside your organization that only have limited access to Wickr. Only valid when federationMode is set to Global.
        public var enableGuestFederation: Swift.Bool?
        /// Enables restricted global federation to limit communication to specific permitted networks only. Requires globalFederation to be enabled.
        public var enableRestrictedGlobalFederation: Swift.Bool?
        /// The local federation mode. Values: 0 (none), 1 (federated - all networks), 2 (restricted - only permitted networks).
        public var federationMode: Swift.Int?
        /// Allow users to securely federate with all Amazon Web Services Wickr networks and Amazon Web Services Enterprise networks.
        public var globalFederation: Swift.Bool?
        /// The number of failed password attempts before a user account is locked out.
        public var lockoutThreshold: Swift.Int?
        /// A list of network IDs that are permitted for local federation when federation mode is set to restricted.
        public var permittedNetworks: [Swift.String]?
        /// A list of permitted Amazon Web Services Wickr networks for restricted global federation.
        public var permittedWickrAwsNetworks: [WickrClientTypes.WickrAwsNetworks]?
        /// A list of permitted Wickr Enterprise networks for restricted global federation.
        public var permittedWickrEnterpriseNetworks: [WickrClientTypes.PermittedWickrEnterpriseNetwork]?

        public init(
            enableGuestFederation: Swift.Bool? = nil,
            enableRestrictedGlobalFederation: Swift.Bool? = nil,
            federationMode: Swift.Int? = nil,
            globalFederation: Swift.Bool? = nil,
            lockoutThreshold: Swift.Int? = nil,
            permittedNetworks: [Swift.String]? = nil,
            permittedWickrAwsNetworks: [WickrClientTypes.WickrAwsNetworks]? = nil,
            permittedWickrEnterpriseNetworks: [WickrClientTypes.PermittedWickrEnterpriseNetwork]? = nil
        ) {
            self.enableGuestFederation = enableGuestFederation
            self.enableRestrictedGlobalFederation = enableRestrictedGlobalFederation
            self.federationMode = federationMode
            self.globalFederation = globalFederation
            self.lockoutThreshold = lockoutThreshold
            self.permittedNetworks = permittedNetworks
            self.permittedWickrAwsNetworks = permittedWickrAwsNetworks
            self.permittedWickrEnterpriseNetworks = permittedWickrEnterpriseNetworks
        }
    }
}

public struct CreateSecurityGroupInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name for the new security group.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Wickr network where the security group will be created.
    /// This member is required.
    public var networkId: Swift.String?
    /// The configuration settings for the security group, including permissions, federation settings, and feature controls.
    /// This member is required.
    public var securityGroupSettings: WickrClientTypes.SecurityGroupSettingsRequest?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        networkId: Swift.String? = nil,
        securityGroupSettings: WickrClientTypes.SecurityGroupSettingsRequest? = nil
    ) {
        self.clientToken = clientToken
        self.name = name
        self.networkId = networkId
        self.securityGroupSettings = securityGroupSettings
    }
}

extension WickrClientTypes {

    /// Defines password complexity requirements for users in a security group, including minimum length and character type requirements.
    public struct PasswordRequirements: Swift.Sendable {
        /// The minimum number of lowercase letters required in passwords.
        public var lowercase: Swift.Int?
        /// The minimum password length in characters.
        public var minLength: Swift.Int?
        /// The minimum number of numeric characters required in passwords.
        public var numbers: Swift.Int?
        /// The minimum number of special symbol characters required in passwords.
        public var symbols: Swift.Int?
        /// The minimum number of uppercase letters required in passwords.
        public var uppercase: Swift.Int?

        public init(
            lowercase: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            numbers: Swift.Int? = nil,
            symbols: Swift.Int? = nil,
            uppercase: Swift.Int? = nil
        ) {
            self.lowercase = lowercase
            self.minLength = minLength
            self.numbers = numbers
            self.symbols = symbols
            self.uppercase = uppercase
        }
    }
}

extension WickrClientTypes {

    /// Configuration for the message shredder feature, which securely deletes messages and files from devices to prevent data recovery.
    public struct ShredderSettings: Swift.Sendable {
        /// Specifies whether users can manually trigger the shredder to delete content.
        public var canProcessManually: Swift.Bool?
        /// Prevents Wickr data from being recovered by overwriting deleted Wickr data. Valid Values: Must be one of [0, 20, 60, 100]
        public var intensity: Swift.Int?

        public init(
            canProcessManually: Swift.Bool? = nil,
            intensity: Swift.Int? = nil
        ) {
            self.canProcessManually = canProcessManually
            self.intensity = intensity
        }
    }
}

extension WickrClientTypes {

    /// Comprehensive configuration settings that define all user capabilities, restrictions, and features for members of a security group. These settings control everything from calling permissions to federation settings to security policies.
    public struct SecurityGroupSettings: Swift.Sendable {
        /// Requires users to reauthenticate every time they return to the application, providing an additional layer of security.
        public var alwaysReauthenticate: Swift.Bool?
        /// Configuration values for ATAK (Android Team Awareness Kit) package integration, when ATAK is enabled.
        public var atakPackageValues: [Swift.String]?
        /// The calling feature permissions and settings that control what types of calls users can initiate and participate in.
        public var calling: WickrClientTypes.CallingSettings?
        /// Enables automatic checking for Wickr client updates to ensure users stay current with the latest version.
        public var checkForUpdates: Swift.Bool?
        /// Enables ATAK (Android Team Awareness Kit) integration for tactical communication and situational awareness.
        public var enableAtak: Swift.Bool?
        /// Allow users to report crashes.
        public var enableCrashReports: Swift.Bool?
        /// Specifies whether users can download files from messages to their devices.
        public var enableFileDownload: Swift.Bool?
        /// Allows users to communicate with guest users from other Wickr networks and federated external networks.
        public var enableGuestFederation: Swift.Bool?
        /// Enables message preview text in push notifications, allowing users to see message content before opening the app.
        public var enableNotificationPreview: Swift.Bool?
        /// Allow users to avoid censorship when they are geo-blocked or have network limitations.
        public var enableOpenAccessOption: Swift.Bool?
        /// Enables restricted global federation, limiting external communication to only specified permitted networks.
        public var enableRestrictedGlobalFederation: Swift.Bool?
        /// The local federation mode controlling how users can communicate with other networks. Values: 0 (none), 1 (federated), 2 (restricted).
        public var federationMode: Swift.Int?
        /// Enables file sharing capabilities, allowing users to send and receive files in conversations.
        public var filesEnabled: Swift.Bool?
        /// Defines the number of failed login attempts before data stored on the device is reset. Should be less than lockoutThreshold.
        public var forceDeviceLockout: Swift.Int?
        /// Automatically enable and enforce Wickr open access on all devices. Valid only if enableOpenAccessOption settings is enabled.
        public var forceOpenAccess: Swift.Bool?
        /// Allow user approved bots to read messages in rooms without using a slash command.
        public var forceReadReceipts: Swift.Bool?
        /// Allows users to communicate with users on other Wickr instances (Wickr Enterprise) outside the current network.
        public var globalFederation: Swift.Bool?
        /// Enforces a two-factor authentication when a user adds a new device to their account.
        public var isAtoEnabled: Swift.Bool?
        /// Enables automatic preview of links shared in messages, showing webpage thumbnails and descriptions.
        public var isLinkPreviewEnabled: Swift.Bool?
        /// Allows map integration in location sharing, enabling users to view shared locations on interactive maps. Only allowed when location setting is enabled.
        public var locationAllowMaps: Swift.Bool?
        /// Enables location sharing features, allowing users to share their current location with others.
        public var locationEnabled: Swift.Bool?
        /// The number of failed password attempts before a user account is locked out.
        public var lockoutThreshold: Swift.Int?
        /// The maximum file size in bytes that will be automatically downloaded without user confirmation. Only allowed if fileDownload is enabled. Valid Values [512000 (low_quality), 7340032 (high_quality) ]
        public var maxAutoDownloadSize: Swift.Int?
        /// The maximum burn-on-read (BOR) time in seconds, which determines how long messages remain visible before auto-deletion after being read.
        public var maxBor: Swift.Int?
        /// The maximum time-to-live (TTL) in seconds for messages, after which they will be automatically deleted from all devices.
        public var maxTtl: Swift.Int?
        /// Enables message forwarding, allowing users to forward messages from one conversation to another.
        public var messageForwardingEnabled: Swift.Bool?
        /// The password complexity requirements that users must follow when creating or changing passwords.
        public var passwordRequirements: WickrClientTypes.PasswordRequirements?
        /// A list of network IDs that are permitted for local federation when federation mode is set to restricted.
        public var permittedNetworks: [Swift.String]?
        /// A list of permitted Wickr networks for global federation, restricting communication to specific approved networks.
        public var permittedWickrAwsNetworks: [WickrClientTypes.WickrAwsNetworks]?
        /// A list of permitted Wickr Enterprise networks for global federation, restricting communication to specific approved networks.
        public var permittedWickrEnterpriseNetworks: [WickrClientTypes.PermittedWickrEnterpriseNetwork]?
        /// Enables presence indicators that show whether users are online, away, or offline.
        public var presenceEnabled: Swift.Bool?
        /// A list of pre-defined quick response message templates that users can send with a single tap.
        public var quickResponses: [Swift.String]?
        /// Users will get a master recovery key that can be used to securely sign in to their Wickr account without having access to their primary device for authentication. Available in SSO enabled network.
        public var showMasterRecoveryKey: Swift.Bool?
        /// The message shredder configuration that controls secure deletion of messages and files from devices.
        public var shredder: WickrClientTypes.ShredderSettings?
        /// The duration for which users SSO session remains inactive before automatically logging them out for security. Available in SSO enabled network.
        public var ssoMaxIdleMinutes: Swift.Int?

        public init(
            alwaysReauthenticate: Swift.Bool? = nil,
            atakPackageValues: [Swift.String]? = nil,
            calling: WickrClientTypes.CallingSettings? = nil,
            checkForUpdates: Swift.Bool? = nil,
            enableAtak: Swift.Bool? = nil,
            enableCrashReports: Swift.Bool? = nil,
            enableFileDownload: Swift.Bool? = nil,
            enableGuestFederation: Swift.Bool? = nil,
            enableNotificationPreview: Swift.Bool? = nil,
            enableOpenAccessOption: Swift.Bool? = nil,
            enableRestrictedGlobalFederation: Swift.Bool? = nil,
            federationMode: Swift.Int? = nil,
            filesEnabled: Swift.Bool? = nil,
            forceDeviceLockout: Swift.Int? = nil,
            forceOpenAccess: Swift.Bool? = nil,
            forceReadReceipts: Swift.Bool? = nil,
            globalFederation: Swift.Bool? = nil,
            isAtoEnabled: Swift.Bool? = nil,
            isLinkPreviewEnabled: Swift.Bool? = nil,
            locationAllowMaps: Swift.Bool? = nil,
            locationEnabled: Swift.Bool? = nil,
            lockoutThreshold: Swift.Int? = nil,
            maxAutoDownloadSize: Swift.Int? = nil,
            maxBor: Swift.Int? = nil,
            maxTtl: Swift.Int? = nil,
            messageForwardingEnabled: Swift.Bool? = nil,
            passwordRequirements: WickrClientTypes.PasswordRequirements? = nil,
            permittedNetworks: [Swift.String]? = nil,
            permittedWickrAwsNetworks: [WickrClientTypes.WickrAwsNetworks]? = nil,
            permittedWickrEnterpriseNetworks: [WickrClientTypes.PermittedWickrEnterpriseNetwork]? = nil,
            presenceEnabled: Swift.Bool? = nil,
            quickResponses: [Swift.String]? = nil,
            showMasterRecoveryKey: Swift.Bool? = nil,
            shredder: WickrClientTypes.ShredderSettings? = nil,
            ssoMaxIdleMinutes: Swift.Int? = nil
        ) {
            self.alwaysReauthenticate = alwaysReauthenticate
            self.atakPackageValues = atakPackageValues
            self.calling = calling
            self.checkForUpdates = checkForUpdates
            self.enableAtak = enableAtak
            self.enableCrashReports = enableCrashReports
            self.enableFileDownload = enableFileDownload
            self.enableGuestFederation = enableGuestFederation
            self.enableNotificationPreview = enableNotificationPreview
            self.enableOpenAccessOption = enableOpenAccessOption
            self.enableRestrictedGlobalFederation = enableRestrictedGlobalFederation
            self.federationMode = federationMode
            self.filesEnabled = filesEnabled
            self.forceDeviceLockout = forceDeviceLockout
            self.forceOpenAccess = forceOpenAccess
            self.forceReadReceipts = forceReadReceipts
            self.globalFederation = globalFederation
            self.isAtoEnabled = isAtoEnabled
            self.isLinkPreviewEnabled = isLinkPreviewEnabled
            self.locationAllowMaps = locationAllowMaps
            self.locationEnabled = locationEnabled
            self.lockoutThreshold = lockoutThreshold
            self.maxAutoDownloadSize = maxAutoDownloadSize
            self.maxBor = maxBor
            self.maxTtl = maxTtl
            self.messageForwardingEnabled = messageForwardingEnabled
            self.passwordRequirements = passwordRequirements
            self.permittedNetworks = permittedNetworks
            self.permittedWickrAwsNetworks = permittedWickrAwsNetworks
            self.permittedWickrEnterpriseNetworks = permittedWickrEnterpriseNetworks
            self.presenceEnabled = presenceEnabled
            self.quickResponses = quickResponses
            self.showMasterRecoveryKey = showMasterRecoveryKey
            self.shredder = shredder
            self.ssoMaxIdleMinutes = ssoMaxIdleMinutes
        }
    }
}

extension WickrClientTypes {

    /// Represents a security group in a Wickr network, containing membership statistics, configuration, and all permission settings that apply to its members.
    public struct SecurityGroup: Swift.Sendable {
        /// The GUID of the Active Directory group associated with this security group, if synchronized with LDAP.
        public var activeDirectoryGuid: Swift.String?
        /// The number of active user members currently in the security group.
        /// This member is required.
        public var activeMembers: Swift.Int?
        /// The number of bot members currently in the security group.
        /// This member is required.
        public var botMembers: Swift.Int?
        /// The unique identifier of the security group.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether this is the default security group for the network. Each network has only one default group.
        /// This member is required.
        public var isDefault: Swift.Bool?
        /// The timestamp when the security group was last modified, specified in epoch seconds.
        /// This member is required.
        public var modified: Swift.Int?
        /// The human-readable name of the security group.
        /// This member is required.
        public var name: Swift.String?
        /// The comprehensive configuration settings that define capabilities and restrictions for members of this security group.
        /// This member is required.
        public var securityGroupSettings: WickrClientTypes.SecurityGroupSettings?

        public init(
            activeDirectoryGuid: Swift.String? = nil,
            activeMembers: Swift.Int? = nil,
            botMembers: Swift.Int? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            modified: Swift.Int? = nil,
            name: Swift.String? = nil,
            securityGroupSettings: WickrClientTypes.SecurityGroupSettings? = nil
        ) {
            self.activeDirectoryGuid = activeDirectoryGuid
            self.activeMembers = activeMembers
            self.botMembers = botMembers
            self.id = id
            self.isDefault = isDefault
            self.modified = modified
            self.name = name
            self.securityGroupSettings = securityGroupSettings
        }
    }
}

public struct CreateSecurityGroupOutput: Swift.Sendable {
    /// The details of the newly created security group, including its ID, name, and settings.
    /// This member is required.
    public var securityGroup: WickrClientTypes.SecurityGroup?

    public init(
        securityGroup: WickrClientTypes.SecurityGroup? = nil
    ) {
        self.securityGroup = securityGroup
    }
}

extension WickrClientTypes {

    public enum DataRetentionActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disable
        case enable
        case pubkeyMsgAck
        case sdkUnknown(Swift.String)

        public static var allCases: [DataRetentionActionType] {
            return [
                .disable,
                .enable,
                .pubkeyMsgAck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .pubkeyMsgAck: return "PUBKEY_MSG_ACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteBotInput: Swift.Sendable {
    /// The unique identifier of the bot to be deleted.
    /// This member is required.
    public var botId: Swift.String?
    /// The ID of the Wickr network from which the bot will be deleted.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.botId = botId
        self.networkId = networkId
    }
}

public struct DeleteBotOutput: Swift.Sendable {
    /// A message indicating the result of the bot deletion operation.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteDataRetentionBotInput: Swift.Sendable {
    /// The ID of the Wickr network from which the data retention bot will be deleted.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct DeleteDataRetentionBotOutput: Swift.Sendable {
    /// A message indicating that the data retention bot and all associated data were successfully deleted.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteNetworkInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency. If you retry a request with the same client token, the service will return the same response without attempting to delete the network again.
    public var clientToken: Swift.String?
    /// The ID of the Wickr network to delete.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.networkId = networkId
    }
}

public struct DeleteNetworkOutput: Swift.Sendable {
    /// A message indicating that the network deletion has been initiated successfully.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteSecurityGroupInput: Swift.Sendable {
    /// The unique identifier of the security group to delete.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the Wickr network from which the security group will be deleted.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.groupId = groupId
        self.networkId = networkId
    }
}

public struct DeleteSecurityGroupOutput: Swift.Sendable {
    /// The ID of the security group that was deleted.
    public var groupId: Swift.String?
    /// A message indicating the result of the security group deletion operation.
    public var message: Swift.String?
    /// The ID of the network from which the security group was deleted.
    public var networkId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        message: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.groupId = groupId
        self.message = message
        self.networkId = networkId
    }
}

public struct GetBotInput: Swift.Sendable {
    /// The unique identifier of the bot to retrieve.
    /// This member is required.
    public var botId: Swift.String?
    /// The ID of the Wickr network containing the bot.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        botId: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.botId = botId
        self.networkId = networkId
    }
}

public struct GetBotOutput: Swift.Sendable {
    /// The unique identifier of the bot.
    public var botId: Swift.String?
    /// The display name of the bot that is visible to users.
    public var displayName: Swift.String?
    /// The ID of the security group to which the bot belongs.
    public var groupId: Swift.String?
    /// Indicates whether the bot has a password set.
    public var hasChallenge: Swift.Bool?
    /// The timestamp of the bot's last login.
    public var lastLogin: Swift.String?
    /// The public key of the bot used for encryption.
    public var pubkey: Swift.String?
    /// The current status of the bot (1 for pending, 2 for active).
    public var status: BotStatus?
    /// Indicates whether the bot is currently suspended.
    public var suspended: Swift.Bool?
    /// The unique username hash identifier for the bot.
    public var uname: Swift.String?
    /// The username of the bot.
    public var username: Swift.String?

    public init(
        botId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        hasChallenge: Swift.Bool? = nil,
        lastLogin: Swift.String? = nil,
        pubkey: Swift.String? = nil,
        status: BotStatus? = nil,
        suspended: Swift.Bool? = nil,
        uname: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.botId = botId
        self.displayName = displayName
        self.groupId = groupId
        self.hasChallenge = hasChallenge
        self.lastLogin = lastLogin
        self.pubkey = pubkey
        self.status = status
        self.suspended = suspended
        self.uname = uname
        self.username = username
    }
}

public struct GetBotsCountInput: Swift.Sendable {
    /// The ID of the Wickr network for which to retrieve bot counts.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct GetBotsCountOutput: Swift.Sendable {
    /// The number of bots with active status.
    /// This member is required.
    public var active: Swift.Int?
    /// The number of bots with pending status (invited but not yet activated).
    /// This member is required.
    public var pending: Swift.Int?
    /// The total number of bots in the network (active and pending).
    /// This member is required.
    public var total: Swift.Int?

    public init(
        active: Swift.Int? = nil,
        pending: Swift.Int? = nil,
        total: Swift.Int? = nil
    ) {
        self.active = active
        self.pending = pending
        self.total = total
    }
}

public struct GetDataRetentionBotInput: Swift.Sendable {
    /// The ID of the Wickr network containing the data retention bot.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct GetDataRetentionBotOutput: Swift.Sendable {
    /// Indicates whether a data retention bot exists in the network.
    public var botExists: Swift.Bool?
    /// The name of the data retention bot.
    public var botName: Swift.String?
    /// Indicates whether the data retention bot is active and operational.
    public var isBotActive: Swift.Bool?
    /// Indicates whether the data retention bot has been registered with the network.
    public var isDataRetentionBotRegistered: Swift.Bool?
    /// Indicates whether the data retention service is enabled for the network.
    public var isDataRetentionServiceEnabled: Swift.Bool?
    /// Indicates whether the public key message has been acknowledged by the bot.
    public var isPubkeyMsgAcked: Swift.Bool?

    public init(
        botExists: Swift.Bool? = nil,
        botName: Swift.String? = nil,
        isBotActive: Swift.Bool? = nil,
        isDataRetentionBotRegistered: Swift.Bool? = nil,
        isDataRetentionServiceEnabled: Swift.Bool? = nil,
        isPubkeyMsgAcked: Swift.Bool? = nil
    ) {
        self.botExists = botExists
        self.botName = botName
        self.isBotActive = isBotActive
        self.isDataRetentionBotRegistered = isDataRetentionBotRegistered
        self.isDataRetentionServiceEnabled = isDataRetentionServiceEnabled
        self.isPubkeyMsgAcked = isPubkeyMsgAcked
    }
}

public struct GetGuestUserHistoryCountInput: Swift.Sendable {
    /// The ID of the Wickr network for which to retrieve guest user history.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

extension WickrClientTypes {

    /// Contains the count of guest users for a specific billing period, used for tracking historical guest user activity.
    public struct GuestUserHistoryCount: Swift.Sendable {
        /// The number of guest users who have communicated with your Wickr network during this billing period.
        /// This member is required.
        public var count: Swift.String?
        /// The month and billing period in YYYY_MM format (e.g., '2024_01').
        /// This member is required.
        public var month: Swift.String?

        public init(
            count: Swift.String? = nil,
            month: Swift.String? = nil
        ) {
            self.count = count
            self.month = month
        }
    }
}

public struct GetGuestUserHistoryCountOutput: Swift.Sendable {
    /// A list of historical guest user counts, organized by month and billing period.
    /// This member is required.
    public var history: [WickrClientTypes.GuestUserHistoryCount]?

    public init(
        history: [WickrClientTypes.GuestUserHistoryCount]? = nil
    ) {
        self.history = history
    }
}

public struct GetNetworkInput: Swift.Sendable {
    /// The ID of the Wickr network to retrieve.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct GetNetworkOutput: Swift.Sendable {
    /// The access level of the network (STANDARD or PREMIUM), which determines available features and capabilities.
    /// This member is required.
    public var accessLevel: WickrClientTypes.AccessLevel?
    /// The Amazon Web Services account ID that owns the network.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ARN of the Amazon Web Services KMS customer managed key used for encrypting sensitive data in the network.
    public var encryptionKeyArn: Swift.String?
    /// The expiration date and time for the network's free trial period, if applicable.
    public var freeTrialExpiration: Swift.String?
    /// The SSO redirect URI migration state, managed by the SSO redirect migration wizard. Values: 0 (not started), 1 (in progress), or 2 (completed).
    public var migrationState: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The unique identifier of the network.
    /// This member is required.
    public var networkId: Swift.String?
    /// The name of the network.
    /// This member is required.
    public var networkName: Swift.String?
    /// The current standing or status of the network.
    public var standing: Swift.Int?

    public init(
        accessLevel: WickrClientTypes.AccessLevel? = nil,
        awsAccountId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        freeTrialExpiration: Swift.String? = nil,
        migrationState: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        networkId: Swift.String? = nil,
        networkName: Swift.String? = nil,
        standing: Swift.Int? = nil
    ) {
        self.accessLevel = accessLevel
        self.awsAccountId = awsAccountId
        self.encryptionKeyArn = encryptionKeyArn
        self.freeTrialExpiration = freeTrialExpiration
        self.migrationState = migrationState
        self.networkArn = networkArn
        self.networkId = networkId
        self.networkName = networkName
        self.standing = standing
    }
}

public struct GetNetworkSettingsInput: Swift.Sendable {
    /// The ID of the Wickr network whose settings will be retrieved.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

extension WickrClientTypes {

    /// Represents a single network-level configuration setting with its name, value, and data type. Settings control network-wide behaviors and features.
    public struct Setting: Swift.Sendable {
        /// The name of the network setting (e.g., 'enableClientMetrics', 'dataRetention').
        /// This member is required.
        public var optionName: Swift.String?
        /// The data type of the setting value (e.g., 'boolean', 'string', 'number').
        /// This member is required.
        public var type: Swift.String?
        /// The current value of the setting as a string. Boolean values are represented as 'true' or 'false'.
        /// This member is required.
        public var value: Swift.String?

        public init(
            optionName: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.optionName = optionName
            self.type = type
            self.value = value
        }
    }
}

public struct GetNetworkSettingsOutput: Swift.Sendable {
    /// A list of network settings, where each setting includes a name, value, and type.
    /// This member is required.
    public var settings: [WickrClientTypes.Setting]?

    public init(
        settings: [WickrClientTypes.Setting]? = nil
    ) {
        self.settings = settings
    }
}

public struct GetOidcInfoInput: Swift.Sendable {
    /// The CA certificate for secure communication with the OIDC provider (optional).
    public var certificate: Swift.String?
    /// The OAuth client ID for retrieving access tokens (optional).
    public var clientId: Swift.String?
    /// The OAuth client secret for retrieving access tokens (optional).
    public var clientSecret: Swift.String?
    /// The authorization code for retrieving access tokens (optional).
    public var code: Swift.String?
    /// The PKCE code verifier for enhanced security in the OAuth flow (optional).
    public var codeVerifier: Swift.String?
    /// The OAuth grant type for retrieving access tokens (optional).
    public var grantType: Swift.String?
    /// The ID of the Wickr network whose OIDC configuration will be retrieved.
    /// This member is required.
    public var networkId: Swift.String?
    /// The redirect URI for the OAuth flow (optional).
    public var redirectUri: Swift.String?
    /// The URL for the OIDC provider (optional).
    public var url: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        code: Swift.String? = nil,
        codeVerifier: Swift.String? = nil,
        grantType: Swift.String? = nil,
        networkId: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        url: Swift.String? = nil
    ) {
        self.certificate = certificate
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.codeVerifier = codeVerifier
        self.grantType = grantType
        self.networkId = networkId
        self.redirectUri = redirectUri
        self.url = url
    }
}

extension GetOidcInfoInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOidcInfoInput(certificate: \(Swift.String(describing: certificate)), clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), codeVerifier: \(Swift.String(describing: codeVerifier)), grantType: \(Swift.String(describing: grantType)), networkId: \(Swift.String(describing: networkId)), redirectUri: \(Swift.String(describing: redirectUri)), url: \(Swift.String(describing: url)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension WickrClientTypes {

    /// Contains the OpenID Connect (OIDC) configuration information for Single Sign-On (SSO) authentication, including identity provider settings and client credentials.
    public struct OidcConfigInfo: Swift.Sendable {
        /// The unique identifier for the registered OIDC application. Valid range is 1-10.
        public var applicationId: Swift.Int?
        /// The name of the OIDC application as registered with the identity provider.
        public var applicationName: Swift.String?
        /// The X.509 CA certificate for validating SSL/TLS connections to the identity provider when using self-signed or enterprise certificates.
        public var caCertificate: Swift.String?
        /// The OAuth client ID assigned by the identity provider for authentication requests.
        public var clientId: Swift.String?
        /// The OAuth client secret used to authenticate the application with the identity provider.
        public var clientSecret: Swift.String?
        /// Custom identifier your end users will use to sign in with SSO.
        /// This member is required.
        public var companyId: Swift.String?
        /// A custom field mapping to extract the username from the OIDC token when the standard username claim is insufficient.
        public var customUsername: Swift.String?
        /// Additional authentication parameters to include in the OIDC authorization request as a query string. Useful for provider-specific extensions.
        public var extraAuthParams: Swift.String?
        /// The issuer URL of the identity provider, which serves as the base URL for OIDC endpoints and configuration discovery.
        /// This member is required.
        public var issuer: Swift.String?
        /// The callback URL where the identity provider redirects users after successful authentication. This URL must be registered with the identity provider.
        public var redirectUrl: Swift.String?
        /// The OAuth scopes requested from the identity provider, which determine what user information is accessible (e.g., 'openid profile email').
        /// This member is required.
        public var scopes: Swift.String?
        /// An additional secret credential used by the identity provider for authentication.
        public var secret: Swift.String?
        /// The grace period in minutes before the SSO token expires when the system should proactively refresh the token to maintain seamless user access.
        public var ssoTokenBufferMinutes: Swift.Int?
        /// The claim field from the OIDC token to use as the unique user identifier (e.g., 'email', 'sub', or a custom claim).
        public var userId: Swift.String?

        public init(
            applicationId: Swift.Int? = nil,
            applicationName: Swift.String? = nil,
            caCertificate: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            companyId: Swift.String? = nil,
            customUsername: Swift.String? = nil,
            extraAuthParams: Swift.String? = nil,
            issuer: Swift.String? = nil,
            redirectUrl: Swift.String? = nil,
            scopes: Swift.String? = nil,
            secret: Swift.String? = nil,
            ssoTokenBufferMinutes: Swift.Int? = nil,
            userId: Swift.String? = nil
        ) {
            self.applicationId = applicationId
            self.applicationName = applicationName
            self.caCertificate = caCertificate
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.companyId = companyId
            self.customUsername = customUsername
            self.extraAuthParams = extraAuthParams
            self.issuer = issuer
            self.redirectUrl = redirectUrl
            self.scopes = scopes
            self.secret = secret
            self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
            self.userId = userId
        }
    }
}

extension WickrClientTypes.OidcConfigInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OidcConfigInfo(applicationId: \(Swift.String(describing: applicationId)), applicationName: \(Swift.String(describing: applicationName)), caCertificate: \(Swift.String(describing: caCertificate)), clientId: \(Swift.String(describing: clientId)), companyId: \(Swift.String(describing: companyId)), customUsername: \(Swift.String(describing: customUsername)), extraAuthParams: \(Swift.String(describing: extraAuthParams)), issuer: \(Swift.String(describing: issuer)), redirectUrl: \(Swift.String(describing: redirectUrl)), scopes: \(Swift.String(describing: scopes)), ssoTokenBufferMinutes: \(Swift.String(describing: ssoTokenBufferMinutes)), userId: \(Swift.String(describing: userId)), clientSecret: \"CONTENT_REDACTED\", secret: \"CONTENT_REDACTED\")"}
}

extension WickrClientTypes {

    /// Contains OAuth token information returned from the identity provider, including access tokens, ID tokens, and PKCE parameters used for secure authentication.
    public struct OidcTokenInfo: Swift.Sendable {
        /// The OAuth access token that can be used to access protected resources on behalf of the authenticated user.
        public var accessToken: Swift.String?
        /// The PKCE code challenge, a transformed version of the code verifier sent during the authorization request for verification.
        public var codeChallenge: Swift.String?
        /// The PKCE (Proof Key for Code Exchange) code verifier, a cryptographically random string used to enhance security in the OAuth flow.
        public var codeVerifier: Swift.String?
        /// The lifetime of the access token in seconds, indicating when the token will expire and need to be refreshed.
        public var expiresIn: Swift.Int?
        /// The OpenID Connect ID token containing user identity information and authentication context as a signed JWT.
        public var idToken: Swift.String?
        /// The OAuth refresh token that can be used to obtain new access tokens without requiring the user to re-authenticate.
        public var refreshToken: Swift.String?
        /// The type of access token issued, typically 'Bearer', which indicates how the token should be used in API requests.
        public var tokenType: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            codeChallenge: Swift.String? = nil,
            codeVerifier: Swift.String? = nil,
            expiresIn: Swift.Int? = nil,
            idToken: Swift.String? = nil,
            refreshToken: Swift.String? = nil,
            tokenType: Swift.String? = nil
        ) {
            self.accessToken = accessToken
            self.codeChallenge = codeChallenge
            self.codeVerifier = codeVerifier
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.tokenType = tokenType
        }
    }
}

public struct GetOidcInfoOutput: Swift.Sendable {
    /// The OpenID Connect configuration information for the network, including issuer, client ID, scopes, and other SSO settings.
    public var openidConnectInfo: WickrClientTypes.OidcConfigInfo?
    /// OAuth token information including access token, refresh token, and expiration details (only present if token parameters were provided in the request).
    public var tokenInfo: WickrClientTypes.OidcTokenInfo?

    public init(
        openidConnectInfo: WickrClientTypes.OidcConfigInfo? = nil,
        tokenInfo: WickrClientTypes.OidcTokenInfo? = nil
    ) {
        self.openidConnectInfo = openidConnectInfo
        self.tokenInfo = tokenInfo
    }
}

public struct GetSecurityGroupInput: Swift.Sendable {
    /// The unique identifier of the security group to retrieve.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the Wickr network containing the security group.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        networkId: Swift.String? = nil
    ) {
        self.groupId = groupId
        self.networkId = networkId
    }
}

public struct GetSecurityGroupOutput: Swift.Sendable {
    /// The detailed information about the security group, including all its settings and member counts.
    /// This member is required.
    public var securityGroup: WickrClientTypes.SecurityGroup?

    public init(
        securityGroup: WickrClientTypes.SecurityGroup? = nil
    ) {
        self.securityGroup = securityGroup
    }
}

public struct GetUserInput: Swift.Sendable {
    /// The end time for filtering the user's last activity. Only activity before this timestamp will be considered. Time is specified in epoch seconds.
    public var endTime: Foundation.Date?
    /// The ID of the Wickr network containing the user.
    /// This member is required.
    public var networkId: Swift.String?
    /// The start time for filtering the user's last activity. Only activity after this timestamp will be considered. Time is specified in epoch seconds.
    public var startTime: Foundation.Date?
    /// The unique identifier of the user to retrieve.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        networkId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        userId: Swift.String? = nil
    ) {
        self.endTime = endTime
        self.networkId = networkId
        self.startTime = startTime
        self.userId = userId
    }
}

public struct GetUserOutput: Swift.Sendable {
    /// The first name of the user.
    public var firstName: Swift.String?
    /// Indicates whether the user has administrator privileges in the network.
    public var isAdmin: Swift.Bool?
    /// The timestamp of the user's last activity in the network, specified in epoch seconds.
    public var lastActivity: Swift.Int?
    /// The timestamp of the user's last login to the network, specified in epoch seconds.
    public var lastLogin: Swift.Int?
    /// The last name of the user.
    public var lastName: Swift.String?
    /// A list of security group IDs to which the user belongs.
    public var securityGroupIds: [Swift.String]?
    /// The current status of the user (1 for pending, 2 for active).
    public var status: Swift.Int?
    /// Indicates whether the user is currently suspended.
    public var suspended: Swift.Bool?
    /// The unique identifier of the user.
    /// This member is required.
    public var userId: Swift.String?
    /// The email address or username of the user.
    public var username: Swift.String?

    public init(
        firstName: Swift.String? = nil,
        isAdmin: Swift.Bool? = nil,
        lastActivity: Swift.Int? = nil,
        lastLogin: Swift.Int? = nil,
        lastName: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: Swift.Int? = nil,
        suspended: Swift.Bool? = nil,
        userId: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.firstName = firstName
        self.isAdmin = isAdmin
        self.lastActivity = lastActivity
        self.lastLogin = lastLogin
        self.lastName = lastName
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.suspended = suspended
        self.userId = userId
        self.username = username
    }
}

extension GetUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserOutput(isAdmin: \(Swift.String(describing: isAdmin)), lastActivity: \(Swift.String(describing: lastActivity)), lastLogin: \(Swift.String(describing: lastLogin)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), status: \(Swift.String(describing: status)), suspended: \(Swift.String(describing: suspended)), userId: \(Swift.String(describing: userId)), username: \(Swift.String(describing: username)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

public struct GetUsersCountInput: Swift.Sendable {
    /// The ID of the Wickr network for which to retrieve user counts.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        networkId: Swift.String? = nil
    ) {
        self.networkId = networkId
    }
}

public struct GetUsersCountOutput: Swift.Sendable {
    /// The number of users with active status in the network.
    /// This member is required.
    public var active: Swift.Int?
    /// The number of users with pending status (invited but not yet accepted).
    /// This member is required.
    public var pending: Swift.Int?
    /// The number of users who have rejected network invitations.
    /// This member is required.
    public var rejected: Swift.Int?
    /// The number of additional users that can be added to the network while maintaining premium free trial eligibility.
    /// This member is required.
    public var remaining: Swift.Int?
    /// The total number of users in the network (active and pending combined).
    /// This member is required.
    public var total: Swift.Int?

    public init(
        active: Swift.Int? = nil,
        pending: Swift.Int? = nil,
        rejected: Swift.Int? = nil,
        remaining: Swift.Int? = nil,
        total: Swift.Int? = nil
    ) {
        self.active = active
        self.pending = pending
        self.rejected = rejected
        self.remaining = remaining
        self.total = total
    }
}

extension WickrClientTypes {

    /// Represents a guest user who has accessed the network from a federated Wickr network.
    public struct GuestUser: Swift.Sendable {
        /// The billing period when this guest user accessed the network (e.g., '2024-01').
        /// This member is required.
        public var billingPeriod: Swift.String?
        /// The username of the guest user.
        /// This member is required.
        public var username: Swift.String?
        /// The unique username hash identifier for the guest user.
        /// This member is required.
        public var usernameHash: Swift.String?

        public init(
            billingPeriod: Swift.String? = nil,
            username: Swift.String? = nil,
            usernameHash: Swift.String? = nil
        ) {
            self.billingPeriod = billingPeriod
            self.username = username
            self.usernameHash = usernameHash
        }
    }
}

extension WickrClientTypes {

    public enum SortDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListBlockedGuestUsersInput: Swift.Sendable {
    /// Filter results to only include blocked guest users that were blocked by this administrator.
    public var admin: Swift.String?
    /// The maximum number of blocked guest users to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network from which to list blocked guest users.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The field to sort blocked guest users by. Accepted values include 'username', 'admin', and 'modified'.
    public var sortFields: Swift.String?
    /// Filter results to only include blocked guest users with usernames matching this value.
    public var username: Swift.String?

    public init(
        admin: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.admin = admin
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
        self.username = username
    }
}

public struct ListBlockedGuestUsersOutput: Swift.Sendable {
    /// A list of blocked guest user objects within the current page.
    /// This member is required.
    public var blocklist: [WickrClientTypes.BlockedGuestUser]?
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?

    public init(
        blocklist: [WickrClientTypes.BlockedGuestUser]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.blocklist = blocklist
        self.nextToken = nextToken
    }
}

public struct ListBotsInput: Swift.Sendable {
    /// Filter results to only include bots with display names matching this value.
    public var displayName: Swift.String?
    /// Filter results to only include bots belonging to this security group.
    public var groupId: Swift.String?
    /// The maximum number of bots to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network from which to list bots.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The fields to sort bots by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', 'displayName', 'status', and 'groupId'.
    public var sortFields: Swift.String?
    /// Filter results to only include bots with this status (1 for pending, 2 for active).
    public var status: BotStatus?
    /// Filter results to only include bots with usernames matching this value.
    public var username: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil,
        status: BotStatus? = nil,
        username: Swift.String? = nil
    ) {
        self.displayName = displayName
        self.groupId = groupId
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
        self.status = status
        self.username = username
    }
}

public struct ListBotsOutput: Swift.Sendable {
    /// A list of bot objects matching the specified filters and within the current page.
    /// This member is required.
    public var bots: [WickrClientTypes.Bot]?
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?

    public init(
        bots: [WickrClientTypes.Bot]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.bots = bots
        self.nextToken = nextToken
    }
}

public struct ListDevicesForUserInput: Swift.Sendable {
    /// The maximum number of devices to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network containing the user.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The fields to sort devices by. Multiple fields can be specified by separating them with '+'. Accepted values include 'lastlogin', 'type', 'suspend', and 'created'.
    public var sortFields: Swift.String?
    /// The unique identifier of the user whose devices will be listed.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil,
        userId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
        self.userId = userId
    }
}

public struct ListDevicesForUserOutput: Swift.Sendable {
    /// A list of device objects associated with the user within the current page.
    /// This member is required.
    public var devices: [WickrClientTypes.BasicDeviceObject]?
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?

    public init(
        devices: [WickrClientTypes.BasicDeviceObject]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListGuestUsersInput: Swift.Sendable {
    /// Filter results to only include guest users from this billing period (e.g., '2024-01').
    public var billingPeriod: Swift.String?
    /// The maximum number of guest users to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network from which to list guest users.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The field to sort guest users by. Accepted values include 'username' and 'billingPeriod'.
    public var sortFields: Swift.String?
    /// Filter results to only include guest users with usernames matching this value.
    public var username: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
        self.username = username
    }
}

public struct ListGuestUsersOutput: Swift.Sendable {
    /// A list of guest user objects within the current page.
    /// This member is required.
    public var guestlist: [WickrClientTypes.GuestUser]?
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?

    public init(
        guestlist: [WickrClientTypes.GuestUser]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.guestlist = guestlist
        self.nextToken = nextToken
    }
}

public struct ListNetworksInput: Swift.Sendable {
    /// The maximum number of networks to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The field to sort networks by. Accepted values are 'networkId' and 'networkName'. Default is 'networkId'.
    public var sortFields: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
    }
}

extension WickrClientTypes {

    /// Represents a Wickr network with all its configuration and status information.
    public struct Network: Swift.Sendable {
        /// The access level of the network (STANDARD or PREMIUM), which determines available features and capabilities.
        /// This member is required.
        public var accessLevel: WickrClientTypes.AccessLevel?
        /// The Amazon Web Services account ID that owns the network.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The ARN of the Amazon Web Services KMS customer managed key used for encrypting sensitive data in the network.
        public var encryptionKeyArn: Swift.String?
        /// The expiration date and time for the network's free trial period, if applicable.
        public var freeTrialExpiration: Swift.String?
        /// The SSO redirect URI migration state, managed by the SSO redirect migration wizard. Values: 0 (not started), 1 (in progress), or 2 (completed).
        public var migrationState: Swift.Int?
        /// The Amazon Resource Name (ARN) of the network.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The unique identifier of the network.
        /// This member is required.
        public var networkId: Swift.String?
        /// The name of the network.
        /// This member is required.
        public var networkName: Swift.String?
        /// The current standing or status of the network.
        public var standing: Swift.Int?

        public init(
            accessLevel: WickrClientTypes.AccessLevel? = nil,
            awsAccountId: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            freeTrialExpiration: Swift.String? = nil,
            migrationState: Swift.Int? = nil,
            networkArn: Swift.String? = nil,
            networkId: Swift.String? = nil,
            networkName: Swift.String? = nil,
            standing: Swift.Int? = nil
        ) {
            self.accessLevel = accessLevel
            self.awsAccountId = awsAccountId
            self.encryptionKeyArn = encryptionKeyArn
            self.freeTrialExpiration = freeTrialExpiration
            self.migrationState = migrationState
            self.networkArn = networkArn
            self.networkId = networkId
            self.networkName = networkName
            self.standing = standing
        }
    }
}

public struct ListNetworksOutput: Swift.Sendable {
    /// A list of network objects for the Amazon Web Services account.
    /// This member is required.
    public var networks: [WickrClientTypes.Network]?
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?

    public init(
        networks: [WickrClientTypes.Network]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.networks = networks
        self.nextToken = nextToken
    }
}

public struct ListSecurityGroupsInput: Swift.Sendable {
    /// The maximum number of security groups to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network from which to list security groups.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The field to sort security groups by. Accepted values include 'id' and 'name'.
    public var sortFields: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
    }
}

public struct ListSecurityGroupsOutput: Swift.Sendable {
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?
    /// A list of security group objects in the current page.
    public var securityGroups: [WickrClientTypes.SecurityGroup]?

    public init(
        nextToken: Swift.String? = nil,
        securityGroups: [WickrClientTypes.SecurityGroup]? = nil
    ) {
        self.nextToken = nextToken
        self.securityGroups = securityGroups
    }
}

public struct ListSecurityGroupUsersInput: Swift.Sendable {
    /// The unique identifier of the security group whose users will be listed.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of users to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network containing the security group.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The field to sort users by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', and 'lastName'.
    public var sortFields: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil
    ) {
        self.groupId = groupId
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
    }
}

public struct ListSecurityGroupUsersOutput: Swift.Sendable {
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?
    /// A list of user objects belonging to the security group within the current page.
    /// This member is required.
    public var users: [WickrClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [WickrClientTypes.User]? = nil
    ) {
        self.nextToken = nextToken
        self.users = users
    }
}

public enum UserStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
    /// The user has accepted their invitation and is active in the network.
    case active
    /// The user has been invited to the network but has not yet accepted their invitation.
    case pending
    case sdkUnknown(Swift.Int)

    public static var allCases: [UserStatus] {
        return [
            .active,
            .pending
        ]
    }

    public init(rawValue: Swift.Int) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }

    public var rawValue: Swift.Int {
        switch self {
        case .active: return 2
        case .pending: return 1
        case let .sdkUnknown(s): return s
        }
    }
}

public struct ListUsersInput: Swift.Sendable {
    /// Filter results to only include users with first names matching this value.
    public var firstName: Swift.String?
    /// Filter results to only include users belonging to this security group.
    public var groupId: Swift.String?
    /// Filter results to only include users with last names matching this value.
    public var lastName: Swift.String?
    /// The maximum number of users to return in a single page. Valid range is 1-100. Default is 10.
    public var maxResults: Swift.Int?
    /// The ID of the Wickr network from which to list users.
    /// This member is required.
    public var networkId: Swift.String?
    /// The token for retrieving the next page of results. This is returned from a previous request when there are more results available.
    public var nextToken: Swift.String?
    /// The direction to sort results. Valid values are 'ASC' (ascending) or 'DESC' (descending). Default is 'DESC'.
    public var sortDirection: WickrClientTypes.SortDirection?
    /// The fields to sort users by. Multiple fields can be specified by separating them with '+'. Accepted values include 'username', 'firstName', 'lastName', 'status', and 'groupId'.
    public var sortFields: Swift.String?
    /// Filter results to only include users with this status (1 for pending, 2 for active).
    public var status: UserStatus?
    /// Filter results to only include users with usernames matching this value.
    public var username: Swift.String?

    public init(
        firstName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        lastName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortDirection: WickrClientTypes.SortDirection? = nil,
        sortFields: Swift.String? = nil,
        status: UserStatus? = nil,
        username: Swift.String? = nil
    ) {
        self.firstName = firstName
        self.groupId = groupId
        self.lastName = lastName
        self.maxResults = maxResults
        self.networkId = networkId
        self.nextToken = nextToken
        self.sortDirection = sortDirection
        self.sortFields = sortFields
        self.status = status
        self.username = username
    }
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(groupId: \(Swift.String(describing: groupId)), maxResults: \(Swift.String(describing: maxResults)), networkId: \(Swift.String(describing: networkId)), nextToken: \(Swift.String(describing: nextToken)), sortDirection: \(Swift.String(describing: sortDirection)), sortFields: \(Swift.String(describing: sortFields)), status: \(Swift.String(describing: status)), username: \(Swift.String(describing: username)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

public struct ListUsersOutput: Swift.Sendable {
    /// The token to use for retrieving the next page of results. If this is not present, there are no more results.
    public var nextToken: Swift.String?
    /// A list of user objects matching the specified filters and within the current page.
    public var users: [WickrClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [WickrClientTypes.User]? = nil
    ) {
        self.nextToken = nextToken
        self.users = users
    }
}

extension WickrClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case forceEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled,
                .forceEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .forceEnabled: return "FORCE_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WickrClientTypes {

    /// Configuration for read receipts at the network level, controlling whether senders can see when their messages have been read.
    public struct ReadReceiptConfig: Swift.Sendable {
        /// The read receipt status mode for the network.
        public var status: WickrClientTypes.Status?

        public init(
            status: WickrClientTypes.Status? = nil
        ) {
            self.status = status
        }
    }
}

extension WickrClientTypes {

    /// Contains network-level configuration settings that apply to all users and security groups within a Wickr network.
    public struct NetworkSettings: Swift.Sendable {
        /// Indicates whether the data retention feature is enabled for the network. When true, messages are captured by the data retention bot for compliance and archiving purposes.
        public var dataRetention: Swift.Bool?
        /// Allows Wickr clients to send anonymized performance and usage metrics to the Wickr backend server for service improvement and troubleshooting.
        public var enableClientMetrics: Swift.Bool?
        /// Configuration for read receipts at the network level, controlling the default behavior for whether senders can see when their messages have been read.
        public var readReceiptConfig: WickrClientTypes.ReadReceiptConfig?

        public init(
            dataRetention: Swift.Bool? = nil,
            enableClientMetrics: Swift.Bool? = nil,
            readReceiptConfig: WickrClientTypes.ReadReceiptConfig? = nil
        ) {
            self.dataRetention = dataRetention
            self.enableClientMetrics = enableClientMetrics
            self.readReceiptConfig = readReceiptConfig
        }
    }
}

public struct RegisterOidcConfigInput: Swift.Sendable {
    /// Custom identifier your end users will use to sign in with SSO.
    /// This member is required.
    public var companyId: Swift.String?
    /// A custom field mapping to extract the username from the OIDC token (optional). The customUsername is only required if you use something other than email as the username field.
    public var customUsername: Swift.String?
    /// Additional authentication parameters to include in the OIDC flow (optional).
    public var extraAuthParams: Swift.String?
    /// The issuer URL of the OIDC provider (e.g., 'https://login.example.com').
    /// This member is required.
    public var issuer: Swift.String?
    /// The ID of the Wickr network for which OIDC will be configured.
    /// This member is required.
    public var networkId: Swift.String?
    /// The OAuth scopes to request from the OIDC provider (e.g., 'openid profile email').
    /// This member is required.
    public var scopes: Swift.String?
    /// The client secret for authenticating with the OIDC provider (optional).
    public var secret: Swift.String?
    /// The buffer time in minutes before the SSO token expires to refresh it (optional).
    public var ssoTokenBufferMinutes: Swift.Int?
    /// Unique identifier provided by your identity provider to authenticate the access request. Also referred to as clientID.
    public var userId: Swift.String?

    public init(
        companyId: Swift.String? = nil,
        customUsername: Swift.String? = nil,
        extraAuthParams: Swift.String? = nil,
        issuer: Swift.String? = nil,
        networkId: Swift.String? = nil,
        scopes: Swift.String? = nil,
        secret: Swift.String? = nil,
        ssoTokenBufferMinutes: Swift.Int? = nil,
        userId: Swift.String? = nil
    ) {
        self.companyId = companyId
        self.customUsername = customUsername
        self.extraAuthParams = extraAuthParams
        self.issuer = issuer
        self.networkId = networkId
        self.scopes = scopes
        self.secret = secret
        self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
        self.userId = userId
    }
}

extension RegisterOidcConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterOidcConfigInput(companyId: \(Swift.String(describing: companyId)), customUsername: \(Swift.String(describing: customUsername)), extraAuthParams: \(Swift.String(describing: extraAuthParams)), issuer: \(Swift.String(describing: issuer)), networkId: \(Swift.String(describing: networkId)), scopes: \(Swift.String(describing: scopes)), ssoTokenBufferMinutes: \(Swift.String(describing: ssoTokenBufferMinutes)), userId: \(Swift.String(describing: userId)), secret: \"CONTENT_REDACTED\")"}
}

public struct RegisterOidcConfigOutput: Swift.Sendable {
    /// The unique identifier for the registered OIDC application.
    public var applicationId: Swift.Int?
    /// The name of the registered OIDC application.
    public var applicationName: Swift.String?
    /// The CA certificate used for secure communication with the OIDC provider.
    public var caCertificate: Swift.String?
    /// The OAuth client ID assigned to the application.
    public var clientId: Swift.String?
    /// The OAuth client secret for the application.
    public var clientSecret: Swift.String?
    /// Custom identifier your end users will use to sign in with SSO.
    /// This member is required.
    public var companyId: Swift.String?
    /// The custom field mapping used for extracting the username.
    public var customUsername: Swift.String?
    /// The additional authentication parameters configured for the OIDC flow.
    public var extraAuthParams: Swift.String?
    /// The issuer URL of the OIDC provider.
    /// This member is required.
    public var issuer: Swift.String?
    /// The redirect URL configured for the OAuth flow.
    public var redirectUrl: Swift.String?
    /// The OAuth scopes configured for the application.
    /// This member is required.
    public var scopes: Swift.String?
    /// The client secret for authenticating with the OIDC provider.
    public var secret: Swift.String?
    /// The buffer time in minutes before the SSO token expires.
    public var ssoTokenBufferMinutes: Swift.Int?
    /// The claim field being used as the user identifier.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.Int? = nil,
        applicationName: Swift.String? = nil,
        caCertificate: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        companyId: Swift.String? = nil,
        customUsername: Swift.String? = nil,
        extraAuthParams: Swift.String? = nil,
        issuer: Swift.String? = nil,
        redirectUrl: Swift.String? = nil,
        scopes: Swift.String? = nil,
        secret: Swift.String? = nil,
        ssoTokenBufferMinutes: Swift.Int? = nil,
        userId: Swift.String? = nil
    ) {
        self.applicationId = applicationId
        self.applicationName = applicationName
        self.caCertificate = caCertificate
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.companyId = companyId
        self.customUsername = customUsername
        self.extraAuthParams = extraAuthParams
        self.issuer = issuer
        self.redirectUrl = redirectUrl
        self.scopes = scopes
        self.secret = secret
        self.ssoTokenBufferMinutes = ssoTokenBufferMinutes
        self.userId = userId
    }
}

extension RegisterOidcConfigOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterOidcConfigOutput(applicationId: \(Swift.String(describing: applicationId)), applicationName: \(Swift.String(describing: applicationName)), caCertificate: \(Swift.String(describing: caCertificate)), clientId: \(Swift.String(describing: clientId)), companyId: \(Swift.String(describing: companyId)), customUsername: \(Swift.String(describing: customUsername)), extraAuthParams: \(Swift.String(describing: extraAuthParams)), issuer: \(Swift.String(describing: issuer)), redirectUrl: \(Swift.String(describing: redirectUrl)), scopes: \(Swift.String(describing: scopes)), ssoTokenBufferMinutes: \(Swift.String(describing: ssoTokenBufferMinutes)), userId: \(Swift.String(describing: userId)), clientSecret: \"CONTENT_REDACTED\", secret: \"CONTENT_REDACTED\")"}
}

public struct RegisterOidcConfigTestInput: Swift.Sendable {
    /// The CA certificate for secure communication with the OIDC provider (optional).
    public var certificate: Swift.String?
    /// Additional authentication parameters to include in the test (optional).
    public var extraAuthParams: Swift.String?
    /// The issuer URL of the OIDC provider to test.
    /// This member is required.
    public var issuer: Swift.String?
    /// The ID of the Wickr network for which the OIDC configuration will be tested.
    /// This member is required.
    public var networkId: Swift.String?
    /// The OAuth scopes to test with the OIDC provider.
    /// This member is required.
    public var scopes: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        extraAuthParams: Swift.String? = nil,
        issuer: Swift.String? = nil,
        networkId: Swift.String? = nil,
        scopes: Swift.String? = nil
    ) {
        self.certificate = certificate
        self.extraAuthParams = extraAuthParams
        self.issuer = issuer
        self.networkId = networkId
        self.scopes = scopes
    }
}

public struct RegisterOidcConfigTestOutput: Swift.Sendable {
    /// The authorization endpoint URL discovered from the OIDC provider.
    public var authorizationEndpoint: Swift.String?
    /// The end session endpoint URL for logging out users from the OIDC provider.
    public var endSessionEndpoint: Swift.String?
    /// The OAuth grant types supported by the OIDC provider.
    public var grantTypesSupported: [Swift.String]?
    /// The issuer URL confirmed by the OIDC provider.
    public var issuer: Swift.String?
    /// The logout endpoint URL for terminating user sessions.
    public var logoutEndpoint: Swift.String?
    /// Indicates whether the provider supports Microsoft multi-refresh tokens.
    public var microsoftMultiRefreshToken: Swift.Bool?
    /// The OAuth response types supported by the OIDC provider.
    public var responseTypesSupported: [Swift.String]?
    /// The token revocation endpoint URL for invalidating tokens.
    public var revocationEndpoint: Swift.String?
    /// The OAuth scopes supported by the OIDC provider.
    public var scopesSupported: [Swift.String]?
    /// The token endpoint URL discovered from the OIDC provider.
    public var tokenEndpoint: Swift.String?
    /// The authentication methods supported by the token endpoint.
    public var tokenEndpointAuthMethodsSupported: [Swift.String]?
    /// The user info endpoint URL discovered from the OIDC provider.
    public var userinfoEndpoint: Swift.String?

    public init(
        authorizationEndpoint: Swift.String? = nil,
        endSessionEndpoint: Swift.String? = nil,
        grantTypesSupported: [Swift.String]? = nil,
        issuer: Swift.String? = nil,
        logoutEndpoint: Swift.String? = nil,
        microsoftMultiRefreshToken: Swift.Bool? = nil,
        responseTypesSupported: [Swift.String]? = nil,
        revocationEndpoint: Swift.String? = nil,
        scopesSupported: [Swift.String]? = nil,
        tokenEndpoint: Swift.String? = nil,
        tokenEndpointAuthMethodsSupported: [Swift.String]? = nil,
        userinfoEndpoint: Swift.String? = nil
    ) {
        self.authorizationEndpoint = authorizationEndpoint
        self.endSessionEndpoint = endSessionEndpoint
        self.grantTypesSupported = grantTypesSupported
        self.issuer = issuer
        self.logoutEndpoint = logoutEndpoint
        self.microsoftMultiRefreshToken = microsoftMultiRefreshToken
        self.responseTypesSupported = responseTypesSupported
        self.revocationEndpoint = revocationEndpoint
        self.scopesSupported = scopesSupported
        self.tokenEndpoint = tokenEndpoint
        self.tokenEndpointAuthMethodsSupported = tokenEndpointAuthMethodsSupported
        self.userinfoEndpoint = userinfoEndpoint
    }
}

public struct UpdateBotInput: Swift.Sendable {
    /// The unique identifier of the bot to update.
    /// This member is required.
    public var botId: Swift.String?
    /// The new password for the bot account.
    public var challenge: Swift.String?
    /// The new display name for the bot.
    public var displayName: Swift.String?
    /// The ID of the new security group to assign the bot to.
    public var groupId: Swift.String?
    /// The ID of the Wickr network containing the bot to update.
    /// This member is required.
    public var networkId: Swift.String?
    /// Set to true to suspend the bot or false to unsuspend it. Omit this field for standard updates that don't affect suspension status.
    public var suspend: Swift.Bool?

    public init(
        botId: Swift.String? = nil,
        challenge: Swift.String? = nil,
        displayName: Swift.String? = nil,
        groupId: Swift.String? = nil,
        networkId: Swift.String? = nil,
        suspend: Swift.Bool? = nil
    ) {
        self.botId = botId
        self.challenge = challenge
        self.displayName = displayName
        self.groupId = groupId
        self.networkId = networkId
        self.suspend = suspend
    }
}

extension UpdateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBotInput(botId: \(Swift.String(describing: botId)), displayName: \(Swift.String(describing: displayName)), groupId: \(Swift.String(describing: groupId)), networkId: \(Swift.String(describing: networkId)), suspend: \(Swift.String(describing: suspend)), challenge: \"CONTENT_REDACTED\")"}
}

public struct UpdateBotOutput: Swift.Sendable {
    /// A message indicating the result of the bot update operation.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct UpdateDataRetentionInput: Swift.Sendable {
    /// The action to perform. Valid values are 'ENABLE' (to enable the data retention service), 'DISABLE' (to disable the service), or 'PUBKEY_MSG_ACK' (to acknowledge the public key message).
    /// This member is required.
    public var actionType: WickrClientTypes.DataRetentionActionType?
    /// The ID of the Wickr network containing the data retention bot.
    /// This member is required.
    public var networkId: Swift.String?

    public init(
        actionType: WickrClientTypes.DataRetentionActionType? = nil,
        networkId: Swift.String? = nil
    ) {
        self.actionType = actionType
        self.networkId = networkId
    }
}

public struct UpdateDataRetentionOutput: Swift.Sendable {
    /// A message indicating the result of the update operation.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct UpdateGuestUserInput: Swift.Sendable {
    /// Set to true to block the guest user or false to unblock them.
    /// This member is required.
    public var block: Swift.Bool?
    /// The ID of the Wickr network where the guest user's status will be updated.
    /// This member is required.
    public var networkId: Swift.String?
    /// The username hash (unique identifier) of the guest user to update.
    /// This member is required.
    public var usernameHash: Swift.String?

    public init(
        block: Swift.Bool? = nil,
        networkId: Swift.String? = nil,
        usernameHash: Swift.String? = nil
    ) {
        self.block = block
        self.networkId = networkId
        self.usernameHash = usernameHash
    }
}

public struct UpdateGuestUserOutput: Swift.Sendable {
    /// A message indicating the result of the update operation.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct UpdateNetworkInput: Swift.Sendable {
    /// A unique identifier for this request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ARN of the Amazon Web Services KMS customer managed key to use for encrypting sensitive data in the network.
    public var encryptionKeyArn: Swift.String?
    /// The ID of the Wickr network to update.
    /// This member is required.
    public var networkId: Swift.String?
    /// The new name for the network. Must be between 1 and 20 characters.
    /// This member is required.
    public var networkName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        networkId: Swift.String? = nil,
        networkName: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.encryptionKeyArn = encryptionKeyArn
        self.networkId = networkId
        self.networkName = networkName
    }
}

public struct UpdateNetworkOutput: Swift.Sendable {
    /// A message indicating that the network was updated successfully.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct UpdateNetworkSettingsInput: Swift.Sendable {
    /// The ID of the Wickr network whose settings will be updated.
    /// This member is required.
    public var networkId: Swift.String?
    /// A map of setting names to their new values. Each setting should be provided with its appropriate type (boolean, string, number, etc.).
    /// This member is required.
    public var settings: WickrClientTypes.NetworkSettings?

    public init(
        networkId: Swift.String? = nil,
        settings: WickrClientTypes.NetworkSettings? = nil
    ) {
        self.networkId = networkId
        self.settings = settings
    }
}

public struct UpdateNetworkSettingsOutput: Swift.Sendable {
    /// A list of the updated network settings, showing the new values for each modified setting.
    /// This member is required.
    public var settings: [WickrClientTypes.Setting]?

    public init(
        settings: [WickrClientTypes.Setting]? = nil
    ) {
        self.settings = settings
    }
}

public struct UpdateSecurityGroupInput: Swift.Sendable {
    /// The unique identifier of the security group to update.
    /// This member is required.
    public var groupId: Swift.String?
    /// The new name for the security group.
    public var name: Swift.String?
    /// The ID of the Wickr network containing the security group to update.
    /// This member is required.
    public var networkId: Swift.String?
    /// The updated configuration settings for the security group. Federation mode - 0 (Local federation), 1 (Restricted federation), 2 (Global federation)
    public var securityGroupSettings: WickrClientTypes.SecurityGroupSettings?

    public init(
        groupId: Swift.String? = nil,
        name: Swift.String? = nil,
        networkId: Swift.String? = nil,
        securityGroupSettings: WickrClientTypes.SecurityGroupSettings? = nil
    ) {
        self.groupId = groupId
        self.name = name
        self.networkId = networkId
        self.securityGroupSettings = securityGroupSettings
    }
}

public struct UpdateSecurityGroupOutput: Swift.Sendable {
    /// The updated security group details, including the new settings.
    /// This member is required.
    public var securityGroup: WickrClientTypes.SecurityGroup?

    public init(
        securityGroup: WickrClientTypes.SecurityGroup? = nil
    ) {
        self.securityGroup = securityGroup
    }
}

extension WickrClientTypes {

    /// Contains the modifiable details for updating an existing user, including name, password, security group membership, and invitation settings. A user can only be assigned to a single security group. Attempting to add a user to multiple security groups is not supported and will result in an error.
    public struct UpdateUserDetails: Swift.Sendable {
        /// Indicates whether the user can be verified through a custom invite code.
        public var codeValidation: Swift.Bool?
        /// The new first name for the user.
        public var firstName: Swift.String?
        /// A new custom invite code for the user.
        public var inviteCode: Swift.String?
        /// The new time-to-live for the invite code in days.
        public var inviteCodeTtl: Swift.Int?
        /// The new last name for the user.
        public var lastName: Swift.String?
        /// The updated list of security group IDs to which the user should belong.
        public var securityGroupIds: [Swift.String]?
        /// The new username or email address for the user.
        public var username: Swift.String?

        public init(
            codeValidation: Swift.Bool? = nil,
            firstName: Swift.String? = nil,
            inviteCode: Swift.String? = nil,
            inviteCodeTtl: Swift.Int? = nil,
            lastName: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            username: Swift.String? = nil
        ) {
            self.codeValidation = codeValidation
            self.firstName = firstName
            self.inviteCode = inviteCode
            self.inviteCodeTtl = inviteCodeTtl
            self.lastName = lastName
            self.securityGroupIds = securityGroupIds
            self.username = username
        }
    }
}

extension WickrClientTypes.UpdateUserDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserDetails(codeValidation: \(Swift.String(describing: codeValidation)), inviteCode: \(Swift.String(describing: inviteCode)), inviteCodeTtl: \(Swift.String(describing: inviteCodeTtl)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), username: \(Swift.String(describing: username)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

public struct UpdateUserInput: Swift.Sendable {
    /// The ID of the Wickr network containing the user to update.
    /// This member is required.
    public var networkId: Swift.String?
    /// An object containing the user details to be updated, such as name, password, security groups, and invite code settings.
    public var userDetails: WickrClientTypes.UpdateUserDetails?
    /// The unique identifier of the user to update.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        networkId: Swift.String? = nil,
        userDetails: WickrClientTypes.UpdateUserDetails? = nil,
        userId: Swift.String? = nil
    ) {
        self.networkId = networkId
        self.userDetails = userDetails
        self.userId = userId
    }
}

public struct UpdateUserOutput: Swift.Sendable {
    /// Indicates whether the user can be verified through a custom invite code.
    public var codeValidation: Swift.Bool?
    /// The updated first name of the user.
    public var firstName: Swift.String?
    /// The updated invite code for the user, if applicable.
    public var inviteCode: Swift.String?
    /// The expiration time of the user's invite code, specified in epoch seconds.
    public var inviteExpiration: Swift.Int?
    /// The updated last name of the user.
    public var lastName: Swift.String?
    /// The middle name of the user (currently not used).
    public var middleName: Swift.String?
    /// The timestamp when the user was last modified, specified in epoch seconds.
    public var modified: Swift.Int?
    /// The ID of the network where the user was updated.
    /// This member is required.
    public var networkId: Swift.String?
    /// The list of security group IDs to which the user now belongs after the update.
    public var securityGroupIds: [Swift.String]?
    /// The user's status after the update.
    public var status: Swift.Int?
    /// Indicates whether the user is suspended after the update.
    /// This member is required.
    public var suspended: Swift.Bool?
    /// The unique identifier of the updated user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        codeValidation: Swift.Bool? = nil,
        firstName: Swift.String? = nil,
        inviteCode: Swift.String? = nil,
        inviteExpiration: Swift.Int? = nil,
        lastName: Swift.String? = nil,
        middleName: Swift.String? = nil,
        modified: Swift.Int? = nil,
        networkId: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: Swift.Int? = nil,
        suspended: Swift.Bool? = nil,
        userId: Swift.String? = nil
    ) {
        self.codeValidation = codeValidation
        self.firstName = firstName
        self.inviteCode = inviteCode
        self.inviteExpiration = inviteExpiration
        self.lastName = lastName
        self.middleName = middleName
        self.modified = modified
        self.networkId = networkId
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.suspended = suspended
        self.userId = userId
    }
}

extension UpdateUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserOutput(codeValidation: \(Swift.String(describing: codeValidation)), inviteCode: \(Swift.String(describing: inviteCode)), inviteExpiration: \(Swift.String(describing: inviteExpiration)), middleName: \(Swift.String(describing: middleName)), modified: \(Swift.String(describing: modified)), networkId: \(Swift.String(describing: networkId)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), status: \(Swift.String(describing: status)), suspended: \(Swift.String(describing: suspended)), userId: \(Swift.String(describing: userId)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension BatchCreateUserInput {

    static func urlPathProvider(_ value: BatchCreateUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users"
    }
}

extension BatchCreateUserInput {

    static func headerProvider(_ value: BatchCreateUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchDeleteUserInput {

    static func urlPathProvider(_ value: BatchDeleteUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/batch-delete"
    }
}

extension BatchDeleteUserInput {

    static func headerProvider(_ value: BatchDeleteUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchLookupUserUnameInput {

    static func urlPathProvider(_ value: BatchLookupUserUnameInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/uname-lookup"
    }
}

extension BatchLookupUserUnameInput {

    static func headerProvider(_ value: BatchLookupUserUnameInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchReinviteUserInput {

    static func urlPathProvider(_ value: BatchReinviteUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/re-invite"
    }
}

extension BatchReinviteUserInput {

    static func headerProvider(_ value: BatchReinviteUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchResetDevicesForUserInput {

    static func urlPathProvider(_ value: BatchResetDevicesForUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/devices"
    }
}

extension BatchResetDevicesForUserInput {

    static func headerProvider(_ value: BatchResetDevicesForUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchToggleUserSuspendStatusInput {

    static func urlPathProvider(_ value: BatchToggleUserSuspendStatusInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/toggleSuspend"
    }
}

extension BatchToggleUserSuspendStatusInput {

    static func headerProvider(_ value: BatchToggleUserSuspendStatusInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension BatchToggleUserSuspendStatusInput {

    static func queryItemProvider(_ value: BatchToggleUserSuspendStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let suspend = value.suspend else {
            let message = "Creating a URL Query Item failed. suspend is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let suspendQueryItem = Smithy.URIQueryItem(name: "suspend".urlPercentEncoding(), value: Swift.String(suspend).urlPercentEncoding())
        items.append(suspendQueryItem)
        return items
    }
}

extension CreateBotInput {

    static func urlPathProvider(_ value: CreateBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots"
    }
}

extension CreateDataRetentionBotInput {

    static func urlPathProvider(_ value: CreateDataRetentionBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/data-retention-bots"
    }
}

extension CreateDataRetentionBotChallengeInput {

    static func urlPathProvider(_ value: CreateDataRetentionBotChallengeInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/data-retention-bots/challenge"
    }
}

extension CreateNetworkInput {

    static func urlPathProvider(_ value: CreateNetworkInput) -> Swift.String? {
        return "/networks"
    }
}

extension CreateSecurityGroupInput {

    static func urlPathProvider(_ value: CreateSecurityGroupInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups"
    }
}

extension CreateSecurityGroupInput {

    static func headerProvider(_ value: CreateSecurityGroupInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteBotInput {

    static func urlPathProvider(_ value: DeleteBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension DeleteDataRetentionBotInput {

    static func urlPathProvider(_ value: DeleteDataRetentionBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/data-retention-bots"
    }
}

extension DeleteNetworkInput {

    static func urlPathProvider(_ value: DeleteNetworkInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())"
    }
}

extension DeleteNetworkInput {

    static func headerProvider(_ value: DeleteNetworkInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteSecurityGroupInput {

    static func urlPathProvider(_ value: DeleteSecurityGroupInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let groupId = value.groupId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups/\(groupId.urlPercentEncoding())"
    }
}

extension GetBotInput {

    static func urlPathProvider(_ value: GetBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension GetBotsCountInput {

    static func urlPathProvider(_ value: GetBotsCountInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots/count"
    }
}

extension GetDataRetentionBotInput {

    static func urlPathProvider(_ value: GetDataRetentionBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/data-retention-bots"
    }
}

extension GetGuestUserHistoryCountInput {

    static func urlPathProvider(_ value: GetGuestUserHistoryCountInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/guest-users/count"
    }
}

extension GetNetworkInput {

    static func urlPathProvider(_ value: GetNetworkInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())"
    }
}

extension GetNetworkSettingsInput {

    static func urlPathProvider(_ value: GetNetworkSettingsInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/settings"
    }
}

extension GetOidcInfoInput {

    static func urlPathProvider(_ value: GetOidcInfoInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/oidc"
    }
}

extension GetOidcInfoInput {

    static func queryItemProvider(_ value: GetOidcInfoInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let redirectUri = value.redirectUri {
            let redirectUriQueryItem = Smithy.URIQueryItem(name: "redirectUri".urlPercentEncoding(), value: Swift.String(redirectUri).urlPercentEncoding())
            items.append(redirectUriQueryItem)
        }
        if let clientId = value.clientId {
            let clientIdQueryItem = Smithy.URIQueryItem(name: "clientId".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
            items.append(clientIdQueryItem)
        }
        if let code = value.code {
            let codeQueryItem = Smithy.URIQueryItem(name: "code".urlPercentEncoding(), value: Swift.String(code).urlPercentEncoding())
            items.append(codeQueryItem)
        }
        if let codeVerifier = value.codeVerifier {
            let codeVerifierQueryItem = Smithy.URIQueryItem(name: "codeVerifier".urlPercentEncoding(), value: Swift.String(codeVerifier).urlPercentEncoding())
            items.append(codeVerifierQueryItem)
        }
        if let certificate = value.certificate {
            let certificateQueryItem = Smithy.URIQueryItem(name: "certificate".urlPercentEncoding(), value: Swift.String(certificate).urlPercentEncoding())
            items.append(certificateQueryItem)
        }
        if let clientSecret = value.clientSecret {
            let clientSecretQueryItem = Smithy.URIQueryItem(name: "clientSecret".urlPercentEncoding(), value: Swift.String(clientSecret).urlPercentEncoding())
            items.append(clientSecretQueryItem)
        }
        if let grantType = value.grantType {
            let grantTypeQueryItem = Smithy.URIQueryItem(name: "grantType".urlPercentEncoding(), value: Swift.String(grantType).urlPercentEncoding())
            items.append(grantTypeQueryItem)
        }
        if let url = value.url {
            let urlQueryItem = Smithy.URIQueryItem(name: "url".urlPercentEncoding(), value: Swift.String(url).urlPercentEncoding())
            items.append(urlQueryItem)
        }
        return items
    }
}

extension GetSecurityGroupInput {

    static func urlPathProvider(_ value: GetSecurityGroupInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let groupId = value.groupId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups/\(groupId.urlPercentEncoding())"
    }
}

extension GetUserInput {

    static func urlPathProvider(_ value: GetUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension GetUserInput {

    static func queryItemProvider(_ value: GetUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .epochSeconds).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .epochSeconds).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        return items
    }
}

extension GetUsersCountInput {

    static func urlPathProvider(_ value: GetUsersCountInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/count"
    }
}

extension ListBlockedGuestUsersInput {

    static func urlPathProvider(_ value: ListBlockedGuestUsersInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/guest-users/blocklist"
    }
}

extension ListBlockedGuestUsersInput {

    static func queryItemProvider(_ value: ListBlockedGuestUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let admin = value.admin {
            let adminQueryItem = Smithy.URIQueryItem(name: "admin".urlPercentEncoding(), value: Swift.String(admin).urlPercentEncoding())
            items.append(adminQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        if let username = value.username {
            let usernameQueryItem = Smithy.URIQueryItem(name: "username".urlPercentEncoding(), value: Swift.String(username).urlPercentEncoding())
            items.append(usernameQueryItem)
        }
        return items
    }
}

extension ListBotsInput {

    static func urlPathProvider(_ value: ListBotsInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots"
    }
}

extension ListBotsInput {

    static func queryItemProvider(_ value: ListBotsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let displayName = value.displayName {
            let displayNameQueryItem = Smithy.URIQueryItem(name: "displayName".urlPercentEncoding(), value: Swift.String(displayName).urlPercentEncoding())
            items.append(displayNameQueryItem)
        }
        if let groupId = value.groupId {
            let groupIdQueryItem = Smithy.URIQueryItem(name: "groupId".urlPercentEncoding(), value: Swift.String(groupId).urlPercentEncoding())
            items.append(groupIdQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        if let username = value.username {
            let usernameQueryItem = Smithy.URIQueryItem(name: "username".urlPercentEncoding(), value: Swift.String(username).urlPercentEncoding())
            items.append(usernameQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDevicesForUserInput {

    static func urlPathProvider(_ value: ListDevicesForUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/devices"
    }
}

extension ListDevicesForUserInput {

    static func queryItemProvider(_ value: ListDevicesForUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        return items
    }
}

extension ListGuestUsersInput {

    static func urlPathProvider(_ value: ListGuestUsersInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/guest-users"
    }
}

extension ListGuestUsersInput {

    static func queryItemProvider(_ value: ListGuestUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let billingPeriod = value.billingPeriod {
            let billingPeriodQueryItem = Smithy.URIQueryItem(name: "billingPeriod".urlPercentEncoding(), value: Swift.String(billingPeriod).urlPercentEncoding())
            items.append(billingPeriodQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        if let username = value.username {
            let usernameQueryItem = Smithy.URIQueryItem(name: "username".urlPercentEncoding(), value: Swift.String(username).urlPercentEncoding())
            items.append(usernameQueryItem)
        }
        return items
    }
}

extension ListNetworksInput {

    static func urlPathProvider(_ value: ListNetworksInput) -> Swift.String? {
        return "/networks"
    }
}

extension ListNetworksInput {

    static func queryItemProvider(_ value: ListNetworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        return items
    }
}

extension ListSecurityGroupsInput {

    static func urlPathProvider(_ value: ListSecurityGroupsInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups"
    }
}

extension ListSecurityGroupsInput {

    static func queryItemProvider(_ value: ListSecurityGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        return items
    }
}

extension ListSecurityGroupUsersInput {

    static func urlPathProvider(_ value: ListSecurityGroupUsersInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let groupId = value.groupId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups/\(groupId.urlPercentEncoding())/users"
    }
}

extension ListSecurityGroupUsersInput {

    static func queryItemProvider(_ value: ListSecurityGroupUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        return items
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users"
    }
}

extension ListUsersInput {

    static func queryItemProvider(_ value: ListUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let firstName = value.firstName {
            let firstNameQueryItem = Smithy.URIQueryItem(name: "firstName".urlPercentEncoding(), value: Swift.String(firstName).urlPercentEncoding())
            items.append(firstNameQueryItem)
        }
        if let lastName = value.lastName {
            let lastNameQueryItem = Smithy.URIQueryItem(name: "lastName".urlPercentEncoding(), value: Swift.String(lastName).urlPercentEncoding())
            items.append(lastNameQueryItem)
        }
        if let sortDirection = value.sortDirection {
            let sortDirectionQueryItem = Smithy.URIQueryItem(name: "sortDirection".urlPercentEncoding(), value: Swift.String(sortDirection.rawValue).urlPercentEncoding())
            items.append(sortDirectionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let groupId = value.groupId {
            let groupIdQueryItem = Smithy.URIQueryItem(name: "groupId".urlPercentEncoding(), value: Swift.String(groupId).urlPercentEncoding())
            items.append(groupIdQueryItem)
        }
        if let sortFields = value.sortFields {
            let sortFieldsQueryItem = Smithy.URIQueryItem(name: "sortFields".urlPercentEncoding(), value: Swift.String(sortFields).urlPercentEncoding())
            items.append(sortFieldsQueryItem)
        }
        if let username = value.username {
            let usernameQueryItem = Smithy.URIQueryItem(name: "username".urlPercentEncoding(), value: Swift.String(username).urlPercentEncoding())
            items.append(usernameQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension RegisterOidcConfigInput {

    static func urlPathProvider(_ value: RegisterOidcConfigInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/oidc/save"
    }
}

extension RegisterOidcConfigTestInput {

    static func urlPathProvider(_ value: RegisterOidcConfigTestInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/oidc/test"
    }
}

extension UpdateBotInput {

    static func urlPathProvider(_ value: UpdateBotInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension UpdateDataRetentionInput {

    static func urlPathProvider(_ value: UpdateDataRetentionInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/data-retention-bots"
    }
}

extension UpdateGuestUserInput {

    static func urlPathProvider(_ value: UpdateGuestUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let usernameHash = value.usernameHash else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/guest-users/\(usernameHash.urlPercentEncoding())"
    }
}

extension UpdateNetworkInput {

    static func urlPathProvider(_ value: UpdateNetworkInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())"
    }
}

extension UpdateNetworkInput {

    static func headerProvider(_ value: UpdateNetworkInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateNetworkSettingsInput {

    static func urlPathProvider(_ value: UpdateNetworkSettingsInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/settings"
    }
}

extension UpdateSecurityGroupInput {

    static func urlPathProvider(_ value: UpdateSecurityGroupInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        guard let groupId = value.groupId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/security-groups/\(groupId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let networkId = value.networkId else {
            return nil
        }
        return "/networks/\(networkId.urlPercentEncoding())/users"
    }
}

extension BatchCreateUserInput {

    static func write(value: BatchCreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["users"].writeList(value.users, memberWritingClosure: WickrClientTypes.BatchCreateUserRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteUserInput {

    static func write(value: BatchDeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchLookupUserUnameInput {

    static func write(value: BatchLookupUserUnameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unames"].writeList(value.unames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchReinviteUserInput {

    static func write(value: BatchReinviteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchResetDevicesForUserInput {

    static func write(value: BatchResetDevicesForUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIds"].writeList(value.appIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchToggleUserSuspendStatusInput {

    static func write(value: BatchToggleUserSuspendStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBotInput {

    static func write(value: CreateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["challenge"].write(value.challenge)
        try writer["displayName"].write(value.displayName)
        try writer["groupId"].write(value.groupId)
        try writer["username"].write(value.username)
    }
}

extension CreateNetworkInput {

    static func write(value: CreateNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLevel"].write(value.accessLevel)
        try writer["enablePremiumFreeTrial"].write(value.enablePremiumFreeTrial)
        try writer["encryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["networkName"].write(value.networkName)
    }
}

extension CreateSecurityGroupInput {

    static func write(value: CreateSecurityGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["securityGroupSettings"].write(value.securityGroupSettings, with: WickrClientTypes.SecurityGroupSettingsRequest.write(value:to:))
    }
}

extension RegisterOidcConfigInput {

    static func write(value: RegisterOidcConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["companyId"].write(value.companyId)
        try writer["customUsername"].write(value.customUsername)
        try writer["extraAuthParams"].write(value.extraAuthParams)
        try writer["issuer"].write(value.issuer)
        try writer["scopes"].write(value.scopes)
        try writer["secret"].write(value.secret)
        try writer["ssoTokenBufferMinutes"].write(value.ssoTokenBufferMinutes)
        try writer["userId"].write(value.userId)
    }
}

extension RegisterOidcConfigTestInput {

    static func write(value: RegisterOidcConfigTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificate"].write(value.certificate)
        try writer["extraAuthParams"].write(value.extraAuthParams)
        try writer["issuer"].write(value.issuer)
        try writer["scopes"].write(value.scopes)
    }
}

extension UpdateBotInput {

    static func write(value: UpdateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["challenge"].write(value.challenge)
        try writer["displayName"].write(value.displayName)
        try writer["groupId"].write(value.groupId)
        try writer["suspend"].write(value.suspend)
    }
}

extension UpdateDataRetentionInput {

    static func write(value: UpdateDataRetentionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType)
    }
}

extension UpdateGuestUserInput {

    static func write(value: UpdateGuestUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["block"].write(value.block)
    }
}

extension UpdateNetworkInput {

    static func write(value: UpdateNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["networkName"].write(value.networkName)
    }
}

extension UpdateNetworkSettingsInput {

    static func write(value: UpdateNetworkSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["settings"].write(value.settings, with: WickrClientTypes.NetworkSettings.write(value:to:))
    }
}

extension UpdateSecurityGroupInput {

    static func write(value: UpdateSecurityGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["securityGroupSettings"].write(value.securityGroupSettings, with: WickrClientTypes.SecurityGroupSettings.write(value:to:))
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userDetails"].write(value.userDetails, with: WickrClientTypes.UpdateUserDetails.write(value:to:))
        try writer["userId"].write(value.userId)
    }
}

extension BatchCreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateUserOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteUserOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserSuccessResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchLookupUserUnameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchLookupUserUnameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchLookupUserUnameOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUnameErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUnameSuccessResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchReinviteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchReinviteUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchReinviteUserOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserSuccessResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchResetDevicesForUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchResetDevicesForUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchResetDevicesForUserOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchDeviceErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchDeviceSuccessResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchToggleUserSuspendStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchToggleUserSuspendStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchToggleUserSuspendStatusOutput()
        value.failed = try reader["failed"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserErrorResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: WickrClientTypes.BatchUserSuccessResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBotOutput()
        value.botId = try reader["botId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.groupId = try reader["groupId"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.networkId = try reader["networkId"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        return value
    }
}

extension CreateDataRetentionBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataRetentionBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataRetentionBotOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension CreateDataRetentionBotChallengeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataRetentionBotChallengeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataRetentionBotChallengeOutput()
        value.challenge = try reader["challenge"].readIfPresent() ?? ""
        return value
    }
}

extension CreateNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkOutput()
        value.encryptionKeyArn = try reader["encryptionKeyArn"].readIfPresent()
        value.networkId = try reader["networkId"].readIfPresent()
        value.networkName = try reader["networkName"].readIfPresent()
        return value
    }
}

extension CreateSecurityGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityGroupOutput()
        value.securityGroup = try reader["securityGroup"].readIfPresent(with: WickrClientTypes.SecurityGroup.read(from:))
        return value
    }
}

extension DeleteBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBotOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DeleteDataRetentionBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataRetentionBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataRetentionBotOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DeleteNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNetworkOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DeleteSecurityGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSecurityGroupOutput()
        value.groupId = try reader["groupId"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.networkId = try reader["networkId"].readIfPresent()
        return value
    }
}

extension GetBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBotOutput()
        value.botId = try reader["botId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.groupId = try reader["groupId"].readIfPresent()
        value.hasChallenge = try reader["hasChallenge"].readIfPresent()
        value.lastLogin = try reader["lastLogin"].readIfPresent()
        value.pubkey = try reader["pubkey"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.suspended = try reader["suspended"].readIfPresent()
        value.uname = try reader["uname"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        return value
    }
}

extension GetBotsCountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBotsCountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBotsCountOutput()
        value.active = try reader["active"].readIfPresent() ?? 0
        value.pending = try reader["pending"].readIfPresent() ?? 0
        value.total = try reader["total"].readIfPresent() ?? 0
        return value
    }
}

extension GetDataRetentionBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataRetentionBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataRetentionBotOutput()
        value.botExists = try reader["botExists"].readIfPresent()
        value.botName = try reader["botName"].readIfPresent()
        value.isBotActive = try reader["isBotActive"].readIfPresent()
        value.isDataRetentionBotRegistered = try reader["isDataRetentionBotRegistered"].readIfPresent()
        value.isDataRetentionServiceEnabled = try reader["isDataRetentionServiceEnabled"].readIfPresent()
        value.isPubkeyMsgAcked = try reader["isPubkeyMsgAcked"].readIfPresent()
        return value
    }
}

extension GetGuestUserHistoryCountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGuestUserHistoryCountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGuestUserHistoryCountOutput()
        value.history = try reader["history"].readListIfPresent(memberReadingClosure: WickrClientTypes.GuestUserHistoryCount.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkOutput()
        value.accessLevel = try reader["accessLevel"].readIfPresent() ?? .sdkUnknown("")
        value.awsAccountId = try reader["awsAccountId"].readIfPresent() ?? ""
        value.encryptionKeyArn = try reader["encryptionKeyArn"].readIfPresent()
        value.freeTrialExpiration = try reader["freeTrialExpiration"].readIfPresent()
        value.migrationState = try reader["migrationState"].readIfPresent()
        value.networkArn = try reader["networkArn"].readIfPresent() ?? ""
        value.networkId = try reader["networkId"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.standing = try reader["standing"].readIfPresent()
        return value
    }
}

extension GetNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkSettingsOutput()
        value.settings = try reader["settings"].readListIfPresent(memberReadingClosure: WickrClientTypes.Setting.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetOidcInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOidcInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOidcInfoOutput()
        value.openidConnectInfo = try reader["openidConnectInfo"].readIfPresent(with: WickrClientTypes.OidcConfigInfo.read(from:))
        value.tokenInfo = try reader["tokenInfo"].readIfPresent(with: WickrClientTypes.OidcTokenInfo.read(from:))
        return value
    }
}

extension GetSecurityGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityGroupOutput()
        value.securityGroup = try reader["securityGroup"].readIfPresent(with: WickrClientTypes.SecurityGroup.read(from:))
        return value
    }
}

extension GetUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserOutput()
        value.firstName = try reader["firstName"].readIfPresent()
        value.isAdmin = try reader["isAdmin"].readIfPresent()
        value.lastActivity = try reader["lastActivity"].readIfPresent()
        value.lastLogin = try reader["lastLogin"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.suspended = try reader["suspended"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent() ?? ""
        value.username = try reader["username"].readIfPresent()
        return value
    }
}

extension GetUsersCountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsersCountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsersCountOutput()
        value.active = try reader["active"].readIfPresent() ?? 0
        value.pending = try reader["pending"].readIfPresent() ?? 0
        value.rejected = try reader["rejected"].readIfPresent() ?? 0
        value.remaining = try reader["remaining"].readIfPresent() ?? 0
        value.total = try reader["total"].readIfPresent() ?? 0
        return value
    }
}

extension ListBlockedGuestUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBlockedGuestUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBlockedGuestUsersOutput()
        value.blocklist = try reader["blocklist"].readListIfPresent(memberReadingClosure: WickrClientTypes.BlockedGuestUser.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBotsOutput()
        value.bots = try reader["bots"].readListIfPresent(memberReadingClosure: WickrClientTypes.Bot.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesForUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesForUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesForUserOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: WickrClientTypes.BasicDeviceObject.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGuestUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGuestUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGuestUsersOutput()
        value.guestlist = try reader["guestlist"].readListIfPresent(memberReadingClosure: WickrClientTypes.GuestUser.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworksOutput()
        value.networks = try reader["networks"].readListIfPresent(memberReadingClosure: WickrClientTypes.Network.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSecurityGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityGroupsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: WickrClientTypes.SecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityGroupUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityGroupUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityGroupUsersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: WickrClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: WickrClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RegisterOidcConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterOidcConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterOidcConfigOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.applicationName = try reader["applicationName"].readIfPresent()
        value.caCertificate = try reader["caCertificate"].readIfPresent()
        value.clientId = try reader["clientId"].readIfPresent()
        value.clientSecret = try reader["clientSecret"].readIfPresent()
        value.companyId = try reader["companyId"].readIfPresent() ?? ""
        value.customUsername = try reader["customUsername"].readIfPresent()
        value.extraAuthParams = try reader["extraAuthParams"].readIfPresent()
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.redirectUrl = try reader["redirectUrl"].readIfPresent()
        value.scopes = try reader["scopes"].readIfPresent() ?? ""
        value.secret = try reader["secret"].readIfPresent()
        value.ssoTokenBufferMinutes = try reader["ssoTokenBufferMinutes"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension RegisterOidcConfigTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterOidcConfigTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterOidcConfigTestOutput()
        value.authorizationEndpoint = try reader["authorizationEndpoint"].readIfPresent()
        value.endSessionEndpoint = try reader["endSessionEndpoint"].readIfPresent()
        value.grantTypesSupported = try reader["grantTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.issuer = try reader["issuer"].readIfPresent()
        value.logoutEndpoint = try reader["logoutEndpoint"].readIfPresent()
        value.microsoftMultiRefreshToken = try reader["microsoftMultiRefreshToken"].readIfPresent()
        value.responseTypesSupported = try reader["responseTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.revocationEndpoint = try reader["revocationEndpoint"].readIfPresent()
        value.scopesSupported = try reader["scopesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tokenEndpoint = try reader["tokenEndpoint"].readIfPresent()
        value.tokenEndpointAuthMethodsSupported = try reader["tokenEndpointAuthMethodsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userinfoEndpoint = try reader["userinfoEndpoint"].readIfPresent()
        return value
    }
}

extension UpdateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBotOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension UpdateDataRetentionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataRetentionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataRetentionOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension UpdateGuestUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGuestUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGuestUserOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension UpdateNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension UpdateNetworkSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkSettingsOutput()
        value.settings = try reader["settings"].readListIfPresent(memberReadingClosure: WickrClientTypes.Setting.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension UpdateSecurityGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSecurityGroupOutput()
        value.securityGroup = try reader["securityGroup"].readIfPresent(with: WickrClientTypes.SecurityGroup.read(from:))
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.codeValidation = try reader["codeValidation"].readIfPresent()
        value.firstName = try reader["firstName"].readIfPresent()
        value.inviteCode = try reader["inviteCode"].readIfPresent()
        value.inviteExpiration = try reader["inviteExpiration"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        value.middleName = try reader["middleName"].readIfPresent()
        value.modified = try reader["modified"].readIfPresent()
        value.networkId = try reader["networkId"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.suspended = try reader["suspended"].readIfPresent() ?? false
        value.userId = try reader["userId"].readIfPresent() ?? ""
        return value
    }
}

enum BatchCreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchLookupUserUnameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchReinviteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchResetDevicesForUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchToggleUserSuspendStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataRetentionBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataRetentionBotChallengeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataRetentionBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBotsCountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataRetentionBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGuestUserHistoryCountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOidcInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsersCountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBlockedGuestUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesForUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGuestUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityGroupUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterOidcConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterOidcConfigTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataRetentionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGuestUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestError": return try BadRequestError.makeError(baseError: baseError)
            case "ForbiddenError": return try ForbiddenError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "RateLimitError": return try RateLimitError.makeError(baseError: baseError)
            case "ResourceNotFoundError": return try ResourceNotFoundError.makeError(baseError: baseError)
            case "UnauthorizedError": return try UnauthorizedError.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestError {
        let reader = baseError.errorBodyReader
        var value = BadRequestError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenError {
        let reader = baseError.errorBodyReader
        var value = ForbiddenError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RateLimitError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RateLimitError {
        let reader = baseError.errorBodyReader
        var value = RateLimitError()
        value.properties.message = try reader["message"].readIfPresent() ?? "Too many requests sent"
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundError {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedError {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationError {
        let reader = baseError.errorBodyReader
        var value = ValidationError()
        value.properties.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: WickrClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WickrClientTypes.BasicDeviceObject {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BasicDeviceObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BasicDeviceObject()
        value.appId = try reader["appId"].readIfPresent()
        value.created = try reader["created"].readIfPresent()
        value.lastLogin = try reader["lastLogin"].readIfPresent()
        value.statusText = try reader["statusText"].readIfPresent()
        value.suspend = try reader["suspend"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.BatchCreateUserRequestItem {

    static func write(value: WickrClientTypes.BatchCreateUserRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["codeValidation"].write(value.codeValidation)
        try writer["firstName"].write(value.firstName)
        try writer["inviteCode"].write(value.inviteCode)
        try writer["inviteCodeTtl"].write(value.inviteCodeTtl)
        try writer["lastName"].write(value.lastName)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["username"].write(value.username)
    }
}

extension WickrClientTypes.BatchDeviceErrorResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchDeviceErrorResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchDeviceErrorResponseItem()
        value.field = try reader["field"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BatchDeviceSuccessResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchDeviceSuccessResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchDeviceSuccessResponseItem()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BatchUnameErrorResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchUnameErrorResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchUnameErrorResponseItem()
        value.field = try reader["field"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.uname = try reader["uname"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BatchUnameSuccessResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchUnameSuccessResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchUnameSuccessResponseItem()
        value.uname = try reader["uname"].readIfPresent() ?? ""
        value.username = try reader["username"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BatchUserErrorResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchUserErrorResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchUserErrorResponseItem()
        value.field = try reader["field"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BatchUserSuccessResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BatchUserSuccessResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BatchUserSuccessResponseItem()
        value.userId = try reader["userId"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.BlockedGuestUser {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.BlockedGuestUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.BlockedGuestUser()
        value.username = try reader["username"].readIfPresent() ?? ""
        value.admin = try reader["admin"].readIfPresent() ?? ""
        value.modified = try reader["modified"].readIfPresent() ?? ""
        value.usernameHash = try reader["usernameHash"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.Bot {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.Bot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.Bot()
        value.botId = try reader["botId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        value.uname = try reader["uname"].readIfPresent()
        value.pubkey = try reader["pubkey"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.groupId = try reader["groupId"].readIfPresent()
        value.hasChallenge = try reader["hasChallenge"].readIfPresent()
        value.suspended = try reader["suspended"].readIfPresent()
        value.lastLogin = try reader["lastLogin"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.CallingSettings {

    static func write(value: WickrClientTypes.CallingSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canStart11Call"].write(value.canStart11Call)
        try writer["canVideoCall"].write(value.canVideoCall)
        try writer["forceTcpCall"].write(value.forceTcpCall)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.CallingSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.CallingSettings()
        value.canStart11Call = try reader["canStart11Call"].readIfPresent()
        value.canVideoCall = try reader["canVideoCall"].readIfPresent()
        value.forceTcpCall = try reader["forceTcpCall"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.ErrorDetail()
        value.field = try reader["field"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.GuestUser {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.GuestUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.GuestUser()
        value.billingPeriod = try reader["billingPeriod"].readIfPresent() ?? ""
        value.username = try reader["username"].readIfPresent() ?? ""
        value.usernameHash = try reader["usernameHash"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.GuestUserHistoryCount {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.GuestUserHistoryCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.GuestUserHistoryCount()
        value.month = try reader["month"].readIfPresent() ?? ""
        value.count = try reader["count"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.Network {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.Network {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.Network()
        value.networkId = try reader["networkId"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.accessLevel = try reader["accessLevel"].readIfPresent() ?? .sdkUnknown("")
        value.awsAccountId = try reader["awsAccountId"].readIfPresent() ?? ""
        value.networkArn = try reader["networkArn"].readIfPresent() ?? ""
        value.standing = try reader["standing"].readIfPresent()
        value.freeTrialExpiration = try reader["freeTrialExpiration"].readIfPresent()
        value.migrationState = try reader["migrationState"].readIfPresent()
        value.encryptionKeyArn = try reader["encryptionKeyArn"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.NetworkSettings {

    static func write(value: WickrClientTypes.NetworkSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataRetention"].write(value.dataRetention)
        try writer["enableClientMetrics"].write(value.enableClientMetrics)
        try writer["readReceiptConfig"].write(value.readReceiptConfig, with: WickrClientTypes.ReadReceiptConfig.write(value:to:))
    }
}

extension WickrClientTypes.OidcConfigInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.OidcConfigInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.OidcConfigInfo()
        value.applicationName = try reader["applicationName"].readIfPresent()
        value.clientId = try reader["clientId"].readIfPresent()
        value.companyId = try reader["companyId"].readIfPresent() ?? ""
        value.scopes = try reader["scopes"].readIfPresent() ?? ""
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.clientSecret = try reader["clientSecret"].readIfPresent()
        value.secret = try reader["secret"].readIfPresent()
        value.redirectUrl = try reader["redirectUrl"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.customUsername = try reader["customUsername"].readIfPresent()
        value.caCertificate = try reader["caCertificate"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.ssoTokenBufferMinutes = try reader["ssoTokenBufferMinutes"].readIfPresent()
        value.extraAuthParams = try reader["extraAuthParams"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.OidcTokenInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.OidcTokenInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.OidcTokenInfo()
        value.codeVerifier = try reader["codeVerifier"].readIfPresent()
        value.codeChallenge = try reader["codeChallenge"].readIfPresent()
        value.accessToken = try reader["accessToken"].readIfPresent()
        value.idToken = try reader["idToken"].readIfPresent()
        value.refreshToken = try reader["refreshToken"].readIfPresent()
        value.tokenType = try reader["tokenType"].readIfPresent()
        value.expiresIn = try reader["expiresIn"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.PasswordRequirements {

    static func write(value: WickrClientTypes.PasswordRequirements?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lowercase"].write(value.lowercase)
        try writer["minLength"].write(value.minLength)
        try writer["numbers"].write(value.numbers)
        try writer["symbols"].write(value.symbols)
        try writer["uppercase"].write(value.uppercase)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.PasswordRequirements {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.PasswordRequirements()
        value.lowercase = try reader["lowercase"].readIfPresent()
        value.minLength = try reader["minLength"].readIfPresent()
        value.numbers = try reader["numbers"].readIfPresent()
        value.symbols = try reader["symbols"].readIfPresent()
        value.uppercase = try reader["uppercase"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.PermittedWickrEnterpriseNetwork {

    static func write(value: WickrClientTypes.PermittedWickrEnterpriseNetwork?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domain"].write(value.domain)
        try writer["networkId"].write(value.networkId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.PermittedWickrEnterpriseNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.PermittedWickrEnterpriseNetwork()
        value.domain = try reader["domain"].readIfPresent() ?? ""
        value.networkId = try reader["networkId"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.ReadReceiptConfig {

    static func write(value: WickrClientTypes.ReadReceiptConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension WickrClientTypes.SecurityGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.SecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.SecurityGroup()
        value.activeMembers = try reader["activeMembers"].readIfPresent() ?? 0
        value.botMembers = try reader["botMembers"].readIfPresent() ?? 0
        value.activeDirectoryGuid = try reader["activeDirectoryGuid"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.isDefault = try reader["isDefault"].readIfPresent() ?? false
        value.name = try reader["name"].readIfPresent() ?? ""
        value.modified = try reader["modified"].readIfPresent() ?? 0
        value.securityGroupSettings = try reader["securityGroupSettings"].readIfPresent(with: WickrClientTypes.SecurityGroupSettings.read(from:))
        return value
    }
}

extension WickrClientTypes.SecurityGroupSettings {

    static func write(value: WickrClientTypes.SecurityGroupSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alwaysReauthenticate"].write(value.alwaysReauthenticate)
        try writer["atakPackageValues"].writeList(value.atakPackageValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["calling"].write(value.calling, with: WickrClientTypes.CallingSettings.write(value:to:))
        try writer["checkForUpdates"].write(value.checkForUpdates)
        try writer["enableAtak"].write(value.enableAtak)
        try writer["enableCrashReports"].write(value.enableCrashReports)
        try writer["enableFileDownload"].write(value.enableFileDownload)
        try writer["enableGuestFederation"].write(value.enableGuestFederation)
        try writer["enableNotificationPreview"].write(value.enableNotificationPreview)
        try writer["enableOpenAccessOption"].write(value.enableOpenAccessOption)
        try writer["enableRestrictedGlobalFederation"].write(value.enableRestrictedGlobalFederation)
        try writer["federationMode"].write(value.federationMode)
        try writer["filesEnabled"].write(value.filesEnabled)
        try writer["forceDeviceLockout"].write(value.forceDeviceLockout)
        try writer["forceOpenAccess"].write(value.forceOpenAccess)
        try writer["forceReadReceipts"].write(value.forceReadReceipts)
        try writer["globalFederation"].write(value.globalFederation)
        try writer["isAtoEnabled"].write(value.isAtoEnabled)
        try writer["isLinkPreviewEnabled"].write(value.isLinkPreviewEnabled)
        try writer["locationAllowMaps"].write(value.locationAllowMaps)
        try writer["locationEnabled"].write(value.locationEnabled)
        try writer["lockoutThreshold"].write(value.lockoutThreshold)
        try writer["maxAutoDownloadSize"].write(value.maxAutoDownloadSize)
        try writer["maxBor"].write(value.maxBor)
        try writer["maxTtl"].write(value.maxTtl)
        try writer["messageForwardingEnabled"].write(value.messageForwardingEnabled)
        try writer["passwordRequirements"].write(value.passwordRequirements, with: WickrClientTypes.PasswordRequirements.write(value:to:))
        try writer["permittedNetworks"].writeList(value.permittedNetworks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["permittedWickrAwsNetworks"].writeList(value.permittedWickrAwsNetworks, memberWritingClosure: WickrClientTypes.WickrAwsNetworks.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["permittedWickrEnterpriseNetworks"].writeList(value.permittedWickrEnterpriseNetworks, memberWritingClosure: WickrClientTypes.PermittedWickrEnterpriseNetwork.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["presenceEnabled"].write(value.presenceEnabled)
        try writer["quickResponses"].writeList(value.quickResponses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["showMasterRecoveryKey"].write(value.showMasterRecoveryKey)
        try writer["shredder"].write(value.shredder, with: WickrClientTypes.ShredderSettings.write(value:to:))
        try writer["ssoMaxIdleMinutes"].write(value.ssoMaxIdleMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.SecurityGroupSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.SecurityGroupSettings()
        value.alwaysReauthenticate = try reader["alwaysReauthenticate"].readIfPresent()
        value.atakPackageValues = try reader["atakPackageValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.calling = try reader["calling"].readIfPresent(with: WickrClientTypes.CallingSettings.read(from:))
        value.checkForUpdates = try reader["checkForUpdates"].readIfPresent()
        value.enableAtak = try reader["enableAtak"].readIfPresent()
        value.enableCrashReports = try reader["enableCrashReports"].readIfPresent()
        value.enableFileDownload = try reader["enableFileDownload"].readIfPresent()
        value.enableGuestFederation = try reader["enableGuestFederation"].readIfPresent()
        value.enableNotificationPreview = try reader["enableNotificationPreview"].readIfPresent()
        value.enableOpenAccessOption = try reader["enableOpenAccessOption"].readIfPresent()
        value.enableRestrictedGlobalFederation = try reader["enableRestrictedGlobalFederation"].readIfPresent()
        value.filesEnabled = try reader["filesEnabled"].readIfPresent()
        value.forceDeviceLockout = try reader["forceDeviceLockout"].readIfPresent()
        value.forceOpenAccess = try reader["forceOpenAccess"].readIfPresent()
        value.forceReadReceipts = try reader["forceReadReceipts"].readIfPresent()
        value.globalFederation = try reader["globalFederation"].readIfPresent()
        value.isAtoEnabled = try reader["isAtoEnabled"].readIfPresent()
        value.isLinkPreviewEnabled = try reader["isLinkPreviewEnabled"].readIfPresent()
        value.locationAllowMaps = try reader["locationAllowMaps"].readIfPresent()
        value.locationEnabled = try reader["locationEnabled"].readIfPresent()
        value.maxAutoDownloadSize = try reader["maxAutoDownloadSize"].readIfPresent()
        value.maxBor = try reader["maxBor"].readIfPresent()
        value.maxTtl = try reader["maxTtl"].readIfPresent()
        value.messageForwardingEnabled = try reader["messageForwardingEnabled"].readIfPresent()
        value.passwordRequirements = try reader["passwordRequirements"].readIfPresent(with: WickrClientTypes.PasswordRequirements.read(from:))
        value.presenceEnabled = try reader["presenceEnabled"].readIfPresent()
        value.quickResponses = try reader["quickResponses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.showMasterRecoveryKey = try reader["showMasterRecoveryKey"].readIfPresent()
        value.shredder = try reader["shredder"].readIfPresent(with: WickrClientTypes.ShredderSettings.read(from:))
        value.ssoMaxIdleMinutes = try reader["ssoMaxIdleMinutes"].readIfPresent()
        value.federationMode = try reader["federationMode"].readIfPresent()
        value.lockoutThreshold = try reader["lockoutThreshold"].readIfPresent()
        value.permittedNetworks = try reader["permittedNetworks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.permittedWickrAwsNetworks = try reader["permittedWickrAwsNetworks"].readListIfPresent(memberReadingClosure: WickrClientTypes.WickrAwsNetworks.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permittedWickrEnterpriseNetworks = try reader["permittedWickrEnterpriseNetworks"].readListIfPresent(memberReadingClosure: WickrClientTypes.PermittedWickrEnterpriseNetwork.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WickrClientTypes.SecurityGroupSettingsRequest {

    static func write(value: WickrClientTypes.SecurityGroupSettingsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableGuestFederation"].write(value.enableGuestFederation)
        try writer["enableRestrictedGlobalFederation"].write(value.enableRestrictedGlobalFederation)
        try writer["federationMode"].write(value.federationMode)
        try writer["globalFederation"].write(value.globalFederation)
        try writer["lockoutThreshold"].write(value.lockoutThreshold)
        try writer["permittedNetworks"].writeList(value.permittedNetworks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["permittedWickrAwsNetworks"].writeList(value.permittedWickrAwsNetworks, memberWritingClosure: WickrClientTypes.WickrAwsNetworks.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["permittedWickrEnterpriseNetworks"].writeList(value.permittedWickrEnterpriseNetworks, memberWritingClosure: WickrClientTypes.PermittedWickrEnterpriseNetwork.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WickrClientTypes.Setting {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.Setting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.Setting()
        value.optionName = try reader["optionName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        return value
    }
}

extension WickrClientTypes.ShredderSettings {

    static func write(value: WickrClientTypes.ShredderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canProcessManually"].write(value.canProcessManually)
        try writer["intensity"].write(value.intensity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.ShredderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.ShredderSettings()
        value.canProcessManually = try reader["canProcessManually"].readIfPresent()
        value.intensity = try reader["intensity"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.UpdateUserDetails {

    static func write(value: WickrClientTypes.UpdateUserDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["codeValidation"].write(value.codeValidation)
        try writer["firstName"].write(value.firstName)
        try writer["inviteCode"].write(value.inviteCode)
        try writer["inviteCodeTtl"].write(value.inviteCodeTtl)
        try writer["lastName"].write(value.lastName)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["username"].write(value.username)
    }
}

extension WickrClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.User()
        value.userId = try reader["userId"].readIfPresent()
        value.firstName = try reader["firstName"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isAdmin = try reader["isAdmin"].readIfPresent()
        value.suspended = try reader["suspended"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.otpEnabled = try reader["otpEnabled"].readIfPresent()
        value.scimId = try reader["scimId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.cell = try reader["cell"].readIfPresent()
        value.countryCode = try reader["countryCode"].readIfPresent()
        value.challengeFailures = try reader["challengeFailures"].readIfPresent()
        value.isInviteExpired = try reader["isInviteExpired"].readIfPresent()
        value.isUser = try reader["isUser"].readIfPresent()
        value.inviteCode = try reader["inviteCode"].readIfPresent()
        value.codeValidation = try reader["codeValidation"].readIfPresent()
        value.uname = try reader["uname"].readIfPresent()
        return value
    }
}

extension WickrClientTypes.WickrAwsNetworks {

    static func write(value: WickrClientTypes.WickrAwsNetworks?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkId"].write(value.networkId)
        try writer["region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WickrClientTypes.WickrAwsNetworks {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WickrClientTypes.WickrAwsNetworks()
        value.region = try reader["region"].readIfPresent() ?? ""
        value.networkId = try reader["networkId"].readIfPresent() ?? ""
        return value
    }
}

public enum WickrClientTypes {}
