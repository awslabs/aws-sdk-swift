//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension WickrClient {
    /// Paginate over `[ListBlockedGuestUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBlockedGuestUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBlockedGuestUsersOutput`
    public func listBlockedGuestUsersPaginated(input: ListBlockedGuestUsersInput) -> ClientRuntime.PaginatorSequence<ListBlockedGuestUsersInput, ListBlockedGuestUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListBlockedGuestUsersInput, ListBlockedGuestUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBlockedGuestUsers(input:))
    }
}

extension ListBlockedGuestUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBlockedGuestUsersInput {
        return ListBlockedGuestUsersInput(
            admin: self.admin,
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields,
            username: self.username
        )}
}

extension PaginatorSequence where OperationStackInput == ListBlockedGuestUsersInput, OperationStackOutput == ListBlockedGuestUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBlockedGuestUsersPaginated`
    /// to access the nested member `[WickrClientTypes.BlockedGuestUser]`
    /// - Returns: `[WickrClientTypes.BlockedGuestUser]`
    public func blocklist() async throws -> [WickrClientTypes.BlockedGuestUser] {
        return try await self.asyncCompactMap { item in item.blocklist }
    }
}
extension WickrClient {
    /// Paginate over `[ListBotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotsOutput`
    public func listBotsPaginated(input: ListBotsInput) -> ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutput> {
        return ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBots(input:))
    }
}

extension ListBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotsInput {
        return ListBotsInput(
            displayName: self.displayName,
            groupId: self.groupId,
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields,
            status: self.status,
            username: self.username
        )}
}

extension PaginatorSequence where OperationStackInput == ListBotsInput, OperationStackOutput == ListBotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBotsPaginated`
    /// to access the nested member `[WickrClientTypes.Bot]`
    /// - Returns: `[WickrClientTypes.Bot]`
    public func bots() async throws -> [WickrClientTypes.Bot] {
        return try await self.asyncCompactMap { item in item.bots }
    }
}
extension WickrClient {
    /// Paginate over `[ListDevicesForUserOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesForUserInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesForUserOutput`
    public func listDevicesForUserPaginated(input: ListDevicesForUserInput) -> ClientRuntime.PaginatorSequence<ListDevicesForUserInput, ListDevicesForUserOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesForUserInput, ListDevicesForUserOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevicesForUser(input:))
    }
}

extension ListDevicesForUserInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesForUserInput {
        return ListDevicesForUserInput(
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields,
            userId: self.userId
        )}
}

extension PaginatorSequence where OperationStackInput == ListDevicesForUserInput, OperationStackOutput == ListDevicesForUserOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicesForUserPaginated`
    /// to access the nested member `[WickrClientTypes.BasicDeviceObject]`
    /// - Returns: `[WickrClientTypes.BasicDeviceObject]`
    public func devices() async throws -> [WickrClientTypes.BasicDeviceObject] {
        return try await self.asyncCompactMap { item in item.devices }
    }
}
extension WickrClient {
    /// Paginate over `[ListGuestUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGuestUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGuestUsersOutput`
    public func listGuestUsersPaginated(input: ListGuestUsersInput) -> ClientRuntime.PaginatorSequence<ListGuestUsersInput, ListGuestUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListGuestUsersInput, ListGuestUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGuestUsers(input:))
    }
}

extension ListGuestUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGuestUsersInput {
        return ListGuestUsersInput(
            billingPeriod: self.billingPeriod,
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields,
            username: self.username
        )}
}

extension PaginatorSequence where OperationStackInput == ListGuestUsersInput, OperationStackOutput == ListGuestUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGuestUsersPaginated`
    /// to access the nested member `[WickrClientTypes.GuestUser]`
    /// - Returns: `[WickrClientTypes.GuestUser]`
    public func guestlist() async throws -> [WickrClientTypes.GuestUser] {
        return try await self.asyncCompactMap { item in item.guestlist }
    }
}
extension WickrClient {
    /// Paginate over `[ListNetworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNetworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNetworksOutput`
    public func listNetworksPaginated(input: ListNetworksInput) -> ClientRuntime.PaginatorSequence<ListNetworksInput, ListNetworksOutput> {
        return ClientRuntime.PaginatorSequence<ListNetworksInput, ListNetworksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNetworks(input:))
    }
}

extension ListNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNetworksInput {
        return ListNetworksInput(
            maxResults: self.maxResults,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields
        )}
}

extension PaginatorSequence where OperationStackInput == ListNetworksInput, OperationStackOutput == ListNetworksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNetworksPaginated`
    /// to access the nested member `[WickrClientTypes.Network]`
    /// - Returns: `[WickrClientTypes.Network]`
    public func networks() async throws -> [WickrClientTypes.Network] {
        return try await self.asyncCompactMap { item in item.networks }
    }
}
extension WickrClient {
    /// Paginate over `[ListSecurityGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityGroupsOutput`
    public func listSecurityGroupsPaginated(input: ListSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<ListSecurityGroupsInput, ListSecurityGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityGroupsInput, ListSecurityGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSecurityGroups(input:))
    }
}

extension ListSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityGroupsInput {
        return ListSecurityGroupsInput(
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields
        )}
}

extension PaginatorSequence where OperationStackInput == ListSecurityGroupsInput, OperationStackOutput == ListSecurityGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityGroupsPaginated`
    /// to access the nested member `[WickrClientTypes.SecurityGroup]`
    /// - Returns: `[WickrClientTypes.SecurityGroup]`
    public func securityGroups() async throws -> [WickrClientTypes.SecurityGroup] {
        return try await self.asyncCompactMap { item in item.securityGroups }
    }
}
extension WickrClient {
    /// Paginate over `[ListSecurityGroupUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityGroupUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityGroupUsersOutput`
    public func listSecurityGroupUsersPaginated(input: ListSecurityGroupUsersInput) -> ClientRuntime.PaginatorSequence<ListSecurityGroupUsersInput, ListSecurityGroupUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityGroupUsersInput, ListSecurityGroupUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSecurityGroupUsers(input:))
    }
}

extension ListSecurityGroupUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityGroupUsersInput {
        return ListSecurityGroupUsersInput(
            groupId: self.groupId,
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields
        )}
}

extension PaginatorSequence where OperationStackInput == ListSecurityGroupUsersInput, OperationStackOutput == ListSecurityGroupUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityGroupUsersPaginated`
    /// to access the nested member `[WickrClientTypes.User]`
    /// - Returns: `[WickrClientTypes.User]`
    public func users() async throws -> [WickrClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
extension WickrClient {
    /// Paginate over `[ListUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutput`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            firstName: self.firstName,
            groupId: self.groupId,
            lastName: self.lastName,
            maxResults: self.maxResults,
            networkId: self.networkId,
            nextToken: token,
            sortDirection: self.sortDirection,
            sortFields: self.sortFields,
            status: self.status,
            username: self.username
        )}
}

extension PaginatorSequence where OperationStackInput == ListUsersInput, OperationStackOutput == ListUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
    /// to access the nested member `[WickrClientTypes.User]`
    /// - Returns: `[WickrClientTypes.User]`
    public func users() async throws -> [WickrClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
