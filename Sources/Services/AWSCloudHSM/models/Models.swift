// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tagList: [CloudHSMClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tagList: [CloudHSMClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagList: [CloudHSMClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension AddTagsToResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddTagsToResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct AddTagsToResourceOutput: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct AddTagsToResourceOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension AddTagsToResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum AddTagsToResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudHSMClientTypes {
    public enum ClientVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fiveOne
        case fiveThree
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientVersion] {
            return [
                .fiveOne,
                .fiveThree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fiveOne: return "5.1"
            case .fiveThree: return "5.3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientVersion(rawValue: rawValue) ?? ClientVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmInternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.retryable = output.retryable
        } else {
            self.properties.message = nil
            self.properties.retryable = false
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an internal error occurred.
public struct CloudHsmInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the error.
        public internal(set) var message: Swift.String? = nil
        /// Indicates if the action can be retried.
        public internal(set) var retryable: Swift.Bool = false
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmInternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.properties.message = message
        self.properties.retryable = retryable
    }
}

struct CloudHsmInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension CloudHsmInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension CloudHSMClientTypes {
    public enum CloudHsmObjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case ready
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudHsmObjectState] {
            return [
                .degraded,
                .ready,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudHsmObjectState(rawValue: rawValue) ?? CloudHsmObjectState.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.retryable = output.retryable
        } else {
            self.properties.message = nil
            self.properties.retryable = false
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an exception occurred in the AWS CloudHSM service.
public struct CloudHsmServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the error.
        public internal(set) var message: Swift.String? = nil
        /// Indicates if the action can be retried.
        public internal(set) var retryable: Swift.Bool = false
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmServiceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.properties.message = message
        self.properties.retryable = retryable
    }
}

struct CloudHsmServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension CloudHsmServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension CreateHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

extension CreateHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateHapgRequest] action.
public struct CreateHapgInput: Swift.Equatable {
    /// The label of the new high-availability partition group.
    /// This member is required.
    public var label: Swift.String?

    public init(
        label: Swift.String? = nil
    )
    {
        self.label = label
    }
}

struct CreateHapgInputBody: Swift.Equatable {
    let label: Swift.String?
}

extension CreateHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

extension CreateHapgOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateHapgOutputBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

/// Contains the output of the [CreateHAPartitionGroup] action.
public struct CreateHapgOutput: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?

    public init(
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct CreateHapgOutputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension CreateHapgOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

enum CreateHapgOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let sshKey = self.sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let subscriptionType = self.subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
        if let syslogIp = self.syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

extension CreateHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the CreateHsm operation.
public struct CreateHsmInput: Swift.Equatable {
    /// A user-defined token to ensure idempotence. Subsequent calls to this operation with the same token will be ignored.
    public var clientToken: Swift.String?
    /// The IP address to assign to the HSM's ENI. If an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the subnet.
    public var eniIp: Swift.String?
    /// The external ID from IamRoleArn, if present.
    public var externalId: Swift.String?
    /// The ARN of an IAM role to enable the AWS CloudHSM service to allocate an ENI on your behalf.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The SSH public key to install on the HSM.
    /// This member is required.
    public var sshKey: Swift.String?
    /// The identifier of the subnet in your VPC in which to place the HSM.
    /// This member is required.
    public var subnetId: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    /// This member is required.
    public var subscriptionType: CloudHSMClientTypes.SubscriptionType?
    /// The IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
    public var syslogIp: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        sshKey: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionType: CloudHSMClientTypes.SubscriptionType? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eniIp = eniIp
        self.externalId = externalId
        self.iamRoleArn = iamRoleArn
        self.sshKey = sshKey
        self.subnetId = subnetId
        self.subscriptionType = subscriptionType
        self.syslogIp = syslogIp
    }
}

struct CreateHsmInputBody: Swift.Equatable {
    let subnetId: Swift.String?
    let sshKey: Swift.String?
    let eniIp: Swift.String?
    let iamRoleArn: Swift.String?
    let externalId: Swift.String?
    let subscriptionType: CloudHSMClientTypes.SubscriptionType?
    let clientToken: Swift.String?
    let syslogIp: Swift.String?
}

extension CreateHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension CreateHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the CreateHsm operation.
public struct CreateHsmOutput: Swift.Equatable {
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?

    public init(
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct CreateHsmOutputBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension CreateHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

enum CreateHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

extension CreateLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateLunaClient] action.
public struct CreateLunaClientInput: Swift.Equatable {
    /// The contents of a Base64-Encoded X.509 v3 certificate to be installed on the HSMs used by this client.
    /// This member is required.
    public var certificate: Swift.String?
    /// The label for the client.
    public var label: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        label: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.label = label
    }
}

struct CreateLunaClientInputBody: Swift.Equatable {
    let label: Swift.String?
    let certificate: Swift.String?
}

extension CreateLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension CreateLunaClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLunaClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

/// Contains the output of the [CreateLunaClient] action.
public struct CreateLunaClientOutput: Swift.Equatable {
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init(
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct CreateLunaClientOutputBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension CreateLunaClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

enum CreateLunaClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

extension DeleteHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteHapg] action.
public struct DeleteHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to delete.
    /// This member is required.
    public var hapgArn: Swift.String?

    public init(
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DeleteHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension DeleteHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DeleteHapgOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteHapgOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the [DeleteHapg] action.
public struct DeleteHapgOutput: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHapgOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteHapgOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteHapgOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
    }
}

extension DeleteHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteHsm] operation.
public struct DeleteHsmInput: Swift.Equatable {
    /// The ARN of the HSM to delete.
    /// This member is required.
    public var hsmArn: Swift.String?

    public init(
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct DeleteHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension DeleteHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension DeleteHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the [DeleteHsm] operation.
public struct DeleteHsmOutput: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHsmOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension DeleteLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLunaClientInput: Swift.Equatable {
    /// The ARN of the client to delete.
    /// This member is required.
    public var clientArn: Swift.String?

    public init(
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct DeleteLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension DeleteLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension DeleteLunaClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLunaClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteLunaClientOutput: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteLunaClientOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteLunaClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteLunaClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

extension DescribeHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeHapg] action.
public struct DescribeHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to describe.
    /// This member is required.
    public var hapgArn: Swift.String?

    public init(
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DescribeHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension DescribeHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DescribeHapgOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHapgOutputBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
            self.hapgSerial = output.hapgSerial
            self.hsmsLastActionFailed = output.hsmsLastActionFailed
            self.hsmsPendingDeletion = output.hsmsPendingDeletion
            self.hsmsPendingRegistration = output.hsmsPendingRegistration
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.partitionSerialList = output.partitionSerialList
            self.state = output.state
        } else {
            self.hapgArn = nil
            self.hapgSerial = nil
            self.hsmsLastActionFailed = nil
            self.hsmsPendingDeletion = nil
            self.hsmsPendingRegistration = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
            self.partitionSerialList = nil
            self.state = nil
        }
    }
}

/// Contains the output of the [DescribeHapg] action.
public struct DescribeHapgOutput: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?
    /// The serial number of the high-availability partition group.
    public var hapgSerial: Swift.String?
    ///
    public var hsmsLastActionFailed: [Swift.String]?
    ///
    public var hsmsPendingDeletion: [Swift.String]?
    ///
    public var hsmsPendingRegistration: [Swift.String]?
    /// The label for the high-availability partition group.
    public var label: Swift.String?
    /// The date and time the high-availability partition group was last modified.
    public var lastModifiedTimestamp: Swift.String?
    /// The list of partition serial numbers that belong to the high-availability partition group.
    public var partitionSerialList: [Swift.String]?
    /// The state of the high-availability partition group.
    public var state: CloudHSMClientTypes.CloudHsmObjectState?

    public init(
        hapgArn: Swift.String? = nil,
        hapgSerial: Swift.String? = nil,
        hsmsLastActionFailed: [Swift.String]? = nil,
        hsmsPendingDeletion: [Swift.String]? = nil,
        hsmsPendingRegistration: [Swift.String]? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil,
        state: CloudHSMClientTypes.CloudHsmObjectState? = nil
    )
    {
        self.hapgArn = hapgArn
        self.hapgSerial = hapgSerial
        self.hsmsLastActionFailed = hsmsLastActionFailed
        self.hsmsPendingDeletion = hsmsPendingDeletion
        self.hsmsPendingRegistration = hsmsPendingRegistration
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.partitionSerialList = partitionSerialList
        self.state = state
    }
}

struct DescribeHapgOutputBody: Swift.Equatable {
    let hapgArn: Swift.String?
    let hapgSerial: Swift.String?
    let hsmsLastActionFailed: [Swift.String]?
    let hsmsPendingDeletion: [Swift.String]?
    let hsmsPendingRegistration: [Swift.String]?
    let label: Swift.String?
    let lastModifiedTimestamp: Swift.String?
    let partitionSerialList: [Swift.String]?
    let state: CloudHSMClientTypes.CloudHsmObjectState?
}

extension DescribeHapgOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case hapgSerial = "HapgSerial"
        case hsmsLastActionFailed = "HsmsLastActionFailed"
        case hsmsPendingDeletion = "HsmsPendingDeletion"
        case hsmsPendingRegistration = "HsmsPendingRegistration"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case partitionSerialList = "PartitionSerialList"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let hapgSerialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgSerial)
        hapgSerial = hapgSerialDecoded
        let hsmsLastActionFailedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsLastActionFailed)
        var hsmsLastActionFailedDecoded0:[Swift.String]? = nil
        if let hsmsLastActionFailedContainer = hsmsLastActionFailedContainer {
            hsmsLastActionFailedDecoded0 = [Swift.String]()
            for string0 in hsmsLastActionFailedContainer {
                if let string0 = string0 {
                    hsmsLastActionFailedDecoded0?.append(string0)
                }
            }
        }
        hsmsLastActionFailed = hsmsLastActionFailedDecoded0
        let hsmsPendingDeletionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingDeletion)
        var hsmsPendingDeletionDecoded0:[Swift.String]? = nil
        if let hsmsPendingDeletionContainer = hsmsPendingDeletionContainer {
            hsmsPendingDeletionDecoded0 = [Swift.String]()
            for string0 in hsmsPendingDeletionContainer {
                if let string0 = string0 {
                    hsmsPendingDeletionDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingDeletion = hsmsPendingDeletionDecoded0
        let hsmsPendingRegistrationContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingRegistration)
        var hsmsPendingRegistrationDecoded0:[Swift.String]? = nil
        if let hsmsPendingRegistrationContainer = hsmsPendingRegistrationContainer {
            hsmsPendingRegistrationDecoded0 = [Swift.String]()
            for string0 in hsmsPendingRegistrationContainer {
                if let string0 = string0 {
                    hsmsPendingRegistrationDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingRegistration = hsmsPendingRegistrationDecoded0
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.CloudHsmObjectState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DescribeHapgOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let hsmSerialNumber = self.hsmSerialNumber {
            try encodeContainer.encode(hsmSerialNumber, forKey: .hsmSerialNumber)
        }
    }
}

extension DescribeHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeHsm] operation.
public struct DescribeHsmInput: Swift.Equatable {
    /// The ARN of the HSM. Either the HsmArn or the SerialNumber parameter must be specified.
    public var hsmArn: Swift.String?
    /// The serial number of the HSM. Either the HsmArn or the HsmSerialNumber parameter must be specified.
    public var hsmSerialNumber: Swift.String?

    public init(
        hsmArn: Swift.String? = nil,
        hsmSerialNumber: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
        self.hsmSerialNumber = hsmSerialNumber
    }
}

struct DescribeHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let hsmSerialNumber: Swift.String?
}

extension DescribeHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let hsmSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmSerialNumber)
        hsmSerialNumber = hsmSerialNumberDecoded
    }
}

extension DescribeHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZone = output.availabilityZone
            self.eniId = output.eniId
            self.eniIp = output.eniIp
            self.hsmArn = output.hsmArn
            self.hsmType = output.hsmType
            self.iamRoleArn = output.iamRoleArn
            self.partitions = output.partitions
            self.serialNumber = output.serialNumber
            self.serverCertLastUpdated = output.serverCertLastUpdated
            self.serverCertUri = output.serverCertUri
            self.softwareVersion = output.softwareVersion
            self.sshKeyLastUpdated = output.sshKeyLastUpdated
            self.sshPublicKey = output.sshPublicKey
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.subnetId = output.subnetId
            self.subscriptionEndDate = output.subscriptionEndDate
            self.subscriptionStartDate = output.subscriptionStartDate
            self.subscriptionType = output.subscriptionType
            self.vendorName = output.vendorName
            self.vpcId = output.vpcId
        } else {
            self.availabilityZone = nil
            self.eniId = nil
            self.eniIp = nil
            self.hsmArn = nil
            self.hsmType = nil
            self.iamRoleArn = nil
            self.partitions = nil
            self.serialNumber = nil
            self.serverCertLastUpdated = nil
            self.serverCertUri = nil
            self.softwareVersion = nil
            self.sshKeyLastUpdated = nil
            self.sshPublicKey = nil
            self.status = nil
            self.statusDetails = nil
            self.subnetId = nil
            self.subscriptionEndDate = nil
            self.subscriptionStartDate = nil
            self.subscriptionType = nil
            self.vendorName = nil
            self.vpcId = nil
        }
    }
}

/// Contains the output of the [DescribeHsm] operation.
public struct DescribeHsmOutput: Swift.Equatable {
    /// The Availability Zone that the HSM is in.
    public var availabilityZone: Swift.String?
    /// The identifier of the elastic network interface (ENI) attached to the HSM.
    public var eniId: Swift.String?
    /// The IP address assigned to the HSM's ENI.
    public var eniIp: Swift.String?
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?
    /// The HSM model type.
    public var hsmType: Swift.String?
    /// The ARN of the IAM role assigned to the HSM.
    public var iamRoleArn: Swift.String?
    /// The list of partitions on the HSM.
    public var partitions: [Swift.String]?
    /// The serial number of the HSM.
    public var serialNumber: Swift.String?
    /// The date and time that the server certificate was last updated.
    public var serverCertLastUpdated: Swift.String?
    /// The URI of the certificate server.
    public var serverCertUri: Swift.String?
    /// The HSM software version.
    public var softwareVersion: Swift.String?
    /// The date and time that the SSH key was last updated.
    public var sshKeyLastUpdated: Swift.String?
    /// The public SSH key.
    public var sshPublicKey: Swift.String?
    /// The status of the HSM.
    public var status: CloudHSMClientTypes.HsmStatus?
    /// Contains additional information about the status of the HSM.
    public var statusDetails: Swift.String?
    /// The identifier of the subnet that the HSM is in.
    public var subnetId: Swift.String?
    /// The subscription end date.
    public var subscriptionEndDate: Swift.String?
    /// The subscription start date.
    public var subscriptionStartDate: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    public var subscriptionType: CloudHSMClientTypes.SubscriptionType?
    /// The name of the HSM vendor.
    public var vendorName: Swift.String?
    /// The identifier of the VPC that the HSM is in.
    public var vpcId: Swift.String?

    public init(
        availabilityZone: Swift.String? = nil,
        eniId: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        hsmType: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        partitions: [Swift.String]? = nil,
        serialNumber: Swift.String? = nil,
        serverCertLastUpdated: Swift.String? = nil,
        serverCertUri: Swift.String? = nil,
        softwareVersion: Swift.String? = nil,
        sshKeyLastUpdated: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        status: CloudHSMClientTypes.HsmStatus? = nil,
        statusDetails: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionEndDate: Swift.String? = nil,
        subscriptionStartDate: Swift.String? = nil,
        subscriptionType: CloudHSMClientTypes.SubscriptionType? = nil,
        vendorName: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmArn = hsmArn
        self.hsmType = hsmType
        self.iamRoleArn = iamRoleArn
        self.partitions = partitions
        self.serialNumber = serialNumber
        self.serverCertLastUpdated = serverCertLastUpdated
        self.serverCertUri = serverCertUri
        self.softwareVersion = softwareVersion
        self.sshKeyLastUpdated = sshKeyLastUpdated
        self.sshPublicKey = sshPublicKey
        self.status = status
        self.statusDetails = statusDetails
        self.subnetId = subnetId
        self.subscriptionEndDate = subscriptionEndDate
        self.subscriptionStartDate = subscriptionStartDate
        self.subscriptionType = subscriptionType
        self.vendorName = vendorName
        self.vpcId = vpcId
    }
}

struct DescribeHsmOutputBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let status: CloudHSMClientTypes.HsmStatus?
    let statusDetails: Swift.String?
    let availabilityZone: Swift.String?
    let eniId: Swift.String?
    let eniIp: Swift.String?
    let subscriptionType: CloudHSMClientTypes.SubscriptionType?
    let subscriptionStartDate: Swift.String?
    let subscriptionEndDate: Swift.String?
    let vpcId: Swift.String?
    let subnetId: Swift.String?
    let iamRoleArn: Swift.String?
    let serialNumber: Swift.String?
    let vendorName: Swift.String?
    let hsmType: Swift.String?
    let softwareVersion: Swift.String?
    let sshPublicKey: Swift.String?
    let sshKeyLastUpdated: Swift.String?
    let serverCertUri: Swift.String?
    let serverCertLastUpdated: Swift.String?
    let partitions: [Swift.String]?
}

extension DescribeHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmArn = "HsmArn"
        case hsmType = "HsmType"
        case iamRoleArn = "IamRoleArn"
        case partitions = "Partitions"
        case serialNumber = "SerialNumber"
        case serverCertLastUpdated = "ServerCertLastUpdated"
        case serverCertUri = "ServerCertUri"
        case softwareVersion = "SoftwareVersion"
        case sshKeyLastUpdated = "SshKeyLastUpdated"
        case sshPublicKey = "SshPublicKey"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case subnetId = "SubnetId"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case subscriptionType = "SubscriptionType"
        case vendorName = "VendorName"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.HsmStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let vendorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let sshKeyLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyLastUpdated)
        sshKeyLastUpdated = sshKeyLastUpdatedDecoded
        let serverCertUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertUri)
        serverCertUri = serverCertUriDecoded
        let serverCertLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertLastUpdated)
        serverCertLastUpdated = serverCertLastUpdatedDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.String]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.String]()
            for string0 in partitionsContainer {
                if let string0 = string0 {
                    partitionsDecoded0?.append(string0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

enum DescribeHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateFingerprint = self.certificateFingerprint {
            try encodeContainer.encode(certificateFingerprint, forKey: .certificateFingerprint)
        }
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension DescribeLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLunaClientInput: Swift.Equatable {
    /// The certificate fingerprint.
    public var certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init(
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
    }
}

struct DescribeLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificateFingerprint: Swift.String?
}

extension DescribeLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
    }
}

extension DescribeLunaClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLunaClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.certificateFingerprint = output.certificateFingerprint
            self.clientArn = output.clientArn
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.certificate = nil
            self.certificateFingerprint = nil
            self.clientArn = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct DescribeLunaClientOutput: Swift.Equatable {
    /// The certificate installed on the HSMs used by this client.
    public var certificate: Swift.String?
    /// The certificate fingerprint.
    public var certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public var clientArn: Swift.String?
    /// The label of the client.
    public var label: Swift.String?
    /// The date and time the client was last modified.
    public var lastModifiedTimestamp: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct DescribeLunaClientOutputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificate: Swift.String?
    let certificateFingerprint: Swift.String?
    let lastModifiedTimestamp: Swift.String?
    let label: Swift.String?
}

extension DescribeLunaClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

enum DescribeLunaClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
        if let clientVersion = self.clientVersion {
            try encodeContainer.encode(clientVersion.rawValue, forKey: .clientVersion)
        }
        if let hapgList = hapgList {
            var hapgListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hapgList)
            for hapgarn0 in hapgList {
                try hapgListContainer.encode(hapgarn0)
            }
        }
    }
}

extension GetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConfigInput: Swift.Equatable {
    /// The ARN of the client.
    /// This member is required.
    public var clientArn: Swift.String?
    /// The client version.
    /// This member is required.
    public var clientVersion: CloudHSMClientTypes.ClientVersion?
    /// A list of ARNs that identify the high-availability partition groups that are associated with the client.
    /// This member is required.
    public var hapgList: [Swift.String]?

    public init(
        clientArn: Swift.String? = nil,
        clientVersion: CloudHSMClientTypes.ClientVersion? = nil,
        hapgList: [Swift.String]? = nil
    )
    {
        self.clientArn = clientArn
        self.clientVersion = clientVersion
        self.hapgList = hapgList
    }
}

struct GetConfigInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let clientVersion: CloudHSMClientTypes.ClientVersion?
    let hapgList: [Swift.String]?
}

extension GetConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let clientVersionDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.ClientVersion.self, forKey: .clientVersion)
        clientVersion = clientVersionDecoded
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
    }
}

extension GetConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.configCred = output.configCred
            self.configFile = output.configFile
            self.configType = output.configType
        } else {
            self.configCred = nil
            self.configFile = nil
            self.configType = nil
        }
    }
}

public struct GetConfigOutput: Swift.Equatable {
    /// The certificate file containing the server.pem files of the HSMs.
    public var configCred: Swift.String?
    /// The chrystoki.conf configuration file.
    public var configFile: Swift.String?
    /// The type of credentials.
    public var configType: Swift.String?

    public init(
        configCred: Swift.String? = nil,
        configFile: Swift.String? = nil,
        configType: Swift.String? = nil
    )
    {
        self.configCred = configCred
        self.configFile = configFile
        self.configType = configType
    }
}

struct GetConfigOutputBody: Swift.Equatable {
    let configType: Swift.String?
    let configFile: Swift.String?
    let configCred: Swift.String?
}

extension GetConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configCred = "ConfigCred"
        case configFile = "ConfigFile"
        case configType = "ConfigType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configType)
        configType = configTypeDecoded
        let configFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configFile)
        configFile = configFileDecoded
        let configCredDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configCred)
        configCred = configCredDecoded
    }
}

enum GetConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudHSMClientTypes {
    public enum HsmStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case pending
        case running
        case suspended
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [HsmStatus] {
            return [
                .degraded,
                .pending,
                .running,
                .suspended,
                .terminated,
                .terminating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HsmStatus(rawValue: rawValue) ?? HsmStatus.sdkUnknown(rawValue)
        }
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.retryable = output.retryable
        } else {
            self.properties.message = nil
            self.properties.retryable = false
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that one or more of the request parameters are not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the error.
        public internal(set) var message: Swift.String? = nil
        /// Indicates if the action can be retried.
        public internal(set) var retryable: Swift.Bool = false
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.properties.message = message
        self.properties.retryable = retryable
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension ListAvailableZonesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListAvailableZonesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [ListAvailableZones] action.
public struct ListAvailableZonesInput: Swift.Equatable {

    public init() { }
}

struct ListAvailableZonesInputBody: Swift.Equatable {
}

extension ListAvailableZonesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableZonesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableZonesOutputBody = try responseDecoder.decode(responseBody: data)
            self.azList = output.azList
        } else {
            self.azList = nil
        }
    }
}

public struct ListAvailableZonesOutput: Swift.Equatable {
    /// The list of Availability Zones that have available AWS CloudHSM capacity.
    public var azList: [Swift.String]?

    public init(
        azList: [Swift.String]? = nil
    )
    {
        self.azList = azList
    }
}

struct ListAvailableZonesOutputBody: Swift.Equatable {
    let azList: [Swift.String]?
}

extension ListAvailableZonesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case azList = "AZList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let azListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .azList)
        var azListDecoded0:[Swift.String]? = nil
        if let azListContainer = azListContainer {
            azListDecoded0 = [Swift.String]()
            for string0 in azListContainer {
                if let string0 = string0 {
                    azListDecoded0?.append(string0)
                }
            }
        }
        azList = azListDecoded0
    }
}

enum ListAvailableZonesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHapgsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHapgsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHapgsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHapgs. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHapgsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListHapgsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHapgsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHapgsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hapgList = output.hapgList
            self.nextToken = output.nextToken
        } else {
            self.hapgList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHapgsOutput: Swift.Equatable {
    /// The list of high-availability partition groups.
    /// This member is required.
    public var hapgList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHapgs to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        hapgList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hapgList = hapgList
        self.nextToken = nextToken
    }
}

struct ListHapgsOutputBody: Swift.Equatable {
    let hapgList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListHapgsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgList = "HapgList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHapgsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHsmsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHsmsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHsmsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHsms. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHsmsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListHsmsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHsmsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHsmsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hsmList = output.hsmList
            self.nextToken = output.nextToken
        } else {
            self.hsmList = nil
            self.nextToken = nil
        }
    }
}

/// Contains the output of the ListHsms operation.
public struct ListHsmsOutput: Swift.Equatable {
    /// The list of ARNs that identify the HSMs.
    public var hsmList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHsms to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        hsmList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hsmList = hsmList
        self.nextToken = nextToken
    }
}

struct ListHsmsOutputBody: Swift.Equatable {
    let hsmList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListHsmsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmList = "HsmList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmList)
        var hsmListDecoded0:[Swift.String]? = nil
        if let hsmListContainer = hsmListContainer {
            hsmListDecoded0 = [Swift.String]()
            for string0 in hsmListContainer {
                if let string0 = string0 {
                    hsmListDecoded0?.append(string0)
                }
            }
        }
        hsmList = hsmListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHsmsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLunaClientsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLunaClientsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLunaClientsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListLunaClients. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLunaClientsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListLunaClientsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLunaClientsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLunaClientsOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientList = output.clientList
            self.nextToken = output.nextToken
        } else {
            self.clientList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLunaClientsOutput: Swift.Equatable {
    /// The list of clients.
    /// This member is required.
    public var clientList: [Swift.String]?
    /// If not null, more results are available. Pass this to ListLunaClients to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        clientList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientList = clientList
        self.nextToken = nextToken
    }
}

struct ListLunaClientsOutputBody: Swift.Equatable {
    let clientList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLunaClientsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientList = "ClientList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLunaClientsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// One or more tags.
    /// This member is required.
    public var tagList: [CloudHSMClientTypes.Tag]?

    public init(
        tagList: [CloudHSMClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tagList: [CloudHSMClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let partitionSerialList = partitionSerialList {
            var partitionSerialListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionSerialList)
            for partitionserial0 in partitionSerialList {
                try partitionSerialListContainer.encode(partitionserial0)
            }
        }
    }
}

extension ModifyHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to modify.
    /// This member is required.
    public var hapgArn: Swift.String?
    /// The new label for the high-availability partition group.
    public var label: Swift.String?
    /// The list of partition serial numbers to make members of the high-availability partition group.
    public var partitionSerialList: [Swift.String]?

    public init(
        hapgArn: Swift.String? = nil,
        label: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil
    )
    {
        self.hapgArn = hapgArn
        self.label = label
        self.partitionSerialList = partitionSerialList
    }
}

struct ModifyHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
    let label: Swift.String?
    let partitionSerialList: [Swift.String]?
}

extension ModifyHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
    }
}

extension ModifyHapgOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyHapgOutputBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

public struct ModifyHapgOutput: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?

    public init(
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct ModifyHapgOutputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension ModifyHapgOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

enum ModifyHapgOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let syslogIp = self.syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

extension ModifyHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [ModifyHsm] operation.
public struct ModifyHsmInput: Swift.Equatable {
    /// The new IP address for the elastic network interface (ENI) attached to the HSM. If the HSM is moved to a different subnet, and an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the new subnet.
    public var eniIp: Swift.String?
    /// The new external ID.
    public var externalId: Swift.String?
    /// The ARN of the HSM to modify.
    /// This member is required.
    public var hsmArn: Swift.String?
    /// The new IAM role ARN.
    public var iamRoleArn: Swift.String?
    /// The new identifier of the subnet that the HSM is in. The new subnet must be in the same Availability Zone as the current subnet.
    public var subnetId: Swift.String?
    /// The new IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
    public var syslogIp: Swift.String?

    public init(
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.eniIp = eniIp
        self.externalId = externalId
        self.hsmArn = hsmArn
        self.iamRoleArn = iamRoleArn
        self.subnetId = subnetId
        self.syslogIp = syslogIp
    }
}

struct ModifyHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let subnetId: Swift.String?
    let eniIp: Swift.String?
    let iamRoleArn: Swift.String?
    let externalId: Swift.String?
    let syslogIp: Swift.String?
}

extension ModifyHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension ModifyHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the [ModifyHsm] operation.
public struct ModifyHsmOutput: Swift.Equatable {
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?

    public init(
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct ModifyHsmOutputBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension ModifyHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

enum ModifyHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension ModifyLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyLunaClientInput: Swift.Equatable {
    /// The new certificate for the client.
    /// This member is required.
    public var certificate: Swift.String?
    /// The ARN of the client.
    /// This member is required.
    public var clientArn: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificate: Swift.String?
}

extension ModifyLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension ModifyLunaClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyLunaClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

public struct ModifyLunaClientOutput: Swift.Equatable {
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init(
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientOutputBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension ModifyLunaClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

enum ModifyLunaClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key or keys to remove. Specify only the tag key to remove (not the value). To overwrite the value for an existing tag, use [AddTagsToResource].
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension RemoveTagsFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveTagsFromResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RemoveTagsFromResourceOutput: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct RemoveTagsFromResourceOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension RemoveTagsFromResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmInternalException": return try await CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudHSMClientTypes {
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension CloudHSMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudHSMClientTypes {
    /// A key-value pair that identifies or specifies metadata about an AWS CloudHSM resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}
