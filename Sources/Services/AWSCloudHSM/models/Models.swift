// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tagList: [CloudHSMClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tagList: [CloudHSMClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagList: [CloudHSMClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudHSMClientTypes {
    public enum ClientVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fiveOne
        case fiveThree
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientVersion] {
            return [
                .fiveOne,
                .fiveThree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fiveOne: return "5.1"
            case .fiveThree: return "5.3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientVersion(rawValue: rawValue) ?? ClientVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudHsmInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an internal error occurred.
public struct CloudHsmInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension CloudHsmInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension CloudHSMClientTypes {
    public enum CloudHsmObjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case ready
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudHsmObjectState] {
            return [
                .degraded,
                .ready,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudHsmObjectState(rawValue: rawValue) ?? CloudHsmObjectState.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an exception occurred in the AWS CloudHSM service.
public struct CloudHsmServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension CloudHsmServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension CreateHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

extension CreateHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateHapgRequest] action.
public struct CreateHapgInput: Swift.Equatable {
    /// The label of the new high-availability partition group.
    /// This member is required.
    public var label: Swift.String?

    public init (
        label: Swift.String? = nil
    )
    {
        self.label = label
    }
}

struct CreateHapgInputBody: Swift.Equatable {
    let label: Swift.String?
}

extension CreateHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

extension CreateHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

/// Contains the output of the [CreateHAPartitionGroup] action.
public struct CreateHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct CreateHapgOutputResponseBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension CreateHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension CreateHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let sshKey = self.sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let subscriptionType = self.subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
        if let syslogIp = self.syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

extension CreateHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the CreateHsm operation.
public struct CreateHsmInput: Swift.Equatable {
    /// A user-defined token to ensure idempotence. Subsequent calls to this operation with the same token will be ignored.
    public var clientToken: Swift.String?
    /// The IP address to assign to the HSM's ENI. If an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the subnet.
    public var eniIp: Swift.String?
    /// The external ID from IamRoleArn, if present.
    public var externalId: Swift.String?
    /// The ARN of an IAM role to enable the AWS CloudHSM service to allocate an ENI on your behalf.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The SSH public key to install on the HSM.
    /// This member is required.
    public var sshKey: Swift.String?
    /// The identifier of the subnet in your VPC in which to place the HSM.
    /// This member is required.
    public var subnetId: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    /// This member is required.
    public var subscriptionType: CloudHSMClientTypes.SubscriptionType?
    /// The IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
    public var syslogIp: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        sshKey: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionType: CloudHSMClientTypes.SubscriptionType? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eniIp = eniIp
        self.externalId = externalId
        self.iamRoleArn = iamRoleArn
        self.sshKey = sshKey
        self.subnetId = subnetId
        self.subscriptionType = subscriptionType
        self.syslogIp = syslogIp
    }
}

struct CreateHsmInputBody: Swift.Equatable {
    let subnetId: Swift.String?
    let sshKey: Swift.String?
    let eniIp: Swift.String?
    let iamRoleArn: Swift.String?
    let externalId: Swift.String?
    let subscriptionType: CloudHSMClientTypes.SubscriptionType?
    let clientToken: Swift.String?
    let syslogIp: Swift.String?
}

extension CreateHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension CreateHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the CreateHsm operation.
public struct CreateHsmOutputResponse: Swift.Equatable {
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct CreateHsmOutputResponseBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension CreateHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension CreateLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

extension CreateLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateLunaClient] action.
public struct CreateLunaClientInput: Swift.Equatable {
    /// The contents of a Base64-Encoded X.509 v3 certificate to be installed on the HSMs used by this client.
    /// This member is required.
    public var certificate: Swift.String?
    /// The label for the client.
    public var label: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        label: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.label = label
    }
}

struct CreateLunaClientInputBody: Swift.Equatable {
    let label: Swift.String?
    let certificate: Swift.String?
}

extension CreateLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension CreateLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

/// Contains the output of the [CreateLunaClient] action.
public struct CreateLunaClientOutputResponse: Swift.Equatable {
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct CreateLunaClientOutputResponseBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension CreateLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension DeleteHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

extension DeleteHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteHapg] action.
public struct DeleteHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to delete.
    /// This member is required.
    public var hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DeleteHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension DeleteHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DeleteHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the [DeleteHapg] action.
public struct DeleteHapgOutputResponse: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHapgOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
    }
}

extension DeleteHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteHsm] operation.
public struct DeleteHsmInput: Swift.Equatable {
    /// The ARN of the HSM to delete.
    /// This member is required.
    public var hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct DeleteHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension DeleteHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension DeleteHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the [DeleteHsm] operation.
public struct DeleteHsmOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHsmOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension DeleteLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLunaClientInput: Swift.Equatable {
    /// The ARN of the client to delete.
    /// This member is required.
    public var clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct DeleteLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension DeleteLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension DeleteLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteLunaClientOutputResponse: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteLunaClientOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

extension DescribeHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeHapg] action.
public struct DescribeHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to describe.
    /// This member is required.
    public var hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DescribeHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension DescribeHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DescribeHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
            self.hapgSerial = output.hapgSerial
            self.hsmsLastActionFailed = output.hsmsLastActionFailed
            self.hsmsPendingDeletion = output.hsmsPendingDeletion
            self.hsmsPendingRegistration = output.hsmsPendingRegistration
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.partitionSerialList = output.partitionSerialList
            self.state = output.state
        } else {
            self.hapgArn = nil
            self.hapgSerial = nil
            self.hsmsLastActionFailed = nil
            self.hsmsPendingDeletion = nil
            self.hsmsPendingRegistration = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
            self.partitionSerialList = nil
            self.state = nil
        }
    }
}

/// Contains the output of the [DescribeHapg] action.
public struct DescribeHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?
    /// The serial number of the high-availability partition group.
    public var hapgSerial: Swift.String?
    ///
    public var hsmsLastActionFailed: [Swift.String]?
    ///
    public var hsmsPendingDeletion: [Swift.String]?
    ///
    public var hsmsPendingRegistration: [Swift.String]?
    /// The label for the high-availability partition group.
    public var label: Swift.String?
    /// The date and time the high-availability partition group was last modified.
    public var lastModifiedTimestamp: Swift.String?
    /// The list of partition serial numbers that belong to the high-availability partition group.
    public var partitionSerialList: [Swift.String]?
    /// The state of the high-availability partition group.
    public var state: CloudHSMClientTypes.CloudHsmObjectState?

    public init (
        hapgArn: Swift.String? = nil,
        hapgSerial: Swift.String? = nil,
        hsmsLastActionFailed: [Swift.String]? = nil,
        hsmsPendingDeletion: [Swift.String]? = nil,
        hsmsPendingRegistration: [Swift.String]? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil,
        state: CloudHSMClientTypes.CloudHsmObjectState? = nil
    )
    {
        self.hapgArn = hapgArn
        self.hapgSerial = hapgSerial
        self.hsmsLastActionFailed = hsmsLastActionFailed
        self.hsmsPendingDeletion = hsmsPendingDeletion
        self.hsmsPendingRegistration = hsmsPendingRegistration
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.partitionSerialList = partitionSerialList
        self.state = state
    }
}

struct DescribeHapgOutputResponseBody: Swift.Equatable {
    let hapgArn: Swift.String?
    let hapgSerial: Swift.String?
    let hsmsLastActionFailed: [Swift.String]?
    let hsmsPendingDeletion: [Swift.String]?
    let hsmsPendingRegistration: [Swift.String]?
    let label: Swift.String?
    let lastModifiedTimestamp: Swift.String?
    let partitionSerialList: [Swift.String]?
    let state: CloudHSMClientTypes.CloudHsmObjectState?
}

extension DescribeHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case hapgSerial = "HapgSerial"
        case hsmsLastActionFailed = "HsmsLastActionFailed"
        case hsmsPendingDeletion = "HsmsPendingDeletion"
        case hsmsPendingRegistration = "HsmsPendingRegistration"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case partitionSerialList = "PartitionSerialList"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let hapgSerialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgSerial)
        hapgSerial = hapgSerialDecoded
        let hsmsLastActionFailedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsLastActionFailed)
        var hsmsLastActionFailedDecoded0:[Swift.String]? = nil
        if let hsmsLastActionFailedContainer = hsmsLastActionFailedContainer {
            hsmsLastActionFailedDecoded0 = [Swift.String]()
            for string0 in hsmsLastActionFailedContainer {
                if let string0 = string0 {
                    hsmsLastActionFailedDecoded0?.append(string0)
                }
            }
        }
        hsmsLastActionFailed = hsmsLastActionFailedDecoded0
        let hsmsPendingDeletionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingDeletion)
        var hsmsPendingDeletionDecoded0:[Swift.String]? = nil
        if let hsmsPendingDeletionContainer = hsmsPendingDeletionContainer {
            hsmsPendingDeletionDecoded0 = [Swift.String]()
            for string0 in hsmsPendingDeletionContainer {
                if let string0 = string0 {
                    hsmsPendingDeletionDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingDeletion = hsmsPendingDeletionDecoded0
        let hsmsPendingRegistrationContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingRegistration)
        var hsmsPendingRegistrationDecoded0:[Swift.String]? = nil
        if let hsmsPendingRegistrationContainer = hsmsPendingRegistrationContainer {
            hsmsPendingRegistrationDecoded0 = [Swift.String]()
            for string0 in hsmsPendingRegistrationContainer {
                if let string0 = string0 {
                    hsmsPendingRegistrationDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingRegistration = hsmsPendingRegistrationDecoded0
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.CloudHsmObjectState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribeHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let hsmSerialNumber = self.hsmSerialNumber {
            try encodeContainer.encode(hsmSerialNumber, forKey: .hsmSerialNumber)
        }
    }
}

extension DescribeHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeHsm] operation.
public struct DescribeHsmInput: Swift.Equatable {
    /// The ARN of the HSM. Either the HsmArn or the SerialNumber parameter must be specified.
    public var hsmArn: Swift.String?
    /// The serial number of the HSM. Either the HsmArn or the HsmSerialNumber parameter must be specified.
    public var hsmSerialNumber: Swift.String?

    public init (
        hsmArn: Swift.String? = nil,
        hsmSerialNumber: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
        self.hsmSerialNumber = hsmSerialNumber
    }
}

struct DescribeHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let hsmSerialNumber: Swift.String?
}

extension DescribeHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let hsmSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmSerialNumber)
        hsmSerialNumber = hsmSerialNumberDecoded
    }
}

extension DescribeHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZone = output.availabilityZone
            self.eniId = output.eniId
            self.eniIp = output.eniIp
            self.hsmArn = output.hsmArn
            self.hsmType = output.hsmType
            self.iamRoleArn = output.iamRoleArn
            self.partitions = output.partitions
            self.serialNumber = output.serialNumber
            self.serverCertLastUpdated = output.serverCertLastUpdated
            self.serverCertUri = output.serverCertUri
            self.softwareVersion = output.softwareVersion
            self.sshKeyLastUpdated = output.sshKeyLastUpdated
            self.sshPublicKey = output.sshPublicKey
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.subnetId = output.subnetId
            self.subscriptionEndDate = output.subscriptionEndDate
            self.subscriptionStartDate = output.subscriptionStartDate
            self.subscriptionType = output.subscriptionType
            self.vendorName = output.vendorName
            self.vpcId = output.vpcId
        } else {
            self.availabilityZone = nil
            self.eniId = nil
            self.eniIp = nil
            self.hsmArn = nil
            self.hsmType = nil
            self.iamRoleArn = nil
            self.partitions = nil
            self.serialNumber = nil
            self.serverCertLastUpdated = nil
            self.serverCertUri = nil
            self.softwareVersion = nil
            self.sshKeyLastUpdated = nil
            self.sshPublicKey = nil
            self.status = nil
            self.statusDetails = nil
            self.subnetId = nil
            self.subscriptionEndDate = nil
            self.subscriptionStartDate = nil
            self.subscriptionType = nil
            self.vendorName = nil
            self.vpcId = nil
        }
    }
}

/// Contains the output of the [DescribeHsm] operation.
public struct DescribeHsmOutputResponse: Swift.Equatable {
    /// The Availability Zone that the HSM is in.
    public var availabilityZone: Swift.String?
    /// The identifier of the elastic network interface (ENI) attached to the HSM.
    public var eniId: Swift.String?
    /// The IP address assigned to the HSM's ENI.
    public var eniIp: Swift.String?
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?
    /// The HSM model type.
    public var hsmType: Swift.String?
    /// The ARN of the IAM role assigned to the HSM.
    public var iamRoleArn: Swift.String?
    /// The list of partitions on the HSM.
    public var partitions: [Swift.String]?
    /// The serial number of the HSM.
    public var serialNumber: Swift.String?
    /// The date and time that the server certificate was last updated.
    public var serverCertLastUpdated: Swift.String?
    /// The URI of the certificate server.
    public var serverCertUri: Swift.String?
    /// The HSM software version.
    public var softwareVersion: Swift.String?
    /// The date and time that the SSH key was last updated.
    public var sshKeyLastUpdated: Swift.String?
    /// The public SSH key.
    public var sshPublicKey: Swift.String?
    /// The status of the HSM.
    public var status: CloudHSMClientTypes.HsmStatus?
    /// Contains additional information about the status of the HSM.
    public var statusDetails: Swift.String?
    /// The identifier of the subnet that the HSM is in.
    public var subnetId: Swift.String?
    /// The subscription end date.
    public var subscriptionEndDate: Swift.String?
    /// The subscription start date.
    public var subscriptionStartDate: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    public var subscriptionType: CloudHSMClientTypes.SubscriptionType?
    /// The name of the HSM vendor.
    public var vendorName: Swift.String?
    /// The identifier of the VPC that the HSM is in.
    public var vpcId: Swift.String?

    public init (
        availabilityZone: Swift.String? = nil,
        eniId: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        hsmType: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        partitions: [Swift.String]? = nil,
        serialNumber: Swift.String? = nil,
        serverCertLastUpdated: Swift.String? = nil,
        serverCertUri: Swift.String? = nil,
        softwareVersion: Swift.String? = nil,
        sshKeyLastUpdated: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        status: CloudHSMClientTypes.HsmStatus? = nil,
        statusDetails: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionEndDate: Swift.String? = nil,
        subscriptionStartDate: Swift.String? = nil,
        subscriptionType: CloudHSMClientTypes.SubscriptionType? = nil,
        vendorName: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmArn = hsmArn
        self.hsmType = hsmType
        self.iamRoleArn = iamRoleArn
        self.partitions = partitions
        self.serialNumber = serialNumber
        self.serverCertLastUpdated = serverCertLastUpdated
        self.serverCertUri = serverCertUri
        self.softwareVersion = softwareVersion
        self.sshKeyLastUpdated = sshKeyLastUpdated
        self.sshPublicKey = sshPublicKey
        self.status = status
        self.statusDetails = statusDetails
        self.subnetId = subnetId
        self.subscriptionEndDate = subscriptionEndDate
        self.subscriptionStartDate = subscriptionStartDate
        self.subscriptionType = subscriptionType
        self.vendorName = vendorName
        self.vpcId = vpcId
    }
}

struct DescribeHsmOutputResponseBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let status: CloudHSMClientTypes.HsmStatus?
    let statusDetails: Swift.String?
    let availabilityZone: Swift.String?
    let eniId: Swift.String?
    let eniIp: Swift.String?
    let subscriptionType: CloudHSMClientTypes.SubscriptionType?
    let subscriptionStartDate: Swift.String?
    let subscriptionEndDate: Swift.String?
    let vpcId: Swift.String?
    let subnetId: Swift.String?
    let iamRoleArn: Swift.String?
    let serialNumber: Swift.String?
    let vendorName: Swift.String?
    let hsmType: Swift.String?
    let softwareVersion: Swift.String?
    let sshPublicKey: Swift.String?
    let sshKeyLastUpdated: Swift.String?
    let serverCertUri: Swift.String?
    let serverCertLastUpdated: Swift.String?
    let partitions: [Swift.String]?
}

extension DescribeHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmArn = "HsmArn"
        case hsmType = "HsmType"
        case iamRoleArn = "IamRoleArn"
        case partitions = "Partitions"
        case serialNumber = "SerialNumber"
        case serverCertLastUpdated = "ServerCertLastUpdated"
        case serverCertUri = "ServerCertUri"
        case softwareVersion = "SoftwareVersion"
        case sshKeyLastUpdated = "SshKeyLastUpdated"
        case sshPublicKey = "SshPublicKey"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case subnetId = "SubnetId"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case subscriptionType = "SubscriptionType"
        case vendorName = "VendorName"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.HsmStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let vendorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let sshKeyLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyLastUpdated)
        sshKeyLastUpdated = sshKeyLastUpdatedDecoded
        let serverCertUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertUri)
        serverCertUri = serverCertUriDecoded
        let serverCertLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertLastUpdated)
        serverCertLastUpdated = serverCertLastUpdatedDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.String]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.String]()
            for string0 in partitionsContainer {
                if let string0 = string0 {
                    partitionsDecoded0?.append(string0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension DescribeLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateFingerprint = self.certificateFingerprint {
            try encodeContainer.encode(certificateFingerprint, forKey: .certificateFingerprint)
        }
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension DescribeLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLunaClientInput: Swift.Equatable {
    /// The certificate fingerprint.
    public var certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init (
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
    }
}

struct DescribeLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificateFingerprint: Swift.String?
}

extension DescribeLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
    }
}

extension DescribeLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.certificateFingerprint = output.certificateFingerprint
            self.clientArn = output.clientArn
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.certificate = nil
            self.certificateFingerprint = nil
            self.clientArn = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct DescribeLunaClientOutputResponse: Swift.Equatable {
    /// The certificate installed on the HSMs used by this client.
    public var certificate: Swift.String?
    /// The certificate fingerprint.
    public var certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public var clientArn: Swift.String?
    /// The label of the client.
    public var label: Swift.String?
    /// The date and time the client was last modified.
    public var lastModifiedTimestamp: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct DescribeLunaClientOutputResponseBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificate: Swift.String?
    let certificateFingerprint: Swift.String?
    let lastModifiedTimestamp: Swift.String?
    let label: Swift.String?
}

extension DescribeLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

extension GetConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
        if let clientVersion = self.clientVersion {
            try encodeContainer.encode(clientVersion.rawValue, forKey: .clientVersion)
        }
        if let hapgList = hapgList {
            var hapgListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hapgList)
            for hapgarn0 in hapgList {
                try hapgListContainer.encode(hapgarn0)
            }
        }
    }
}

extension GetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConfigInput: Swift.Equatable {
    /// The ARN of the client.
    /// This member is required.
    public var clientArn: Swift.String?
    /// The client version.
    /// This member is required.
    public var clientVersion: CloudHSMClientTypes.ClientVersion?
    /// A list of ARNs that identify the high-availability partition groups that are associated with the client.
    /// This member is required.
    public var hapgList: [Swift.String]?

    public init (
        clientArn: Swift.String? = nil,
        clientVersion: CloudHSMClientTypes.ClientVersion? = nil,
        hapgList: [Swift.String]? = nil
    )
    {
        self.clientArn = clientArn
        self.clientVersion = clientVersion
        self.hapgList = hapgList
    }
}

struct GetConfigInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let clientVersion: CloudHSMClientTypes.ClientVersion?
    let hapgList: [Swift.String]?
}

extension GetConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let clientVersionDecoded = try containerValues.decodeIfPresent(CloudHSMClientTypes.ClientVersion.self, forKey: .clientVersion)
        clientVersion = clientVersionDecoded
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
    }
}

extension GetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configCred = output.configCred
            self.configFile = output.configFile
            self.configType = output.configType
        } else {
            self.configCred = nil
            self.configFile = nil
            self.configType = nil
        }
    }
}

public struct GetConfigOutputResponse: Swift.Equatable {
    /// The certificate file containing the server.pem files of the HSMs.
    public var configCred: Swift.String?
    /// The chrystoki.conf configuration file.
    public var configFile: Swift.String?
    /// The type of credentials.
    public var configType: Swift.String?

    public init (
        configCred: Swift.String? = nil,
        configFile: Swift.String? = nil,
        configType: Swift.String? = nil
    )
    {
        self.configCred = configCred
        self.configFile = configFile
        self.configType = configType
    }
}

struct GetConfigOutputResponseBody: Swift.Equatable {
    let configType: Swift.String?
    let configFile: Swift.String?
    let configCred: Swift.String?
}

extension GetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configCred = "ConfigCred"
        case configFile = "ConfigFile"
        case configType = "ConfigType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configType)
        configType = configTypeDecoded
        let configFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configFile)
        configFile = configFileDecoded
        let configCredDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configCred)
        configCred = configCredDecoded
    }
}

extension CloudHSMClientTypes {
    public enum HsmStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case pending
        case running
        case suspended
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [HsmStatus] {
            return [
                .degraded,
                .pending,
                .running,
                .suspended,
                .terminated,
                .terminating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HsmStatus(rawValue: rawValue) ?? HsmStatus.sdkUnknown(rawValue)
        }
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that one or more of the request parameters are not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryable: Swift.Bool
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
    }
}

extension ListAvailableZonesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListAvailableZonesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [ListAvailableZones] action.
public struct ListAvailableZonesInput: Swift.Equatable {

    public init () { }
}

struct ListAvailableZonesInputBody: Swift.Equatable {
}

extension ListAvailableZonesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableZonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableZonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailableZonesOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableZonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailableZonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.azList = output.azList
        } else {
            self.azList = nil
        }
    }
}

public struct ListAvailableZonesOutputResponse: Swift.Equatable {
    /// The list of Availability Zones that have available AWS CloudHSM capacity.
    public var azList: [Swift.String]?

    public init (
        azList: [Swift.String]? = nil
    )
    {
        self.azList = azList
    }
}

struct ListAvailableZonesOutputResponseBody: Swift.Equatable {
    let azList: [Swift.String]?
}

extension ListAvailableZonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case azList = "AZList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let azListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .azList)
        var azListDecoded0:[Swift.String]? = nil
        if let azListContainer = azListContainer {
            azListDecoded0 = [Swift.String]()
            for string0 in azListContainer {
                if let string0 = string0 {
                    azListDecoded0?.append(string0)
                }
            }
        }
        azList = azListDecoded0
    }
}

extension ListHapgsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHapgsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHapgsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHapgs. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHapgsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListHapgsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHapgsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHapgsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListHapgsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHapgsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListHapgsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgList = output.hapgList
            self.nextToken = output.nextToken
        } else {
            self.hapgList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHapgsOutputResponse: Swift.Equatable {
    /// The list of high-availability partition groups.
    /// This member is required.
    public var hapgList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHapgs to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        hapgList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hapgList = hapgList
        self.nextToken = nextToken
    }
}

struct ListHapgsOutputResponseBody: Swift.Equatable {
    let hapgList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListHapgsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgList = "HapgList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHsmsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHsmsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHsmsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHsms. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHsmsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListHsmsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHsmsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHsmsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListHsmsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHsmsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListHsmsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmList = output.hsmList
            self.nextToken = output.nextToken
        } else {
            self.hsmList = nil
            self.nextToken = nil
        }
    }
}

/// Contains the output of the ListHsms operation.
public struct ListHsmsOutputResponse: Swift.Equatable {
    /// The list of ARNs that identify the HSMs.
    public var hsmList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHsms to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        hsmList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hsmList = hsmList
        self.nextToken = nextToken
    }
}

struct ListHsmsOutputResponseBody: Swift.Equatable {
    let hsmList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListHsmsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmList = "HsmList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmList)
        var hsmListDecoded0:[Swift.String]? = nil
        if let hsmListContainer = hsmListContainer {
            hsmListDecoded0 = [Swift.String]()
            for string0 in hsmListContainer {
                if let string0 = string0 {
                    hsmListDecoded0?.append(string0)
                }
            }
        }
        hsmList = hsmListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLunaClientsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLunaClientsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLunaClientsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListLunaClients. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLunaClientsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListLunaClientsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLunaClientsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLunaClientsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLunaClientsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLunaClientsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLunaClientsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientList = output.clientList
            self.nextToken = output.nextToken
        } else {
            self.clientList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLunaClientsOutputResponse: Swift.Equatable {
    /// The list of clients.
    /// This member is required.
    public var clientList: [Swift.String]?
    /// If not null, more results are available. Pass this to ListLunaClients to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        clientList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientList = clientList
        self.nextToken = nextToken
    }
}

struct ListLunaClientsOutputResponseBody: Swift.Equatable {
    let clientList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLunaClientsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientList = "ClientList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// One or more tags.
    /// This member is required.
    public var tagList: [CloudHSMClientTypes.Tag]?

    public init (
        tagList: [CloudHSMClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [CloudHSMClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension ModifyHapgInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = self.hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let partitionSerialList = partitionSerialList {
            var partitionSerialListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionSerialList)
            for partitionserial0 in partitionSerialList {
                try partitionSerialListContainer.encode(partitionserial0)
            }
        }
    }
}

extension ModifyHapgInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to modify.
    /// This member is required.
    public var hapgArn: Swift.String?
    /// The new label for the high-availability partition group.
    public var label: Swift.String?
    /// The list of partition serial numbers to make members of the high-availability partition group.
    public var partitionSerialList: [Swift.String]?

    public init (
        hapgArn: Swift.String? = nil,
        label: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil
    )
    {
        self.hapgArn = hapgArn
        self.label = label
        self.partitionSerialList = partitionSerialList
    }
}

struct ModifyHapgInputBody: Swift.Equatable {
    let hapgArn: Swift.String?
    let label: Swift.String?
    let partitionSerialList: [Swift.String]?
}

extension ModifyHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
    }
}

extension ModifyHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

public struct ModifyHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public var hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct ModifyHapgOutputResponseBody: Swift.Equatable {
    let hapgArn: Swift.String?
}

extension ModifyHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension ModifyHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let hsmArn = self.hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let syslogIp = self.syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

extension ModifyHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [ModifyHsm] operation.
public struct ModifyHsmInput: Swift.Equatable {
    /// The new IP address for the elastic network interface (ENI) attached to the HSM. If the HSM is moved to a different subnet, and an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the new subnet.
    public var eniIp: Swift.String?
    /// The new external ID.
    public var externalId: Swift.String?
    /// The ARN of the HSM to modify.
    /// This member is required.
    public var hsmArn: Swift.String?
    /// The new IAM role ARN.
    public var iamRoleArn: Swift.String?
    /// The new identifier of the subnet that the HSM is in. The new subnet must be in the same Availability Zone as the current subnet.
    public var subnetId: Swift.String?
    /// The new IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
    public var syslogIp: Swift.String?

    public init (
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.eniIp = eniIp
        self.externalId = externalId
        self.hsmArn = hsmArn
        self.iamRoleArn = iamRoleArn
        self.subnetId = subnetId
        self.syslogIp = syslogIp
    }
}

struct ModifyHsmInputBody: Swift.Equatable {
    let hsmArn: Swift.String?
    let subnetId: Swift.String?
    let eniIp: Swift.String?
    let iamRoleArn: Swift.String?
    let externalId: Swift.String?
    let syslogIp: Swift.String?
}

extension ModifyHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension ModifyHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the [ModifyHsm] operation.
public struct ModifyHsmOutputResponse: Swift.Equatable {
    /// The ARN of the HSM.
    public var hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct ModifyHsmOutputResponseBody: Swift.Equatable {
    let hsmArn: Swift.String?
}

extension ModifyHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension ModifyLunaClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let clientArn = self.clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

extension ModifyLunaClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyLunaClientInput: Swift.Equatable {
    /// The new certificate for the client.
    /// This member is required.
    public var certificate: Swift.String?
    /// The ARN of the client.
    /// This member is required.
    public var clientArn: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientInputBody: Swift.Equatable {
    let clientArn: Swift.String?
    let certificate: Swift.String?
}

extension ModifyLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension ModifyLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

public struct ModifyLunaClientOutputResponse: Swift.Equatable {
    /// The ARN of the client.
    public var clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientOutputResponseBody: Swift.Equatable {
    let clientArn: Swift.String?
}

extension ModifyLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key or keys to remove. Specify only the tag key to remove (not the value). To overwrite the value for an existing tag, use [AddTagsToResource].
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudHSMClientTypes {
    /// Specifies the type of subscription for the HSM.
    ///
    /// * PRODUCTION - The HSM is being used in a production environment.
    ///
    /// * TRIAL - The HSM is being used in a product trial.
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension CloudHSMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudHSMClientTypes {
    /// A key-value pair that identifies or specifies metadata about an AWS CloudHSM resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}
