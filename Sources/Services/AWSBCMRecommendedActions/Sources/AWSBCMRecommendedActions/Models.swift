//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BCMRecommendedActionsAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum FilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case feature
        case severity
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterName] {
            return [
                .feature,
                .severity,
                .type
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .feature: return "FEATURE"
            case .severity: return "SEVERITY"
            case .type: return "TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    /// Describes a filter that returns a more specific list of recommended actions.
    public struct ActionFilter: Swift.Sendable {
        /// The category to filter on. Valid values are FEATURE for feature type, SEVERITY for severity level, and TYPE for recommendation type.
        /// This member is required.
        public var key: BCMRecommendedActionsClientTypes.FilterName?
        /// Specifies how to apply the filter. Use EQUALS to include matching results or NOT_EQUALS to exclude matching results.
        /// This member is required.
        public var matchOption: BCMRecommendedActionsClientTypes.MatchOption?
        /// One or more values to match against the specified key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: BCMRecommendedActionsClientTypes.FilterName? = nil,
            matchOption: BCMRecommendedActionsClientTypes.MatchOption? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.matchOption = matchOption
            self.values = values
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum ActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addAlternateBillingContact
        case createAnomalyMonitor
        case createBudget
        case enableCostOptimizationHub
        case migrateToGranularPermissions
        case paymentsDue
        case paymentsPastDue
        case reviewAnomalies
        case reviewBudgetsExceeded
        case reviewBudgetAlerts
        case reviewExpiringRi
        case reviewExpiringSp
        case reviewFreetierCreditsRemaining
        case reviewFreetierDaysRemaining
        case reviewFreetierUsageAlerts
        case reviewSavingsOpportunityRecommendations
        case updateExpiredPaymentMethod
        case updateInvalidPaymentMethod
        case updateTaxExemptionCertificate
        case updateTaxRegistrationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .addAlternateBillingContact,
                .createAnomalyMonitor,
                .createBudget,
                .enableCostOptimizationHub,
                .migrateToGranularPermissions,
                .paymentsDue,
                .paymentsPastDue,
                .reviewAnomalies,
                .reviewBudgetsExceeded,
                .reviewBudgetAlerts,
                .reviewExpiringRi,
                .reviewExpiringSp,
                .reviewFreetierCreditsRemaining,
                .reviewFreetierDaysRemaining,
                .reviewFreetierUsageAlerts,
                .reviewSavingsOpportunityRecommendations,
                .updateExpiredPaymentMethod,
                .updateInvalidPaymentMethod,
                .updateTaxExemptionCertificate,
                .updateTaxRegistrationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addAlternateBillingContact: return "ADD_ALTERNATE_BILLING_CONTACT"
            case .createAnomalyMonitor: return "CREATE_ANOMALY_MONITOR"
            case .createBudget: return "CREATE_BUDGET"
            case .enableCostOptimizationHub: return "ENABLE_COST_OPTIMIZATION_HUB"
            case .migrateToGranularPermissions: return "MIGRATE_TO_GRANULAR_PERMISSIONS"
            case .paymentsDue: return "PAYMENTS_DUE"
            case .paymentsPastDue: return "PAYMENTS_PAST_DUE"
            case .reviewAnomalies: return "REVIEW_ANOMALIES"
            case .reviewBudgetsExceeded: return "REVIEW_BUDGETS_EXCEEDED"
            case .reviewBudgetAlerts: return "REVIEW_BUDGET_ALERTS"
            case .reviewExpiringRi: return "REVIEW_EXPIRING_RI"
            case .reviewExpiringSp: return "REVIEW_EXPIRING_SP"
            case .reviewFreetierCreditsRemaining: return "REVIEW_FREETIER_CREDITS_REMAINING"
            case .reviewFreetierDaysRemaining: return "REVIEW_FREETIER_DAYS_REMAINING"
            case .reviewFreetierUsageAlerts: return "REVIEW_FREETIER_USAGE_ALERTS"
            case .reviewSavingsOpportunityRecommendations: return "REVIEW_SAVINGS_OPPORTUNITY_RECOMMENDATIONS"
            case .updateExpiredPaymentMethod: return "UPDATE_EXPIRED_PAYMENT_METHOD"
            case .updateInvalidPaymentMethod: return "UPDATE_INVALID_PAYMENT_METHOD"
            case .updateTaxExemptionCertificate: return "UPDATE_TAX_EXEMPTION_CERTIFICATE"
            case .updateTaxRegistrationNumber: return "UPDATE_TAX_REGISTRATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An unexpected error occurred during the processing of your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BCMRecommendedActionsInternalServer" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BCMRecommendedActionsThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BCMRecommendedActionsClientTypes {

    /// Provides specific details about why a particular field failed validation.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Provides a message explaining why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// Provides the name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Lists each problematic field and why it failed validation.
        public internal(set) var fieldList: [BCMRecommendedActionsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Provides a single, overarching explanation for the validation failure.
        /// This member is required.
        public internal(set) var reason: BCMRecommendedActionsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BCMRecommendedActionsValidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BCMRecommendedActionsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BCMRecommendedActionsClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension BCMRecommendedActionsClientTypes {

    /// Enables filtering of results based on specified action criteria. You can define multiple action filters to refine results using combinations of feature type, severity level, and recommendation type.
    public struct RequestFilter: Swift.Sendable {
        /// A list of action filters that define criteria for filtering results. Each filter specifies a key, match option, and corresponding values to filter on.
        public var actions: [BCMRecommendedActionsClientTypes.ActionFilter]?

        public init(
            actions: [BCMRecommendedActionsClientTypes.ActionFilter]? = nil
        ) {
            self.actions = actions
        }
    }
}

public struct ListRecommendedActionsInput: Swift.Sendable {
    /// The criteria that you want all returned recommended actions to match.
    public var filter: BCMRecommendedActionsClientTypes.RequestFilter?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init(
        filter: BCMRecommendedActionsClientTypes.RequestFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum Feature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case budgets
        case costAnomalyDetection
        case costOptimizationHub
        case freeTier
        case iam
        case payments
        case reservations
        case savingsPlans
        case taxSettings
        case sdkUnknown(Swift.String)

        public static var allCases: [Feature] {
            return [
                .account,
                .budgets,
                .costAnomalyDetection,
                .costOptimizationHub,
                .freeTier,
                .iam,
                .payments,
                .reservations,
                .savingsPlans,
                .taxSettings
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .budgets: return "BUDGETS"
            case .costAnomalyDetection: return "COST_ANOMALY_DETECTION"
            case .costOptimizationHub: return "COST_OPTIMIZATION_HUB"
            case .freeTier: return "FREE_TIER"
            case .iam: return "IAM"
            case .payments: return "PAYMENTS"
            case .reservations: return "RESERVATIONS"
            case .savingsPlans: return "SAVINGS_PLANS"
            case .taxSettings: return "TAX_SETTINGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    public enum Severity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .info,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMRecommendedActionsClientTypes {

    /// Describes a specific recommended action.
    public struct RecommendedAction: Swift.Sendable {
        /// The account that the recommended action is for.
        public var accountId: Swift.String?
        /// Context that applies to the recommended action.
        public var context: [Swift.String: Swift.String]?
        /// The feature associated with the recommended action.
        public var feature: BCMRecommendedActionsClientTypes.Feature?
        /// The ID for the recommended action.
        public var id: Swift.String?
        /// The time when the recommended action status was last updated.
        public var lastUpdatedTimeStamp: Swift.String?
        /// The possible next steps to execute the recommended action.
        public var nextSteps: [Swift.String]?
        /// The severity associated with the recommended action.
        public var severity: BCMRecommendedActionsClientTypes.Severity?
        /// The type of action you can take by adopting the recommended action.
        public var type: BCMRecommendedActionsClientTypes.ActionType?

        public init(
            accountId: Swift.String? = nil,
            context: [Swift.String: Swift.String]? = nil,
            feature: BCMRecommendedActionsClientTypes.Feature? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimeStamp: Swift.String? = nil,
            nextSteps: [Swift.String]? = nil,
            severity: BCMRecommendedActionsClientTypes.Severity? = nil,
            type: BCMRecommendedActionsClientTypes.ActionType? = nil
        ) {
            self.accountId = accountId
            self.context = context
            self.feature = feature
            self.id = id
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.nextSteps = nextSteps
            self.severity = severity
            self.type = type
        }
    }
}

public struct ListRecommendedActionsOutput: Swift.Sendable {
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The list of recommended actions that satisfy the filter criteria.
    /// This member is required.
    public var recommendedActions: [BCMRecommendedActionsClientTypes.RecommendedAction]?

    public init(
        nextToken: Swift.String? = nil,
        recommendedActions: [BCMRecommendedActionsClientTypes.RecommendedAction]? = nil
    ) {
        self.nextToken = nextToken
        self.recommendedActions = recommendedActions
    }
}

extension ListRecommendedActionsInput {

    static func urlPathProvider(_ value: ListRecommendedActionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecommendedActionsInput {

    static func write(value: ListRecommendedActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMRecommendedActionsClientTypes.RequestFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRecommendedActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecommendedActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendedActionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: BCMRecommendedActionsClientTypes.RecommendedAction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum ListRecommendedActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BCMRecommendedActionsAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "BCMRecommendedActionsInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "BCMRecommendedActionsThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "BCMRecommendedActionsValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BCMRecommendedActionsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BCMRecommendedActionsClientTypes.RecommendedAction {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMRecommendedActionsClientTypes.RecommendedAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMRecommendedActionsClientTypes.RecommendedAction()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.severity = try reader["severity"].readIfPresent()
        value.feature = try reader["feature"].readIfPresent()
        value.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextSteps = try reader["nextSteps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTimeStamp = try reader["lastUpdatedTimeStamp"].readIfPresent()
        return value
    }
}

extension BCMRecommendedActionsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMRecommendedActionsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMRecommendedActionsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BCMRecommendedActionsClientTypes.RequestFilter {

    static func write(value: BCMRecommendedActionsClientTypes.RequestFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: BCMRecommendedActionsClientTypes.ActionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BCMRecommendedActionsClientTypes.ActionFilter {

    static func write(value: BCMRecommendedActionsClientTypes.ActionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["matchOption"].write(value.matchOption)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum BCMRecommendedActionsClientTypes {}
