// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OSISClientTypes.ChangeProgressStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastUpdatedAt = "LastUpdatedAt"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OSISClientTypes.ChangeProgressStageStatuses.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension OSISClientTypes {
    /// Progress details for a specific stage of a pipeline configuration change.
    public struct ChangeProgressStage: Swift.Equatable {
        /// A description of the stage.
        public var description: Swift.String?
        /// The most recent updated timestamp of the stage.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the stage.
        public var name: Swift.String?
        /// The current status of the stage that the change is in.
        public var status: OSISClientTypes.ChangeProgressStageStatuses?

        public init(
            description: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: OSISClientTypes.ChangeProgressStageStatuses? = nil
        )
        {
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }

}

extension OSISClientTypes {
    public enum ChangeProgressStageStatuses: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeProgressStageStatuses] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeProgressStageStatuses(rawValue: rawValue) ?? ChangeProgressStageStatuses.sdkUnknown(rawValue)
        }
    }
}

extension OSISClientTypes.ChangeProgressStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeProgressStages = "ChangeProgressStages"
        case startTime = "StartTime"
        case status = "Status"
        case totalNumberOfStages = "TotalNumberOfStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeProgressStages = changeProgressStages {
            var changeProgressStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeProgressStages)
            for changeprogressstage0 in changeProgressStages {
                try changeProgressStagesContainer.encode(changeprogressstage0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if totalNumberOfStages != 0 {
            try encodeContainer.encode(totalNumberOfStages, forKey: .totalNumberOfStages)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OSISClientTypes.ChangeProgressStatuses.self, forKey: .status)
        status = statusDecoded
        let totalNumberOfStagesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfStages) ?? 0
        totalNumberOfStages = totalNumberOfStagesDecoded
        let changeProgressStagesContainer = try containerValues.decodeIfPresent([OSISClientTypes.ChangeProgressStage?].self, forKey: .changeProgressStages)
        var changeProgressStagesDecoded0:[OSISClientTypes.ChangeProgressStage]? = nil
        if let changeProgressStagesContainer = changeProgressStagesContainer {
            changeProgressStagesDecoded0 = [OSISClientTypes.ChangeProgressStage]()
            for structure0 in changeProgressStagesContainer {
                if let structure0 = structure0 {
                    changeProgressStagesDecoded0?.append(structure0)
                }
            }
        }
        changeProgressStages = changeProgressStagesDecoded0
    }
}

extension OSISClientTypes {
    /// The progress details of a pipeline configuration change.
    public struct ChangeProgressStatus: Swift.Equatable {
        /// Information about the stages that the pipeline is going through to perform the configuration change.
        public var changeProgressStages: [OSISClientTypes.ChangeProgressStage]?
        /// The time at which the configuration change is made on the pipeline.
        public var startTime: ClientRuntime.Date?
        /// The overall status of the pipeline configuration change.
        public var status: OSISClientTypes.ChangeProgressStatuses?
        /// The total number of stages required for the pipeline configuration change.
        public var totalNumberOfStages: Swift.Int

        public init(
            changeProgressStages: [OSISClientTypes.ChangeProgressStage]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OSISClientTypes.ChangeProgressStatuses? = nil,
            totalNumberOfStages: Swift.Int = 0
        )
        {
            self.changeProgressStages = changeProgressStages
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }
    }

}

extension OSISClientTypes {
    public enum ChangeProgressStatuses: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeProgressStatuses] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeProgressStatuses(rawValue: rawValue) ?? ChangeProgressStatuses.sdkUnknown(rawValue)
        }
    }
}

extension OSISClientTypes.CloudWatchLogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroup = "LogGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension OSISClientTypes {
    /// The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch.
    public struct CloudWatchLogDestination: Swift.Equatable {
        /// The name of the CloudWatch Logs group to send pipeline logs to. You can specify an existing log group or create a new one. For example, /aws/OpenSearchService/IngestionService/my-pipeline.
        /// This member is required.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client attempted to remove a resource that is currently in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPublishingOptions = "LogPublishingOptions"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
        case pipelineName = "PipelineName"
        case tags = "Tags"
        case vpcOptions = "VpcOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if let maxUnits = self.maxUnits {
            try encodeContainer.encode(maxUnits, forKey: .maxUnits)
        }
        if let minUnits = self.minUnits {
            try encodeContainer.encode(minUnits, forKey: .minUnits)
        }
        if let pipelineConfigurationBody = self.pipelineConfigurationBody {
            try encodeContainer.encode(pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
        }
        if let pipelineName = self.pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcOptions = self.vpcOptions {
            try encodeContainer.encode(vpcOptions, forKey: .vpcOptions)
        }
    }
}

extension CreatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/createPipeline"
    }
}

public struct CreatePipelineInput: Swift.Equatable {
    /// Key-value pairs to configure log publishing.
    public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
    /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
    /// This member is required.
    public var maxUnits: Swift.Int?
    /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
    /// This member is required.
    public var minUnits: Swift.Int?
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    /// This member is required.
    public var pipelineConfigurationBody: Swift.String?
    /// The name of the OpenSearch Ingestion pipeline to create. Pipeline names are unique across the pipelines owned by an account within an Amazon Web Services Region.
    /// This member is required.
    public var pipelineName: Swift.String?
    /// List of tags to add to the pipeline upon creation.
    public var tags: [OSISClientTypes.Tag]?
    /// Container for the values required to configure VPC access for the pipeline. If you don't specify these values, OpenSearch Ingestion creates the pipeline with a public endpoint.
    public var vpcOptions: OSISClientTypes.VpcOptions?

    public init(
        logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
        maxUnits: Swift.Int? = nil,
        minUnits: Swift.Int? = nil,
        pipelineConfigurationBody: Swift.String? = nil,
        pipelineName: Swift.String? = nil,
        tags: [OSISClientTypes.Tag]? = nil,
        vpcOptions: OSISClientTypes.VpcOptions? = nil
    )
    {
        self.logPublishingOptions = logPublishingOptions
        self.maxUnits = maxUnits
        self.minUnits = minUnits
        self.pipelineConfigurationBody = pipelineConfigurationBody
        self.pipelineName = pipelineName
        self.tags = tags
        self.vpcOptions = vpcOptions
    }
}

struct CreatePipelineInputBody: Swift.Equatable {
    let pipelineName: Swift.String?
    let minUnits: Swift.Int?
    let maxUnits: Swift.Int?
    let pipelineConfigurationBody: Swift.String?
    let logPublishingOptions: OSISClientTypes.LogPublishingOptions?
    let vpcOptions: OSISClientTypes.VpcOptions?
    let tags: [OSISClientTypes.Tag]?
}

extension CreatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPublishingOptions = "LogPublishingOptions"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
        case pipelineName = "PipelineName"
        case tags = "Tags"
        case vpcOptions = "VpcOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let minUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUnits)
        minUnits = minUnitsDecoded
        let maxUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUnits)
        maxUnits = maxUnitsDecoded
        let pipelineConfigurationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationBody)
        pipelineConfigurationBody = pipelineConfigurationBodyDecoded
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(OSISClientTypes.LogPublishingOptions.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
        let vpcOptionsDecoded = try containerValues.decodeIfPresent(OSISClientTypes.VpcOptions.self, forKey: .vpcOptions)
        vpcOptions = vpcOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OSISClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OSISClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OSISClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct CreatePipelineOutput: Swift.Equatable {
    /// Container for information about the created pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct CreatePipelineOutputBody: Swift.Equatable {
    let pipeline: OSISClientTypes.Pipeline?
}

extension CreatePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(OSISClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum CreatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/deletePipeline/\(pipelineName.urlPercentEncoding())"
    }
}

public struct DeletePipelineInput: Swift.Equatable {
    /// The name of the pipeline to delete.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct DeletePipelineInputBody: Swift.Equatable {
}

extension DeletePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeletePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPipelineBlueprintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let blueprintName = blueprintName else {
            return nil
        }
        return "/2022-01-01/osis/getPipelineBlueprint/\(blueprintName.urlPercentEncoding())"
    }
}

public struct GetPipelineBlueprintInput: Swift.Equatable {
    /// The name of the blueprint to retrieve.
    /// This member is required.
    public var blueprintName: Swift.String?

    public init(
        blueprintName: Swift.String? = nil
    )
    {
        self.blueprintName = blueprintName
    }
}

struct GetPipelineBlueprintInputBody: Swift.Equatable {
}

extension GetPipelineBlueprintInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPipelineBlueprintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPipelineBlueprintOutputBody = try responseDecoder.decode(responseBody: data)
            self.blueprint = output.blueprint
        } else {
            self.blueprint = nil
        }
    }
}

public struct GetPipelineBlueprintOutput: Swift.Equatable {
    /// The requested blueprint in YAML format.
    public var blueprint: OSISClientTypes.PipelineBlueprint?

    public init(
        blueprint: OSISClientTypes.PipelineBlueprint? = nil
    )
    {
        self.blueprint = blueprint
    }
}

struct GetPipelineBlueprintOutputBody: Swift.Equatable {
    let blueprint: OSISClientTypes.PipelineBlueprint?
}

extension GetPipelineBlueprintOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blueprint = "Blueprint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blueprintDecoded = try containerValues.decodeIfPresent(OSISClientTypes.PipelineBlueprint.self, forKey: .blueprint)
        blueprint = blueprintDecoded
    }
}

enum GetPipelineBlueprintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPipelineChangeProgressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/getPipelineChangeProgress/\(pipelineName.urlPercentEncoding())"
    }
}

public struct GetPipelineChangeProgressInput: Swift.Equatable {
    /// The name of the pipeline.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct GetPipelineChangeProgressInputBody: Swift.Equatable {
}

extension GetPipelineChangeProgressInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPipelineChangeProgressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPipelineChangeProgressOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeProgressStatuses = output.changeProgressStatuses
        } else {
            self.changeProgressStatuses = nil
        }
    }
}

public struct GetPipelineChangeProgressOutput: Swift.Equatable {
    /// The current status of the change happening on the pipeline.
    public var changeProgressStatuses: [OSISClientTypes.ChangeProgressStatus]?

    public init(
        changeProgressStatuses: [OSISClientTypes.ChangeProgressStatus]? = nil
    )
    {
        self.changeProgressStatuses = changeProgressStatuses
    }
}

struct GetPipelineChangeProgressOutputBody: Swift.Equatable {
    let changeProgressStatuses: [OSISClientTypes.ChangeProgressStatus]?
}

extension GetPipelineChangeProgressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeProgressStatuses = "ChangeProgressStatuses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeProgressStatusesContainer = try containerValues.decodeIfPresent([OSISClientTypes.ChangeProgressStatus?].self, forKey: .changeProgressStatuses)
        var changeProgressStatusesDecoded0:[OSISClientTypes.ChangeProgressStatus]? = nil
        if let changeProgressStatusesContainer = changeProgressStatusesContainer {
            changeProgressStatusesDecoded0 = [OSISClientTypes.ChangeProgressStatus]()
            for structure0 in changeProgressStatusesContainer {
                if let structure0 = structure0 {
                    changeProgressStatusesDecoded0?.append(structure0)
                }
            }
        }
        changeProgressStatuses = changeProgressStatusesDecoded0
    }
}

enum GetPipelineChangeProgressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/getPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

public struct GetPipelineInput: Swift.Equatable {
    /// The name of the pipeline to get information about.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct GetPipelineInputBody: Swift.Equatable {
}

extension GetPipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct GetPipelineOutput: Swift.Equatable {
    /// Detailed information about the requested pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct GetPipelineOutputBody: Swift.Equatable {
    let pipeline: OSISClientTypes.Pipeline?
}

extension GetPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(OSISClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum GetPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because of an unknown error, exception, or failure (the failure is internal to the service).
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An invalid pagination token provided in the request.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You attempted to create more than the allowed number of tags.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPipelineBlueprintsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/listPipelineBlueprints"
    }
}

public struct ListPipelineBlueprintsInput: Swift.Equatable {

    public init() { }
}

struct ListPipelineBlueprintsInputBody: Swift.Equatable {
}

extension ListPipelineBlueprintsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPipelineBlueprintsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPipelineBlueprintsOutputBody = try responseDecoder.decode(responseBody: data)
            self.blueprints = output.blueprints
        } else {
            self.blueprints = nil
        }
    }
}

public struct ListPipelineBlueprintsOutput: Swift.Equatable {
    /// A list of available blueprints for Data Prepper.
    public var blueprints: [OSISClientTypes.PipelineBlueprintSummary]?

    public init(
        blueprints: [OSISClientTypes.PipelineBlueprintSummary]? = nil
    )
    {
        self.blueprints = blueprints
    }
}

struct ListPipelineBlueprintsOutputBody: Swift.Equatable {
    let blueprints: [OSISClientTypes.PipelineBlueprintSummary]?
}

extension ListPipelineBlueprintsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blueprints = "Blueprints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blueprintsContainer = try containerValues.decodeIfPresent([OSISClientTypes.PipelineBlueprintSummary?].self, forKey: .blueprints)
        var blueprintsDecoded0:[OSISClientTypes.PipelineBlueprintSummary]? = nil
        if let blueprintsContainer = blueprintsContainer {
            blueprintsDecoded0 = [OSISClientTypes.PipelineBlueprintSummary]()
            for structure0 in blueprintsContainer {
                if let structure0 = structure0 {
                    blueprintsDecoded0?.append(structure0)
                }
            }
        }
        blueprints = blueprintsDecoded0
    }
}

enum ListPipelineBlueprintsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/listPipelines"
    }
}

public struct ListPipelinesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListPipelines operation returns a nextToken, you can include the returned nextToken in subsequent ListPipelines operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPipelinesInputBody: Swift.Equatable {
}

extension ListPipelinesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelines = output.pipelines
        } else {
            self.nextToken = nil
            self.pipelines = nil
        }
    }
}

public struct ListPipelinesOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// A list of all existing Data Prepper pipelines.
    public var pipelines: [OSISClientTypes.PipelineSummary]?

    public init(
        nextToken: Swift.String? = nil,
        pipelines: [OSISClientTypes.PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelines = pipelines
    }
}

struct ListPipelinesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pipelines: [OSISClientTypes.PipelineSummary]?
}

extension ListPipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pipelines = "Pipelines"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pipelinesContainer = try containerValues.decodeIfPresent([OSISClientTypes.PipelineSummary?].self, forKey: .pipelines)
        var pipelinesDecoded0:[OSISClientTypes.PipelineSummary]? = nil
        if let pipelinesContainer = pipelinesContainer {
            pipelinesDecoded0 = [OSISClientTypes.PipelineSummary]()
            for structure0 in pipelinesContainer {
                if let structure0 = structure0 {
                    pipelinesDecoded0?.append(structure0)
                }
            }
        }
        pipelines = pipelinesDecoded0
    }
}

enum ListPipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/listTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pipeline to retrieve tags for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags associated with the given pipeline.
    public var tags: [OSISClientTypes.Tag]?

    public init(
        tags: [OSISClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [OSISClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OSISClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OSISClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OSISClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OSISClientTypes.LogPublishingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDestination = "CloudWatchLogDestination"
        case isLoggingEnabled = "IsLoggingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogDestination = self.cloudWatchLogDestination {
            try encodeContainer.encode(cloudWatchLogDestination, forKey: .cloudWatchLogDestination)
        }
        if let isLoggingEnabled = self.isLoggingEnabled {
            try encodeContainer.encode(isLoggingEnabled, forKey: .isLoggingEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isLoggingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLoggingEnabled)
        isLoggingEnabled = isLoggingEnabledDecoded
        let cloudWatchLogDestinationDecoded = try containerValues.decodeIfPresent(OSISClientTypes.CloudWatchLogDestination.self, forKey: .cloudWatchLogDestination)
        cloudWatchLogDestination = cloudWatchLogDestinationDecoded
    }
}

extension OSISClientTypes {
    /// Container for the values required to configure logging for the pipeline. If you don't specify these values, OpenSearch Ingestion will not publish logs from your application to CloudWatch Logs.
    public struct LogPublishingOptions: Swift.Equatable {
        /// The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch Logs. This parameter is required if IsLoggingEnabled is set to true.
        public var cloudWatchLogDestination: OSISClientTypes.CloudWatchLogDestination?
        /// Whether logs should be published.
        public var isLoggingEnabled: Swift.Bool?

        public init(
            cloudWatchLogDestination: OSISClientTypes.CloudWatchLogDestination? = nil,
            isLoggingEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogDestination = cloudWatchLogDestination
            self.isLoggingEnabled = isLoggingEnabled
        }
    }

}

extension OSISClientTypes.Pipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case ingestEndpointUrls = "IngestEndpointUrls"
        case lastUpdatedAt = "LastUpdatedAt"
        case logPublishingOptions = "LogPublishingOptions"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineArn = "PipelineArn"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
        case pipelineName = "PipelineName"
        case status = "Status"
        case statusReason = "StatusReason"
        case vpcEndpoints = "VpcEndpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let ingestEndpointUrls = ingestEndpointUrls {
            var ingestEndpointUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingestEndpointUrls)
            for string0 in ingestEndpointUrls {
                try ingestEndpointUrlsContainer.encode(string0)
            }
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if maxUnits != 0 {
            try encodeContainer.encode(maxUnits, forKey: .maxUnits)
        }
        if minUnits != 0 {
            try encodeContainer.encode(minUnits, forKey: .minUnits)
        }
        if let pipelineArn = self.pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let pipelineConfigurationBody = self.pipelineConfigurationBody {
            try encodeContainer.encode(pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
        }
        if let pipelineName = self.pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcEndpoints = vpcEndpoints {
            var vpcEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpoints)
            for vpcendpoint0 in vpcEndpoints {
                try vpcEndpointsContainer.encode(vpcendpoint0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let minUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUnits) ?? 0
        minUnits = minUnitsDecoded
        let maxUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUnits) ?? 0
        maxUnits = maxUnitsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OSISClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(OSISClientTypes.PipelineStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let pipelineConfigurationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationBody)
        pipelineConfigurationBody = pipelineConfigurationBodyDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let ingestEndpointUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ingestEndpointUrls)
        var ingestEndpointUrlsDecoded0:[Swift.String]? = nil
        if let ingestEndpointUrlsContainer = ingestEndpointUrlsContainer {
            ingestEndpointUrlsDecoded0 = [Swift.String]()
            for string0 in ingestEndpointUrlsContainer {
                if let string0 = string0 {
                    ingestEndpointUrlsDecoded0?.append(string0)
                }
            }
        }
        ingestEndpointUrls = ingestEndpointUrlsDecoded0
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(OSISClientTypes.LogPublishingOptions.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
        let vpcEndpointsContainer = try containerValues.decodeIfPresent([OSISClientTypes.VpcEndpoint?].self, forKey: .vpcEndpoints)
        var vpcEndpointsDecoded0:[OSISClientTypes.VpcEndpoint]? = nil
        if let vpcEndpointsContainer = vpcEndpointsContainer {
            vpcEndpointsDecoded0 = [OSISClientTypes.VpcEndpoint]()
            for structure0 in vpcEndpointsContainer {
                if let structure0 = structure0 {
                    vpcEndpointsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpoints = vpcEndpointsDecoded0
    }
}

extension OSISClientTypes {
    /// Information about an existing OpenSearch Ingestion pipeline.
    public struct Pipeline: Swift.Equatable {
        /// The date and time when the pipeline was created.
        public var createdAt: ClientRuntime.Date?
        /// The ingestion endpoints for the pipeline, which you can send data to.
        public var ingestEndpointUrls: [Swift.String]?
        /// The date and time when the pipeline was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Key-value pairs that represent log publishing settings.
        public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var maxUnits: Swift.Int
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var minUnits: Swift.Int
        /// The Amazon Resource Name (ARN) of the pipeline.
        public var pipelineArn: Swift.String?
        /// The Data Prepper pipeline configuration in YAML format.
        public var pipelineConfigurationBody: Swift.String?
        /// The name of the pipeline.
        public var pipelineName: Swift.String?
        /// The current status of the pipeline.
        public var status: OSISClientTypes.PipelineStatus?
        /// The reason for the current status of the pipeline.
        public var statusReason: OSISClientTypes.PipelineStatusReason?
        /// The VPC interface endpoints that have access to the pipeline.
        public var vpcEndpoints: [OSISClientTypes.VpcEndpoint]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            ingestEndpointUrls: [Swift.String]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
            maxUnits: Swift.Int = 0,
            minUnits: Swift.Int = 0,
            pipelineArn: Swift.String? = nil,
            pipelineConfigurationBody: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            status: OSISClientTypes.PipelineStatus? = nil,
            statusReason: OSISClientTypes.PipelineStatusReason? = nil,
            vpcEndpoints: [OSISClientTypes.VpcEndpoint]? = nil
        )
        {
            self.createdAt = createdAt
            self.ingestEndpointUrls = ingestEndpointUrls
            self.lastUpdatedAt = lastUpdatedAt
            self.logPublishingOptions = logPublishingOptions
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.pipelineName = pipelineName
            self.status = status
            self.statusReason = statusReason
            self.vpcEndpoints = vpcEndpoints
        }
    }

}

extension OSISClientTypes.PipelineBlueprint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blueprintName = "BlueprintName"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blueprintName = self.blueprintName {
            try encodeContainer.encode(blueprintName, forKey: .blueprintName)
        }
        if let pipelineConfigurationBody = self.pipelineConfigurationBody {
            try encodeContainer.encode(pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blueprintNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blueprintName)
        blueprintName = blueprintNameDecoded
        let pipelineConfigurationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationBody)
        pipelineConfigurationBody = pipelineConfigurationBodyDecoded
    }
}

extension OSISClientTypes {
    /// Container for information about an OpenSearch Ingestion blueprint.
    public struct PipelineBlueprint: Swift.Equatable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?
        /// The YAML configuration of the blueprint.
        public var pipelineConfigurationBody: Swift.String?

        public init(
            blueprintName: Swift.String? = nil,
            pipelineConfigurationBody: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
            self.pipelineConfigurationBody = pipelineConfigurationBody
        }
    }

}

extension OSISClientTypes.PipelineBlueprintSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blueprintName = "BlueprintName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blueprintName = self.blueprintName {
            try encodeContainer.encode(blueprintName, forKey: .blueprintName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blueprintNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blueprintName)
        blueprintName = blueprintNameDecoded
    }
}

extension OSISClientTypes {
    /// A summary of an OpenSearch Ingestion blueprint.
    public struct PipelineBlueprintSummary: Swift.Equatable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?

        public init(
            blueprintName: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
        }
    }

}

extension OSISClientTypes {
    public enum PipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleting
        case starting
        case startFailed
        case stopped
        case stopping
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleting,
                .starting,
                .startFailed,
                .stopped,
                .stopping,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineStatus(rawValue: rawValue) ?? PipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension OSISClientTypes.PipelineStatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension OSISClientTypes {
    /// Information about a pipeline's current status.
    public struct PipelineStatusReason: Swift.Equatable {
        /// A description of why a pipeline has a certain status.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }

}

extension OSISClientTypes.PipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case lastUpdatedAt = "LastUpdatedAt"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineArn = "PipelineArn"
        case pipelineName = "PipelineName"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let maxUnits = self.maxUnits {
            try encodeContainer.encode(maxUnits, forKey: .maxUnits)
        }
        if let minUnits = self.minUnits {
            try encodeContainer.encode(minUnits, forKey: .minUnits)
        }
        if let pipelineArn = self.pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let pipelineName = self.pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OSISClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(OSISClientTypes.PipelineStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let minUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUnits)
        minUnits = minUnitsDecoded
        let maxUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUnits)
        maxUnits = maxUnitsDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension OSISClientTypes {
    /// Summary information for an OpenSearch Ingestion pipeline.
    public struct PipelineSummary: Swift.Equatable {
        /// The date and time when the pipeline was created.
        public var createdAt: ClientRuntime.Date?
        /// The date and time when the pipeline was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var maxUnits: Swift.Int?
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var minUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public var pipelineArn: Swift.String?
        /// The name of the pipeline.
        public var pipelineName: Swift.String?
        /// The current status of the pipeline.
        public var status: OSISClientTypes.PipelineStatus?
        /// Information about a pipeline's current status.
        public var statusReason: OSISClientTypes.PipelineStatusReason?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            maxUnits: Swift.Int? = nil,
            minUnits: Swift.Int? = nil,
            pipelineArn: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            status: OSISClientTypes.PipelineStatus? = nil,
            statusReason: OSISClientTypes.PipelineStatusReason? = nil
        )
        {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineName = pipelineName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You attempted to access or delete a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/startPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

public struct StartPipelineInput: Swift.Equatable {
    /// The name of the pipeline to start.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct StartPipelineInputBody: Swift.Equatable {
}

extension StartPipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct StartPipelineOutput: Swift.Equatable {
    /// Information about an existing OpenSearch Ingestion pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct StartPipelineOutputBody: Swift.Equatable {
    let pipeline: OSISClientTypes.Pipeline?
}

extension StartPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(OSISClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum StartPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/stopPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

public struct StopPipelineInput: Swift.Equatable {
    /// The name of the pipeline to stop.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct StopPipelineInputBody: Swift.Equatable {
}

extension StopPipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct StopPipelineOutput: Swift.Equatable {
    /// Information about an existing OpenSearch Ingestion pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct StopPipelineOutputBody: Swift.Equatable {
    let pipeline: OSISClientTypes.Pipeline?
}

extension StopPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(OSISClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum StopPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OSISClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OSISClientTypes {
    /// A tag (key-value pair) for an OpenSearch Ingestion pipeline.
    public struct Tag: Swift.Equatable {
        /// The tag key. Tag keys must be unique for the pipeline to which they are attached.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/tagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pipeline to tag.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of key-value tags to add to the pipeline.
    /// This member is required.
    public var tags: [OSISClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [OSISClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [OSISClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OSISClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OSISClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OSISClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/untagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pipeline to remove tags from.
    /// This member is required.
    public var arn: Swift.String?
    /// The tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPublishingOptions = "LogPublishingOptions"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if let maxUnits = self.maxUnits {
            try encodeContainer.encode(maxUnits, forKey: .maxUnits)
        }
        if let minUnits = self.minUnits {
            try encodeContainer.encode(minUnits, forKey: .minUnits)
        }
        if let pipelineConfigurationBody = self.pipelineConfigurationBody {
            try encodeContainer.encode(pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
        }
    }
}

extension UpdatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let pipelineName = pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/updatePipeline/\(pipelineName.urlPercentEncoding())"
    }
}

public struct UpdatePipelineInput: Swift.Equatable {
    /// Key-value pairs to configure log publishing.
    public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
    /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs)
    public var maxUnits: Swift.Int?
    /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
    public var minUnits: Swift.Int?
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    public var pipelineConfigurationBody: Swift.String?
    /// The name of the pipeline to update.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
        maxUnits: Swift.Int? = nil,
        minUnits: Swift.Int? = nil,
        pipelineConfigurationBody: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.logPublishingOptions = logPublishingOptions
        self.maxUnits = maxUnits
        self.minUnits = minUnits
        self.pipelineConfigurationBody = pipelineConfigurationBody
        self.pipelineName = pipelineName
    }
}

struct UpdatePipelineInputBody: Swift.Equatable {
    let minUnits: Swift.Int?
    let maxUnits: Swift.Int?
    let pipelineConfigurationBody: Swift.String?
    let logPublishingOptions: OSISClientTypes.LogPublishingOptions?
}

extension UpdatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPublishingOptions = "LogPublishingOptions"
        case maxUnits = "MaxUnits"
        case minUnits = "MinUnits"
        case pipelineConfigurationBody = "PipelineConfigurationBody"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUnits)
        minUnits = minUnitsDecoded
        let maxUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUnits)
        maxUnits = maxUnitsDecoded
        let pipelineConfigurationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationBody)
        pipelineConfigurationBody = pipelineConfigurationBodyDecoded
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(OSISClientTypes.LogPublishingOptions.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
    }
}

extension UpdatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct UpdatePipelineOutput: Swift.Equatable {
    /// Container for information about the updated pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineOutputBody: Swift.Equatable {
    let pipeline: OSISClientTypes.Pipeline?
}

extension UpdatePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(OSISClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum UpdatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineConfigurationBody = "PipelineConfigurationBody"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineConfigurationBody = self.pipelineConfigurationBody {
            try encodeContainer.encode(pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
        }
    }
}

extension ValidatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2022-01-01/osis/validatePipeline"
    }
}

public struct ValidatePipelineInput: Swift.Equatable {
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    /// This member is required.
    public var pipelineConfigurationBody: Swift.String?

    public init(
        pipelineConfigurationBody: Swift.String? = nil
    )
    {
        self.pipelineConfigurationBody = pipelineConfigurationBody
    }
}

struct ValidatePipelineInputBody: Swift.Equatable {
    let pipelineConfigurationBody: Swift.String?
}

extension ValidatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineConfigurationBody = "PipelineConfigurationBody"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineConfigurationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationBody)
        pipelineConfigurationBody = pipelineConfigurationBodyDecoded
    }
}

extension ValidatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidatePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.isValid = output.isValid
        } else {
            self.errors = nil
            self.isValid = nil
        }
    }
}

public struct ValidatePipelineOutput: Swift.Equatable {
    /// A list of errors if the configuration is invalid.
    public var errors: [OSISClientTypes.ValidationMessage]?
    /// A boolean indicating whether or not the pipeline configuration is valid.
    public var isValid: Swift.Bool?

    public init(
        errors: [OSISClientTypes.ValidationMessage]? = nil,
        isValid: Swift.Bool? = nil
    )
    {
        self.errors = errors
        self.isValid = isValid
    }
}

struct ValidatePipelineOutputBody: Swift.Equatable {
    let isValid: Swift.Bool?
    let errors: [OSISClientTypes.ValidationMessage]?
}

extension ValidatePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case isValid
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isValidDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValid)
        isValid = isValidDecoded
        let errorsContainer = try containerValues.decodeIfPresent([OSISClientTypes.ValidationMessage?].self, forKey: .errors)
        var errorsDecoded0:[OSISClientTypes.ValidationMessage]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [OSISClientTypes.ValidationMessage]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum ValidatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception for missing or invalid input fields.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OSISClientTypes.ValidationMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OSISClientTypes {
    /// A validation message associated with a ValidatePipeline request in OpenSearch Ingestion.
    public struct ValidationMessage: Swift.Equatable {
        /// The validation message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension OSISClientTypes.VpcEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
        case vpcOptions = "VpcOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcOptions = self.vpcOptions {
            try encodeContainer.encode(vpcOptions, forKey: .vpcOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcOptionsDecoded = try containerValues.decodeIfPresent(OSISClientTypes.VpcOptions.self, forKey: .vpcOptions)
        vpcOptions = vpcOptionsDecoded
    }
}

extension OSISClientTypes {
    /// An OpenSearch Ingestion-managed VPC endpoint that will access one or more pipelines.
    public struct VpcEndpoint: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var vpcEndpointId: Swift.String?
        /// The ID for your VPC. Amazon Web Services PrivateLink generates this value when you create a VPC.
        public var vpcId: Swift.String?
        /// Information about the VPC, including associated subnets and security groups.
        public var vpcOptions: OSISClientTypes.VpcOptions?

        public init(
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcOptions: OSISClientTypes.VpcOptions? = nil
        )
        {
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
            self.vpcOptions = vpcOptions
        }
    }

}

extension OSISClientTypes.VpcOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension OSISClientTypes {
    /// Options that specify the subnets and security groups for an OpenSearch Ingestion VPC endpoint.
    public struct VpcOptions: Swift.Equatable {
        /// A list of security groups associated with the VPC endpoint.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoint.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
