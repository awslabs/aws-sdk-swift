//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You don't have permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception is thrown when an operation has been disabled.
public struct DisabledOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because of an unknown error, exception, or failure (the failure is internal to the service).
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You attempted to create more than the allowed number of tags.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You attempted to access or delete a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for missing or invalid input fields.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OSISClientTypes {

    /// Options that specify the configuration of a persistent buffer. To configure how OpenSearch Ingestion encrypts this data, set the EncryptionAtRestOptions. For more information, see [Persistent buffering](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/osis-features-overview.html#persistent-buffering).
    public struct BufferOptions: Swift.Sendable {
        /// Whether persistent buffering should be enabled.
        /// This member is required.
        public var persistentBufferEnabled: Swift.Bool?

        public init(
            persistentBufferEnabled: Swift.Bool? = nil
        )
        {
            self.persistentBufferEnabled = persistentBufferEnabled
        }
    }
}

extension OSISClientTypes {

    /// Options to control how OpenSearch encrypts buffer data.
    public struct EncryptionAtRestOptions: Swift.Sendable {
        /// The ARN of the KMS key used to encrypt buffer data. By default, data is encrypted using an Amazon Web Services owned key.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

extension OSISClientTypes {

    /// The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch.
    public struct CloudWatchLogDestination: Swift.Sendable {
        /// The name of the CloudWatch Logs group to send pipeline logs to. You can specify an existing log group or create a new one. For example, /aws/vendedlogs/OpenSearchService/pipelines.
        /// This member is required.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }
}

extension OSISClientTypes {

    /// Container for the values required to configure logging for the pipeline. If you don't specify these values, OpenSearch Ingestion will not publish logs from your application to CloudWatch Logs.
    public struct LogPublishingOptions: Swift.Sendable {
        /// The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch Logs. This parameter is required if IsLoggingEnabled is set to true.
        public var cloudWatchLogDestination: OSISClientTypes.CloudWatchLogDestination?
        /// Whether logs should be published.
        public var isLoggingEnabled: Swift.Bool?

        public init(
            cloudWatchLogDestination: OSISClientTypes.CloudWatchLogDestination? = nil,
            isLoggingEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogDestination = cloudWatchLogDestination
            self.isLoggingEnabled = isLoggingEnabled
        }
    }
}

extension OSISClientTypes {

    /// A tag (key-value pair) for an OpenSearch Ingestion pipeline.
    public struct Tag: Swift.Sendable {
        /// The tag key. Tag keys must be unique for the pipeline to which they are attached.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension OSISClientTypes {

    /// Options for attaching a VPC to pipeline.
    public struct VpcAttachmentOptions: Swift.Sendable {
        /// Whether a VPC is attached to the pipeline.
        /// This member is required.
        public var attachToVpc: Swift.Bool?
        /// The CIDR block to be reserved for OpenSearch Ingestion to create elastic network interfaces (ENIs).
        public var cidrBlock: Swift.String?

        public init(
            attachToVpc: Swift.Bool? = nil,
            cidrBlock: Swift.String? = nil
        )
        {
            self.attachToVpc = attachToVpc
            self.cidrBlock = cidrBlock
        }
    }
}

extension OSISClientTypes {

    public enum VpcEndpointManagement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customer
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointManagement] {
            return [
                .customer,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customer: return "CUSTOMER"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OSISClientTypes {

    /// Options that specify the subnets and security groups for an OpenSearch Ingestion VPC endpoint.
    public struct VpcOptions: Swift.Sendable {
        /// A list of security groups associated with the VPC endpoint.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoint.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// Options for attaching a VPC to a pipeline.
        public var vpcAttachmentOptions: OSISClientTypes.VpcAttachmentOptions?
        /// Defines whether you or Amazon OpenSearch Ingestion service create and manage the VPC endpoint configured for the pipeline.
        public var vpcEndpointManagement: OSISClientTypes.VpcEndpointManagement?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcAttachmentOptions: OSISClientTypes.VpcAttachmentOptions? = nil,
            vpcEndpointManagement: OSISClientTypes.VpcEndpointManagement? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcAttachmentOptions = vpcAttachmentOptions
            self.vpcEndpointManagement = vpcEndpointManagement
        }
    }
}

public struct CreatePipelineInput: Swift.Sendable {
    /// Key-value pairs to configure persistent buffering for the pipeline.
    public var bufferOptions: OSISClientTypes.BufferOptions?
    /// Key-value pairs to configure encryption for data that is written to a persistent buffer.
    public var encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions?
    /// Key-value pairs to configure log publishing.
    public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
    /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
    /// This member is required.
    public var maxUnits: Swift.Int?
    /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
    /// This member is required.
    public var minUnits: Swift.Int?
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    /// This member is required.
    public var pipelineConfigurationBody: Swift.String?
    /// The name of the OpenSearch Ingestion pipeline to create. Pipeline names are unique across the pipelines owned by an account within an Amazon Web Services Region.
    /// This member is required.
    public var pipelineName: Swift.String?
    /// List of tags to add to the pipeline upon creation.
    public var tags: [OSISClientTypes.Tag]?
    /// Container for the values required to configure VPC access for the pipeline. If you don't specify these values, OpenSearch Ingestion creates the pipeline with a public endpoint.
    public var vpcOptions: OSISClientTypes.VpcOptions?

    public init(
        bufferOptions: OSISClientTypes.BufferOptions? = nil,
        encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions? = nil,
        logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
        maxUnits: Swift.Int? = nil,
        minUnits: Swift.Int? = nil,
        pipelineConfigurationBody: Swift.String? = nil,
        pipelineName: Swift.String? = nil,
        tags: [OSISClientTypes.Tag]? = nil,
        vpcOptions: OSISClientTypes.VpcOptions? = nil
    )
    {
        self.bufferOptions = bufferOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.logPublishingOptions = logPublishingOptions
        self.maxUnits = maxUnits
        self.minUnits = minUnits
        self.pipelineConfigurationBody = pipelineConfigurationBody
        self.pipelineName = pipelineName
        self.tags = tags
        self.vpcOptions = vpcOptions
    }
}

extension OSISClientTypes {

    /// An object representing the destination of a pipeline.
    public struct PipelineDestination: Swift.Sendable {
        /// The endpoint receiving data from the pipeline.
        public var endpoint: Swift.String?
        /// The name of the service receiving data from the pipeline.
        public var serviceName: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.serviceName = serviceName
        }
    }
}

extension OSISClientTypes {

    public enum VpcEndpointServiceName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case opensearchServerless
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointServiceName] {
            return [
                .opensearchServerless
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .opensearchServerless: return "OPENSEARCH_SERVERLESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OSISClientTypes {

    /// A container for information about VPC endpoints that were created to other services
    public struct ServiceVpcEndpoint: Swift.Sendable {
        /// The name of the service for which a VPC endpoint was created.
        public var serviceName: OSISClientTypes.VpcEndpointServiceName?
        /// The unique identifier of the VPC endpoint that was created.
        public var vpcEndpointId: Swift.String?

        public init(
            serviceName: OSISClientTypes.VpcEndpointServiceName? = nil,
            vpcEndpointId: Swift.String? = nil
        )
        {
            self.serviceName = serviceName
            self.vpcEndpointId = vpcEndpointId
        }
    }
}

extension OSISClientTypes {

    public enum PipelineStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleting
        case starting
        case startFailed
        case stopped
        case stopping
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleting,
                .starting,
                .startFailed,
                .stopped,
                .stopping,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OSISClientTypes {

    /// Information about a pipeline's current status.
    public struct PipelineStatusReason: Swift.Sendable {
        /// A description of why a pipeline has a certain status.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }
}

extension OSISClientTypes {

    /// An OpenSearch Ingestion-managed VPC endpoint that will access one or more pipelines.
    public struct VpcEndpoint: Swift.Sendable {
        /// The unique identifier of the endpoint.
        public var vpcEndpointId: Swift.String?
        /// The ID for your VPC. Amazon Web Services PrivateLink generates this value when you create a VPC.
        public var vpcId: Swift.String?
        /// Information about the VPC, including associated subnets and security groups.
        public var vpcOptions: OSISClientTypes.VpcOptions?

        public init(
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcOptions: OSISClientTypes.VpcOptions? = nil
        )
        {
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
            self.vpcOptions = vpcOptions
        }
    }
}

extension OSISClientTypes {

    /// Information about an existing OpenSearch Ingestion pipeline.
    public struct Pipeline: Swift.Sendable {
        /// Options that specify the configuration of a persistent buffer. To configure how OpenSearch Ingestion encrypts this data, set the EncryptionAtRestOptions. For more information, see [Persistent buffering](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/osis-features-overview.html#persistent-buffering).
        public var bufferOptions: OSISClientTypes.BufferOptions?
        /// The date and time when the pipeline was created.
        public var createdAt: Foundation.Date?
        /// Destinations to which the pipeline writes data.
        public var destinations: [OSISClientTypes.PipelineDestination]?
        /// Options to control how OpenSearch encrypts buffer data.
        public var encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions?
        /// The ingestion endpoints for the pipeline, which you can send data to.
        public var ingestEndpointUrls: [Swift.String]?
        /// The date and time when the pipeline was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// Key-value pairs that represent log publishing settings.
        public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var maxUnits: Swift.Int
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var minUnits: Swift.Int
        /// The Amazon Resource Name (ARN) of the pipeline.
        public var pipelineArn: Swift.String?
        /// The Data Prepper pipeline configuration in YAML format.
        public var pipelineConfigurationBody: Swift.String?
        /// The name of the pipeline.
        public var pipelineName: Swift.String?
        /// A list of VPC endpoints that OpenSearch Ingestion has created to other Amazon Web Services services.
        public var serviceVpcEndpoints: [OSISClientTypes.ServiceVpcEndpoint]?
        /// The current status of the pipeline.
        public var status: OSISClientTypes.PipelineStatus?
        /// The reason for the current status of the pipeline.
        public var statusReason: OSISClientTypes.PipelineStatusReason?
        /// A list of tags associated with the given pipeline.
        public var tags: [OSISClientTypes.Tag]?
        /// The VPC endpoint service name for the pipeline.
        public var vpcEndpointService: Swift.String?
        /// The VPC interface endpoints that have access to the pipeline.
        public var vpcEndpoints: [OSISClientTypes.VpcEndpoint]?

        public init(
            bufferOptions: OSISClientTypes.BufferOptions? = nil,
            createdAt: Foundation.Date? = nil,
            destinations: [OSISClientTypes.PipelineDestination]? = nil,
            encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions? = nil,
            ingestEndpointUrls: [Swift.String]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
            maxUnits: Swift.Int = 0,
            minUnits: Swift.Int = 0,
            pipelineArn: Swift.String? = nil,
            pipelineConfigurationBody: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            serviceVpcEndpoints: [OSISClientTypes.ServiceVpcEndpoint]? = nil,
            status: OSISClientTypes.PipelineStatus? = nil,
            statusReason: OSISClientTypes.PipelineStatusReason? = nil,
            tags: [OSISClientTypes.Tag]? = nil,
            vpcEndpointService: Swift.String? = nil,
            vpcEndpoints: [OSISClientTypes.VpcEndpoint]? = nil
        )
        {
            self.bufferOptions = bufferOptions
            self.createdAt = createdAt
            self.destinations = destinations
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.ingestEndpointUrls = ingestEndpointUrls
            self.lastUpdatedAt = lastUpdatedAt
            self.logPublishingOptions = logPublishingOptions
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.pipelineName = pipelineName
            self.serviceVpcEndpoints = serviceVpcEndpoints
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.vpcEndpointService = vpcEndpointService
            self.vpcEndpoints = vpcEndpoints
        }
    }
}

public struct CreatePipelineOutput: Swift.Sendable {
    /// Container for information about the created pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

/// The client attempted to remove a resource that is currently in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeletePipelineInput: Swift.Sendable {
    /// The name of the pipeline to delete.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

public struct DeletePipelineOutput: Swift.Sendable {

    public init() { }
}

public struct GetPipelineInput: Swift.Sendable {
    /// The name of the pipeline.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

public struct GetPipelineOutput: Swift.Sendable {
    /// Detailed information about the requested pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

public struct GetPipelineBlueprintInput: Swift.Sendable {
    /// The name of the blueprint to retrieve.
    /// This member is required.
    public var blueprintName: Swift.String?
    /// The format format of the blueprint to retrieve.
    public var format: Swift.String?

    public init(
        blueprintName: Swift.String? = nil,
        format: Swift.String? = nil
    )
    {
        self.blueprintName = blueprintName
        self.format = format
    }
}

extension OSISClientTypes {

    /// Container for information about an OpenSearch Ingestion blueprint.
    public struct PipelineBlueprint: Swift.Sendable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?
        /// A description of the blueprint.
        public var displayDescription: Swift.String?
        /// The display name of the blueprint.
        public var displayName: Swift.String?
        /// The YAML configuration of the blueprint.
        public var pipelineConfigurationBody: Swift.String?
        /// The name of the service that the blueprint is associated with.
        public var service: Swift.String?
        /// The use case that the blueprint relates to.
        public var useCase: Swift.String?

        public init(
            blueprintName: Swift.String? = nil,
            displayDescription: Swift.String? = nil,
            displayName: Swift.String? = nil,
            pipelineConfigurationBody: Swift.String? = nil,
            service: Swift.String? = nil,
            useCase: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
            self.displayDescription = displayDescription
            self.displayName = displayName
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.service = service
            self.useCase = useCase
        }
    }
}

public struct GetPipelineBlueprintOutput: Swift.Sendable {
    /// The requested blueprint in YAML format.
    public var blueprint: OSISClientTypes.PipelineBlueprint?
    /// The format of the blueprint.
    public var format: Swift.String?

    public init(
        blueprint: OSISClientTypes.PipelineBlueprint? = nil,
        format: Swift.String? = nil
    )
    {
        self.blueprint = blueprint
        self.format = format
    }
}

public struct GetPipelineChangeProgressInput: Swift.Sendable {
    /// The name of the pipeline.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

extension OSISClientTypes {

    public enum ChangeProgressStageStatuses: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeProgressStageStatuses] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OSISClientTypes {

    /// Progress details for a specific stage of a pipeline configuration change.
    public struct ChangeProgressStage: Swift.Sendable {
        /// A description of the stage.
        public var description: Swift.String?
        /// The most recent updated timestamp of the stage.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the stage.
        public var name: Swift.String?
        /// The current status of the stage that the change is in.
        public var status: OSISClientTypes.ChangeProgressStageStatuses?

        public init(
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: OSISClientTypes.ChangeProgressStageStatuses? = nil
        )
        {
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }
}

extension OSISClientTypes {

    public enum ChangeProgressStatuses: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeProgressStatuses] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OSISClientTypes {

    /// The progress details of a pipeline configuration change.
    public struct ChangeProgressStatus: Swift.Sendable {
        /// Information about the stages that the pipeline is going through to perform the configuration change.
        public var changeProgressStages: [OSISClientTypes.ChangeProgressStage]?
        /// The time at which the configuration change is made on the pipeline.
        public var startTime: Foundation.Date?
        /// The overall status of the pipeline configuration change.
        public var status: OSISClientTypes.ChangeProgressStatuses?
        /// The total number of stages required for the pipeline configuration change.
        public var totalNumberOfStages: Swift.Int

        public init(
            changeProgressStages: [OSISClientTypes.ChangeProgressStage]? = nil,
            startTime: Foundation.Date? = nil,
            status: OSISClientTypes.ChangeProgressStatuses? = nil,
            totalNumberOfStages: Swift.Int = 0
        )
        {
            self.changeProgressStages = changeProgressStages
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }
    }
}

public struct GetPipelineChangeProgressOutput: Swift.Sendable {
    /// The current status of the change happening on the pipeline.
    public var changeProgressStatuses: [OSISClientTypes.ChangeProgressStatus]?

    public init(
        changeProgressStatuses: [OSISClientTypes.ChangeProgressStatus]? = nil
    )
    {
        self.changeProgressStatuses = changeProgressStatuses
    }
}

/// An invalid pagination token provided in the request.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListPipelineBlueprintsInput: Swift.Sendable {

    public init() { }
}

extension OSISClientTypes {

    /// A summary of an OpenSearch Ingestion blueprint.
    public struct PipelineBlueprintSummary: Swift.Sendable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?
        /// A description of the blueprint.
        public var displayDescription: Swift.String?
        /// The display name of the blueprint.
        public var displayName: Swift.String?
        /// The name of the service that the blueprint is associated with.
        public var service: Swift.String?
        /// The use case that the blueprint relates to.
        public var useCase: Swift.String?

        public init(
            blueprintName: Swift.String? = nil,
            displayDescription: Swift.String? = nil,
            displayName: Swift.String? = nil,
            service: Swift.String? = nil,
            useCase: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
            self.displayDescription = displayDescription
            self.displayName = displayName
            self.service = service
            self.useCase = useCase
        }
    }
}

public struct ListPipelineBlueprintsOutput: Swift.Sendable {
    /// A list of available blueprints for Data Prepper.
    public var blueprints: [OSISClientTypes.PipelineBlueprintSummary]?

    public init(
        blueprints: [OSISClientTypes.PipelineBlueprintSummary]? = nil
    )
    {
        self.blueprints = blueprints
    }
}

public struct ListPipelinesInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListPipelines operation returns a nextToken, you can include the returned nextToken in subsequent ListPipelines operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OSISClientTypes {

    /// Summary information for an OpenSearch Ingestion pipeline.
    public struct PipelineSummary: Swift.Sendable {
        /// The date and time when the pipeline was created.
        public var createdAt: Foundation.Date?
        /// A list of destinations to which the pipeline writes data.
        public var destinations: [OSISClientTypes.PipelineDestination]?
        /// The date and time when the pipeline was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var maxUnits: Swift.Int?
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public var minUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public var pipelineArn: Swift.String?
        /// The name of the pipeline.
        public var pipelineName: Swift.String?
        /// The current status of the pipeline.
        public var status: OSISClientTypes.PipelineStatus?
        /// Information about a pipeline's current status.
        public var statusReason: OSISClientTypes.PipelineStatusReason?
        /// A list of tags associated with the given pipeline.
        public var tags: [OSISClientTypes.Tag]?

        public init(
            createdAt: Foundation.Date? = nil,
            destinations: [OSISClientTypes.PipelineDestination]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            maxUnits: Swift.Int? = nil,
            minUnits: Swift.Int? = nil,
            pipelineArn: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            status: OSISClientTypes.PipelineStatus? = nil,
            statusReason: OSISClientTypes.PipelineStatusReason? = nil,
            tags: [OSISClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.destinations = destinations
            self.lastUpdatedAt = lastUpdatedAt
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineName = pipelineName
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }
    }
}

public struct ListPipelinesOutput: Swift.Sendable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// A list of all existing Data Prepper pipelines.
    public var pipelines: [OSISClientTypes.PipelineSummary]?

    public init(
        nextToken: Swift.String? = nil,
        pipelines: [OSISClientTypes.PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelines = pipelines
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the pipeline to retrieve tags for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags associated with the given pipeline.
    public var tags: [OSISClientTypes.Tag]?

    public init(
        tags: [OSISClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartPipelineInput: Swift.Sendable {
    /// The name of the pipeline to start.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

public struct StartPipelineOutput: Swift.Sendable {
    /// Information about an existing OpenSearch Ingestion pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

public struct StopPipelineInput: Swift.Sendable {
    /// The name of the pipeline to stop.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

public struct StopPipelineOutput: Swift.Sendable {
    /// Information about an existing OpenSearch Ingestion pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the pipeline to tag.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of key-value tags to add to the pipeline.
    /// This member is required.
    public var tags: [OSISClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [OSISClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the pipeline to remove tags from.
    /// This member is required.
    public var arn: Swift.String?
    /// The tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdatePipelineInput: Swift.Sendable {
    /// Key-value pairs to configure persistent buffering for the pipeline.
    public var bufferOptions: OSISClientTypes.BufferOptions?
    /// Key-value pairs to configure encryption for data that is written to a persistent buffer.
    public var encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions?
    /// Key-value pairs to configure log publishing.
    public var logPublishingOptions: OSISClientTypes.LogPublishingOptions?
    /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs)
    public var maxUnits: Swift.Int?
    /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
    public var minUnits: Swift.Int?
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    public var pipelineConfigurationBody: Swift.String?
    /// The name of the pipeline to update.
    /// This member is required.
    public var pipelineName: Swift.String?

    public init(
        bufferOptions: OSISClientTypes.BufferOptions? = nil,
        encryptionAtRestOptions: OSISClientTypes.EncryptionAtRestOptions? = nil,
        logPublishingOptions: OSISClientTypes.LogPublishingOptions? = nil,
        maxUnits: Swift.Int? = nil,
        minUnits: Swift.Int? = nil,
        pipelineConfigurationBody: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.bufferOptions = bufferOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.logPublishingOptions = logPublishingOptions
        self.maxUnits = maxUnits
        self.minUnits = minUnits
        self.pipelineConfigurationBody = pipelineConfigurationBody
        self.pipelineName = pipelineName
    }
}

public struct UpdatePipelineOutput: Swift.Sendable {
    /// Container for information about the updated pipeline.
    public var pipeline: OSISClientTypes.Pipeline?

    public init(
        pipeline: OSISClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

public struct ValidatePipelineInput: Swift.Sendable {
    /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
    /// This member is required.
    public var pipelineConfigurationBody: Swift.String?

    public init(
        pipelineConfigurationBody: Swift.String? = nil
    )
    {
        self.pipelineConfigurationBody = pipelineConfigurationBody
    }
}

extension OSISClientTypes {

    /// A validation message associated with a ValidatePipeline request in OpenSearch Ingestion.
    public struct ValidationMessage: Swift.Sendable {
        /// The validation message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }
}

public struct ValidatePipelineOutput: Swift.Sendable {
    /// A list of errors if the configuration is invalid.
    public var errors: [OSISClientTypes.ValidationMessage]?
    /// A boolean indicating whether or not the pipeline configuration is valid.
    public var isValid: Swift.Bool?

    public init(
        errors: [OSISClientTypes.ValidationMessage]? = nil,
        isValid: Swift.Bool? = nil
    )
    {
        self.errors = errors
        self.isValid = isValid
    }
}

extension CreatePipelineInput {

    static func urlPathProvider(_ value: CreatePipelineInput) -> Swift.String? {
        return "/2022-01-01/osis/createPipeline"
    }
}

extension DeletePipelineInput {

    static func urlPathProvider(_ value: DeletePipelineInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/deletePipeline/\(pipelineName.urlPercentEncoding())"
    }
}

extension GetPipelineInput {

    static func urlPathProvider(_ value: GetPipelineInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/getPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

extension GetPipelineBlueprintInput {

    static func urlPathProvider(_ value: GetPipelineBlueprintInput) -> Swift.String? {
        guard let blueprintName = value.blueprintName else {
            return nil
        }
        return "/2022-01-01/osis/getPipelineBlueprint/\(blueprintName.urlPercentEncoding())"
    }
}

extension GetPipelineBlueprintInput {

    static func queryItemProvider(_ value: GetPipelineBlueprintInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let format = value.format {
            let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension GetPipelineChangeProgressInput {

    static func urlPathProvider(_ value: GetPipelineChangeProgressInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/getPipelineChangeProgress/\(pipelineName.urlPercentEncoding())"
    }
}

extension ListPipelineBlueprintsInput {

    static func urlPathProvider(_ value: ListPipelineBlueprintsInput) -> Swift.String? {
        return "/2022-01-01/osis/listPipelineBlueprints"
    }
}

extension ListPipelinesInput {

    static func urlPathProvider(_ value: ListPipelinesInput) -> Swift.String? {
        return "/2022-01-01/osis/listPipelines"
    }
}

extension ListPipelinesInput {

    static func queryItemProvider(_ value: ListPipelinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/2022-01-01/osis/listTagsForResource"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension StartPipelineInput {

    static func urlPathProvider(_ value: StartPipelineInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/startPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

extension StopPipelineInput {

    static func urlPathProvider(_ value: StopPipelineInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/stopPipeline/\(pipelineName.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/2022-01-01/osis/tagResource"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/2022-01-01/osis/untagResource"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension UpdatePipelineInput {

    static func urlPathProvider(_ value: UpdatePipelineInput) -> Swift.String? {
        guard let pipelineName = value.pipelineName else {
            return nil
        }
        return "/2022-01-01/osis/updatePipeline/\(pipelineName.urlPercentEncoding())"
    }
}

extension ValidatePipelineInput {

    static func urlPathProvider(_ value: ValidatePipelineInput) -> Swift.String? {
        return "/2022-01-01/osis/validatePipeline"
    }
}

extension CreatePipelineInput {

    static func write(value: CreatePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BufferOptions"].write(value.bufferOptions, with: OSISClientTypes.BufferOptions.write(value:to:))
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: OSISClientTypes.EncryptionAtRestOptions.write(value:to:))
        try writer["LogPublishingOptions"].write(value.logPublishingOptions, with: OSISClientTypes.LogPublishingOptions.write(value:to:))
        try writer["MaxUnits"].write(value.maxUnits)
        try writer["MinUnits"].write(value.minUnits)
        try writer["PipelineConfigurationBody"].write(value.pipelineConfigurationBody)
        try writer["PipelineName"].write(value.pipelineName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: OSISClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcOptions"].write(value.vpcOptions, with: OSISClientTypes.VpcOptions.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: OSISClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePipelineInput {

    static func write(value: UpdatePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BufferOptions"].write(value.bufferOptions, with: OSISClientTypes.BufferOptions.write(value:to:))
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: OSISClientTypes.EncryptionAtRestOptions.write(value:to:))
        try writer["LogPublishingOptions"].write(value.logPublishingOptions, with: OSISClientTypes.LogPublishingOptions.write(value:to:))
        try writer["MaxUnits"].write(value.maxUnits)
        try writer["MinUnits"].write(value.minUnits)
        try writer["PipelineConfigurationBody"].write(value.pipelineConfigurationBody)
    }
}

extension ValidatePipelineInput {

    static func write(value: ValidatePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PipelineConfigurationBody"].write(value.pipelineConfigurationBody)
    }
}

extension CreatePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePipelineOutput()
        value.pipeline = try reader["Pipeline"].readIfPresent(with: OSISClientTypes.Pipeline.read(from:))
        return value
    }
}

extension DeletePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePipelineOutput {
        return DeletePipelineOutput()
    }
}

extension GetPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPipelineOutput()
        value.pipeline = try reader["Pipeline"].readIfPresent(with: OSISClientTypes.Pipeline.read(from:))
        return value
    }
}

extension GetPipelineBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPipelineBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPipelineBlueprintOutput()
        value.blueprint = try reader["Blueprint"].readIfPresent(with: OSISClientTypes.PipelineBlueprint.read(from:))
        value.format = try reader["Format"].readIfPresent()
        return value
    }
}

extension GetPipelineChangeProgressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPipelineChangeProgressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPipelineChangeProgressOutput()
        value.changeProgressStatuses = try reader["ChangeProgressStatuses"].readListIfPresent(memberReadingClosure: OSISClientTypes.ChangeProgressStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPipelineBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPipelineBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPipelineBlueprintsOutput()
        value.blueprints = try reader["Blueprints"].readListIfPresent(memberReadingClosure: OSISClientTypes.PipelineBlueprintSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPipelinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPipelinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPipelinesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pipelines = try reader["Pipelines"].readListIfPresent(memberReadingClosure: OSISClientTypes.PipelineSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: OSISClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartPipelineOutput()
        value.pipeline = try reader["Pipeline"].readIfPresent(with: OSISClientTypes.Pipeline.read(from:))
        return value
    }
}

extension StopPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopPipelineOutput()
        value.pipeline = try reader["Pipeline"].readIfPresent(with: OSISClientTypes.Pipeline.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdatePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePipelineOutput()
        value.pipeline = try reader["Pipeline"].readIfPresent(with: OSISClientTypes.Pipeline.read(from:))
        return value
    }
}

extension ValidatePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidatePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidatePipelineOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: OSISClientTypes.ValidationMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isValid = try reader["isValid"].readIfPresent()
        return value
    }
}

enum CreatePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPipelineBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPipelineChangeProgressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPipelineBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPipelinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidatePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisabledOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DisabledOperationException {
        let reader = baseError.errorBodyReader
        var value = DisabledOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OSISClientTypes.Pipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.Pipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.Pipeline()
        value.pipelineName = try reader["PipelineName"].readIfPresent()
        value.pipelineArn = try reader["PipelineArn"].readIfPresent()
        value.minUnits = try reader["MinUnits"].readIfPresent() ?? 0
        value.maxUnits = try reader["MaxUnits"].readIfPresent() ?? 0
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent(with: OSISClientTypes.PipelineStatusReason.read(from:))
        value.pipelineConfigurationBody = try reader["PipelineConfigurationBody"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ingestEndpointUrls = try reader["IngestEndpointUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.logPublishingOptions = try reader["LogPublishingOptions"].readIfPresent(with: OSISClientTypes.LogPublishingOptions.read(from:))
        value.vpcEndpoints = try reader["VpcEndpoints"].readListIfPresent(memberReadingClosure: OSISClientTypes.VpcEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bufferOptions = try reader["BufferOptions"].readIfPresent(with: OSISClientTypes.BufferOptions.read(from:))
        value.encryptionAtRestOptions = try reader["EncryptionAtRestOptions"].readIfPresent(with: OSISClientTypes.EncryptionAtRestOptions.read(from:))
        value.vpcEndpointService = try reader["VpcEndpointService"].readIfPresent()
        value.serviceVpcEndpoints = try reader["ServiceVpcEndpoints"].readListIfPresent(memberReadingClosure: OSISClientTypes.ServiceVpcEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: OSISClientTypes.PipelineDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: OSISClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OSISClientTypes.Tag {

    static func write(value: OSISClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension OSISClientTypes.PipelineDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.PipelineDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.PipelineDestination()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.ServiceVpcEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.ServiceVpcEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.ServiceVpcEndpoint()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.EncryptionAtRestOptions {

    static func write(value: OSISClientTypes.EncryptionAtRestOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.EncryptionAtRestOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.EncryptionAtRestOptions()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent() ?? ""
        return value
    }
}

extension OSISClientTypes.BufferOptions {

    static func write(value: OSISClientTypes.BufferOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PersistentBufferEnabled"].write(value.persistentBufferEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.BufferOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.BufferOptions()
        value.persistentBufferEnabled = try reader["PersistentBufferEnabled"].readIfPresent() ?? false
        return value
    }
}

extension OSISClientTypes.VpcEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.VpcEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.VpcEndpoint()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.vpcOptions = try reader["VpcOptions"].readIfPresent(with: OSISClientTypes.VpcOptions.read(from:))
        return value
    }
}

extension OSISClientTypes.VpcOptions {

    static func write(value: OSISClientTypes.VpcOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcAttachmentOptions"].write(value.vpcAttachmentOptions, with: OSISClientTypes.VpcAttachmentOptions.write(value:to:))
        try writer["VpcEndpointManagement"].write(value.vpcEndpointManagement)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.VpcOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.VpcOptions()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcAttachmentOptions = try reader["VpcAttachmentOptions"].readIfPresent(with: OSISClientTypes.VpcAttachmentOptions.read(from:))
        value.vpcEndpointManagement = try reader["VpcEndpointManagement"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.VpcAttachmentOptions {

    static func write(value: OSISClientTypes.VpcAttachmentOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachToVpc"].write(value.attachToVpc)
        try writer["CidrBlock"].write(value.cidrBlock)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.VpcAttachmentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.VpcAttachmentOptions()
        value.attachToVpc = try reader["AttachToVpc"].readIfPresent() ?? false
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.LogPublishingOptions {

    static func write(value: OSISClientTypes.LogPublishingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogDestination"].write(value.cloudWatchLogDestination, with: OSISClientTypes.CloudWatchLogDestination.write(value:to:))
        try writer["IsLoggingEnabled"].write(value.isLoggingEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.LogPublishingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.LogPublishingOptions()
        value.isLoggingEnabled = try reader["IsLoggingEnabled"].readIfPresent()
        value.cloudWatchLogDestination = try reader["CloudWatchLogDestination"].readIfPresent(with: OSISClientTypes.CloudWatchLogDestination.read(from:))
        return value
    }
}

extension OSISClientTypes.CloudWatchLogDestination {

    static func write(value: OSISClientTypes.CloudWatchLogDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogGroup"].write(value.logGroup)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.CloudWatchLogDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.CloudWatchLogDestination()
        value.logGroup = try reader["LogGroup"].readIfPresent() ?? ""
        return value
    }
}

extension OSISClientTypes.PipelineStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.PipelineStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.PipelineStatusReason()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.PipelineBlueprint {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.PipelineBlueprint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.PipelineBlueprint()
        value.blueprintName = try reader["BlueprintName"].readIfPresent()
        value.pipelineConfigurationBody = try reader["PipelineConfigurationBody"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.displayDescription = try reader["DisplayDescription"].readIfPresent()
        value.service = try reader["Service"].readIfPresent()
        value.useCase = try reader["UseCase"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.ChangeProgressStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.ChangeProgressStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.ChangeProgressStatus()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.totalNumberOfStages = try reader["TotalNumberOfStages"].readIfPresent() ?? 0
        value.changeProgressStages = try reader["ChangeProgressStages"].readListIfPresent(memberReadingClosure: OSISClientTypes.ChangeProgressStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OSISClientTypes.ChangeProgressStage {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.ChangeProgressStage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.ChangeProgressStage()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OSISClientTypes.PipelineBlueprintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.PipelineBlueprintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.PipelineBlueprintSummary()
        value.blueprintName = try reader["BlueprintName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.displayDescription = try reader["DisplayDescription"].readIfPresent()
        value.service = try reader["Service"].readIfPresent()
        value.useCase = try reader["UseCase"].readIfPresent()
        return value
    }
}

extension OSISClientTypes.PipelineSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.PipelineSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.PipelineSummary()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent(with: OSISClientTypes.PipelineStatusReason.read(from:))
        value.pipelineName = try reader["PipelineName"].readIfPresent()
        value.pipelineArn = try reader["PipelineArn"].readIfPresent()
        value.minUnits = try reader["MinUnits"].readIfPresent()
        value.maxUnits = try reader["MaxUnits"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: OSISClientTypes.PipelineDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: OSISClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OSISClientTypes.ValidationMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> OSISClientTypes.ValidationMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OSISClientTypes.ValidationMessage()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

public enum OSISClientTypes {}
