//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
@_spi(SmithyReadWrite) import func SmithyReadWrite.sparseFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// The limit for the number of attachment sets created in a short period of time has been exceeded.
public struct AttachmentLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit for the number of attachment sets created in a short period of time has been exceeded.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The expiration time of the attachment set has passed. The set expires 1 hour after it is created.
public struct AttachmentSetExpired: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The expiration time of the attachment set has passed. The set expires one hour after it is created.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentSetExpired" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An attachment set with the specified ID could not be found.
public struct AttachmentSetIdNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An attachment set with the specified ID could not be found.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentSetIdNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A limit for the size of an attachment set has been exceeded. The limits are three attachments and 5 MB per attachment.
public struct AttachmentSetSizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A limit for the size of an attachment set has been exceeded. The limits are three attachments and 5 MB per attachment.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentSetSizeLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An internal server error occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SupportClientTypes {

    /// An attachment to a case communication. The attachment consists of the file name and the content of the file. Each attachment file size should not exceed 5 MB. File types that are supported include the following: pdf, jpeg,.doc, .log, .text
    public struct Attachment: Swift.Sendable {
        /// The content of the attachment file.
        public var data: Foundation.Data?
        /// The name of the attachment file.
        public var fileName: Swift.String?

        public init(
            data: Foundation.Data? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.data = data
            self.fileName = fileName
        }
    }
}

public struct AddAttachmentsToSetInput: Swift.Sendable {
    /// The ID of the attachment set. If an attachmentSetId is not specified, a new attachment set is created, and the ID of the set is returned in the response. If an attachmentSetId is specified, the attachments are added to the specified set, if it exists.
    public var attachmentSetId: Swift.String?
    /// One or more attachments to add to the set. You can add up to three attachments per set. The size limit is 5 MB per attachment. In the Attachment object, use the data parameter to specify the contents of the attachment file. In the previous request syntax, the value for data appear as blob, which is represented as a base64-encoded string. The value for fileName is the name of the attachment, such as troubleshoot-screenshot.png.
    /// This member is required.
    public var attachments: [SupportClientTypes.Attachment]?

    public init(
        attachmentSetId: Swift.String? = nil,
        attachments: [SupportClientTypes.Attachment]? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.attachments = attachments
    }
}

/// The ID and expiry time of the attachment set returned by the [AddAttachmentsToSet] operation.
public struct AddAttachmentsToSetOutput: Swift.Sendable {
    /// The ID of the attachment set. If an attachmentSetId was not specified, a new attachment set is created, and the ID of the set is returned in the response. If an attachmentSetId was specified, the attachments are added to the specified set, if it exists.
    public var attachmentSetId: Swift.String?
    /// The time and date when the attachment set expires.
    public var expiryTime: Swift.String?

    public init(
        attachmentSetId: Swift.String? = nil,
        expiryTime: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.expiryTime = expiryTime
    }
}

/// The requested caseId couldn't be located.
public struct CaseIdNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The requested CaseId could not be located.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CaseIdNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AddCommunicationToCaseInput: Swift.Sendable {
    /// The ID of a set of one or more attachments for the communication to add to the case. Create the set by calling [AddAttachmentsToSet]
    public var attachmentSetId: Swift.String?
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?
    /// The email addresses in the CC line of an email to be added to the support case.
    public var ccEmailAddresses: [Swift.String]?
    /// The body of an email communication to add to the support case.
    /// This member is required.
    public var communicationBody: Swift.String?

    public init(
        attachmentSetId: Swift.String? = nil,
        caseId: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.caseId = caseId
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
    }
}

/// The result of the [AddCommunicationToCase] operation.
public struct AddCommunicationToCaseOutput: Swift.Sendable {
    /// True if [AddCommunicationToCase] succeeds. Otherwise, returns an error.
    public var result: Swift.Bool

    public init(
        result: Swift.Bool = false
    )
    {
        self.result = result
    }
}

extension SupportClientTypes {

    /// The file name and ID of an attachment to a case communication. You can use the ID to retrieve the attachment with the [DescribeAttachment] operation.
    public struct AttachmentDetails: Swift.Sendable {
        /// The ID of the attachment.
        public var attachmentId: Swift.String?
        /// The file name of the attachment.
        public var fileName: Swift.String?

        public init(
            attachmentId: Swift.String? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.fileName = fileName
        }
    }
}

/// An attachment with the specified ID could not be found.
public struct AttachmentIdNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An attachment with the specified ID could not be found.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentIdNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The case creation limit for the account has been exceeded.
public struct CaseCreationLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message that indicates that you have exceeded the number of cases you can have open.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CaseCreationLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateCaseInput: Swift.Sendable {
    /// The ID of a set of one or more attachments for the case. Create the set by using the [AddAttachmentsToSet] operation.
    public var attachmentSetId: Swift.String?
    /// The category of problem for the support case. You also use the [DescribeServices] operation to get the category code for a service. Each Amazon Web Services service defines its own set of category codes.
    public var categoryCode: Swift.String?
    /// A list of email addresses that Amazon Web Services Support copies on case correspondence. Amazon Web Services Support identifies the account that creates the case when you specify your Amazon Web Services credentials in an HTTP POST method or use the [Amazon Web Services SDKs](http://aws.amazon.com/tools/).
    public var ccEmailAddresses: [Swift.String]?
    /// The communication body text that describes the issue. This text appears in the Description field on the Amazon Web Services Support Center [Create Case](https://console.aws.amazon.com/support/home#/case/create) page.
    /// This member is required.
    public var communicationBody: Swift.String?
    /// The type of issue for the case. You can specify customer-service or technical. If you don't specify a value, the default is technical.
    public var issueType: Swift.String?
    /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    public var language: Swift.String?
    /// The code for the Amazon Web Services service. You can use the [DescribeServices] operation to get the possible serviceCode values.
    public var serviceCode: Swift.String?
    /// A value that indicates the urgency of the case. This value determines the response time according to your service level agreement with Amazon Web Services Support. You can use the [DescribeSeverityLevels] operation to get the possible values for severityCode. For more information, see [SeverityLevel] and [Choosing a Severity](https://docs.aws.amazon.com/awssupport/latest/user/getting-started.html#choosing-severity) in the Amazon Web Services Support User Guide. The availability of severity levels depends on the support plan for the Amazon Web Services account.
    public var severityCode: Swift.String?
    /// The title of the support case. The title appears in the Subject field on the Amazon Web Services Support Center [Create Case](https://console.aws.amazon.com/support/home#/case/create) page.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        attachmentSetId: Swift.String? = nil,
        categoryCode: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil,
        issueType: Swift.String? = nil,
        language: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        severityCode: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.categoryCode = categoryCode
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
        self.issueType = issueType
        self.language = language
        self.serviceCode = serviceCode
        self.severityCode = severityCode
        self.subject = subject
    }
}

/// The support case ID returned by a successful completion of the [CreateCase] operation.
public struct CreateCaseOutput: Swift.Sendable {
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string in the following format: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

/// The limit for the number of [DescribeAttachment] requests in a short period of time has been exceeded.
public struct DescribeAttachmentLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit for the number of [DescribeAttachment] requests in a short period of time has been exceeded.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DescribeAttachmentLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAttachmentInput: Swift.Sendable {
    /// The ID of the attachment to return. Attachment IDs are returned by the [DescribeCommunications] operation.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

/// The content and file name of the attachment returned by the [DescribeAttachment] operation.
public struct DescribeAttachmentOutput: Swift.Sendable {
    /// This object includes the attachment content and file name. In the previous response syntax, the value for the data parameter appears as blob, which is represented as a base64-encoded string. The value for fileName is the name of the attachment, such as troubleshoot-screenshot.png.
    public var attachment: SupportClientTypes.Attachment?

    public init(
        attachment: SupportClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

public struct DescribeCasesInput: Swift.Sendable {
    /// The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var afterTime: Swift.String?
    /// The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var beforeTime: Swift.String?
    /// A list of ID numbers of the support cases you want returned. The maximum number of cases is 100.
    public var caseIdList: [Swift.String]?
    /// The ID displayed for a case in the Amazon Web Services Support Center user interface.
    public var displayId: Swift.String?
    /// Specifies whether to include communications in the DescribeCases response. By default, communications are included.
    public var includeCommunications: Swift.Bool?
    /// Specifies whether to include resolved support cases in the DescribeCases response. By default, resolved cases aren't included.
    public var includeResolvedCases: Swift.Bool?
    /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    public var language: Swift.String?
    /// The maximum number of results to return before paginating.
    public var maxResults: Swift.Int?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init(
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseIdList: [Swift.String]? = nil,
        displayId: Swift.String? = nil,
        includeCommunications: Swift.Bool? = nil,
        includeResolvedCases: Swift.Bool? = false,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseIdList = caseIdList
        self.displayId = displayId
        self.includeCommunications = includeCommunications
        self.includeResolvedCases = includeResolvedCases
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SupportClientTypes {

    /// A communication associated with a support case. The communication consists of the case ID, the message body, attachment information, the submitter of the communication, and the date and time of the communication.
    public struct Communication: Swift.Sendable {
        /// Information about the attachments to the case communication.
        public var attachmentSet: [SupportClientTypes.AttachmentDetails]?
        /// The text of the communication between the customer and Amazon Web Services Support.
        public var body: Swift.String?
        /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
        public var caseId: Swift.String?
        /// The identity of the account that submitted, or responded to, the support case. Customer entries include the IAM role as well as the email address (for example, "AdminRole (Role) ). Entries from the Amazon Web Services Support team display "Amazon Web Services," and don't show an email address.
        public var submittedBy: Swift.String?
        /// The time the communication was created.
        public var timeCreated: Swift.String?

        public init(
            attachmentSet: [SupportClientTypes.AttachmentDetails]? = nil,
            body: Swift.String? = nil,
            caseId: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.attachmentSet = attachmentSet
            self.body = body
            self.caseId = caseId
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }
}

extension SupportClientTypes {

    /// The five most recent communications associated with the case.
    public struct RecentCaseCommunications: Swift.Sendable {
        /// The five most recent communications associated with the case.
        public var communications: [SupportClientTypes.Communication]?
        /// A resumption point for pagination.
        public var nextToken: Swift.String?

        public init(
            communications: [SupportClientTypes.Communication]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.communications = communications
            self.nextToken = nextToken
        }
    }
}

extension SupportClientTypes {

    /// A JSON-formatted object that contains the metadata for a support case. It is contained in the response from a [DescribeCases] request. CaseDetails contains the following fields:
    ///
    /// * caseId - The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47.
    ///
    /// * categoryCode - The category of problem for the support case. Corresponds to the CategoryCode values returned by a call to [DescribeServices].
    ///
    /// * displayId - The identifier for the case on pages in the Amazon Web Services Support Center.
    ///
    /// * language - The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    ///
    /// * nextToken - A resumption point for pagination.
    ///
    /// * recentCommunications - One or more [Communication] objects. Fields of these objects are attachments, body, caseId, submittedBy, and timeCreated.
    ///
    /// * serviceCode - The identifier for the Amazon Web Services service that corresponds to the service code defined in the call to [DescribeServices].
    ///
    /// * severityCode - The severity code assigned to the case. Contains one of the values returned by the call to [DescribeSeverityLevels]. The possible values are: low, normal, high, urgent, and critical.
    ///
    /// * status - The status of the case in the Amazon Web Services Support Center. Valid values:
    ///
    /// * all-open
    ///
    /// * customer-action-completed
    ///
    /// * opened
    ///
    /// * pending-customer-action
    ///
    /// * reopened
    ///
    /// * resolved
    ///
    /// * unassigned
    ///
    /// * work-in-progress
    ///
    ///
    ///
    ///
    /// * subject - The subject line of the case.
    ///
    /// * submittedBy - The email address of the account that submitted the case.
    ///
    /// * timeCreated - The time the case was created, in ISO-8601 format.
    public struct CaseDetails: Swift.Sendable {
        /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
        public var caseId: Swift.String?
        /// The category of problem for the support case.
        public var categoryCode: Swift.String?
        /// The email addresses that receive copies of communication about the case.
        public var ccEmailAddresses: [Swift.String]?
        /// The ID displayed for the case in the Amazon Web Services Support Center. This is a numeric string.
        public var displayId: Swift.String?
        /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
        public var language: Swift.String?
        /// The five most recent communications between you and Amazon Web Services Support Center, including the IDs of any attachments to the communications. Also includes a nextToken that you can use to retrieve earlier communications.
        public var recentCommunications: SupportClientTypes.RecentCaseCommunications?
        /// The code for the Amazon Web Services service. You can get a list of codes and the corresponding service names by calling [DescribeServices].
        public var serviceCode: Swift.String?
        /// The code for the severity level returned by the call to [DescribeSeverityLevels].
        public var severityCode: Swift.String?
        /// The status of the case. Valid values:
        ///
        /// * all-open
        ///
        /// * customer-action-completed
        ///
        /// * opened
        ///
        /// * pending-customer-action
        ///
        /// * reopened
        ///
        /// * resolved
        ///
        /// * unassigned
        ///
        /// * work-in-progress
        public var status: Swift.String?
        /// The subject line for the case in the Amazon Web Services Support Center.
        public var subject: Swift.String?
        /// The email address of the account that submitted the case.
        public var submittedBy: Swift.String?
        /// The time that the case was created in the Amazon Web Services Support Center.
        public var timeCreated: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            categoryCode: Swift.String? = nil,
            ccEmailAddresses: [Swift.String]? = nil,
            displayId: Swift.String? = nil,
            language: Swift.String? = nil,
            recentCommunications: SupportClientTypes.RecentCaseCommunications? = nil,
            serviceCode: Swift.String? = nil,
            severityCode: Swift.String? = nil,
            status: Swift.String? = nil,
            subject: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.categoryCode = categoryCode
            self.ccEmailAddresses = ccEmailAddresses
            self.displayId = displayId
            self.language = language
            self.recentCommunications = recentCommunications
            self.serviceCode = serviceCode
            self.severityCode = severityCode
            self.status = status
            self.subject = subject
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }
}

/// Returns an array of [CaseDetails](https://docs.aws.amazon.com/awssupport/latest/APIReference/API_CaseDetails.html) objects and a nextToken that defines a point for pagination in the result set.
public struct DescribeCasesOutput: Swift.Sendable {
    /// The details for the cases that match the request.
    public var cases: [SupportClientTypes.CaseDetails]?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init(
        cases: [SupportClientTypes.CaseDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

public struct DescribeCommunicationsInput: Swift.Sendable {
    /// The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var afterTime: Swift.String?
    /// The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var beforeTime: Swift.String?
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    /// This member is required.
    public var caseId: Swift.String?
    /// The maximum number of results to return before paginating.
    public var maxResults: Swift.Int?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init(
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The communications returned by the [DescribeCommunications] operation.
public struct DescribeCommunicationsOutput: Swift.Sendable {
    /// The communications for the case.
    public var communications: [SupportClientTypes.Communication]?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init(
        communications: [SupportClientTypes.Communication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.communications = communications
        self.nextToken = nextToken
    }
}

/// You have exceeded the maximum allowed TPS (Transactions Per Second) for the operations.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Throttling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeCreateCaseOptionsInput: Swift.Sendable {
    /// The category of problem for the support case. You also use the [DescribeServices] operation to get the category code for a service. Each Amazon Web Services service defines its own set of category codes.
    /// This member is required.
    public var categoryCode: Swift.String?
    /// The type of issue for the case. You can specify customer-service or technical. If you don't specify a value, the default is technical.
    /// This member is required.
    public var issueType: Swift.String?
    /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    /// This member is required.
    public var language: Swift.String?
    /// The code for the Amazon Web Services service. You can use the [DescribeServices] operation to get the possible serviceCode values.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        categoryCode: Swift.String? = nil,
        issueType: Swift.String? = nil,
        language: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.categoryCode = categoryCode
        self.issueType = issueType
        self.language = language
        self.serviceCode = serviceCode
    }
}

extension SupportClientTypes {

    /// Date and time (UTC) format in RFC 3339 : 'yyyy-MM-dd'T'HH:mm:ss.SSSZZ'.
    public struct DateInterval: Swift.Sendable {
        /// End Date Time (UTC). RFC 3339 format : 'yyyy-MM-dd'T'HH:mm:ss.SSSZZ'.
        public var endDateTime: Swift.String?
        /// A JSON object containing start and date time (UTC). Date and time format is RFC 3339 : 'yyyy-MM-dd'T'HH:mm:ss.SSSZZ'.
        public var startDateTime: Swift.String?

        public init(
            endDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil
        )
        {
            self.endDateTime = endDateTime
            self.startDateTime = startDateTime
        }
    }
}

extension SupportClientTypes {

    /// Time range object with startTime and endTime range in RFC 3339 format. 'HH:mm:ss.SSS'.
    public struct SupportedHour: Swift.Sendable {
        /// End Time. RFC 3339 format 'HH:mm:ss.SSS'.
        public var endTime: Swift.String?
        /// Start Time. RFC 3339 format 'HH:mm:ss.SSS'.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension SupportClientTypes {

    /// A JSON-formatted object that contains the CommunicationTypeOptions for creating a case for a certain communication channel. It is contained in the response from a [DescribeCreateCaseOptions] request. CommunicationTypeOptions contains the following fields:
    ///
    /// * datesWithoutSupport - A JSON-formatted list containing date and time ranges for periods without support in UTC time. Date and time format is RFC 3339 : 'yyyy-MM-dd'T'HH:mm:ss.SSSZZ'.
    ///
    /// * supportedHours - A JSON-formatted list containing time ranges when support are available. Time format is RFC 3339 : 'HH:mm:ss.SSS'.
    ///
    /// * type - A string value indicating the communication type that the aforementioned rules apply to. At the moment the type value can assume one of 3 values at the moment chat, web and call.
    public struct CommunicationTypeOptions: Swift.Sendable {
        /// A JSON-formatted list containing date and time ranges for periods without support
        public var datesWithoutSupport: [SupportClientTypes.DateInterval]?
        /// A JSON-formatted list containing time ranges when support is available.
        public var supportedHours: [SupportClientTypes.SupportedHour]?
        /// A string value indicating the communication type. At the moment the type value can assume one of 3 values at the moment chat, web and call.
        public var type: Swift.String?

        public init(
            datesWithoutSupport: [SupportClientTypes.DateInterval]? = nil,
            supportedHours: [SupportClientTypes.SupportedHour]? = nil,
            type: Swift.String? = nil
        )
        {
            self.datesWithoutSupport = datesWithoutSupport
            self.supportedHours = supportedHours
            self.type = type
        }
    }
}

public struct DescribeCreateCaseOptionsOutput: Swift.Sendable {
    /// A JSON-formatted array that contains the available communication type options, along with the available support timeframes for the given inputs.
    public var communicationTypes: [SupportClientTypes.CommunicationTypeOptions]?
    /// Language availability can be any of the following:
    ///
    /// * available
    ///
    /// * best_effort
    ///
    /// * unavailable
    public var languageAvailability: Swift.String?

    public init(
        communicationTypes: [SupportClientTypes.CommunicationTypeOptions]? = nil,
        languageAvailability: Swift.String? = nil
    )
    {
        self.communicationTypes = communicationTypes
        self.languageAvailability = languageAvailability
    }
}

public struct DescribeServicesInput: Swift.Sendable {
    /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    public var language: Swift.String?
    /// A JSON-formatted list of service codes available for Amazon Web Services services.
    public var serviceCodeList: [Swift.String]?

    public init(
        language: Swift.String? = nil,
        serviceCodeList: [Swift.String]? = nil
    )
    {
        self.language = language
        self.serviceCodeList = serviceCodeList
    }
}

extension SupportClientTypes {

    /// A JSON-formatted name/value pair that represents the category name and category code of the problem, selected from the [DescribeServices] response for each Amazon Web Services service.
    public struct Category: Swift.Sendable {
        /// The category code for the support case.
        public var code: Swift.String?
        /// The category name for the support case.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension SupportClientTypes {

    /// Information about an Amazon Web Services service returned by the [DescribeServices] operation.
    public struct Service: Swift.Sendable {
        /// A list of categories that describe the type of support issue a case describes. Categories consist of a category name and a category code. Category names and codes are passed to Amazon Web Services Support when you call [CreateCase].
        public var categories: [SupportClientTypes.Category]?
        /// The code for an Amazon Web Services service returned by the [DescribeServices] response. The name element contains the corresponding friendly name.
        public var code: Swift.String?
        /// The friendly name for an Amazon Web Services service. The code element contains the corresponding code.
        public var name: Swift.String?

        public init(
            categories: [SupportClientTypes.Category]? = nil,
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.categories = categories
            self.code = code
            self.name = name
        }
    }
}

/// The list of Amazon Web Services services returned by the [DescribeServices] operation.
public struct DescribeServicesOutput: Swift.Sendable {
    /// A JSON-formatted list of Amazon Web Services services.
    public var services: [SupportClientTypes.Service]?

    public init(
        services: [SupportClientTypes.Service]? = nil
    )
    {
        self.services = services
    }
}

public struct DescribeSeverityLevelsInput: Swift.Sendable {
    /// The language in which Amazon Web Services Support handles the case. Amazon Web Services Support currently supports Chinese (“zh”), English ("en"), Japanese ("ja") and Korean (“ko”). You must specify the ISO 639-1 code for the language parameter if you want support in that language.
    public var language: Swift.String?

    public init(
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

extension SupportClientTypes {

    /// A code and name pair that represents the severity level of a support case. The available values depend on the support plan for the account. For more information, see [Choosing a severity](https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity) in the Amazon Web Services Support User Guide.
    public struct SeverityLevel: Swift.Sendable {
        /// The code for case severity level. Valid values: low | normal | high | urgent | critical
        public var code: Swift.String?
        /// The name of the severity level that corresponds to the severity level code. The values returned by the API are different from the values that appear in the Amazon Web Services Support Center. For example, the API uses the code low, but the name appears as General guidance in Support Center. The following are the API code names and how they appear in the console:
        ///
        /// * low - General guidance
        ///
        /// * normal - System impaired
        ///
        /// * high - Production system impaired
        ///
        /// * urgent - Production system down
        ///
        /// * critical - Business-critical system down
        ///
        ///
        /// For more information, see [Choosing a severity](https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity) in the Amazon Web Services Support User Guide.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

/// The list of severity levels returned by the [DescribeSeverityLevels] operation.
public struct DescribeSeverityLevelsOutput: Swift.Sendable {
    /// The available severity levels for the support case. Available severity levels are defined by your service level agreement with Amazon Web Services.
    public var severityLevels: [SupportClientTypes.SeverityLevel]?

    public init(
        severityLevels: [SupportClientTypes.SeverityLevel]? = nil
    )
    {
        self.severityLevels = severityLevels
    }
}

public struct DescribeSupportedLanguagesInput: Swift.Sendable {
    /// The category of problem for the support case. You also use the [DescribeServices] operation to get the category code for a service. Each Amazon Web Services service defines its own set of category codes.
    /// This member is required.
    public var categoryCode: Swift.String?
    /// The type of issue for the case. You can specify customer-service or technical.
    /// This member is required.
    public var issueType: Swift.String?
    /// The code for the Amazon Web Services service. You can use the [DescribeServices] operation to get the possible serviceCode values.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        categoryCode: Swift.String? = nil,
        issueType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.categoryCode = categoryCode
        self.issueType = issueType
        self.serviceCode = serviceCode
    }
}

extension SupportClientTypes {

    /// A JSON-formatted object that contains the available ISO 639-1 language code, language name and langauge display value. The language code is what should be used in the [CreateCase] call.
    public struct SupportedLanguage: Swift.Sendable {
        /// 2 digit ISO 639-1 code. e.g. en
        public var code: Swift.String?
        /// Language display value e.g. ENGLISH
        public var display: Swift.String?
        /// Full language description e.g. ENGLISH
        public var language: Swift.String?

        public init(
            code: Swift.String? = nil,
            display: Swift.String? = nil,
            language: Swift.String? = nil
        )
        {
            self.code = code
            self.display = display
            self.language = language
        }
    }
}

public struct DescribeSupportedLanguagesOutput: Swift.Sendable {
    /// A JSON-formatted array that contains the available ISO 639-1 language codes.
    public var supportedLanguages: [SupportClientTypes.SupportedLanguage]?

    public init(
        supportedLanguages: [SupportClientTypes.SupportedLanguage]? = nil
    )
    {
        self.supportedLanguages = supportedLanguages
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.Sendable {
    /// The IDs of the Trusted Advisor checks to get the status. If you specify the check ID of a check that is automatically refreshed, you might see an InvalidParameterValue error.
    /// This member is required.
    public var checkIds: [Swift.String?]?

    public init(
        checkIds: [Swift.String?]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

extension SupportClientTypes {

    /// The refresh status of a Trusted Advisor check.
    public struct TrustedAdvisorCheckRefreshStatus: Swift.Sendable {
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// The amount of time, in milliseconds, until the Trusted Advisor check is eligible for refresh.
        /// This member is required.
        public var millisUntilNextRefreshable: Swift.Int
        /// The status of the Trusted Advisor check for which a refresh has been requested:
        ///
        /// * none - The check is not refreshed or the non-success status exceeds the timeout
        ///
        /// * enqueued - The check refresh requests has entered the refresh queue
        ///
        /// * processing - The check refresh request is picked up by the rule processing engine
        ///
        /// * success - The check is successfully refreshed
        ///
        /// * abandoned - The check refresh has failed
        /// This member is required.
        public var status: Swift.String?

        public init(
            checkId: Swift.String? = nil,
            millisUntilNextRefreshable: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.checkId = checkId
            self.millisUntilNextRefreshable = millisUntilNextRefreshable
            self.status = status
        }
    }
}

/// The statuses of the Trusted Advisor checks returned by the [DescribeTrustedAdvisorCheckRefreshStatuses] operation.
public struct DescribeTrustedAdvisorCheckRefreshStatusesOutput: Swift.Sendable {
    /// The refresh status of the specified Trusted Advisor checks.
    /// This member is required.
    public var statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]?

    public init(
        statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]? = nil
    )
    {
        self.statuses = statuses
    }
}

///
public struct DescribeTrustedAdvisorCheckResultInput: Swift.Sendable {
    /// The unique identifier for the Trusted Advisor check.
    /// This member is required.
    public var checkId: Swift.String?
    /// The ISO 639-1 code for the language that you want your check results to appear in. The Amazon Web Services Support API currently supports the following languages for Trusted Advisor:
    ///
    /// * Chinese, Simplified - zh
    ///
    /// * Chinese, Traditional - zh_TW
    ///
    /// * English - en
    ///
    /// * French - fr
    ///
    /// * German - de
    ///
    /// * Indonesian - id
    ///
    /// * Italian - it
    ///
    /// * Japanese - ja
    ///
    /// * Korean - ko
    ///
    /// * Portuguese, Brazilian - pt_BR
    ///
    /// * Spanish - es
    public var language: Swift.String?

    public init(
        checkId: Swift.String? = nil,
        language: Swift.String? = nil
    )
    {
        self.checkId = checkId
        self.language = language
    }
}

extension SupportClientTypes {

    /// The estimated cost savings that might be realized if the recommended operations are taken.
    public struct TrustedAdvisorCostOptimizingSummary: Swift.Sendable {
        /// The estimated monthly savings that might be realized if the recommended operations are taken.
        /// This member is required.
        public var estimatedMonthlySavings: Swift.Double
        /// The estimated percentage of savings that might be realized if the recommended operations are taken.
        /// This member is required.
        public var estimatedPercentMonthlySavings: Swift.Double

        public init(
            estimatedMonthlySavings: Swift.Double = 0.0,
            estimatedPercentMonthlySavings: Swift.Double = 0.0
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
        }
    }
}

extension SupportClientTypes {

    /// The container for summary information that relates to the category of the Trusted Advisor check.
    public struct TrustedAdvisorCategorySpecificSummary: Swift.Sendable {
        /// The summary information about cost savings for a Trusted Advisor check that is in the Cost Optimizing category.
        public var costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary?

        public init(
            costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary? = nil
        )
        {
            self.costOptimizing = costOptimizing
        }
    }
}

extension SupportClientTypes {

    /// Contains information about a resource identified by a Trusted Advisor check.
    public struct TrustedAdvisorResourceDetail: Swift.Sendable {
        /// Specifies whether the Amazon Web Services resource was ignored by Trusted Advisor because it was marked as suppressed by the user.
        public var isSuppressed: Swift.Bool
        /// Additional information about the identified resource. The exact metadata and its order can be obtained by inspecting the [TrustedAdvisorCheckDescription] object returned by the call to [DescribeTrustedAdvisorChecks]. Metadata contains all the data that is shown in the Excel download, even in those cases where the UI shows just summary data.
        /// This member is required.
        public var metadata: [Swift.String?]?
        /// The Amazon Web Services Region in which the identified resource is located.
        public var region: Swift.String?
        /// The unique identifier for the identified resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The status code for the resource identified in the Trusted Advisor check.
        /// This member is required.
        public var status: Swift.String?

        public init(
            isSuppressed: Swift.Bool = false,
            metadata: [Swift.String?]? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.isSuppressed = isSuppressed
            self.metadata = metadata
            self.region = region
            self.resourceId = resourceId
            self.status = status
        }
    }
}

extension SupportClientTypes {

    /// Details about Amazon Web Services resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
    public struct TrustedAdvisorResourcesSummary: Swift.Sendable {
        /// The number of Amazon Web Services resources that were flagged (listed) by the Trusted Advisor check.
        /// This member is required.
        public var resourcesFlagged: Swift.Int
        /// The number of Amazon Web Services resources ignored by Trusted Advisor because information was unavailable.
        /// This member is required.
        public var resourcesIgnored: Swift.Int
        /// The number of Amazon Web Services resources that were analyzed by the Trusted Advisor check.
        /// This member is required.
        public var resourcesProcessed: Swift.Int
        /// The number of Amazon Web Services resources ignored by Trusted Advisor because they were marked as suppressed by the user.
        /// This member is required.
        public var resourcesSuppressed: Swift.Int

        public init(
            resourcesFlagged: Swift.Int = 0,
            resourcesIgnored: Swift.Int = 0,
            resourcesProcessed: Swift.Int = 0,
            resourcesSuppressed: Swift.Int = 0
        )
        {
            self.resourcesFlagged = resourcesFlagged
            self.resourcesIgnored = resourcesIgnored
            self.resourcesProcessed = resourcesProcessed
            self.resourcesSuppressed = resourcesSuppressed
        }
    }
}

extension SupportClientTypes {

    /// The results of a Trusted Advisor check returned by [DescribeTrustedAdvisorCheckResult].
    public struct TrustedAdvisorCheckResult: Swift.Sendable {
        /// Summary information that relates to the category of the check. Cost Optimizing is the only category that is currently supported.
        /// This member is required.
        public var categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// The details about each resource listed in the check result.
        /// This member is required.
        public var flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]?
        /// Details about Amazon Web Services resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
        /// This member is required.
        public var resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or "not_available".
        /// This member is required.
        public var status: Swift.String?
        /// The time of the last refresh of the check.
        /// This member is required.
        public var timestamp: Swift.String?

        public init(
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]? = nil,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.flaggedResources = flaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }
}

/// The result of the Trusted Advisor check returned by the [DescribeTrustedAdvisorCheckResult] operation.
public struct DescribeTrustedAdvisorCheckResultOutput: Swift.Sendable {
    /// The detailed results of the Trusted Advisor check.
    public var result: SupportClientTypes.TrustedAdvisorCheckResult?

    public init(
        result: SupportClientTypes.TrustedAdvisorCheckResult? = nil
    )
    {
        self.result = result
    }
}

public struct DescribeTrustedAdvisorChecksInput: Swift.Sendable {
    /// The ISO 639-1 code for the language that you want your checks to appear in. The Amazon Web Services Support API currently supports the following languages for Trusted Advisor:
    ///
    /// * Chinese, Simplified - zh
    ///
    /// * Chinese, Traditional - zh_TW
    ///
    /// * English - en
    ///
    /// * French - fr
    ///
    /// * German - de
    ///
    /// * Indonesian - id
    ///
    /// * Italian - it
    ///
    /// * Japanese - ja
    ///
    /// * Korean - ko
    ///
    /// * Portuguese, Brazilian - pt_BR
    ///
    /// * Spanish - es
    /// This member is required.
    public var language: Swift.String?

    public init(
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

extension SupportClientTypes {

    /// The description and metadata for a Trusted Advisor check.
    public struct TrustedAdvisorCheckDescription: Swift.Sendable {
        /// The category of the Trusted Advisor check.
        /// This member is required.
        public var category: Swift.String?
        /// The description of the Trusted Advisor check, which includes the alert criteria and recommended operations (contains HTML markup).
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var id: Swift.String?
        /// The column headings for the data returned by the Trusted Advisor check. The order of the headings corresponds to the order of the data in the Metadata element of the [TrustedAdvisorResourceDetail] for the check. Metadata contains all the data that is shown in the Excel download, even in those cases where the UI shows just summary data.
        /// This member is required.
        public var metadata: [Swift.String?]?
        /// The display name for the Trusted Advisor check.
        /// This member is required.
        public var name: Swift.String?

        public init(
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String?]? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.id = id
            self.metadata = metadata
            self.name = name
        }
    }
}

/// Information about the Trusted Advisor checks returned by the [DescribeTrustedAdvisorChecks] operation.
public struct DescribeTrustedAdvisorChecksOutput: Swift.Sendable {
    /// Information about all available Trusted Advisor checks.
    /// This member is required.
    public var checks: [SupportClientTypes.TrustedAdvisorCheckDescription]?

    public init(
        checks: [SupportClientTypes.TrustedAdvisorCheckDescription]? = nil
    )
    {
        self.checks = checks
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInput: Swift.Sendable {
    /// The IDs of the Trusted Advisor checks.
    /// This member is required.
    public var checkIds: [Swift.String?]?

    public init(
        checkIds: [Swift.String?]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

extension SupportClientTypes {

    /// A summary of a Trusted Advisor check result, including the alert status, last refresh, and number of resources examined.
    public struct TrustedAdvisorCheckSummary: Swift.Sendable {
        /// Summary information that relates to the category of the check. Cost Optimizing is the only category that is currently supported.
        /// This member is required.
        public var categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// Specifies whether the Trusted Advisor check has flagged resources.
        public var hasFlaggedResources: Swift.Bool
        /// Details about Amazon Web Services resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
        /// This member is required.
        public var resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or "not_available".
        /// This member is required.
        public var status: Swift.String?
        /// The time of the last refresh of the check.
        /// This member is required.
        public var timestamp: Swift.String?

        public init(
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            hasFlaggedResources: Swift.Bool = false,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.hasFlaggedResources = hasFlaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }
}

/// The summaries of the Trusted Advisor checks returned by the [DescribeTrustedAdvisorCheckSummaries] operation.
public struct DescribeTrustedAdvisorCheckSummariesOutput: Swift.Sendable {
    /// The summary information for the requested Trusted Advisor checks.
    /// This member is required.
    public var summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]?

    public init(
        summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]? = nil
    )
    {
        self.summaries = summaries
    }
}

///
public struct RefreshTrustedAdvisorCheckInput: Swift.Sendable {
    /// The unique identifier for the Trusted Advisor check to refresh. Specifying the check ID of a check that is automatically refreshed causes an InvalidParameterValue error.
    /// This member is required.
    public var checkId: Swift.String?

    public init(
        checkId: Swift.String? = nil
    )
    {
        self.checkId = checkId
    }
}

/// The current refresh status of a Trusted Advisor check.
public struct RefreshTrustedAdvisorCheckOutput: Swift.Sendable {
    /// The current refresh status for a check, including the amount of time until the check is eligible for refresh.
    /// This member is required.
    public var status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus?

    public init(
        status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus? = nil
    )
    {
        self.status = status
    }
}

public struct ResolveCaseInput: Swift.Sendable {
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

/// The status of the case returned by the [ResolveCase] operation.
public struct ResolveCaseOutput: Swift.Sendable {
    /// The status of the case after the [ResolveCase] request was processed.
    public var finalCaseStatus: Swift.String?
    /// The status of the case when the [ResolveCase] request was sent.
    public var initialCaseStatus: Swift.String?

    public init(
        finalCaseStatus: Swift.String? = nil,
        initialCaseStatus: Swift.String? = nil
    )
    {
        self.finalCaseStatus = finalCaseStatus
        self.initialCaseStatus = initialCaseStatus
    }
}

extension AddAttachmentsToSetInput {

    static func urlPathProvider(_ value: AddAttachmentsToSetInput) -> Swift.String? {
        return "/"
    }
}

extension AddCommunicationToCaseInput {

    static func urlPathProvider(_ value: AddCommunicationToCaseInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCaseInput {

    static func urlPathProvider(_ value: CreateCaseInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAttachmentInput {

    static func urlPathProvider(_ value: DescribeAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCasesInput {

    static func urlPathProvider(_ value: DescribeCasesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCommunicationsInput {

    static func urlPathProvider(_ value: DescribeCommunicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCreateCaseOptionsInput {

    static func urlPathProvider(_ value: DescribeCreateCaseOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServicesInput {

    static func urlPathProvider(_ value: DescribeServicesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSeverityLevelsInput {

    static func urlPathProvider(_ value: DescribeSeverityLevelsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSupportedLanguagesInput {

    static func urlPathProvider(_ value: DescribeSupportedLanguagesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput {

    static func urlPathProvider(_ value: DescribeTrustedAdvisorCheckRefreshStatusesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrustedAdvisorCheckResultInput {

    static func urlPathProvider(_ value: DescribeTrustedAdvisorCheckResultInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrustedAdvisorChecksInput {

    static func urlPathProvider(_ value: DescribeTrustedAdvisorChecksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrustedAdvisorCheckSummariesInput {

    static func urlPathProvider(_ value: DescribeTrustedAdvisorCheckSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension RefreshTrustedAdvisorCheckInput {

    static func urlPathProvider(_ value: RefreshTrustedAdvisorCheckInput) -> Swift.String? {
        return "/"
    }
}

extension ResolveCaseInput {

    static func urlPathProvider(_ value: ResolveCaseInput) -> Swift.String? {
        return "/"
    }
}

extension AddAttachmentsToSetInput {

    static func write(value: AddAttachmentsToSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentSetId"].write(value.attachmentSetId)
        try writer["attachments"].writeList(value.attachments, memberWritingClosure: SupportClientTypes.Attachment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddCommunicationToCaseInput {

    static func write(value: AddCommunicationToCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentSetId"].write(value.attachmentSetId)
        try writer["caseId"].write(value.caseId)
        try writer["ccEmailAddresses"].writeList(value.ccEmailAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["communicationBody"].write(value.communicationBody)
    }
}

extension CreateCaseInput {

    static func write(value: CreateCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentSetId"].write(value.attachmentSetId)
        try writer["categoryCode"].write(value.categoryCode)
        try writer["ccEmailAddresses"].writeList(value.ccEmailAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["communicationBody"].write(value.communicationBody)
        try writer["issueType"].write(value.issueType)
        try writer["language"].write(value.language)
        try writer["serviceCode"].write(value.serviceCode)
        try writer["severityCode"].write(value.severityCode)
        try writer["subject"].write(value.subject)
    }
}

extension DescribeAttachmentInput {

    static func write(value: DescribeAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentId"].write(value.attachmentId)
    }
}

extension DescribeCasesInput {

    static func write(value: DescribeCasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterTime"].write(value.afterTime)
        try writer["beforeTime"].write(value.beforeTime)
        try writer["caseIdList"].writeList(value.caseIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["displayId"].write(value.displayId)
        try writer["includeCommunications"].write(value.includeCommunications)
        try writer["includeResolvedCases"].write(value.includeResolvedCases)
        try writer["language"].write(value.language)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeCommunicationsInput {

    static func write(value: DescribeCommunicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterTime"].write(value.afterTime)
        try writer["beforeTime"].write(value.beforeTime)
        try writer["caseId"].write(value.caseId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeCreateCaseOptionsInput {

    static func write(value: DescribeCreateCaseOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categoryCode"].write(value.categoryCode)
        try writer["issueType"].write(value.issueType)
        try writer["language"].write(value.language)
        try writer["serviceCode"].write(value.serviceCode)
    }
}

extension DescribeServicesInput {

    static func write(value: DescribeServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["language"].write(value.language)
        try writer["serviceCodeList"].writeList(value.serviceCodeList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSeverityLevelsInput {

    static func write(value: DescribeSeverityLevelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["language"].write(value.language)
    }
}

extension DescribeSupportedLanguagesInput {

    static func write(value: DescribeSupportedLanguagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categoryCode"].write(value.categoryCode)
        try writer["issueType"].write(value.issueType)
        try writer["serviceCode"].write(value.serviceCode)
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput {

    static func write(value: DescribeTrustedAdvisorCheckRefreshStatusesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkIds"].writeList(value.checkIds, memberWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeTrustedAdvisorCheckResultInput {

    static func write(value: DescribeTrustedAdvisorCheckResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkId"].write(value.checkId)
        try writer["language"].write(value.language)
    }
}

extension DescribeTrustedAdvisorChecksInput {

    static func write(value: DescribeTrustedAdvisorChecksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["language"].write(value.language)
    }
}

extension DescribeTrustedAdvisorCheckSummariesInput {

    static func write(value: DescribeTrustedAdvisorCheckSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkIds"].writeList(value.checkIds, memberWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RefreshTrustedAdvisorCheckInput {

    static func write(value: RefreshTrustedAdvisorCheckInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkId"].write(value.checkId)
    }
}

extension ResolveCaseInput {

    static func write(value: ResolveCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseId"].write(value.caseId)
    }
}

extension AddAttachmentsToSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddAttachmentsToSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddAttachmentsToSetOutput()
        value.attachmentSetId = try reader["attachmentSetId"].readIfPresent()
        value.expiryTime = try reader["expiryTime"].readIfPresent()
        return value
    }
}

extension AddCommunicationToCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddCommunicationToCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddCommunicationToCaseOutput()
        value.result = try reader["result"].readIfPresent() ?? false
        return value
    }
}

extension CreateCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCaseOutput()
        value.caseId = try reader["caseId"].readIfPresent()
        return value
    }
}

extension DescribeAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAttachmentOutput()
        value.attachment = try reader["attachment"].readIfPresent(with: SupportClientTypes.Attachment.read(from:))
        return value
    }
}

extension DescribeCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCasesOutput()
        value.cases = try reader["cases"].readListIfPresent(memberReadingClosure: SupportClientTypes.CaseDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeCommunicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCommunicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCommunicationsOutput()
        value.communications = try reader["communications"].readListIfPresent(memberReadingClosure: SupportClientTypes.Communication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeCreateCaseOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCreateCaseOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCreateCaseOptionsOutput()
        value.communicationTypes = try reader["communicationTypes"].readListIfPresent(memberReadingClosure: SupportClientTypes.CommunicationTypeOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.languageAvailability = try reader["languageAvailability"].readIfPresent()
        return value
    }
}

extension DescribeServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServicesOutput()
        value.services = try reader["services"].readListIfPresent(memberReadingClosure: SupportClientTypes.Service.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSeverityLevelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSeverityLevelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSeverityLevelsOutput()
        value.severityLevels = try reader["severityLevels"].readListIfPresent(memberReadingClosure: SupportClientTypes.SeverityLevel.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSupportedLanguagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSupportedLanguagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSupportedLanguagesOutput()
        value.supportedLanguages = try reader["supportedLanguages"].readListIfPresent(memberReadingClosure: SupportClientTypes.SupportedLanguage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrustedAdvisorCheckRefreshStatusesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrustedAdvisorCheckRefreshStatusesOutput()
        value.statuses = try reader["statuses"].readListIfPresent(memberReadingClosure: SupportClientTypes.TrustedAdvisorCheckRefreshStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeTrustedAdvisorCheckResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrustedAdvisorCheckResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrustedAdvisorCheckResultOutput()
        value.result = try reader["result"].readIfPresent(with: SupportClientTypes.TrustedAdvisorCheckResult.read(from:))
        return value
    }
}

extension DescribeTrustedAdvisorChecksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrustedAdvisorChecksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrustedAdvisorChecksOutput()
        value.checks = try reader["checks"].readListIfPresent(memberReadingClosure: SupportClientTypes.TrustedAdvisorCheckDescription.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrustedAdvisorCheckSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrustedAdvisorCheckSummariesOutput()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: SupportClientTypes.TrustedAdvisorCheckSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RefreshTrustedAdvisorCheckOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RefreshTrustedAdvisorCheckOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RefreshTrustedAdvisorCheckOutput()
        value.status = try reader["status"].readIfPresent(with: SupportClientTypes.TrustedAdvisorCheckRefreshStatus.read(from:))
        return value
    }
}

extension ResolveCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResolveCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResolveCaseOutput()
        value.finalCaseStatus = try reader["finalCaseStatus"].readIfPresent()
        value.initialCaseStatus = try reader["initialCaseStatus"].readIfPresent()
        return value
    }
}

enum AddAttachmentsToSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AttachmentLimitExceeded": return try AttachmentLimitExceeded.makeError(baseError: baseError)
            case "AttachmentSetExpired": return try AttachmentSetExpired.makeError(baseError: baseError)
            case "AttachmentSetIdNotFound": return try AttachmentSetIdNotFound.makeError(baseError: baseError)
            case "AttachmentSetSizeLimitExceeded": return try AttachmentSetSizeLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddCommunicationToCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AttachmentSetExpired": return try AttachmentSetExpired.makeError(baseError: baseError)
            case "AttachmentSetIdNotFound": return try AttachmentSetIdNotFound.makeError(baseError: baseError)
            case "CaseIdNotFound": return try CaseIdNotFound.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AttachmentSetExpired": return try AttachmentSetExpired.makeError(baseError: baseError)
            case "AttachmentSetIdNotFound": return try AttachmentSetIdNotFound.makeError(baseError: baseError)
            case "CaseCreationLimitExceeded": return try CaseCreationLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AttachmentIdNotFound": return try AttachmentIdNotFound.makeError(baseError: baseError)
            case "DescribeAttachmentLimitExceeded": return try DescribeAttachmentLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CaseIdNotFound": return try CaseIdNotFound.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCommunicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CaseIdNotFound": return try CaseIdNotFound.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCreateCaseOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSeverityLevelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSupportedLanguagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrustedAdvisorCheckRefreshStatusesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrustedAdvisorCheckResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrustedAdvisorChecksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrustedAdvisorCheckSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "Throttling": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RefreshTrustedAdvisorCheckOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResolveCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CaseIdNotFound": return try CaseIdNotFound.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AttachmentSetIdNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentSetIdNotFound {
        let reader = baseError.errorBodyReader
        var value = AttachmentSetIdNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = AttachmentLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentSetExpired {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentSetExpired {
        let reader = baseError.errorBodyReader
        var value = AttachmentSetExpired()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentSetSizeLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentSetSizeLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = AttachmentSetSizeLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CaseIdNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CaseIdNotFound {
        let reader = baseError.errorBodyReader
        var value = CaseIdNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CaseCreationLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CaseCreationLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = CaseCreationLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentIdNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentIdNotFound {
        let reader = baseError.errorBodyReader
        var value = AttachmentIdNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DescribeAttachmentLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DescribeAttachmentLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = DescribeAttachmentLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SupportClientTypes.Attachment {

    static func write(value: SupportClientTypes.Attachment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["fileName"].write(value.fileName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.Attachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.Attachment()
        value.fileName = try reader["fileName"].readIfPresent()
        value.data = try reader["data"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.CaseDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.CaseDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.CaseDetails()
        value.caseId = try reader["caseId"].readIfPresent()
        value.displayId = try reader["displayId"].readIfPresent()
        value.subject = try reader["subject"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.serviceCode = try reader["serviceCode"].readIfPresent()
        value.categoryCode = try reader["categoryCode"].readIfPresent()
        value.severityCode = try reader["severityCode"].readIfPresent()
        value.submittedBy = try reader["submittedBy"].readIfPresent()
        value.timeCreated = try reader["timeCreated"].readIfPresent()
        value.recentCommunications = try reader["recentCommunications"].readIfPresent(with: SupportClientTypes.RecentCaseCommunications.read(from:))
        value.ccEmailAddresses = try reader["ccEmailAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.language = try reader["language"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.RecentCaseCommunications {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.RecentCaseCommunications {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.RecentCaseCommunications()
        value.communications = try reader["communications"].readListIfPresent(memberReadingClosure: SupportClientTypes.Communication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.Communication {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.Communication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.Communication()
        value.caseId = try reader["caseId"].readIfPresent()
        value.body = try reader["body"].readIfPresent()
        value.submittedBy = try reader["submittedBy"].readIfPresent()
        value.timeCreated = try reader["timeCreated"].readIfPresent()
        value.attachmentSet = try reader["attachmentSet"].readListIfPresent(memberReadingClosure: SupportClientTypes.AttachmentDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SupportClientTypes.AttachmentDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.AttachmentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.AttachmentDetails()
        value.attachmentId = try reader["attachmentId"].readIfPresent()
        value.fileName = try reader["fileName"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.CommunicationTypeOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.CommunicationTypeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.CommunicationTypeOptions()
        value.type = try reader["type"].readIfPresent()
        value.supportedHours = try reader["supportedHours"].readListIfPresent(memberReadingClosure: SupportClientTypes.SupportedHour.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.datesWithoutSupport = try reader["datesWithoutSupport"].readListIfPresent(memberReadingClosure: SupportClientTypes.DateInterval.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SupportClientTypes.DateInterval {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.DateInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.DateInterval()
        value.startDateTime = try reader["startDateTime"].readIfPresent()
        value.endDateTime = try reader["endDateTime"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.SupportedHour {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.SupportedHour {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.SupportedHour()
        value.startTime = try reader["startTime"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.Service()
        value.code = try reader["code"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: SupportClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SupportClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.Category()
        value.code = try reader["code"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.SeverityLevel {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.SeverityLevel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.SeverityLevel()
        value.code = try reader["code"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.SupportedLanguage {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.SupportedLanguage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.SupportedLanguage()
        value.code = try reader["code"].readIfPresent()
        value.language = try reader["language"].readIfPresent()
        value.display = try reader["display"].readIfPresent()
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCheckRefreshStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCheckRefreshStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCheckRefreshStatus()
        value.checkId = try reader["checkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? ""
        value.millisUntilNextRefreshable = try reader["millisUntilNextRefreshable"].readIfPresent() ?? 0
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCheckResult {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCheckResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCheckResult()
        value.checkId = try reader["checkId"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? ""
        value.resourcesSummary = try reader["resourcesSummary"].readIfPresent(with: SupportClientTypes.TrustedAdvisorResourcesSummary.read(from:))
        value.categorySpecificSummary = try reader["categorySpecificSummary"].readIfPresent(with: SupportClientTypes.TrustedAdvisorCategorySpecificSummary.read(from:))
        value.flaggedResources = try reader["flaggedResources"].readListIfPresent(memberReadingClosure: SupportClientTypes.TrustedAdvisorResourceDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorResourceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorResourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorResourceDetail()
        value.status = try reader["status"].readIfPresent() ?? ""
        value.region = try reader["region"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.isSuppressed = try reader["isSuppressed"].readIfPresent() ?? false
        value.metadata = try reader["metadata"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCategorySpecificSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCategorySpecificSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCategorySpecificSummary()
        value.costOptimizing = try reader["costOptimizing"].readIfPresent(with: SupportClientTypes.TrustedAdvisorCostOptimizingSummary.read(from:))
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCostOptimizingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCostOptimizingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCostOptimizingSummary()
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent() ?? 0
        value.estimatedPercentMonthlySavings = try reader["estimatedPercentMonthlySavings"].readIfPresent() ?? 0
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorResourcesSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorResourcesSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorResourcesSummary()
        value.resourcesProcessed = try reader["resourcesProcessed"].readIfPresent() ?? 0
        value.resourcesFlagged = try reader["resourcesFlagged"].readIfPresent() ?? 0
        value.resourcesIgnored = try reader["resourcesIgnored"].readIfPresent() ?? 0
        value.resourcesSuppressed = try reader["resourcesSuppressed"].readIfPresent() ?? 0
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCheckDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCheckDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCheckDescription()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.category = try reader["category"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SupportClientTypes.TrustedAdvisorCheckSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SupportClientTypes.TrustedAdvisorCheckSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupportClientTypes.TrustedAdvisorCheckSummary()
        value.checkId = try reader["checkId"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? ""
        value.hasFlaggedResources = try reader["hasFlaggedResources"].readIfPresent() ?? false
        value.resourcesSummary = try reader["resourcesSummary"].readIfPresent(with: SupportClientTypes.TrustedAdvisorResourcesSummary.read(from:))
        value.categorySpecificSummary = try reader["categorySpecificSummary"].readIfPresent(with: SupportClientTypes.TrustedAdvisorCategorySpecificSummary.read(from:))
        return value
    }
}

public enum SupportClientTypes {}
