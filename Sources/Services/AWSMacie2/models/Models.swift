// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccountId = "administratorAccountId"
        case invitationId = "invitationId"
        case masterAccount = "masterAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccountId = self.administratorAccountId {
            try encodeContainer.encode(administratorAccountId, forKey: .administratorAccountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterAccount = self.masterAccount {
            try encodeContainer.encode(masterAccount, forKey: .masterAccount)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/accept"
    }
}

public struct AcceptInvitationInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that sent the invitation.
    public var administratorAccountId: Swift.String?
    /// The unique identifier for the invitation to accept.
    /// This member is required.
    public var invitationId: Swift.String?
    /// (Deprecated) The Amazon Web Services account ID for the account that sent the invitation. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.
    public var masterAccount: Swift.String?

    public init(
        administratorAccountId: Swift.String? = nil,
        invitationId: Swift.String? = nil,
        masterAccount: Swift.String? = nil
    )
    {
        self.administratorAccountId = administratorAccountId
        self.invitationId = invitationId
        self.masterAccount = masterAccount
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let administratorAccountId: Swift.String?
    let invitationId: Swift.String?
    let masterAccount: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccountId = "administratorAccountId"
        case invitationId = "invitationId"
        case masterAccount = "masterAccount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let masterAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterAccount)
        masterAccount = masterAccountDecoded
    }
}

extension AcceptInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AcceptInvitationOutput: Swift.Equatable {

    public init() { }
}

enum AcceptInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.AccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowsPublicReadAccess = self.allowsPublicReadAccess {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if let allowsPublicWriteAccess = self.allowsPublicWriteAccess {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the permissions settings of the bucket-level access control list (ACL) for an S3 bucket.
    public struct AccessControlList: Swift.Equatable {
        /// Specifies whether the ACL grants the general public with read access permissions for the bucket.
        public var allowsPublicReadAccess: Swift.Bool?
        /// Specifies whether the ACL grants the general public with write access permissions for the bucket.
        public var allowsPublicWriteAccess: Swift.Bool?

        public init(
            allowsPublicReadAccess: Swift.Bool? = nil,
            allowsPublicWriteAccess: Swift.Bool? = nil
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to insufficient access to a specified resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.AccountDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the details of an account to associate with an Amazon Macie administrator account.
    public struct AccountDetail: Swift.Equatable {
        /// The Amazon Web Services account ID for the account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email address for the account.
        /// This member is required.
        public var email: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension Macie2ClientTypes.AccountLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the account-level permissions settings that apply to an S3 bucket.
    public struct AccountLevelPermissions: Swift.Equatable {
        /// The block public access settings for the Amazon Web Services account that owns the bucket.
        public var blockPublicAccess: Macie2ClientTypes.BlockPublicAccess?

        public init(
            blockPublicAccess: Macie2ClientTypes.BlockPublicAccess? = nil
        )
        {
            self.blockPublicAccess = blockPublicAccess
        }
    }

}

extension Macie2ClientTypes.AdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the delegated Amazon Macie administrator account for an organization in Organizations.
    public struct AdminAccount: Swift.Equatable {
        /// The Amazon Web Services account ID for the account.
        public var accountId: Swift.String?
        /// The current status of the account as the delegated Amazon Macie administrator account for the organization.
        public var status: Macie2ClientTypes.AdminStatus?

        public init(
            accountId: Swift.String? = nil,
            status: Macie2ClientTypes.AdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension Macie2ClientTypes {
    /// The current status of an account as the delegated Amazon Macie administrator account for an organization in Organizations. Possible values are:
    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disablingInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disablingInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disablingInProgress: return "DISABLING_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.AllowListCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regex = "regex"
        case s3WordsList = "s3WordsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
        if let s3WordsList = self.s3WordsList {
            try encodeContainer.encode(s3WordsList, forKey: .s3WordsList)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let s3WordsListDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3WordsList.self, forKey: .s3WordsList)
        s3WordsList = s3WordsListDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the criteria for an allow list. The criteria must specify a regular expression (regex) or an S3 object (s3WordsList). It can't specify both.
    public struct AllowListCriteria: Swift.Equatable {
        /// The regular expression (regex) that defines the text pattern to ignore. The expression can contain as many as 512 characters.
        public var regex: Swift.String?
        /// The location and name of the S3 object that lists specific text to ignore.
        public var s3WordsList: Macie2ClientTypes.S3WordsList?

        public init(
            regex: Swift.String? = nil,
            s3WordsList: Macie2ClientTypes.S3WordsList? = nil
        )
        {
            self.regex = regex
            self.s3WordsList = s3WordsList
        }
    }

}

extension Macie2ClientTypes.AllowListStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowListStatusCode.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the current status of an allow list, which indicates whether Amazon Macie can access and use the list's criteria.
    public struct AllowListStatus: Swift.Equatable {
        /// The current status of the allow list. If the list's criteria specify a regular expression (regex), this value is typically OK. Amazon Macie can compile the expression. If the list's criteria specify an S3 object, possible values are:
        ///
        /// * OK - Macie can retrieve and parse the contents of the object.
        ///
        /// * S3_OBJECT_ACCESS_DENIED - Macie isn't allowed to access the object or the object is encrypted with a customer managed KMS key that Macie isn't allowed to use. Check the bucket policy and other permissions settings for the bucket and the object. If the object is encrypted, also ensure that it's encrypted with a key that Macie is allowed to use.
        ///
        /// * S3_OBJECT_EMPTY - Macie can retrieve the object but the object doesn't contain any content. Ensure that the object contains the correct entries. Also ensure that the list's criteria specify the correct bucket and object names.
        ///
        /// * S3_OBJECT_NOT_FOUND - The object doesn't exist in Amazon S3. Ensure that the list's criteria specify the correct bucket and object names.
        ///
        /// * S3_OBJECT_OVERSIZE - Macie can retrieve the object. However, the object contains too many entries or its storage size exceeds the quota for an allow list. Try breaking the list into multiple files and ensure that each file doesn't exceed any quotas. Then configure list settings in Macie for each file.
        ///
        /// * S3_THROTTLED - Amazon S3 throttled the request to retrieve the object. Wait a few minutes and then try again.
        ///
        /// * S3_USER_ACCESS_DENIED - Amazon S3 denied the request to retrieve the object. If the specified object exists, you're not allowed to access it or it's encrypted with an KMS key that you're not allowed to use. Work with your Amazon Web Services administrator to ensure that the list's criteria specify the correct bucket and object names, and you have read access to the bucket and the object. If the object is encrypted, also ensure that it's encrypted with a key that you're allowed to use.
        ///
        /// * UNKNOWN_ERROR - A transient or internal error occurred when Macie attempted to retrieve or parse the object. Wait a few minutes and then try again. A list can also have this status if it's encrypted with a key that Amazon S3 and Macie can't access or use.
        /// This member is required.
        public var code: Macie2ClientTypes.AllowListStatusCode?
        /// A brief description of the status of the allow list. Amazon Macie uses this value to provide additional information about an error that occurred when Macie tried to access and use the list's criteria.
        public var description: Swift.String?

        public init(
            code: Macie2ClientTypes.AllowListStatusCode? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension Macie2ClientTypes {
    /// Indicates the current status of an allow list. Depending on the type of criteria that the list specifies, possible values are:
    public enum AllowListStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ok
        case s3ObjectAccessDenied
        case s3ObjectEmpty
        case s3ObjectNotFound
        case s3ObjectOversize
        case s3Throttled
        case s3UserAccessDenied
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowListStatusCode] {
            return [
                .ok,
                .s3ObjectAccessDenied,
                .s3ObjectEmpty,
                .s3ObjectNotFound,
                .s3ObjectOversize,
                .s3Throttled,
                .s3UserAccessDenied,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ok: return "OK"
            case .s3ObjectAccessDenied: return "S3_OBJECT_ACCESS_DENIED"
            case .s3ObjectEmpty: return "S3_OBJECT_EMPTY"
            case .s3ObjectNotFound: return "S3_OBJECT_NOT_FOUND"
            case .s3ObjectOversize: return "S3_OBJECT_OVERSIZE"
            case .s3Throttled: return "S3_THROTTLED"
            case .s3UserAccessDenied: return "S3_USER_ACCESS_DENIED"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowListStatusCode(rawValue: rawValue) ?? AllowListStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.AllowListSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case name = "name"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides a subset of information about an allow list.
    public struct AllowListSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the allow list.
        public var arn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the allow list was created in Amazon Macie.
        public var createdAt: ClientRuntime.Date?
        /// The custom description of the allow list.
        public var description: Swift.String?
        /// The unique identifier for the allow list.
        public var id: Swift.String?
        /// The custom name of the allow list.
        public var name: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the allow list's settings were most recently changed in Amazon Macie.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

extension Macie2ClientTypes {
    public enum AllowsUnencryptedObjectUploads: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowsUnencryptedObjectUploads] {
            return [
                .false,
                .true,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowsUnencryptedObjectUploads(rawValue: rawValue) ?? AllowsUnencryptedObjectUploads.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.ApiCallDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case api = "api"
        case apiServiceName = "apiServiceName"
        case firstSeen = "firstSeen"
        case lastSeen = "lastSeen"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let api = self.api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let apiServiceName = self.apiServiceName {
            try encodeContainer.encode(apiServiceName, forKey: .apiServiceName)
        }
        if let firstSeen = self.firstSeen {
            try encodeContainer.encodeTimestamp(firstSeen, format: .dateTime, forKey: .firstSeen)
        }
        if let lastSeen = self.lastSeen {
            try encodeContainer.encodeTimestamp(lastSeen, format: .dateTime, forKey: .lastSeen)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .api)
        api = apiDecoded
        let apiServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiServiceName)
        apiServiceName = apiServiceNameDecoded
        let firstSeenDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
        let lastSeenDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an API operation that an entity invoked for an affected resource.
    public struct ApiCallDetails: Swift.Equatable {
        /// The name of the operation that was invoked most recently and produced the finding.
        public var api: Swift.String?
        /// The URL of the Amazon Web Service that provides the operation, for example: s3.amazonaws.com.
        public var apiServiceName: Swift.String?
        /// The first date and time, in UTC and extended ISO 8601 format, when any operation was invoked and produced the finding.
        public var firstSeen: ClientRuntime.Date?
        /// The most recent date and time, in UTC and extended ISO 8601 format, when the specified operation (api) was invoked and produced the finding.
        public var lastSeen: ClientRuntime.Date?

        public init(
            api: Swift.String? = nil,
            apiServiceName: Swift.String? = nil,
            firstSeen: ClientRuntime.Date? = nil,
            lastSeen: ClientRuntime.Date? = nil
        )
        {
            self.api = api
            self.apiServiceName = apiServiceName
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }
    }

}

extension Macie2ClientTypes.AssumedRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "accessKeyId"
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case sessionContext = "sessionContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sessionContext = self.sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an identity that performed an action on an affected resource by using temporary security credentials. The credentials were obtained using the AssumeRole operation of the Security Token Service (STS) API.
    public struct AssumedRole: Swift.Equatable {
        /// The Amazon Web Services access key ID that identifies the credentials.
        public var accessKeyId: Swift.String?
        /// The unique identifier for the Amazon Web Services account that owns the entity that was used to get the credentials.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the entity that was used to get the credentials.
        public var arn: Swift.String?
        /// The unique identifier for the entity that was used to get the credentials.
        public var principalId: Swift.String?
        /// The details of the session that was created for the credentials, including the entity that issued the session.
        public var sessionContext: Macie2ClientTypes.SessionContext?

        public init(
            accessKeyId: Swift.String? = nil,
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            sessionContext: Macie2ClientTypes.SessionContext? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }
    }

}

extension Macie2ClientTypes {
    /// The status of the automated sensitive data discovery configuration for an Amazon Macie account. Valid values are:
    public enum AutomatedDiscoveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedDiscoveryStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomatedDiscoveryStatus(rawValue: rawValue) ?? AutomatedDiscoveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// Specifies whether occurrences of sensitive data can be retrieved for a finding. Possible values are:
    public enum AvailabilityCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityCode] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AvailabilityCode(rawValue: rawValue) ?? AvailabilityCode.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.AwsAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an Amazon Web Services account and entity that performed an action on an affected resource. The action was performed using the credentials for an Amazon Web Services account other than your own account.
    public struct AwsAccount: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The unique identifier for the entity that performed the action.
        public var principalId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.principalId = principalId
        }
    }

}

extension Macie2ClientTypes.AwsService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokedBy = "invokedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokedBy = self.invokedBy {
            try encodeContainer.encode(invokedBy, forKey: .invokedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokedBy)
        invokedBy = invokedByDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an Amazon Web Service that performed an action on an affected resource.
    public struct AwsService: Swift.Equatable {
        /// The name of the Amazon Web Service that performed the action.
        public var invokedBy: Swift.String?

        public init(
            invokedBy: Swift.String? = nil
        )
        {
            self.invokedBy = invokedBy
        }
    }

}

extension Macie2ClientTypes.BatchGetCustomDataIdentifierSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case deleted = "deleted"
        case description = "description"
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let deleted = self.deleted {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a custom data identifier.
    public struct BatchGetCustomDataIdentifierSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom data identifier.
        public var arn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.
        public var createdAt: ClientRuntime.Date?
        /// Specifies whether the custom data identifier was deleted. If you delete a custom data identifier, Amazon Macie doesn't delete it permanently. Instead, it soft deletes the identifier.
        public var deleted: Swift.Bool?
        /// The custom description of the custom data identifier.
        public var description: Swift.String?
        /// The unique identifier for the custom data identifier.
        public var id: Swift.String?
        /// The custom name of the custom data identifier.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deleted: Swift.Bool? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deleted = deleted
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension BatchGetCustomDataIdentifiersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids = "ids"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for __string0 in ids {
                try idsContainer.encode(__string0)
            }
        }
    }
}

extension BatchGetCustomDataIdentifiersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-data-identifiers/get"
    }
}

public struct BatchGetCustomDataIdentifiersInput: Swift.Equatable {
    /// An array of custom data identifier IDs, one for each custom data identifier to retrieve information about.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetCustomDataIdentifiersInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchGetCustomDataIdentifiersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids = "ids"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetCustomDataIdentifiersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetCustomDataIdentifiersOutputBody = try responseDecoder.decode(responseBody: data)
            self.customDataIdentifiers = output.customDataIdentifiers
            self.notFoundIdentifierIds = output.notFoundIdentifierIds
        } else {
            self.customDataIdentifiers = nil
            self.notFoundIdentifierIds = nil
        }
    }
}

public struct BatchGetCustomDataIdentifiersOutput: Swift.Equatable {
    /// An array of objects, one for each custom data identifier that matches the criteria specified in the request.
    public var customDataIdentifiers: [Macie2ClientTypes.BatchGetCustomDataIdentifierSummary]?
    /// An array of custom data identifier IDs, one for each custom data identifier that was specified in the request but doesn't correlate to an existing custom data identifier.
    public var notFoundIdentifierIds: [Swift.String]?

    public init(
        customDataIdentifiers: [Macie2ClientTypes.BatchGetCustomDataIdentifierSummary]? = nil,
        notFoundIdentifierIds: [Swift.String]? = nil
    )
    {
        self.customDataIdentifiers = customDataIdentifiers
        self.notFoundIdentifierIds = notFoundIdentifierIds
    }
}

struct BatchGetCustomDataIdentifiersOutputBody: Swift.Equatable {
    let customDataIdentifiers: [Macie2ClientTypes.BatchGetCustomDataIdentifierSummary]?
    let notFoundIdentifierIds: [Swift.String]?
}

extension BatchGetCustomDataIdentifiersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDataIdentifiers = "customDataIdentifiers"
        case notFoundIdentifierIds = "notFoundIdentifierIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataIdentifiersContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.BatchGetCustomDataIdentifierSummary?].self, forKey: .customDataIdentifiers)
        var customDataIdentifiersDecoded0:[Macie2ClientTypes.BatchGetCustomDataIdentifierSummary]? = nil
        if let customDataIdentifiersContainer = customDataIdentifiersContainer {
            customDataIdentifiersDecoded0 = [Macie2ClientTypes.BatchGetCustomDataIdentifierSummary]()
            for structure0 in customDataIdentifiersContainer {
                if let structure0 = structure0 {
                    customDataIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        customDataIdentifiers = customDataIdentifiersDecoded0
        let notFoundIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notFoundIdentifierIds)
        var notFoundIdentifierIdsDecoded0:[Swift.String]? = nil
        if let notFoundIdentifierIdsContainer = notFoundIdentifierIdsContainer {
            notFoundIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in notFoundIdentifierIdsContainer {
                if let string0 = string0 {
                    notFoundIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        notFoundIdentifierIds = notFoundIdentifierIdsDecoded0
    }
}

enum BatchGetCustomDataIdentifiersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.BlockPublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAcls = self.blockPublicAcls {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if let blockPublicPolicy = self.blockPublicPolicy {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if let ignorePublicAcls = self.ignorePublicAcls {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if let restrictPublicBuckets = self.restrictPublicBuckets {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the block public access settings for an S3 bucket. These settings can apply to a bucket at the account or bucket level. For detailed information about each setting, see [Blocking public access to your Amazon S3 storage](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-block-public-access.html) in the Amazon Simple Storage Service User Guide.
    public struct BlockPublicAccess: Swift.Equatable {
        /// Specifies whether Amazon S3 blocks public access control lists (ACLs) for the bucket and objects in the bucket.
        public var blockPublicAcls: Swift.Bool?
        /// Specifies whether Amazon S3 blocks public bucket policies for the bucket.
        public var blockPublicPolicy: Swift.Bool?
        /// Specifies whether Amazon S3 ignores public ACLs for the bucket and objects in the bucket.
        public var ignorePublicAcls: Swift.Bool?
        /// Specifies whether Amazon S3 restricts public bucket policies for the bucket.
        public var restrictPublicBuckets: Swift.Bool?

        public init(
            blockPublicAcls: Swift.Bool? = nil,
            blockPublicPolicy: Swift.Bool? = nil,
            ignorePublicAcls: Swift.Bool? = nil,
            restrictPublicBuckets: Swift.Bool? = nil
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension Macie2ClientTypes.BucketCountByEffectivePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publiclyAccessible = "publiclyAccessible"
        case publiclyReadable = "publiclyReadable"
        case publiclyWritable = "publiclyWritable"
        case unknown = "unknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let publiclyReadable = self.publiclyReadable {
            try encodeContainer.encode(publiclyReadable, forKey: .publiclyReadable)
        }
        if let publiclyWritable = self.publiclyWritable {
            try encodeContainer.encode(publiclyWritable, forKey: .publiclyWritable)
        }
        if let unknown = self.unknown {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let publiclyReadableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publiclyReadable)
        publiclyReadable = publiclyReadableDecoded
        let publiclyWritableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publiclyWritable)
        publiclyWritable = publiclyWritableDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the number of S3 buckets that are publicly accessible due to a combination of permissions settings for each bucket.
    public struct BucketCountByEffectivePermission: Swift.Equatable {
        /// The total number of buckets that allow the general public to have read or write access to the bucket.
        public var publiclyAccessible: Swift.Int?
        /// The total number of buckets that allow the general public to have read access to the bucket.
        public var publiclyReadable: Swift.Int?
        /// The total number of buckets that allow the general public to have write access to the bucket.
        public var publiclyWritable: Swift.Int?
        /// The total number of buckets that Amazon Macie wasn't able to evaluate permissions settings for. Macie can't determine whether these buckets are publicly accessible.
        public var unknown: Swift.Int?

        public init(
            publiclyAccessible: Swift.Int? = nil,
            publiclyReadable: Swift.Int? = nil,
            publiclyWritable: Swift.Int? = nil,
            unknown: Swift.Int? = nil
        )
        {
            self.publiclyAccessible = publiclyAccessible
            self.publiclyReadable = publiclyReadable
            self.publiclyWritable = publiclyWritable
            self.unknown = unknown
        }
    }

}

extension Macie2ClientTypes.BucketCountByEncryptionType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsManaged = "kmsManaged"
        case s3Managed = "s3Managed"
        case unencrypted = "unencrypted"
        case unknown = "unknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsManaged = self.kmsManaged {
            try encodeContainer.encode(kmsManaged, forKey: .kmsManaged)
        }
        if let s3Managed = self.s3Managed {
            try encodeContainer.encode(s3Managed, forKey: .s3Managed)
        }
        if let unencrypted = self.unencrypted {
            try encodeContainer.encode(unencrypted, forKey: .unencrypted)
        }
        if let unknown = self.unknown {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsManagedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .kmsManaged)
        kmsManaged = kmsManagedDecoded
        let s3ManagedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .s3Managed)
        s3Managed = s3ManagedDecoded
        let unencryptedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unencrypted)
        unencrypted = unencryptedDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the number of S3 buckets whose settings do or don't specify default server-side encryption behavior for objects that are added to the buckets. For detailed information about these settings, see [Setting default server-side encryption behavior for Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html) in the Amazon Simple Storage Service User Guide.
    public struct BucketCountByEncryptionType: Swift.Equatable {
        /// The total number of buckets whose default encryption settings are configured to encrypt new objects with an Amazon Web Services managed KMS key or a customer managed KMS key. By default, these buckets encrypt new objects automatically using SSE-KMS encryption.
        public var kmsManaged: Swift.Int?
        /// The total number of buckets whose default encryption settings are configured to encrypt new objects with an Amazon S3 managed key. By default, these buckets encrypt new objects automatically using SSE-S3 encryption.
        public var s3Managed: Swift.Int?
        /// The total number of buckets that don't specify default server-side encryption behavior for new objects. Default encryption settings aren't configured for these buckets.
        public var unencrypted: Swift.Int?
        /// The total number of buckets that Amazon Macie doesn't have current encryption metadata for. Macie can't provide current data about the default encryption settings for these buckets.
        public var unknown: Swift.Int?

        public init(
            kmsManaged: Swift.Int? = nil,
            s3Managed: Swift.Int? = nil,
            unencrypted: Swift.Int? = nil,
            unknown: Swift.Int? = nil
        )
        {
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
            self.unknown = unknown
        }
    }

}

extension Macie2ClientTypes.BucketCountBySharedAccessType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case external = "external"
        case `internal` = "internal"
        case notShared = "notShared"
        case unknown = "unknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let external = self.external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let `internal` = self.`internal` {
            try encodeContainer.encode(`internal`, forKey: .`internal`)
        }
        if let notShared = self.notShared {
            try encodeContainer.encode(notShared, forKey: .notShared)
        }
        if let unknown = self.unknown {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .external)
        external = externalDecoded
        let internalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .internal)
        `internal` = internalDecoded
        let notSharedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .notShared)
        notShared = notSharedDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the number of S3 buckets that are or aren't shared with other Amazon Web Services accounts, Amazon CloudFront origin access identities (OAIs), or CloudFront origin access controls (OACs). In this data, an Amazon Macie organization is defined as a set of Macie accounts that are centrally managed as a group of related accounts through Organizations or by Macie invitation.
    public struct BucketCountBySharedAccessType: Swift.Equatable {
        /// The total number of buckets that are shared with one or more of the following or any combination of the following: an Amazon CloudFront OAI, a CloudFront OAC, or an Amazon Web Services account that isn't in the same Amazon Macie organization.
        public var external: Swift.Int?
        /// The total number of buckets that are shared with one or more Amazon Web Services accounts in the same Amazon Macie organization. These buckets aren't shared with Amazon CloudFront OAIs or OACs.
        public var `internal`: Swift.Int?
        /// The total number of buckets that aren't shared with other Amazon Web Services accounts, Amazon CloudFront OAIs, or CloudFront OACs.
        public var notShared: Swift.Int?
        /// The total number of buckets that Amazon Macie wasn't able to evaluate shared access settings for. Macie can't determine whether these buckets are shared with other Amazon Web Services accounts, Amazon CloudFront OAIs, or CloudFront OACs.
        public var unknown: Swift.Int?

        public init(
            external: Swift.Int? = nil,
            `internal`: Swift.Int? = nil,
            notShared: Swift.Int? = nil,
            unknown: Swift.Int? = nil
        )
        {
            self.external = external
            self.`internal` = `internal`
            self.notShared = notShared
            self.unknown = unknown
        }
    }

}

extension Macie2ClientTypes.BucketCountPolicyAllowsUnencryptedObjectUploads: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case deniesUnencryptedObjectUploads = "deniesUnencryptedObjectUploads"
        case unknown = "unknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowsUnencryptedObjectUploads = self.allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads, forKey: .allowsUnencryptedObjectUploads)
        }
        if let deniesUnencryptedObjectUploads = self.deniesUnencryptedObjectUploads {
            try encodeContainer.encode(deniesUnencryptedObjectUploads, forKey: .deniesUnencryptedObjectUploads)
        }
        if let unknown = self.unknown {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let deniesUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deniesUnencryptedObjectUploads)
        deniesUnencryptedObjectUploads = deniesUnencryptedObjectUploadsDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the number of S3 buckets whose bucket policies do or don't require server-side encryption of objects when objects are added to the buckets.
    public struct BucketCountPolicyAllowsUnencryptedObjectUploads: Swift.Equatable {
        /// The total number of buckets that don't have a bucket policy or have a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, the policy doesn't require PutObject requests to include a valid server-side encryption header: the x-amz-server-side-encryption header with a value of AES256 or aws:kms, or the x-amz-server-side-encryption-customer-algorithm header with a value of AES256.
        public var allowsUnencryptedObjectUploads: Swift.Int?
        /// The total number of buckets whose bucket policies require server-side encryption of new objects. PutObject requests for these buckets must include a valid server-side encryption header: the x-amz-server-side-encryption header with a value of AES256 or aws:kms, or the x-amz-server-side-encryption-customer-algorithm header with a value of AES256.
        public var deniesUnencryptedObjectUploads: Swift.Int?
        /// The total number of buckets that Amazon Macie wasn't able to evaluate server-side encryption requirements for. Macie can't determine whether the bucket policies for these buckets require server-side encryption of new objects.
        public var unknown: Swift.Int?

        public init(
            allowsUnencryptedObjectUploads: Swift.Int? = nil,
            deniesUnencryptedObjectUploads: Swift.Int? = nil,
            unknown: Swift.Int? = nil
        )
        {
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.deniesUnencryptedObjectUploads = deniesUnencryptedObjectUploads
            self.unknown = unknown
        }
    }

}

extension Macie2ClientTypes.BucketCriteriaAdditionalProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "eq"
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for __string0 in eq {
                try eqContainer.encode(__string0)
            }
        }
        if let gt = self.gt {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if let gte = self.gte {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if let lt = self.lt {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if let lte = self.lte {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for __string0 in neq {
                try neqContainer.encode(__string0)
            }
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let gtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lte)
        lte = lteDecoded
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the operator to use in a property-based condition that filters the results of a query for information about S3 buckets.
    public struct BucketCriteriaAdditionalProperties: Swift.Equatable {
        /// The value for the property matches (equals) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
        public var eq: [Swift.String]?
        /// The value for the property is greater than the specified value.
        public var gt: Swift.Int?
        /// The value for the property is greater than or equal to the specified value.
        public var gte: Swift.Int?
        /// The value for the property is less than the specified value.
        public var lt: Swift.Int?
        /// The value for the property is less than or equal to the specified value.
        public var lte: Swift.Int?
        /// The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
        public var neq: [Swift.String]?
        /// The name of the bucket begins with the specified value.
        public var `prefix`: Swift.String?

        public init(
            eq: [Swift.String]? = nil,
            gt: Swift.Int? = nil,
            gte: Swift.Int? = nil,
            lt: Swift.Int? = nil,
            lte: Swift.Int? = nil,
            neq: [Swift.String]? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.`prefix` = `prefix`
        }
    }

}

extension Macie2ClientTypes.BucketLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = self.accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = self.bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the bucket-level permissions settings for an S3 bucket.
    public struct BucketLevelPermissions: Swift.Equatable {
        /// The permissions settings of the access control list (ACL) for the bucket. This value is null if an ACL hasn't been defined for the bucket.
        public var accessControlList: Macie2ClientTypes.AccessControlList?
        /// The block public access settings for the bucket.
        public var blockPublicAccess: Macie2ClientTypes.BlockPublicAccess?
        /// The permissions settings of the bucket policy for the bucket. This value is null if a bucket policy hasn't been defined for the bucket.
        public var bucketPolicy: Macie2ClientTypes.BucketPolicy?

        public init(
            accessControlList: Macie2ClientTypes.AccessControlList? = nil,
            blockPublicAccess: Macie2ClientTypes.BlockPublicAccess? = nil,
            bucketPolicy: Macie2ClientTypes.BucketPolicy? = nil
        )
        {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }
    }

}

extension Macie2ClientTypes.BucketMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case bucketArn = "bucketArn"
        case bucketCreatedAt = "bucketCreatedAt"
        case bucketName = "bucketName"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case jobDetails = "jobDetails"
        case lastAutomatedDiscoveryTime = "lastAutomatedDiscoveryTime"
        case lastUpdated = "lastUpdated"
        case objectCount = "objectCount"
        case objectCountByEncryptionType = "objectCountByEncryptionType"
        case publicAccess = "publicAccess"
        case region = "region"
        case replicationDetails = "replicationDetails"
        case sensitivityScore = "sensitivityScore"
        case serverSideEncryption = "serverSideEncryption"
        case sharedAccess = "sharedAccess"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case tags = "tags"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
        case versioning = "versioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let allowsUnencryptedObjectUploads = self.allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads.rawValue, forKey: .allowsUnencryptedObjectUploads)
        }
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let bucketCreatedAt = self.bucketCreatedAt {
            try encodeContainer.encodeTimestamp(bucketCreatedAt, format: .dateTime, forKey: .bucketCreatedAt)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classifiableObjectCount = self.classifiableObjectCount {
            try encodeContainer.encode(classifiableObjectCount, forKey: .classifiableObjectCount)
        }
        if let classifiableSizeInBytes = self.classifiableSizeInBytes {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let jobDetails = self.jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let lastAutomatedDiscoveryTime = self.lastAutomatedDiscoveryTime {
            try encodeContainer.encodeTimestamp(lastAutomatedDiscoveryTime, format: .dateTime, forKey: .lastAutomatedDiscoveryTime)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let objectCount = self.objectCount {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let objectCountByEncryptionType = self.objectCountByEncryptionType {
            try encodeContainer.encode(objectCountByEncryptionType, forKey: .objectCountByEncryptionType)
        }
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let replicationDetails = self.replicationDetails {
            try encodeContainer.encode(replicationDetails, forKey: .replicationDetails)
        }
        if let sensitivityScore = self.sensitivityScore {
            try encodeContainer.encode(sensitivityScore, forKey: .sensitivityScore)
        }
        if let serverSideEncryption = self.serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let sharedAccess = self.sharedAccess {
            try encodeContainer.encode(sharedAccess.rawValue, forKey: .sharedAccess)
        }
        if let sizeInBytes = self.sizeInBytes {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let sizeInBytesCompressed = self.sizeInBytesCompressed {
            try encodeContainer.encode(sizeInBytesCompressed, forKey: .sizeInBytesCompressed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for keyvaluepair0 in tags {
                try tagsContainer.encode(keyvaluepair0)
            }
        }
        if let unclassifiableObjectCount = self.unclassifiableObjectCount {
            try encodeContainer.encode(unclassifiableObjectCount, forKey: .unclassifiableObjectCount)
        }
        if let unclassifiableObjectSizeInBytes = self.unclassifiableObjectSizeInBytes {
            try encodeContainer.encode(unclassifiableObjectSizeInBytes, forKey: .unclassifiableObjectSizeInBytes)
        }
        if let versioning = self.versioning {
            try encodeContainer.encode(versioning, forKey: .versioning)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowsUnencryptedObjectUploads.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let bucketCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .bucketCreatedAt)
        bucketCreatedAt = bucketCreatedAtDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let classifiableObjectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketMetadataErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let lastAutomatedDiscoveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAutomatedDiscoveryTime)
        lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let objectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let objectCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectCountByEncryptionType.self, forKey: .objectCountByEncryptionType)
        objectCountByEncryptionType = objectCountByEncryptionTypeDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketPublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let replicationDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ReplicationDetails.self, forKey: .replicationDetails)
        replicationDetails = replicationDetailsDecoded
        let sensitivityScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sensitivityScore)
        sensitivityScore = sensitivityScoreDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketServerSideEncryption.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sharedAccessDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SharedAccess.self, forKey: .sharedAccess)
        sharedAccess = sharedAccessDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[Macie2ClientTypes.KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Macie2ClientTypes.KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
        let versioningDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .versioning)
        versioning = versioningDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides statistical data and other information about an S3 bucket that Amazon Macie monitors and analyzes for your account. By default, object count and storage size values include data for object parts that are the result of incomplete multipart uploads. For more information, see [How Macie monitors Amazon S3 data security](https://docs.aws.amazon.com/macie/latest/user/monitoring-s3-how-it-works.html) in the Amazon Macie User Guide. If an error occurs when Macie attempts to retrieve and process metadata from Amazon S3 for the bucket or the bucket's objects, the value for the versioning property is false and the value for most other properties is null. Key exceptions are accountId, bucketArn, bucketCreatedAt, bucketName, lastUpdated, and region. To identify the cause of the error, refer to the errorCode and errorMessage values.
    public struct BucketMetadata: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that owns the bucket.
        public var accountId: Swift.String?
        /// Specifies whether the bucket policy for the bucket requires server-side encryption of objects when objects are added to the bucket. Possible values are:
        ///
        /// * FALSE - The bucket policy requires server-side encryption of new objects. PutObject requests must include a valid server-side encryption header.
        ///
        /// * TRUE - The bucket doesn't have a bucket policy or it has a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, it doesn't require PutObject requests to include a valid server-side encryption header.
        ///
        /// * UNKNOWN - Amazon Macie can't determine whether the bucket policy requires server-side encryption of new objects.
        ///
        ///
        /// Valid server-side encryption headers are: x-amz-server-side-encryption with a value of AES256 or aws:kms, and x-amz-server-side-encryption-customer-algorithm with a value of AES256.
        public var allowsUnencryptedObjectUploads: Macie2ClientTypes.AllowsUnencryptedObjectUploads?
        /// The Amazon Resource Name (ARN) of the bucket.
        public var bucketArn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the bucket was created. This value can also indicate when changes such as edits to the bucket's policy were most recently made to the bucket.
        public var bucketCreatedAt: ClientRuntime.Date?
        /// The name of the bucket.
        public var bucketName: Swift.String?
        /// The total number of objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.
        public var classifiableObjectCount: Swift.Int?
        /// The total storage size, in bytes, of the objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format. If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.
        public var classifiableSizeInBytes: Swift.Int?
        /// The error code for an error that prevented Amazon Macie from retrieving and processing information about the bucket and the bucket's objects. If this value is ACCESS_DENIED, Macie doesn't have permission to retrieve the information. For example, the bucket has a restrictive bucket policy and Amazon S3 denied the request. If this value is null, Macie was able to retrieve and process the information.
        public var errorCode: Macie2ClientTypes.BucketMetadataErrorCode?
        /// A brief description of the error (errorCode) that prevented Amazon Macie from retrieving and processing information about the bucket and the bucket's objects. This value is null if Macie was able to retrieve and process the information.
        public var errorMessage: Swift.String?
        /// Specifies whether any one-time or recurring classification jobs are configured to analyze data in the bucket, and, if so, the details of the job that ran most recently.
        public var jobDetails: Macie2ClientTypes.JobDetails?
        /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently analyzed data in the bucket while performing automated sensitive data discovery for your account. This value is null if automated sensitive data discovery is currently disabled for your account.
        public var lastAutomatedDiscoveryTime: ClientRuntime.Date?
        /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently retrieved bucket or object metadata from Amazon S3 for the bucket.
        public var lastUpdated: ClientRuntime.Date?
        /// The total number of objects in the bucket.
        public var objectCount: Swift.Int?
        /// The total number of objects in the bucket, grouped by server-side encryption type. This includes a grouping that reports the total number of objects that aren't encrypted or use client-side encryption.
        public var objectCountByEncryptionType: Macie2ClientTypes.ObjectCountByEncryptionType?
        /// Specifies whether the bucket is publicly accessible due to the combination of permissions settings that apply to the bucket, and provides information about those settings.
        public var publicAccess: Macie2ClientTypes.BucketPublicAccess?
        /// The Amazon Web Services Region that hosts the bucket.
        public var region: Swift.String?
        /// Specifies whether the bucket is configured to replicate one or more objects to buckets for other Amazon Web Services accounts and, if so, which accounts.
        public var replicationDetails: Macie2ClientTypes.ReplicationDetails?
        /// The sensitivity score for the bucket, ranging from -1 (classification error) to 100 (sensitive). This value is null if automated sensitive data discovery is currently disabled for your account.
        public var sensitivityScore: Swift.Int?
        /// The default server-side encryption settings for the bucket.
        public var serverSideEncryption: Macie2ClientTypes.BucketServerSideEncryption?
        /// Specifies whether the bucket is shared with another Amazon Web Services account, an Amazon CloudFront origin access identity (OAI), or a CloudFront origin access control (OAC). Possible values are:
        ///
        /// * EXTERNAL - The bucket is shared with one or more of the following or any combination of the following: a CloudFront OAI, a CloudFront OAC, or an Amazon Web Services account that isn't part of your Amazon Macie organization.
        ///
        /// * INTERNAL - The bucket is shared with one or more Amazon Web Services accounts that are part of your Amazon Macie organization. It isn't shared with a CloudFront OAI or OAC.
        ///
        /// * NOT_SHARED - The bucket isn't shared with another Amazon Web Services account, a CloudFront OAI, or a CloudFront OAC.
        ///
        /// * UNKNOWN - Amazon Macie wasn't able to evaluate the shared access settings for the bucket.
        ///
        ///
        /// An Amazon Macie organization is a set of Macie accounts that are centrally managed as a group of related accounts through Organizations or by Macie invitation.
        public var sharedAccess: Macie2ClientTypes.SharedAccess?
        /// The total storage size, in bytes, of the bucket. If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each object in the bucket. This value doesn't reflect the storage size of all versions of each object in the bucket.
        public var sizeInBytes: Swift.Int?
        /// The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the bucket. If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.
        public var sizeInBytesCompressed: Swift.Int?
        /// An array that specifies the tags (keys and values) that are associated with the bucket.
        public var tags: [Macie2ClientTypes.KeyValuePair]?
        /// The total number of objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
        public var unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics?
        /// The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
        public var unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics?
        /// Specifies whether versioning is enabled for the bucket.
        public var versioning: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            allowsUnencryptedObjectUploads: Macie2ClientTypes.AllowsUnencryptedObjectUploads? = nil,
            bucketArn: Swift.String? = nil,
            bucketCreatedAt: ClientRuntime.Date? = nil,
            bucketName: Swift.String? = nil,
            classifiableObjectCount: Swift.Int? = nil,
            classifiableSizeInBytes: Swift.Int? = nil,
            errorCode: Macie2ClientTypes.BucketMetadataErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            jobDetails: Macie2ClientTypes.JobDetails? = nil,
            lastAutomatedDiscoveryTime: ClientRuntime.Date? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            objectCount: Swift.Int? = nil,
            objectCountByEncryptionType: Macie2ClientTypes.ObjectCountByEncryptionType? = nil,
            publicAccess: Macie2ClientTypes.BucketPublicAccess? = nil,
            region: Swift.String? = nil,
            replicationDetails: Macie2ClientTypes.ReplicationDetails? = nil,
            sensitivityScore: Swift.Int? = nil,
            serverSideEncryption: Macie2ClientTypes.BucketServerSideEncryption? = nil,
            sharedAccess: Macie2ClientTypes.SharedAccess? = nil,
            sizeInBytes: Swift.Int? = nil,
            sizeInBytesCompressed: Swift.Int? = nil,
            tags: [Macie2ClientTypes.KeyValuePair]? = nil,
            unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics? = nil,
            unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics? = nil,
            versioning: Swift.Bool? = nil
        )
        {
            self.accountId = accountId
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.bucketArn = bucketArn
            self.bucketCreatedAt = bucketCreatedAt
            self.bucketName = bucketName
            self.classifiableObjectCount = classifiableObjectCount
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.jobDetails = jobDetails
            self.lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTime
            self.lastUpdated = lastUpdated
            self.objectCount = objectCount
            self.objectCountByEncryptionType = objectCountByEncryptionType
            self.publicAccess = publicAccess
            self.region = region
            self.replicationDetails = replicationDetails
            self.sensitivityScore = sensitivityScore
            self.serverSideEncryption = serverSideEncryption
            self.sharedAccess = sharedAccess
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.tags = tags
            self.unclassifiableObjectCount = unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
            self.versioning = versioning
        }
    }

}

extension Macie2ClientTypes {
    /// The error code for an error that prevented Amazon Macie from retrieving and processing metadata from Amazon S3 for an S3 bucket and the bucket's objects.
    public enum BucketMetadataErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketMetadataErrorCode] {
            return [
                .accessDenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketMetadataErrorCode(rawValue: rawValue) ?? BucketMetadataErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.BucketPermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = self.accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = self.bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the account-level and bucket-level permissions settings for an S3 bucket.
    public struct BucketPermissionConfiguration: Swift.Equatable {
        /// The account-level permissions settings that apply to the bucket.
        public var accountLevelPermissions: Macie2ClientTypes.AccountLevelPermissions?
        /// The bucket-level permissions settings for the bucket.
        public var bucketLevelPermissions: Macie2ClientTypes.BucketLevelPermissions?

        public init(
            accountLevelPermissions: Macie2ClientTypes.AccountLevelPermissions? = nil,
            bucketLevelPermissions: Macie2ClientTypes.BucketLevelPermissions? = nil
        )
        {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }
    }

}

extension Macie2ClientTypes.BucketPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowsPublicReadAccess = self.allowsPublicReadAccess {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if let allowsPublicWriteAccess = self.allowsPublicWriteAccess {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the permissions settings of the bucket policy for an S3 bucket.
    public struct BucketPolicy: Swift.Equatable {
        /// Specifies whether the bucket policy allows the general public to have read access to the bucket.
        public var allowsPublicReadAccess: Swift.Bool?
        /// Specifies whether the bucket policy allows the general public to have write access to the bucket.
        public var allowsPublicWriteAccess: Swift.Bool?

        public init(
            allowsPublicReadAccess: Swift.Bool? = nil,
            allowsPublicWriteAccess: Swift.Bool? = nil
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension Macie2ClientTypes.BucketPublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = self.effectivePermission {
            try encodeContainer.encode(effectivePermission.rawValue, forKey: .effectivePermission)
        }
        if let permissionConfiguration = self.permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.EffectivePermission.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketPermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the permissions settings that determine whether an S3 bucket is publicly accessible.
    public struct BucketPublicAccess: Swift.Equatable {
        /// Specifies whether the bucket is publicly accessible due to the combination of permissions settings that apply to the bucket. Possible values are:
        ///
        /// * NOT_PUBLIC - The bucket isn't publicly accessible.
        ///
        /// * PUBLIC - The bucket is publicly accessible.
        ///
        /// * UNKNOWN - Amazon Macie can't determine whether the bucket is publicly accessible.
        public var effectivePermission: Macie2ClientTypes.EffectivePermission?
        /// The account-level and bucket-level permissions settings for the bucket.
        public var permissionConfiguration: Macie2ClientTypes.BucketPermissionConfiguration?

        public init(
            effectivePermission: Macie2ClientTypes.EffectivePermission? = nil,
            permissionConfiguration: Macie2ClientTypes.BucketPermissionConfiguration? = nil
        )
        {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }
    }

}

extension Macie2ClientTypes.BucketServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsMasterKeyId = "kmsMasterKeyId"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsMasterKeyId = self.kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the default server-side encryption settings for an S3 bucket. For detailed information about these settings, see [Setting default server-side encryption behavior for Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html) in the Amazon Simple Storage Service User Guide.
    public struct BucketServerSideEncryption: Swift.Equatable {
        /// The Amazon Resource Name (ARN) or unique identifier (key ID) for the KMS key that's used by default to encrypt objects that are added to the bucket. This value is null if the bucket is configured to use an Amazon S3 managed key to encrypt new objects.
        public var kmsMasterKeyId: Swift.String?
        /// The server-side encryption algorithm that's used by default to encrypt objects that are added to the bucket. Possible values are:
        ///
        /// * AES256 - New objects are encrypted with an Amazon S3 managed key. They use SSE-S3 encryption.
        ///
        /// * aws:kms - New objects are encrypted with an KMS key (kmsMasterKeyId), either an Amazon Web Services managed key or a customer managed key. They use SSE-KMS encryption.
        ///
        /// * NONE - The bucket's default encryption settings don't specify server-side encryption behavior for new objects.
        public var type: Macie2ClientTypes.ModelType?

        public init(
            kmsMasterKeyId: Swift.String? = nil,
            type: Macie2ClientTypes.ModelType? = nil
        )
        {
            self.kmsMasterKeyId = kmsMasterKeyId
            self.type = type
        }
    }

}

extension Macie2ClientTypes.BucketSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a query for information about S3 buckets.
    public struct BucketSortCriteria: Swift.Equatable {
        /// The name of the bucket property to sort the results by. This value can be one of the following properties that Amazon Macie defines as bucket metadata: accountId, bucketName, classifiableObjectCount, classifiableSizeInBytes, objectCount, sensitivityScore, or sizeInBytes.
        public var attributeName: Swift.String?
        /// The sort order to apply to the results, based on the value specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            attributeName: Swift.String? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension Macie2ClientTypes.BucketStatisticsBySensitivity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classificationError = "classificationError"
        case notClassified = "notClassified"
        case notSensitive = "notSensitive"
        case sensitive = "sensitive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classificationError = self.classificationError {
            try encodeContainer.encode(classificationError, forKey: .classificationError)
        }
        if let notClassified = self.notClassified {
            try encodeContainer.encode(notClassified, forKey: .notClassified)
        }
        if let notSensitive = self.notSensitive {
            try encodeContainer.encode(notSensitive, forKey: .notSensitive)
        }
        if let sensitive = self.sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationErrorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityAggregations.self, forKey: .classificationError)
        classificationError = classificationErrorDecoded
        let notClassifiedDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityAggregations.self, forKey: .notClassified)
        notClassified = notClassifiedDecoded
        let notSensitiveDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityAggregations.self, forKey: .notSensitive)
        notSensitive = notSensitiveDecoded
        let sensitiveDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityAggregations.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides aggregated statistical data for sensitive data discovery metrics that apply to S3 buckets, grouped by bucket sensitivity score (sensitivityScore). If automated sensitive data discovery is currently disabled for your account, the value for each metric is 0.
    public struct BucketStatisticsBySensitivity: Swift.Equatable {
        /// The aggregated statistical data for all buckets that have a sensitivity score of -1.
        public var classificationError: Macie2ClientTypes.SensitivityAggregations?
        /// The aggregated statistical data for all buckets that have a sensitivity score of 50.
        public var notClassified: Macie2ClientTypes.SensitivityAggregations?
        /// The aggregated statistical data for all buckets that have a sensitivity score of 1-49.
        public var notSensitive: Macie2ClientTypes.SensitivityAggregations?
        /// The aggregated statistical data for all buckets that have a sensitivity score of 51-100.
        public var sensitive: Macie2ClientTypes.SensitivityAggregations?

        public init(
            classificationError: Macie2ClientTypes.SensitivityAggregations? = nil,
            notClassified: Macie2ClientTypes.SensitivityAggregations? = nil,
            notSensitive: Macie2ClientTypes.SensitivityAggregations? = nil,
            sensitive: Macie2ClientTypes.SensitivityAggregations? = nil
        )
        {
            self.classificationError = classificationError
            self.notClassified = notClassified
            self.notSensitive = notSensitive
            self.sensitive = sensitive
        }
    }

}

extension Macie2ClientTypes.Cell: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellReference = "cellReference"
        case column = "column"
        case columnName = "columnName"
        case row = "row"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellReference = self.cellReference {
            try encodeContainer.encode(cellReference, forKey: .cellReference)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let row = self.row {
            try encodeContainer.encode(row, forKey: .row)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellReference)
        cellReference = cellReferenceDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column)
        column = columnDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let rowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .row)
        row = rowDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the location of an occurrence of sensitive data in a Microsoft Excel workbook, CSV file, or TSV file.
    public struct Cell: Swift.Equatable {
        /// The location of the cell, as an absolute cell reference, that contains the sensitive data, for example Sheet2!C5 for cell C5 on Sheet2 in a Microsoft Excel workbook. This value is null for CSV and TSV files.
        public var cellReference: Swift.String?
        /// The column number of the column that contains the sensitive data. For a Microsoft Excel workbook, this value correlates to the alphabetical character(s) for a column identifier, for example: 1 for column A, 2 for column B, and so on.
        public var column: Swift.Int?
        /// The name of the column that contains the sensitive data, if available.
        public var columnName: Swift.String?
        /// The row number of the row that contains the sensitive data.
        public var row: Swift.Int?

        public init(
            cellReference: Swift.String? = nil,
            column: Swift.Int? = nil,
            columnName: Swift.String? = nil,
            row: Swift.Int? = nil
        )
        {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }
    }

}

extension Macie2ClientTypes.ClassificationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedResultsLocation = "detailedResultsLocation"
        case jobArn = "jobArn"
        case jobId = "jobId"
        case originType = "originType"
        case result = "result"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedResultsLocation = self.detailedResultsLocation {
            try encodeContainer.encode(detailedResultsLocation, forKey: .detailedResultsLocation)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let originType = self.originType {
            try encodeContainer.encode(originType.rawValue, forKey: .originType)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedResultsLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedResultsLocation)
        detailedResultsLocation = detailedResultsLocationDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let originTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OriginType.self, forKey: .originType)
        originType = originTypeDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationResult.self, forKey: .result)
        result = resultDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a sensitive data finding and the details of the finding.
    public struct ClassificationDetails: Swift.Equatable {
        /// The path to the folder or file in Amazon S3 that contains the corresponding sensitive data discovery result for the finding. If a finding applies to a large archive or compressed file, this value is the path to a folder. Otherwise, this value is the path to a file.
        public var detailedResultsLocation: Swift.String?
        /// The Amazon Resource Name (ARN) of the classification job that produced the finding. This value is null if the origin of the finding (originType) is AUTOMATED_SENSITIVE_DATA_DISCOVERY.
        public var jobArn: Swift.String?
        /// The unique identifier for the classification job that produced the finding. This value is null if the origin of the finding (originType) is AUTOMATED_SENSITIVE_DATA_DISCOVERY.
        public var jobId: Swift.String?
        /// Specifies how Amazon Macie found the sensitive data that produced the finding. Possible values are: SENSITIVE_DATA_DISCOVERY_JOB, for a classification job; and, AUTOMATED_SENSITIVE_DATA_DISCOVERY, for automated sensitive data discovery.
        public var originType: Macie2ClientTypes.OriginType?
        /// The status and other details of the finding.
        public var result: Macie2ClientTypes.ClassificationResult?

        public init(
            detailedResultsLocation: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            originType: Macie2ClientTypes.OriginType? = nil,
            result: Macie2ClientTypes.ClassificationResult? = nil
        )
        {
            self.detailedResultsLocation = detailedResultsLocation
            self.jobArn = jobArn
            self.jobId = jobId
            self.originType = originType
            self.result = result
        }
    }

}

extension Macie2ClientTypes.ClassificationExportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "s3Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies where to store data classification results, and the encryption settings to use when storing results in that location. The location must be an S3 bucket.
    public struct ClassificationExportConfiguration: Swift.Equatable {
        /// The S3 bucket to store data classification results in, and the encryption settings to use when storing results in that bucket.
        public var s3Destination: Macie2ClientTypes.S3Destination?

        public init(
            s3Destination: Macie2ClientTypes.S3Destination? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }

}

extension Macie2ClientTypes.ClassificationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalOccurrences = "additionalOccurrences"
        case customDataIdentifiers = "customDataIdentifiers"
        case mimeType = "mimeType"
        case sensitiveData = "sensitiveData"
        case sizeClassified = "sizeClassified"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalOccurrences = self.additionalOccurrences {
            try encodeContainer.encode(additionalOccurrences, forKey: .additionalOccurrences)
        }
        if let customDataIdentifiers = self.customDataIdentifiers {
            try encodeContainer.encode(customDataIdentifiers, forKey: .customDataIdentifiers)
        }
        if let mimeType = self.mimeType {
            try encodeContainer.encode(mimeType, forKey: .mimeType)
        }
        if let sensitiveData = sensitiveData {
            var sensitiveDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sensitiveData)
            for sensitivedataitem0 in sensitiveData {
                try sensitiveDataContainer.encode(sensitivedataitem0)
            }
        }
        if let sizeClassified = self.sizeClassified {
            try encodeContainer.encode(sizeClassified, forKey: .sizeClassified)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalOccurrencesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .additionalOccurrences)
        additionalOccurrences = additionalOccurrencesDecoded
        let customDataIdentifiersDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.CustomDataIdentifiers.self, forKey: .customDataIdentifiers)
        customDataIdentifiers = customDataIdentifiersDecoded
        let mimeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mimeType)
        mimeType = mimeTypeDecoded
        let sensitiveDataContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SensitiveDataItem?].self, forKey: .sensitiveData)
        var sensitiveDataDecoded0:[Macie2ClientTypes.SensitiveDataItem]? = nil
        if let sensitiveDataContainer = sensitiveDataContainer {
            sensitiveDataDecoded0 = [Macie2ClientTypes.SensitiveDataItem]()
            for structure0 in sensitiveDataContainer {
                if let structure0 = structure0 {
                    sensitiveDataDecoded0?.append(structure0)
                }
            }
        }
        sensitiveData = sensitiveDataDecoded0
        let sizeClassifiedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeClassified)
        sizeClassified = sizeClassifiedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationResultStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides the details of a sensitive data finding, including the types, number of occurrences, and locations of the sensitive data that was detected.
    public struct ClassificationResult: Swift.Equatable {
        /// Specifies whether Amazon Macie detected additional occurrences of sensitive data in the S3 object. A finding includes location data for a maximum of 15 occurrences of sensitive data. This value can help you determine whether to investigate additional occurrences of sensitive data in an object. You can do this by referring to the corresponding sensitive data discovery result for the finding (classificationDetails.detailedResultsLocation).
        public var additionalOccurrences: Swift.Bool?
        /// The custom data identifiers that detected the sensitive data and the number of occurrences of the data that they detected.
        public var customDataIdentifiers: Macie2ClientTypes.CustomDataIdentifiers?
        /// The type of content, as a MIME type, that the finding applies to. For example, application/gzip, for a GNU Gzip compressed archive file, or application/pdf, for an Adobe Portable Document Format file.
        public var mimeType: Swift.String?
        /// The category, types, and number of occurrences of the sensitive data that produced the finding.
        public var sensitiveData: [Macie2ClientTypes.SensitiveDataItem]?
        /// The total size, in bytes, of the data that the finding applies to.
        public var sizeClassified: Swift.Int?
        /// The status of the finding.
        public var status: Macie2ClientTypes.ClassificationResultStatus?

        public init(
            additionalOccurrences: Swift.Bool? = nil,
            customDataIdentifiers: Macie2ClientTypes.CustomDataIdentifiers? = nil,
            mimeType: Swift.String? = nil,
            sensitiveData: [Macie2ClientTypes.SensitiveDataItem]? = nil,
            sizeClassified: Swift.Int? = nil,
            status: Macie2ClientTypes.ClassificationResultStatus? = nil
        )
        {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }
    }

}

extension Macie2ClientTypes.ClassificationResultStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case reason = "reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the status of a sensitive data finding.
    public struct ClassificationResultStatus: Swift.Equatable {
        /// The status of the finding. Possible values are:
        ///
        /// * COMPLETE - Amazon Macie successfully completed its analysis of the S3 object that the finding applies to.
        ///
        /// * PARTIAL - Macie analyzed only a subset of the data in the S3 object that the finding applies to. For example, the object is an archive file that contains files in an unsupported format.
        ///
        /// * SKIPPED - Macie wasn't able to analyze the S3 object that the finding applies to. For example, the object is a file that uses an unsupported format.
        public var code: Swift.String?
        /// A brief description of the status of the finding. This value is null if the status (code) of the finding is COMPLETE. Amazon Macie uses this value to notify you of any errors, warnings, or considerations that might impact your analysis of the finding and the affected S3 object. Possible values are:
        ///
        /// * ARCHIVE_CONTAINS_UNPROCESSED_FILES - The object is an archive file and Macie extracted and analyzed only some or none of the files in the archive. To determine which files Macie analyzed, if any, refer to the corresponding sensitive data discovery result for the finding (classificationDetails.detailedResultsLocation).
        ///
        /// * ARCHIVE_EXCEEDS_SIZE_LIMIT - The object is an archive file whose total storage size exceeds the size quota for this type of archive.
        ///
        /// * ARCHIVE_NESTING_LEVEL_OVER_LIMIT - The object is an archive file whose nested depth exceeds the quota for the maximum number of nested levels that Macie analyzes for this type of archive.
        ///
        /// * ARCHIVE_TOTAL_BYTES_EXTRACTED_OVER_LIMIT - The object is an archive file that exceeds the quota for the maximum amount of data that Macie extracts and analyzes for this type of archive.
        ///
        /// * ARCHIVE_TOTAL_DOCUMENTS_PROCESSED_OVER_LIMIT - The object is an archive file that contains more than the maximum number of files that Macie extracts and analyzes for this type of archive.
        ///
        /// * FILE_EXCEEDS_SIZE_LIMIT - The storage size of the object exceeds the size quota for this type of file.
        ///
        /// * INVALID_ENCRYPTION - The object is encrypted using server-side encryption but Macie isn't allowed to use the key. Macie can't decrypt and analyze the object.
        ///
        /// * INVALID_KMS_KEY - The object is encrypted with an KMS key that was disabled or is being deleted. Macie can't decrypt and analyze the object.
        ///
        /// * INVALID_OBJECT_STATE - The object doesn't use a supported Amazon S3 storage class.
        ///
        /// * JSON_NESTING_LEVEL_OVER_LIMIT - The object contains JSON data and the nested depth of the data exceeds the quota for the number of nested levels that Macie analyzes for this type of file.
        ///
        /// * MALFORMED_FILE - The object is a malformed or corrupted file. An error occurred when Macie attempted to detect the file's type or extract data from the file.
        ///
        /// * MALFORMED_OR_FILE_SIZE_EXCEEDS_LIMIT - The object is a Microsoft Office file that is malformed or exceeds the size quota for this type of file. If the file is malformed, an error occurred when Macie attempted to extract data from the file.
        ///
        /// * NO_SUCH_BUCKET_AVAILABLE - The object was in a bucket that was deleted shortly before or when Macie attempted to analyze the object.
        ///
        /// * OBJECT_VERSION_MISMATCH - The object was changed while Macie was analyzing it.
        ///
        /// * OOXML_UNCOMPRESSED_RATIO_EXCEEDS_LIMIT - The object is an Office Open XML file whose compression ratio exceeds the compression quota for this type of file.
        ///
        /// * OOXML_UNCOMPRESSED_SIZE_EXCEEDS_LIMIT - The object is an Office Open XML file that exceeds the size quota for this type of file.
        ///
        /// * PERMISSION_DENIED - Macie isn't allowed to access the object. The object's permissions settings prevent Macie from analyzing the object.
        ///
        /// * SOURCE_OBJECT_NO_LONGER_AVAILABLE - The object was deleted shortly before or when Macie attempted to analyze it.
        ///
        /// * TIME_CUT_OFF_REACHED - Macie started analyzing the object but additional analysis would exceed the time quota for analyzing an object.
        ///
        /// * UNABLE_TO_PARSE_FILE - The object is a file that contains structured data and an error occurred when Macie attempted to parse the data.
        ///
        /// * UNSUPPORTED_FILE_TYPE_EXCEPTION - The object is a file that uses an unsupported file or storage format.
        ///
        ///
        /// For information about quotas, supported storage classes, and supported file and storage formats, see [Quotas](https://docs.aws.amazon.com/macie/latest/user/macie-quotas.html) and [Supported storage classes and formats](https://docs.aws.amazon.com/macie/latest/user/discovery-supported-storage.html) in the Amazon Macie User Guide.
        public var reason: Swift.String?

        public init(
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension Macie2ClientTypes.ClassificationScopeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the classification scope for an Amazon Macie account. Macie uses the scope's settings when it performs automated sensitive data discovery for the account.
    public struct ClassificationScopeSummary: Swift.Equatable {
        /// The unique identifier for the classification scope.
        public var id: Swift.String?
        /// The name of the classification scope: automated-sensitive-data-discovery.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension Macie2ClientTypes {
    /// Specifies how to apply changes to the S3 bucket exclusion list defined by the classification scope for an Amazon Macie account. Valid values are:
    public enum ClassificationScopeUpdateOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ClassificationScopeUpdateOperation] {
            return [
                .add,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClassificationScopeUpdateOperation(rawValue: rawValue) ?? ClassificationScopeUpdateOperation.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to a versioning conflict for a specified resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAllowListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case criteria = "criteria"
        case description = "description"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let criteria = self.criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAllowListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/allow-lists"
    }
}

public struct CreateAllowListInput: Swift.Equatable {
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The criteria that specify the text or text pattern to ignore. The criteria can be the location and name of an S3 object that lists specific text to ignore (s3WordsList), or a regular expression (regex) that defines a text pattern to ignore.
    /// This member is required.
    public var criteria: Macie2ClientTypes.AllowListCriteria?
    /// A custom description of the allow list. The description can contain as many as 512 characters.
    public var description: Swift.String?
    /// A custom name for the allow list. The name can contain as many as 128 characters.
    /// This member is required.
    public var name: Swift.String?
    /// A map of key-value pairs that specifies the tags to associate with the allow list. An allow list can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        criteria: Macie2ClientTypes.AllowListCriteria? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.criteria = criteria
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAllowListInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let criteria: Macie2ClientTypes.AllowListCriteria?
    let description: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAllowListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case criteria = "criteria"
        case description = "description"
        case name = "name"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowListCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAllowListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAllowListOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateAllowListOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the allow list.
    public var arn: Swift.String?
    /// The unique identifier for the allow list.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateAllowListOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateAllowListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateAllowListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClassificationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowListIds = "allowListIds"
        case clientToken = "clientToken"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobType = "jobType"
        case managedDataIdentifierIds = "managedDataIdentifierIds"
        case managedDataIdentifierSelector = "managedDataIdentifierSelector"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowListIds = allowListIds {
            var allowListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowListIds)
            for __string0 in allowListIds {
                try allowListIdsContainer.encode(__string0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customDataIdentifierIds = customDataIdentifierIds {
            var customDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDataIdentifierIds)
            for __string0 in customDataIdentifierIds {
                try customDataIdentifierIdsContainer.encode(__string0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let initialRun = self.initialRun {
            try encodeContainer.encode(initialRun, forKey: .initialRun)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let managedDataIdentifierIds = managedDataIdentifierIds {
            var managedDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedDataIdentifierIds)
            for __string0 in managedDataIdentifierIds {
                try managedDataIdentifierIdsContainer.encode(__string0)
            }
        }
        if let managedDataIdentifierSelector = self.managedDataIdentifierSelector {
            try encodeContainer.encode(managedDataIdentifierSelector.rawValue, forKey: .managedDataIdentifierSelector)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3JobDefinition = self.s3JobDefinition {
            try encodeContainer.encode(s3JobDefinition, forKey: .s3JobDefinition)
        }
        if let samplingPercentage = self.samplingPercentage {
            try encodeContainer.encode(samplingPercentage, forKey: .samplingPercentage)
        }
        if let scheduleFrequency = self.scheduleFrequency {
            try encodeContainer.encode(scheduleFrequency, forKey: .scheduleFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateClassificationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct CreateClassificationJobInput: Swift.Equatable {
    /// An array of unique identifiers, one for each allow list for the job to use when it analyzes data.
    public var allowListIds: [Swift.String]?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An array of unique identifiers, one for each custom data identifier for the job to use when it analyzes data. To use only managed data identifiers, don't specify a value for this property and specify a value other than NONE for the managedDataIdentifierSelector property.
    public var customDataIdentifierIds: [Swift.String]?
    /// A custom description of the job. The description can contain as many as 200 characters.
    public var description: Swift.String?
    /// For a recurring job, specifies whether to analyze all existing, eligible objects immediately after the job is created (true). To analyze only those objects that are created or changed after you create the job and before the job's first scheduled run, set this value to false. If you configure the job to run only once, don't specify a value for this property.
    public var initialRun: Swift.Bool?
    /// The schedule for running the job. Valid values are:
    ///
    /// * ONE_TIME - Run the job only once. If you specify this value, don't specify a value for the scheduleFrequency property.
    ///
    /// * SCHEDULED - Run the job on a daily, weekly, or monthly basis. If you specify this value, use the scheduleFrequency property to define the recurrence pattern for the job.
    /// This member is required.
    public var jobType: Macie2ClientTypes.JobType?
    /// An array of unique identifiers, one for each managed data identifier for the job to include (use) or exclude (not use) when it analyzes data. Inclusion or exclusion depends on the managed data identifier selection type that you specify for the job (managedDataIdentifierSelector). To retrieve a list of valid values for this property, use the ListManagedDataIdentifiers operation.
    public var managedDataIdentifierIds: [Swift.String]?
    /// The selection type to apply when determining which managed data identifiers the job uses to analyze data. Valid values are:
    ///
    /// * ALL - Use all managed data identifiers. If you specify this value, don't specify any values for the managedDataIdentifierIds property.
    ///
    /// * EXCLUDE - Use all managed data identifiers except the ones specified by the managedDataIdentifierIds property.
    ///
    /// * INCLUDE - Use only the managed data identifiers specified by the managedDataIdentifierIds property.
    ///
    /// * NONE - Don't use any managed data identifiers. If you specify this value, specify at least one value for the customDataIdentifierIds property and don't specify any values for the managedDataIdentifierIds property.
    ///
    /// * RECOMMENDED (default) - Use the recommended set of managed data identifiers. If you specify this value, don't specify any values for the managedDataIdentifierIds property.
    ///
    ///
    /// If you don't specify a value for this property, the job uses the recommended set of managed data identifiers. If the job is a recurring job and you specify ALL or EXCLUDE, each job run automatically uses new managed data identifiers that are released. If you specify RECOMMENDED for a recurring job, each job run automatically uses all the managed data identifiers that are in the recommended set when the run starts. For information about individual managed data identifiers or to determine which ones are in the recommended set, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) and [Recommended managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/discovery-jobs-mdis-recommended.html) in the Amazon Macie User Guide.
    public var managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector?
    /// A custom name for the job. The name can contain as many as 500 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The S3 buckets that contain the objects to analyze, and the scope of that analysis.
    /// This member is required.
    public var s3JobDefinition: Macie2ClientTypes.S3JobDefinition?
    /// The sampling depth, as a percentage, for the job to apply when processing objects. This value determines the percentage of eligible objects that the job analyzes. If this value is less than 100, Amazon Macie selects the objects to analyze at random, up to the specified percentage, and analyzes all the data in those objects.
    public var samplingPercentage: Swift.Int?
    /// The recurrence pattern for running the job. To run the job only once, don't specify a value for this property and set the value for the jobType property to ONE_TIME.
    public var scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency?
    /// A map of key-value pairs that specifies the tags to associate with the job. A job can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        allowListIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customDataIdentifierIds: [Swift.String]? = nil,
        description: Swift.String? = nil,
        initialRun: Swift.Bool? = nil,
        jobType: Macie2ClientTypes.JobType? = nil,
        managedDataIdentifierIds: [Swift.String]? = nil,
        managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector? = nil,
        name: Swift.String? = nil,
        s3JobDefinition: Macie2ClientTypes.S3JobDefinition? = nil,
        samplingPercentage: Swift.Int? = nil,
        scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowListIds = allowListIds
        self.clientToken = clientToken
        self.customDataIdentifierIds = customDataIdentifierIds
        self.description = description
        self.initialRun = initialRun
        self.jobType = jobType
        self.managedDataIdentifierIds = managedDataIdentifierIds
        self.managedDataIdentifierSelector = managedDataIdentifierSelector
        self.name = name
        self.s3JobDefinition = s3JobDefinition
        self.samplingPercentage = samplingPercentage
        self.scheduleFrequency = scheduleFrequency
        self.tags = tags
    }
}

struct CreateClassificationJobInputBody: Swift.Equatable {
    let allowListIds: [Swift.String]?
    let clientToken: Swift.String?
    let customDataIdentifierIds: [Swift.String]?
    let description: Swift.String?
    let initialRun: Swift.Bool?
    let jobType: Macie2ClientTypes.JobType?
    let managedDataIdentifierIds: [Swift.String]?
    let managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector?
    let name: Swift.String?
    let s3JobDefinition: Macie2ClientTypes.S3JobDefinition?
    let samplingPercentage: Swift.Int?
    let scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency?
    let tags: [Swift.String:Swift.String]?
}

extension CreateClassificationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowListIds = "allowListIds"
        case clientToken = "clientToken"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobType = "jobType"
        case managedDataIdentifierIds = "managedDataIdentifierIds"
        case managedDataIdentifierSelector = "managedDataIdentifierSelector"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowListIds)
        var allowListIdsDecoded0:[Swift.String]? = nil
        if let allowListIdsContainer = allowListIdsContainer {
            allowListIdsDecoded0 = [Swift.String]()
            for string0 in allowListIdsContainer {
                if let string0 = string0 {
                    allowListIdsDecoded0?.append(string0)
                }
            }
        }
        allowListIds = allowListIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let customDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customDataIdentifierIds)
        var customDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let customDataIdentifierIdsContainer = customDataIdentifierIdsContainer {
            customDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in customDataIdentifierIdsContainer {
                if let string0 = string0 {
                    customDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        customDataIdentifierIds = customDataIdentifierIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let initialRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .initialRun)
        initialRun = initialRunDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let managedDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedDataIdentifierIds)
        var managedDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let managedDataIdentifierIdsContainer = managedDataIdentifierIdsContainer {
            managedDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in managedDataIdentifierIdsContainer {
                if let string0 = string0 {
                    managedDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        managedDataIdentifierIds = managedDataIdentifierIdsDecoded0
        let managedDataIdentifierSelectorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ManagedDataIdentifierSelector.self, forKey: .managedDataIdentifierSelector)
        managedDataIdentifierSelector = managedDataIdentifierSelectorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3JobDefinitionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3JobDefinition.self, forKey: .s3JobDefinition)
        s3JobDefinition = s3JobDefinitionDecoded
        let samplingPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingPercentage)
        samplingPercentage = samplingPercentageDecoded
        let scheduleFrequencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobScheduleFrequency.self, forKey: .scheduleFrequency)
        scheduleFrequency = scheduleFrequencyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateClassificationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClassificationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CreateClassificationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the job.
    public var jobArn: Swift.String?
    /// The unique identifier for the job.
    public var jobId: Swift.String?

    public init(
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CreateClassificationJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let jobId: Swift.String?
}

extension CreateClassificationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobArn = "jobArn"
        case jobId = "jobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateClassificationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomDataIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case description = "description"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case severityLevels = "severityLevels"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ignoreWords = ignoreWords {
            var ignoreWordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ignoreWords)
            for __string0 in ignoreWords {
                try ignoreWordsContainer.encode(__string0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for __string0 in keywords {
                try keywordsContainer.encode(__string0)
            }
        }
        if let maximumMatchDistance = self.maximumMatchDistance {
            try encodeContainer.encode(maximumMatchDistance, forKey: .maximumMatchDistance)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
        if let severityLevels = severityLevels {
            var severityLevelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityLevels)
            for severitylevel0 in severityLevels {
                try severityLevelsContainer.encode(severitylevel0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCustomDataIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-data-identifiers"
    }
}

public struct CreateCustomDataIdentifierInput: Swift.Equatable {
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// A custom description of the custom data identifier. The description can contain as many as 512 characters. We strongly recommend that you avoid including any sensitive data in the description of a custom data identifier. Other users of your account might be able to see this description, depending on the actions that they're allowed to perform in Amazon Macie.
    public var description: Swift.String?
    /// An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression contains any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4-90 UTF-8 characters. Ignore words are case sensitive.
    public var ignoreWords: [Swift.String]?
    /// An array that lists specific character sequences (keywords), one of which must precede and be within proximity (maximumMatchDistance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3-90 UTF-8 characters. Keywords aren't case sensitive.
    public var keywords: [Swift.String]?
    /// The maximum number of characters that can exist between the end of at least one complete character sequence specified by the keywords array and the end of the text that matches the regex pattern. If a complete keyword precedes all the text that matches the pattern and the keyword is within the specified distance, Amazon Macie includes the result. The distance can be 1-300 characters. The default value is 50.
    public var maximumMatchDistance: Swift.Int?
    /// A custom name for the custom data identifier. The name can contain as many as 128 characters. We strongly recommend that you avoid including any sensitive data in the name of a custom data identifier. Other users of your account might be able to see this name, depending on the actions that they're allowed to perform in Amazon Macie.
    /// This member is required.
    public var name: Swift.String?
    /// The regular expression (regex) that defines the pattern to match. The expression can contain as many as 512 characters.
    /// This member is required.
    public var regex: Swift.String?
    /// The severity to assign to findings that the custom data identifier produces, based on the number of occurrences of text that match the custom data identifier's detection criteria. You can specify as many as three SeverityLevel objects in this array, one for each severity: LOW, MEDIUM, or HIGH. If you specify more than one, the occurrences thresholds must be in ascending order by severity, moving from LOW to HIGH. For example, 1 for LOW, 50 for MEDIUM, and 100 for HIGH. If an S3 object contains fewer occurrences than the lowest specified threshold, Amazon Macie doesn't create a finding. If you don't specify any values for this array, Macie creates findings for S3 objects that contain at least one occurrence of text that matches the detection criteria, and Macie assigns the MEDIUM severity to those findings.
    public var severityLevels: [Macie2ClientTypes.SeverityLevel]?
    /// A map of key-value pairs that specifies the tags to associate with the custom data identifier. A custom data identifier can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ignoreWords: [Swift.String]? = nil,
        keywords: [Swift.String]? = nil,
        maximumMatchDistance: Swift.Int? = nil,
        name: Swift.String? = nil,
        regex: Swift.String? = nil,
        severityLevels: [Macie2ClientTypes.SeverityLevel]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.name = name
        self.regex = regex
        self.severityLevels = severityLevels
        self.tags = tags
    }
}

struct CreateCustomDataIdentifierInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let description: Swift.String?
    let ignoreWords: [Swift.String]?
    let keywords: [Swift.String]?
    let maximumMatchDistance: Swift.Int?
    let name: Swift.String?
    let regex: Swift.String?
    let severityLevels: [Macie2ClientTypes.SeverityLevel]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCustomDataIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case description = "description"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case severityLevels = "severityLevels"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ignoreWordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[Swift.String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [Swift.String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let severityLevelsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SeverityLevel?].self, forKey: .severityLevels)
        var severityLevelsDecoded0:[Macie2ClientTypes.SeverityLevel]? = nil
        if let severityLevelsContainer = severityLevelsContainer {
            severityLevelsDecoded0 = [Macie2ClientTypes.SeverityLevel]()
            for structure0 in severityLevelsContainer {
                if let structure0 = structure0 {
                    severityLevelsDecoded0?.append(structure0)
                }
            }
        }
        severityLevels = severityLevelsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomDataIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomDataIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.customDataIdentifierId = output.customDataIdentifierId
        } else {
            self.customDataIdentifierId = nil
        }
    }
}

public struct CreateCustomDataIdentifierOutput: Swift.Equatable {
    /// The unique identifier for the custom data identifier that was created.
    public var customDataIdentifierId: Swift.String?

    public init(
        customDataIdentifierId: Swift.String? = nil
    )
    {
        self.customDataIdentifierId = customDataIdentifierId
    }
}

struct CreateCustomDataIdentifierOutputBody: Swift.Equatable {
    let customDataIdentifierId: Swift.String?
}

extension CreateCustomDataIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDataIdentifierId = "customDataIdentifierId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataIdentifierIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDataIdentifierId)
        customDataIdentifierId = customDataIdentifierIdDecoded
    }
}

enum CreateCustomDataIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFindingsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFindingsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findingsfilters"
    }
}

public struct CreateFindingsFilterInput: Swift.Equatable {
    /// The action to perform on findings that match the filter criteria (findingCriteria). Valid values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.
    /// This member is required.
    public var action: Macie2ClientTypes.FindingsFilterAction?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// A custom description of the filter. The description can contain as many as 512 characters. We strongly recommend that you avoid including any sensitive data in the description of a filter. Other users of your account might be able to see this description, depending on the actions that they're allowed to perform in Amazon Macie.
    public var description: Swift.String?
    /// The criteria to use to filter findings.
    /// This member is required.
    public var findingCriteria: Macie2ClientTypes.FindingCriteria?
    /// A custom name for the filter. The name must contain at least 3 characters and can contain as many as 64 characters. We strongly recommend that you avoid including any sensitive data in the name of a filter. Other users of your account might be able to see this name, depending on the actions that they're allowed to perform in Amazon Macie.
    /// This member is required.
    public var name: Swift.String?
    /// The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.
    public var position: Swift.Int?
    /// A map of key-value pairs that specifies the tags to associate with the filter. A findings filter can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: Macie2ClientTypes.FindingsFilterAction? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        findingCriteria: Macie2ClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        position: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.position = position
        self.tags = tags
    }
}

struct CreateFindingsFilterInputBody: Swift.Equatable {
    let action: Macie2ClientTypes.FindingsFilterAction?
    let clientToken: Swift.String?
    let description: Swift.String?
    let findingCriteria: Macie2ClientTypes.FindingCriteria?
    let name: Swift.String?
    let position: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFindingsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .position)
        position = positionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFindingsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFindingsFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFindingsFilterOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the filter that was created.
    public var arn: Swift.String?
    /// The unique identifier for the filter that was created.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFindingsFilterOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateFindingsFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateFindingsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __string0 in accountIds {
                try accountIdsContainer.encode(__string0)
            }
        }
        if let disableEmailNotification = self.disableEmailNotification {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

extension CreateInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations"
    }
}

public struct CreateInvitationsInput: Swift.Equatable {
    /// An array that lists Amazon Web Services account IDs, one for each account to send the invitation to.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Specifies whether to send the invitation as an email message. If this value is false, Amazon Macie sends the invitation (as an email message) to the email address that you specified for the recipient's account when you associated the account with your account. The default value is false.
    public var disableEmailNotification: Swift.Bool?
    /// Custom text to include in the email message that contains the invitation. The text can contain as many as 80 alphanumeric characters.
    public var message: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        disableEmailNotification: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct CreateInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let disableEmailNotification: Swift.Bool?
    let message: Swift.String?
}

extension CreateInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateInvitationsOutput: Swift.Equatable {
    /// An array of objects, one for each account whose invitation hasn't been processed. Each object identifies the account and explains why the invitation hasn't been processed for the account.
    public var unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateInvitationsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?
}

extension CreateInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Macie2ClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Macie2ClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum CreateInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "account"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members"
    }
}

public struct CreateMemberInput: Swift.Equatable {
    /// The details of the account to associate with the administrator account.
    /// This member is required.
    public var account: Macie2ClientTypes.AccountDetail?
    /// A map of key-value pairs that specifies the tags to associate with the account in Amazon Macie. An account can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        account: Macie2ClientTypes.AccountDetail? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.account = account
        self.tags = tags
    }
}

struct CreateMemberInputBody: Swift.Equatable {
    let account: Macie2ClientTypes.AccountDetail?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "account"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AccountDetail.self, forKey: .account)
        account = accountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateMemberOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the account that was associated with the administrator account.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateMemberOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSampleFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for findingtype0 in findingTypes {
                try findingTypesContainer.encode(findingtype0.rawValue)
            }
        }
    }
}

extension CreateSampleFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/sample"
    }
}

public struct CreateSampleFindingsInput: Swift.Equatable {
    /// An array of finding types, one for each type of sample finding to create. To create a sample of every type of finding that Amazon Macie supports, don't include this array in your request.
    public var findingTypes: [Macie2ClientTypes.FindingType]?

    public init(
        findingTypes: [Macie2ClientTypes.FindingType]? = nil
    )
    {
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Swift.Equatable {
    let findingTypes: [Macie2ClientTypes.FindingType]?
}

extension CreateSampleFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.FindingType?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[Macie2ClientTypes.FindingType]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [Macie2ClientTypes.FindingType]()
            for enum0 in findingTypesContainer {
                if let enum0 = enum0 {
                    findingTypesDecoded0?.append(enum0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateSampleFindingsOutput: Swift.Equatable {

    public init() { }
}

enum CreateSampleFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.CriteriaBlockForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for criteriaforjob0 in and {
                try andContainer.encode(criteriaforjob0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.CriteriaForJob?].self, forKey: .and)
        var andDecoded0:[Macie2ClientTypes.CriteriaForJob]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [Macie2ClientTypes.CriteriaForJob]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 buckets from a classification job.
    public struct CriteriaBlockForJob: Swift.Equatable {
        /// An array of conditions, one for each condition that determines which buckets to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.
        public var and: [Macie2ClientTypes.CriteriaForJob]?

        public init(
            and: [Macie2ClientTypes.CriteriaForJob]? = nil
        )
        {
            self.and = and
        }
    }

}

extension Macie2ClientTypes.CriteriaForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleCriterion = "simpleCriterion"
        case tagCriterion = "tagCriterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleCriterion = self.simpleCriterion {
            try encodeContainer.encode(simpleCriterion, forKey: .simpleCriterion)
        }
        if let tagCriterion = self.tagCriterion {
            try encodeContainer.encode(tagCriterion, forKey: .tagCriterion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleCriterionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SimpleCriterionForJob.self, forKey: .simpleCriterion)
        simpleCriterion = simpleCriterionDecoded
        let tagCriterionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TagCriterionForJob.self, forKey: .tagCriterion)
        tagCriterion = tagCriterionDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a property- or tag-based condition that defines criteria for including or excluding S3 buckets from a classification job.
    public struct CriteriaForJob: Swift.Equatable {
        /// A property-based condition that defines a property, operator, and one or more values for including or excluding buckets from the job.
        public var simpleCriterion: Macie2ClientTypes.SimpleCriterionForJob?
        /// A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding buckets from the job.
        public var tagCriterion: Macie2ClientTypes.TagCriterionForJob?

        public init(
            simpleCriterion: Macie2ClientTypes.SimpleCriterionForJob? = nil,
            tagCriterion: Macie2ClientTypes.TagCriterionForJob? = nil
        )
        {
            self.simpleCriterion = simpleCriterion
            self.tagCriterion = tagCriterion
        }
    }

}

extension Macie2ClientTypes.CriterionAdditionalProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "eq"
        case eqExactMatch = "eqExactMatch"
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for __string0 in eq {
                try eqContainer.encode(__string0)
            }
        }
        if let eqExactMatch = eqExactMatch {
            var eqExactMatchContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eqExactMatch)
            for __string0 in eqExactMatch {
                try eqExactMatchContainer.encode(__string0)
            }
        }
        if let gt = self.gt {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if let gte = self.gte {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if let lt = self.lt {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if let lte = self.lte {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for __string0 in neq {
                try neqContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let eqExactMatchContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eqExactMatch)
        var eqExactMatchDecoded0:[Swift.String]? = nil
        if let eqExactMatchContainer = eqExactMatchContainer {
            eqExactMatchDecoded0 = [Swift.String]()
            for string0 in eqExactMatchContainer {
                if let string0 = string0 {
                    eqExactMatchDecoded0?.append(string0)
                }
            }
        }
        eqExactMatch = eqExactMatchDecoded0
        let gtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lte)
        lte = lteDecoded
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies the operator to use in a property-based condition that filters the results of a query for findings. For detailed information and examples of each operator, see [Fundamentals of filtering findings](https://docs.aws.amazon.com/macie/latest/user/findings-filter-basics.html) in the Amazon Macie User Guide.
    public struct CriterionAdditionalProperties: Swift.Equatable {
        /// The value for the property matches (equals) the specified value. If you specify multiple values, Macie uses OR logic to join the values.
        public var eq: [Swift.String]?
        /// The value for the property exclusively matches (equals an exact match for) all the specified values. If you specify multiple values, Amazon Macie uses AND logic to join the values. You can use this operator with the following properties: customDataIdentifiers.detections.arn, customDataIdentifiers.detections.name, resourcesAffected.s3Bucket.tags.key, resourcesAffected.s3Bucket.tags.value, resourcesAffected.s3Object.tags.key, resourcesAffected.s3Object.tags.value, sensitiveData.category, and sensitiveData.detections.type.
        public var eqExactMatch: [Swift.String]?
        /// The value for the property is greater than the specified value.
        public var gt: Swift.Int?
        /// The value for the property is greater than or equal to the specified value.
        public var gte: Swift.Int?
        /// The value for the property is less than the specified value.
        public var lt: Swift.Int?
        /// The value for the property is less than or equal to the specified value.
        public var lte: Swift.Int?
        /// The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Macie uses OR logic to join the values.
        public var neq: [Swift.String]?

        public init(
            eq: [Swift.String]? = nil,
            eqExactMatch: [Swift.String]? = nil,
            gt: Swift.Int? = nil,
            gte: Swift.Int? = nil,
            lt: Swift.Int? = nil,
            lte: Swift.Int? = nil,
            neq: [Swift.String]? = nil
        )
        {
            self.eq = eq
            self.eqExactMatch = eqExactMatch
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
        }
    }

}

extension Macie2ClientTypes {
    /// The type of currency that the data for an Amazon Macie usage metric is reported in. Possible values are:
    public enum Currency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [Currency] {
            return [
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Currency(rawValue: rawValue) ?? Currency.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.CustomDataIdentifierSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a custom data identifier.
    public struct CustomDataIdentifierSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom data identifier.
        public var arn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.
        public var createdAt: ClientRuntime.Date?
        /// The custom description of the custom data identifier.
        public var description: Swift.String?
        /// The unique identifier for the custom data identifier.
        public var id: Swift.String?
        /// The custom name of the custom data identifier.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension Macie2ClientTypes.CustomDataIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detections = "detections"
        case totalCount = "totalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for customdetection0 in detections {
                try detectionsContainer.encode(customdetection0)
            }
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectionsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.CustomDetection?].self, forKey: .detections)
        var detectionsDecoded0:[Macie2ClientTypes.CustomDetection]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [Macie2ClientTypes.CustomDetection]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about custom data identifiers that produced a sensitive data finding, and the number of occurrences of the data that they detected for the finding.
    public struct CustomDataIdentifiers: Swift.Equatable {
        /// The custom data identifiers that detected the data, and the number of occurrences of the data that each identifier detected.
        public var detections: [Macie2ClientTypes.CustomDetection]?
        /// The total number of occurrences of the data that was detected by the custom data identifiers and produced the finding.
        public var totalCount: Swift.Int?

        public init(
            detections: [Macie2ClientTypes.CustomDetection]? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension Macie2ClientTypes.CustomDetection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case count = "count"
        case name = "name"
        case occurrences = "occurrences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let occurrences = self.occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a custom data identifier that produced a sensitive data finding, and the sensitive data that it detected for the finding.
    public struct CustomDetection: Swift.Equatable {
        /// The unique identifier for the custom data identifier.
        public var arn: Swift.String?
        /// The total number of occurrences of the sensitive data that the custom data identifier detected.
        public var count: Swift.Int?
        /// The name of the custom data identifier.
        public var name: Swift.String?
        /// The location of 1-15 occurrences of the sensitive data that the custom data identifier detected. A finding includes location data for a maximum of 15 occurrences of sensitive data.
        public var occurrences: Macie2ClientTypes.Occurrences?

        public init(
            arn: Swift.String? = nil,
            count: Swift.Int? = nil,
            name: Swift.String? = nil,
            occurrences: Macie2ClientTypes.Occurrences? = nil
        )
        {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }
    }

}

extension Macie2ClientTypes.DailySchedule: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension Macie2ClientTypes {
    /// Specifies that a classification job runs once a day, every day. This is an empty object.
    public struct DailySchedule: Swift.Equatable {

        public init() { }
    }

}

extension Macie2ClientTypes {
    /// The severity of a finding, ranging from LOW, for least severe, to HIGH, for most severe. Valid values are:
    public enum DataIdentifierSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIdentifierSeverity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataIdentifierSeverity(rawValue: rawValue) ?? DataIdentifierSeverity.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The type of data identifier that detected a specific type of sensitive data in an S3 bucket. Possible values are:
    public enum DataIdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIdentifierType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .managed: return "MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataIdentifierType(rawValue: rawValue) ?? DataIdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeclineInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __string0 in accountIds {
                try accountIdsContainer.encode(__string0)
            }
        }
    }
}

extension DeclineInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/decline"
    }
}

public struct DeclineInvitationsInput: Swift.Equatable {
    /// An array that lists Amazon Web Services account IDs, one for each account that sent an invitation to decline.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeclineInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeclineInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutput: Swift.Equatable {
    /// An array of objects, one for each account whose invitation hasn't been declined. Each object identifies the account and explains why the request hasn't been processed for that account.
    public var unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?
}

extension DeclineInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Macie2ClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Macie2ClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DeclineInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.DefaultDetection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "count"
        case occurrences = "occurrences"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let occurrences = self.occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a type of sensitive data that was detected by a managed data identifier and produced a sensitive data finding.
    public struct DefaultDetection: Swift.Equatable {
        /// The total number of occurrences of the type of sensitive data that was detected.
        public var count: Swift.Int?
        /// The location of 1-15 occurrences of the sensitive data that was detected. A finding includes location data for a maximum of 15 occurrences of sensitive data.
        public var occurrences: Macie2ClientTypes.Occurrences?
        /// The type of sensitive data that was detected. For example, AWS_CREDENTIALS, PHONE_NUMBER, or ADDRESS.
        public var type: Swift.String?

        public init(
            count: Swift.Int? = nil,
            occurrences: Macie2ClientTypes.Occurrences? = nil,
            type: Swift.String? = nil
        )
        {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }
    }

}

extension DeleteAllowListInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ignoreJobChecks = ignoreJobChecks {
                let ignoreJobChecksQueryItem = ClientRuntime.URLQueryItem(name: "ignoreJobChecks".urlPercentEncoding(), value: Swift.String(ignoreJobChecks).urlPercentEncoding())
                items.append(ignoreJobChecksQueryItem)
            }
            return items
        }
    }
}

extension DeleteAllowListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/allow-lists/\(id.urlPercentEncoding())"
    }
}

public struct DeleteAllowListInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether to force deletion of the allow list, even if active classification jobs are configured to use the list. When you try to delete an allow list, Amazon Macie checks for classification jobs that use the list and have a status other than COMPLETE or CANCELLED. By default, Macie rejects your request if any jobs meet these criteria. To skip these checks and delete the list, set this value to true. To delete the list only if no active jobs are configured to use it, set this value to false.
    public var ignoreJobChecks: Swift.String?

    public init(
        id: Swift.String? = nil,
        ignoreJobChecks: Swift.String? = nil
    )
    {
        self.id = id
        self.ignoreJobChecks = ignoreJobChecks
    }
}

struct DeleteAllowListInputBody: Swift.Equatable {
}

extension DeleteAllowListInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAllowListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAllowListOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAllowListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomDataIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/custom-data-identifiers/\(id.urlPercentEncoding())"
    }
}

public struct DeleteCustomDataIdentifierInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteCustomDataIdentifierInputBody: Swift.Equatable {
}

extension DeleteCustomDataIdentifierInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomDataIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomDataIdentifierOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomDataIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFindingsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/findingsfilters/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFindingsFilterInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFindingsFilterInputBody: Swift.Equatable {
}

extension DeleteFindingsFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFindingsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFindingsFilterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFindingsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __string0 in accountIds {
                try accountIdsContainer.encode(__string0)
            }
        }
    }
}

extension DeleteInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/delete"
    }
}

public struct DeleteInvitationsInput: Swift.Equatable {
    /// An array that lists Amazon Web Services account IDs, one for each account that sent an invitation to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutput: Swift.Equatable {
    /// An array of objects, one for each account whose invitation hasn't been deleted. Each object identifies the account and explains why the request hasn't been processed for that account.
    public var unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [Macie2ClientTypes.UnprocessedAccount]?
}

extension DeleteInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[Macie2ClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [Macie2ClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DeleteInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/members/\(id.urlPercentEncoding())"
    }
}

public struct DeleteMemberInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMemberInputBody: Swift.Equatable {
}

extension DeleteMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMemberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBucketsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria = "criteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = criteria {
            var criteriaContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .criteria)
            for (dictKey0, bucketCriteria0) in criteria {
                try criteriaContainer.encode(bucketCriteria0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension DescribeBucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasources/s3"
    }
}

public struct DescribeBucketsInput: Swift.Equatable {
    /// The criteria to use to filter the query results.
    public var criteria: [Swift.String:Macie2ClientTypes.BucketCriteriaAdditionalProperties]?
    /// The maximum number of items to include in each page of the response. The default value is 50.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The criteria to use to sort the query results.
    public var sortCriteria: Macie2ClientTypes.BucketSortCriteria?

    public init(
        criteria: [Swift.String:Macie2ClientTypes.BucketCriteriaAdditionalProperties]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Macie2ClientTypes.BucketSortCriteria? = nil
    )
    {
        self.criteria = criteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct DescribeBucketsInputBody: Swift.Equatable {
    let criteria: [Swift.String:Macie2ClientTypes.BucketCriteriaAdditionalProperties]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortCriteria: Macie2ClientTypes.BucketSortCriteria?
}

extension DescribeBucketsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria = "criteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaContainer = try containerValues.decodeIfPresent([Swift.String: Macie2ClientTypes.BucketCriteriaAdditionalProperties?].self, forKey: .criteria)
        var criteriaDecoded0: [Swift.String:Macie2ClientTypes.BucketCriteriaAdditionalProperties]? = nil
        if let criteriaContainer = criteriaContainer {
            criteriaDecoded0 = [Swift.String:Macie2ClientTypes.BucketCriteriaAdditionalProperties]()
            for (key0, bucketcriteriaadditionalproperties0) in criteriaContainer {
                if let bucketcriteriaadditionalproperties0 = bucketcriteriaadditionalproperties0 {
                    criteriaDecoded0?[key0] = bucketcriteriaadditionalproperties0
                }
            }
        }
        criteria = criteriaDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension DescribeBucketsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBucketsOutputBody = try responseDecoder.decode(responseBody: data)
            self.buckets = output.buckets
            self.nextToken = output.nextToken
        } else {
            self.buckets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBucketsOutput: Swift.Equatable {
    /// An array of objects, one for each bucket that matches the filter criteria specified in the request.
    public var buckets: [Macie2ClientTypes.BucketMetadata]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        buckets: [Macie2ClientTypes.BucketMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.buckets = buckets
        self.nextToken = nextToken
    }
}

struct DescribeBucketsOutputBody: Swift.Equatable {
    let buckets: [Macie2ClientTypes.BucketMetadata]?
    let nextToken: Swift.String?
}

extension DescribeBucketsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "buckets"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.BucketMetadata?].self, forKey: .buckets)
        var bucketsDecoded0:[Macie2ClientTypes.BucketMetadata]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [Macie2ClientTypes.BucketMetadata]()
            for structure0 in bucketsContainer {
                if let structure0 = structure0 {
                    bucketsDecoded0?.append(structure0)
                }
            }
        }
        buckets = bucketsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBucketsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClassificationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeClassificationJobInput: Swift.Equatable {
    /// The unique identifier for the classification job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeClassificationJobInputBody: Swift.Equatable {
}

extension DescribeClassificationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClassificationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClassificationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowListIds = output.allowListIds
            self.clientToken = output.clientToken
            self.createdAt = output.createdAt
            self.customDataIdentifierIds = output.customDataIdentifierIds
            self.description = output.description
            self.initialRun = output.initialRun
            self.jobArn = output.jobArn
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
            self.jobType = output.jobType
            self.lastRunErrorStatus = output.lastRunErrorStatus
            self.lastRunTime = output.lastRunTime
            self.managedDataIdentifierIds = output.managedDataIdentifierIds
            self.managedDataIdentifierSelector = output.managedDataIdentifierSelector
            self.name = output.name
            self.s3JobDefinition = output.s3JobDefinition
            self.samplingPercentage = output.samplingPercentage
            self.scheduleFrequency = output.scheduleFrequency
            self.statistics = output.statistics
            self.tags = output.tags
            self.userPausedDetails = output.userPausedDetails
        } else {
            self.allowListIds = nil
            self.clientToken = nil
            self.createdAt = nil
            self.customDataIdentifierIds = nil
            self.description = nil
            self.initialRun = nil
            self.jobArn = nil
            self.jobId = nil
            self.jobStatus = nil
            self.jobType = nil
            self.lastRunErrorStatus = nil
            self.lastRunTime = nil
            self.managedDataIdentifierIds = nil
            self.managedDataIdentifierSelector = nil
            self.name = nil
            self.s3JobDefinition = nil
            self.samplingPercentage = nil
            self.scheduleFrequency = nil
            self.statistics = nil
            self.tags = nil
            self.userPausedDetails = nil
        }
    }
}

public struct DescribeClassificationJobOutput: Swift.Equatable {
    /// An array of unique identifiers, one for each allow list that the job uses when it analyzes data.
    public var allowListIds: [Swift.String]?
    /// The token that was provided to ensure the idempotency of the request to create the job.
    public var clientToken: Swift.String?
    /// The date and time, in UTC and extended ISO 8601 format, when the job was created.
    public var createdAt: ClientRuntime.Date?
    /// An array of unique identifiers, one for each custom data identifier that the job uses when it analyzes data. This value is null if the job uses only managed data identifiers to analyze data.
    public var customDataIdentifierIds: [Swift.String]?
    /// The custom description of the job.
    public var description: Swift.String?
    /// For a recurring job, specifies whether you configured the job to analyze all existing, eligible objects immediately after the job was created (true). If you configured the job to analyze only those objects that were created or changed after the job was created and before the job's first scheduled run, this value is false. This value is also false for a one-time job.
    public var initialRun: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the job.
    public var jobArn: Swift.String?
    /// The unique identifier for the job.
    public var jobId: Swift.String?
    /// The current status of the job. Possible values are:
    ///
    /// * CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.
    ///
    /// * COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.
    ///
    /// * IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.
    ///
    /// * PAUSED - Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.
    ///
    /// * RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.
    ///
    /// * USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.
    public var jobStatus: Macie2ClientTypes.JobStatus?
    /// The schedule for running the job. Possible values are:
    ///
    /// * ONE_TIME - The job runs only once.
    ///
    /// * SCHEDULED - The job runs on a daily, weekly, or monthly basis. The scheduleFrequency property indicates the recurrence pattern for the job.
    public var jobType: Macie2ClientTypes.JobType?
    /// Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.
    public var lastRunErrorStatus: Macie2ClientTypes.LastRunErrorStatus?
    /// The date and time, in UTC and extended ISO 8601 format, when the job started. If the job is a recurring job, this value indicates when the most recent run started or, if the job hasn't run yet, when the job was created.
    public var lastRunTime: ClientRuntime.Date?
    /// An array of unique identifiers, one for each managed data identifier that the job is explicitly configured to include (use) or exclude (not use) when it analyzes data. Inclusion or exclusion depends on the managed data identifier selection type specified for the job (managedDataIdentifierSelector).This value is null if the job's managed data identifier selection type is ALL, NONE, or RECOMMENDED.
    public var managedDataIdentifierIds: [Swift.String]?
    /// The selection type that determines which managed data identifiers the job uses when it analyzes data. Possible values are:
    ///
    /// * ALL - Use all managed data identifiers.
    ///
    /// * EXCLUDE - Use all managed data identifiers except the ones specified by the managedDataIdentifierIds property.
    ///
    /// * INCLUDE - Use only the managed data identifiers specified by the managedDataIdentifierIds property.
    ///
    /// * NONE - Don't use any managed data identifiers. Use only custom data identifiers (customDataIdentifierIds).
    ///
    /// * RECOMMENDED (default) - Use the recommended set of managed data identifiers.
    ///
    ///
    /// If this value is null, the job uses the recommended set of managed data identifiers. If the job is a recurring job and this value is ALL or EXCLUDE, each job run automatically uses new managed data identifiers that are released. If this value is null or RECOMMENDED for a recurring job, each job run uses all the managed data identifiers that are in the recommended set when the run starts. For information about individual managed data identifiers or to determine which ones are in the recommended set, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) and [Recommended managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/discovery-jobs-mdis-recommended.html) in the Amazon Macie User Guide.
    public var managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector?
    /// The custom name of the job.
    public var name: Swift.String?
    /// The S3 buckets that contain the objects to analyze, and the scope of that analysis.
    public var s3JobDefinition: Macie2ClientTypes.S3JobDefinition?
    /// The sampling depth, as a percentage, that determines the percentage of eligible objects that the job analyzes.
    public var samplingPercentage: Swift.Int?
    /// The recurrence pattern for running the job. This value is null if the job is configured to run only once.
    public var scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency?
    /// The number of times that the job has run and processing statistics for the job's current run.
    public var statistics: Macie2ClientTypes.Statistics?
    /// A map of key-value pairs that specifies which tags (keys and values) are associated with the classification job.
    public var tags: [Swift.String:Swift.String]?
    /// If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.
    public var userPausedDetails: Macie2ClientTypes.UserPausedDetails?

    public init(
        allowListIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        customDataIdentifierIds: [Swift.String]? = nil,
        description: Swift.String? = nil,
        initialRun: Swift.Bool? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: Macie2ClientTypes.JobStatus? = nil,
        jobType: Macie2ClientTypes.JobType? = nil,
        lastRunErrorStatus: Macie2ClientTypes.LastRunErrorStatus? = nil,
        lastRunTime: ClientRuntime.Date? = nil,
        managedDataIdentifierIds: [Swift.String]? = nil,
        managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector? = nil,
        name: Swift.String? = nil,
        s3JobDefinition: Macie2ClientTypes.S3JobDefinition? = nil,
        samplingPercentage: Swift.Int? = nil,
        scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency? = nil,
        statistics: Macie2ClientTypes.Statistics? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userPausedDetails: Macie2ClientTypes.UserPausedDetails? = nil
    )
    {
        self.allowListIds = allowListIds
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.customDataIdentifierIds = customDataIdentifierIds
        self.description = description
        self.initialRun = initialRun
        self.jobArn = jobArn
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.lastRunErrorStatus = lastRunErrorStatus
        self.lastRunTime = lastRunTime
        self.managedDataIdentifierIds = managedDataIdentifierIds
        self.managedDataIdentifierSelector = managedDataIdentifierSelector
        self.name = name
        self.s3JobDefinition = s3JobDefinition
        self.samplingPercentage = samplingPercentage
        self.scheduleFrequency = scheduleFrequency
        self.statistics = statistics
        self.tags = tags
        self.userPausedDetails = userPausedDetails
    }
}

struct DescribeClassificationJobOutputBody: Swift.Equatable {
    let allowListIds: [Swift.String]?
    let clientToken: Swift.String?
    let createdAt: ClientRuntime.Date?
    let customDataIdentifierIds: [Swift.String]?
    let description: Swift.String?
    let initialRun: Swift.Bool?
    let jobArn: Swift.String?
    let jobId: Swift.String?
    let jobStatus: Macie2ClientTypes.JobStatus?
    let jobType: Macie2ClientTypes.JobType?
    let lastRunErrorStatus: Macie2ClientTypes.LastRunErrorStatus?
    let lastRunTime: ClientRuntime.Date?
    let managedDataIdentifierIds: [Swift.String]?
    let managedDataIdentifierSelector: Macie2ClientTypes.ManagedDataIdentifierSelector?
    let name: Swift.String?
    let s3JobDefinition: Macie2ClientTypes.S3JobDefinition?
    let samplingPercentage: Swift.Int?
    let scheduleFrequency: Macie2ClientTypes.JobScheduleFrequency?
    let statistics: Macie2ClientTypes.Statistics?
    let tags: [Swift.String:Swift.String]?
    let userPausedDetails: Macie2ClientTypes.UserPausedDetails?
}

extension DescribeClassificationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowListIds = "allowListIds"
        case clientToken = "clientToken"
        case createdAt = "createdAt"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobArn = "jobArn"
        case jobId = "jobId"
        case jobStatus = "jobStatus"
        case jobType = "jobType"
        case lastRunErrorStatus = "lastRunErrorStatus"
        case lastRunTime = "lastRunTime"
        case managedDataIdentifierIds = "managedDataIdentifierIds"
        case managedDataIdentifierSelector = "managedDataIdentifierSelector"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case statistics = "statistics"
        case tags = "tags"
        case userPausedDetails = "userPausedDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowListIds)
        var allowListIdsDecoded0:[Swift.String]? = nil
        if let allowListIdsContainer = allowListIdsContainer {
            allowListIdsDecoded0 = [Swift.String]()
            for string0 in allowListIdsContainer {
                if let string0 = string0 {
                    allowListIdsDecoded0?.append(string0)
                }
            }
        }
        allowListIds = allowListIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let customDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customDataIdentifierIds)
        var customDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let customDataIdentifierIdsContainer = customDataIdentifierIdsContainer {
            customDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in customDataIdentifierIdsContainer {
                if let string0 = string0 {
                    customDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        customDataIdentifierIds = customDataIdentifierIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let initialRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .initialRun)
        initialRun = initialRunDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let lastRunErrorStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.LastRunErrorStatus.self, forKey: .lastRunErrorStatus)
        lastRunErrorStatus = lastRunErrorStatusDecoded
        let lastRunTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunTime)
        lastRunTime = lastRunTimeDecoded
        let managedDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedDataIdentifierIds)
        var managedDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let managedDataIdentifierIdsContainer = managedDataIdentifierIdsContainer {
            managedDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in managedDataIdentifierIdsContainer {
                if let string0 = string0 {
                    managedDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        managedDataIdentifierIds = managedDataIdentifierIdsDecoded0
        let managedDataIdentifierSelectorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ManagedDataIdentifierSelector.self, forKey: .managedDataIdentifierSelector)
        managedDataIdentifierSelector = managedDataIdentifierSelectorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3JobDefinitionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3JobDefinition.self, forKey: .s3JobDefinition)
        s3JobDefinition = s3JobDefinitionDecoded
        let samplingPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingPercentage)
        samplingPercentage = samplingPercentageDecoded
        let scheduleFrequencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobScheduleFrequency.self, forKey: .scheduleFrequency)
        scheduleFrequency = scheduleFrequencyDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Statistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let userPausedDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UserPausedDetails.self, forKey: .userPausedDetails)
        userPausedDetails = userPausedDetailsDecoded
    }
}

enum DescribeClassificationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/configuration"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.maxAccountLimitReached = output.maxAccountLimitReached
        } else {
            self.autoEnable = nil
            self.maxAccountLimitReached = nil
        }
    }
}

public struct DescribeOrganizationConfigurationOutput: Swift.Equatable {
    /// Specifies whether Amazon Macie is enabled automatically for accounts that are added to the organization.
    public var autoEnable: Swift.Bool?
    /// Specifies whether the maximum number of Amazon Macie member accounts are part of the organization.
    public var maxAccountLimitReached: Swift.Bool?

    public init(
        autoEnable: Swift.Bool? = nil,
        maxAccountLimitReached: Swift.Bool? = nil
    )
    {
        self.autoEnable = autoEnable
        self.maxAccountLimitReached = maxAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputBody: Swift.Equatable {
    let autoEnable: Swift.Bool?
    let maxAccountLimitReached: Swift.Bool?
}

extension DescribeOrganizationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case maxAccountLimitReached = "maxAccountLimitReached"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let maxAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .maxAccountLimitReached)
        maxAccountLimitReached = maxAccountLimitReachedDecoded
    }
}

enum DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.DetectedDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies 1-10 occurrences of a specific type of sensitive data reported by a finding.
    public struct DetectedDataDetails: Swift.Equatable {
        /// An occurrence of the specified type of sensitive data. Each occurrence can contain 1-128 characters.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension Macie2ClientTypes.Detection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case count = "count"
        case id = "id"
        case name = "name"
        case suppressed = "suppressed"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let suppressed = self.suppressed {
            try encodeContainer.encode(suppressed, forKey: .suppressed)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let suppressedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressed)
        suppressed = suppressedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DataIdentifierType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a type of sensitive data that Amazon Macie found in an S3 bucket while performing automated sensitive data discovery for the bucket. The information also specifies the custom data identifier or managed data identifier that detected the data. This information is available only if automated sensitive data discovery is currently enabled for your account.
    public struct Detection: Swift.Equatable {
        /// If the sensitive data was detected by a custom data identifier, the Amazon Resource Name (ARN) of the custom data identifier that detected the data. Otherwise, this value is null.
        public var arn: Swift.String?
        /// The total number of occurrences of the sensitive data.
        public var count: Swift.Int?
        /// The unique identifier for the custom data identifier or managed data identifier that detected the sensitive data. For additional details about a specified managed data identifier, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) in the Amazon Macie User Guide.
        public var id: Swift.String?
        /// The name of the custom data identifier or managed data identifier that detected the sensitive data. For a managed data identifier, this value is the same as the unique identifier (id).
        public var name: Swift.String?
        /// Specifies whether occurrences of this type of sensitive data are excluded (true) or included (false) in the bucket's sensitivity score.
        public var suppressed: Swift.Bool?
        /// The type of data identifier that detected the sensitive data. Possible values are: CUSTOM, for a custom data identifier; and, MANAGED, for a managed data identifier.
        public var type: Macie2ClientTypes.DataIdentifierType?

        public init(
            arn: Swift.String? = nil,
            count: Swift.Int? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            suppressed: Swift.Bool? = nil,
            type: Macie2ClientTypes.DataIdentifierType? = nil
        )
        {
            self.arn = arn
            self.count = count
            self.id = id
            self.name = name
            self.suppressed = suppressed
            self.type = type
        }
    }

}

extension DisableMacieInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/macie"
    }
}

public struct DisableMacieInput: Swift.Equatable {

    public init() { }
}

struct DisableMacieInputBody: Swift.Equatable {
}

extension DisableMacieInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableMacieOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableMacieOutput: Swift.Equatable {

    public init() { }
}

enum DisableMacieOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let adminAccountId = adminAccountId else {
                let message = "Creating a URL Query Item failed. adminAccountId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let adminAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "adminAccountId".urlPercentEncoding(), value: Swift.String(adminAccountId).urlPercentEncoding())
            items.append(adminAccountIdQueryItem)
            return items
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the delegated Amazon Macie administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableOrganizationAdminAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFromAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/administrator/disassociate"
    }
}

public struct DisassociateFromAdministratorAccountInput: Swift.Equatable {

    public init() { }
}

struct DisassociateFromAdministratorAccountInputBody: Swift.Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateFromAdministratorAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFromAdministratorAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFromMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/master/disassociate"
    }
}

public struct DisassociateFromMasterAccountInput: Swift.Equatable {

    public init() { }
}

struct DisassociateFromMasterAccountInputBody: Swift.Equatable {
}

extension DisassociateFromMasterAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateFromMasterAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFromMasterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/members/disassociate/\(id.urlPercentEncoding())"
    }
}

public struct DisassociateMemberInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateMemberInputBody: Swift.Equatable {
}

extension DisassociateMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.DomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the domain name of the device that an entity used to perform an action on an affected resource.
    public struct DomainDetails: Swift.Equatable {
        /// The name of the domain.
        public var domainName: Swift.String?

        public init(
            domainName: Swift.String? = nil
        )
        {
            self.domainName = domainName
        }
    }

}

extension Macie2ClientTypes {
    public enum EffectivePermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notPublic
        case `public`
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [EffectivePermission] {
            return [
                .notPublic,
                .public,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notPublic: return "NOT_PUBLIC"
            case .public: return "PUBLIC"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EffectivePermission(rawValue: rawValue) ?? EffectivePermission.sdkUnknown(rawValue)
        }
    }
}

extension EnableMacieInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension EnableMacieInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/macie"
    }
}

public struct EnableMacieInput: Swift.Equatable {
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Specifies how often to publish updates to policy findings for the account. This includes publishing updates to Security Hub and Amazon EventBridge (formerly Amazon CloudWatch Events).
    public var findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    /// Specifies the new status for the account. To enable Amazon Macie and start all Macie activities for the account, set this value to ENABLED.
    public var status: Macie2ClientTypes.MacieStatus?

    public init(
        clientToken: Swift.String? = nil,
        findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency? = nil,
        status: Macie2ClientTypes.MacieStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.findingPublishingFrequency = findingPublishingFrequency
        self.status = status
    }
}

struct EnableMacieInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    let status: Macie2ClientTypes.MacieStatus?
}

extension EnableMacieInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension EnableMacieOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableMacieOutput: Swift.Equatable {

    public init() { }
}

enum EnableMacieOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
        case clientToken = "clientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account to designate as the delegated Amazon Macie administrator account for the organization.
    /// This member is required.
    public var adminAccountId: Swift.String?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.clientToken = clientToken
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let clientToken: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
        case clientToken = "clientToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableOrganizationAdminAccountOutput: Swift.Equatable {

    public init() { }
}

enum EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes {
    /// The server-side encryption algorithm that was used to encrypt an S3 object or is used by default to encrypt objects that are added to an S3 bucket. Possible values are:
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case `none`
        case unknown
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .aes256,
                .none,
                .unknown,
                .awsKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .none: return "NONE"
            case .unknown: return "UNKNOWN"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The source of an issue or delay. Possible values are:
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clienterror
        case internalerror
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .clienterror,
                .internalerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clienterror: return "ClientError"
            case .internalerror: return "InternalError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.FederatedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "accessKeyId"
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case sessionContext = "sessionContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sessionContext = self.sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an identity that performed an action on an affected resource by using temporary security credentials. The credentials were obtained using the GetFederationToken operation of the Security Token Service (STS) API.
    public struct FederatedUser: Swift.Equatable {
        /// The Amazon Web Services access key ID that identifies the credentials.
        public var accessKeyId: Swift.String?
        /// The unique identifier for the Amazon Web Services account that owns the entity that was used to get the credentials.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the entity that was used to get the credentials.
        public var arn: Swift.String?
        /// The unique identifier for the entity that was used to get the credentials.
        public var principalId: Swift.String?
        /// The details of the session that was created for the credentials, including the entity that issued the session.
        public var sessionContext: Macie2ClientTypes.SessionContext?

        public init(
            accessKeyId: Swift.String? = nil,
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            sessionContext: Macie2ClientTypes.SessionContext? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }
    }

}

extension Macie2ClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case archived = "archived"
        case category = "category"
        case classificationDetails = "classificationDetails"
        case count = "count"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case policyDetails = "policyDetails"
        case region = "region"
        case resourcesAffected = "resourcesAffected"
        case sample = "sample"
        case schemaVersion = "schemaVersion"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let archived = self.archived {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let classificationDetails = self.classificationDetails {
            try encodeContainer.encode(classificationDetails, forKey: .classificationDetails)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let policyDetails = self.policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourcesAffected = self.resourcesAffected {
            try encodeContainer.encode(resourcesAffected, forKey: .resourcesAffected)
        }
        if let sample = self.sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let archivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archived)
        archived = archivedDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCategory.self, forKey: .category)
        category = categoryDecoded
        let classificationDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationDetails.self, forKey: .classificationDetails)
        classificationDetails = classificationDetailsDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourcesAffectedDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ResourcesAffected.self, forKey: .resourcesAffected)
        resourcesAffected = resourcesAffectedDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sample)
        sample = sampleDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides the details of a finding.
    public struct Finding: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that the finding applies to. This is typically the account that owns the affected resource.
        public var accountId: Swift.String?
        /// Specifies whether the finding is archived (suppressed).
        public var archived: Swift.Bool?
        /// The category of the finding. Possible values are: CLASSIFICATION, for a sensitive data finding; and, POLICY, for a policy finding.
        public var category: Macie2ClientTypes.FindingCategory?
        /// The details of a sensitive data finding. This value is null for a policy finding.
        public var classificationDetails: Macie2ClientTypes.ClassificationDetails?
        /// The total number of occurrences of the finding. For sensitive data findings, this value is always 1. All sensitive data findings are considered unique.
        public var count: Swift.Int?
        /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie created the finding.
        public var createdAt: ClientRuntime.Date?
        /// The description of the finding.
        public var description: Swift.String?
        /// The unique identifier for the finding. This is a random string that Amazon Macie generates and assigns to a finding when it creates the finding.
        public var id: Swift.String?
        /// The Amazon Web Services partition that Amazon Macie created the finding in.
        public var partition: Swift.String?
        /// The details of a policy finding. This value is null for a sensitive data finding.
        public var policyDetails: Macie2ClientTypes.PolicyDetails?
        /// The Amazon Web Services Region that Amazon Macie created the finding in.
        public var region: Swift.String?
        /// The resources that the finding applies to.
        public var resourcesAffected: Macie2ClientTypes.ResourcesAffected?
        /// Specifies whether the finding is a sample finding. A sample finding is a finding that uses example data to demonstrate what a finding might contain.
        public var sample: Swift.Bool?
        /// The version of the schema that was used to define the data structures in the finding.
        public var schemaVersion: Swift.String?
        /// The severity level and score for the finding.
        public var severity: Macie2ClientTypes.Severity?
        /// The brief description of the finding.
        public var title: Swift.String?
        /// The type of the finding.
        public var type: Macie2ClientTypes.FindingType?
        /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie last updated the finding. For sensitive data findings, this value is the same as the value for the createdAt property. All sensitive data findings are considered new.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            archived: Swift.Bool? = nil,
            category: Macie2ClientTypes.FindingCategory? = nil,
            classificationDetails: Macie2ClientTypes.ClassificationDetails? = nil,
            count: Swift.Int? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            policyDetails: Macie2ClientTypes.PolicyDetails? = nil,
            region: Swift.String? = nil,
            resourcesAffected: Macie2ClientTypes.ResourcesAffected? = nil,
            sample: Swift.Bool? = nil,
            schemaVersion: Swift.String? = nil,
            severity: Macie2ClientTypes.Severity? = nil,
            title: Swift.String? = nil,
            type: Macie2ClientTypes.FindingType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.archived = archived
            self.category = category
            self.classificationDetails = classificationDetails
            self.count = count
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.policyDetails = policyDetails
            self.region = region
            self.resourcesAffected = resourcesAffected
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension Macie2ClientTypes.FindingAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "actionType"
        case apiCallDetails = "apiCallDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let apiCallDetails = self.apiCallDetails {
            try encodeContainer.encode(apiCallDetails, forKey: .apiCallDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let apiCallDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ApiCallDetails.self, forKey: .apiCallDetails)
        apiCallDetails = apiCallDetailsDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an action that occurred for a resource and produced a policy finding.
    public struct FindingAction: Swift.Equatable {
        /// The type of action that occurred for the affected resource. This value is typically AWS_API_CALL, which indicates that an entity invoked an API operation for the resource.
        public var actionType: Macie2ClientTypes.FindingActionType?
        /// The invocation details of the API operation that an entity invoked for the affected resource, if the value for the actionType property is AWS_API_CALL.
        public var apiCallDetails: Macie2ClientTypes.ApiCallDetails?

        public init(
            actionType: Macie2ClientTypes.FindingActionType? = nil,
            apiCallDetails: Macie2ClientTypes.ApiCallDetails? = nil
        )
        {
            self.actionType = actionType
            self.apiCallDetails = apiCallDetails
        }
    }

}

extension Macie2ClientTypes {
    /// The type of action that occurred for the resource and produced the policy finding:
    public enum FindingActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsApiCall
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingActionType] {
            return [
                .awsApiCall,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsApiCall: return "AWS_API_CALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingActionType(rawValue: rawValue) ?? FindingActionType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.FindingActor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainDetails = "domainDetails"
        case ipAddressDetails = "ipAddressDetails"
        case userIdentity = "userIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainDetails = self.domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let ipAddressDetails = self.ipAddressDetails {
            try encodeContainer.encode(ipAddressDetails, forKey: .ipAddressDetails)
        }
        if let userIdentity = self.userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let ipAddressDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IpAddressDetails.self, forKey: .ipAddressDetails)
        ipAddressDetails = ipAddressDetailsDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an entity that performed an action that produced a policy finding for a resource.
    public struct FindingActor: Swift.Equatable {
        /// The domain name of the device that the entity used to perform the action on the affected resource.
        public var domainDetails: Macie2ClientTypes.DomainDetails?
        /// The IP address of the device that the entity used to perform the action on the affected resource. This object also provides information such as the owner and geographic location for the IP address.
        public var ipAddressDetails: Macie2ClientTypes.IpAddressDetails?
        /// The type and other characteristics of the entity that performed the action on the affected resource.
        public var userIdentity: Macie2ClientTypes.UserIdentity?

        public init(
            domainDetails: Macie2ClientTypes.DomainDetails? = nil,
            ipAddressDetails: Macie2ClientTypes.IpAddressDetails? = nil,
            userIdentity: Macie2ClientTypes.UserIdentity? = nil
        )
        {
            self.domainDetails = domainDetails
            self.ipAddressDetails = ipAddressDetails
            self.userIdentity = userIdentity
        }
    }

}

extension Macie2ClientTypes {
    /// The category of the finding. Possible values are:
    public enum FindingCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case classification
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingCategory] {
            return [
                .classification,
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .classification: return "CLASSIFICATION"
            case .policy: return "POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingCategory(rawValue: rawValue) ?? FindingCategory.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.FindingCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([Swift.String: Macie2ClientTypes.CriterionAdditionalProperties?].self, forKey: .criterion)
        var criterionDecoded0: [Swift.String:Macie2ClientTypes.CriterionAdditionalProperties]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [Swift.String:Macie2ClientTypes.CriterionAdditionalProperties]()
            for (key0, criterionadditionalproperties0) in criterionContainer {
                if let criterionadditionalproperties0 = criterionadditionalproperties0 {
                    criterionDecoded0?[key0] = criterionadditionalproperties0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies, as a map, one or more property-based conditions that filter the results of a query for findings.
    public struct FindingCriteria: Swift.Equatable {
        /// A condition that specifies the property, operator, and one or more values to use to filter the results.
        public var criterion: [Swift.String:Macie2ClientTypes.CriterionAdditionalProperties]?

        public init(
            criterion: [Swift.String:Macie2ClientTypes.CriterionAdditionalProperties]? = nil
        )
        {
            self.criterion = criterion
        }
    }

}

extension Macie2ClientTypes {
    /// The frequency with which Amazon Macie publishes updates to policy findings for an account. This includes publishing updates to Security Hub and Amazon EventBridge (formerly Amazon CloudWatch Events). For more information, see [Monitoring and processing findings](https://docs.aws.amazon.com/macie/latest/user/findings-monitor.html) in the Amazon Macie User Guide. Valid values are:
    public enum FindingPublishingFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fifteenMinutes
        case oneHour
        case sixHours
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingPublishingFrequency] {
            return [
                .fifteenMinutes,
                .oneHour,
                .sixHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fifteenMinutes: return "FIFTEEN_MINUTES"
            case .oneHour: return "ONE_HOUR"
            case .sixHours: return "SIX_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The grouping to sort the results by. Valid values are:
    public enum FindingStatisticsSortAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case groupkey
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatisticsSortAttributeName] {
            return [
                .count,
                .groupkey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "count"
            case .groupkey: return "groupKey"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatisticsSortAttributeName(rawValue: rawValue) ?? FindingStatisticsSortAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.FindingStatisticsSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingStatisticsSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a query that retrieves aggregated statistical data about findings.
    public struct FindingStatisticsSortCriteria: Swift.Equatable {
        /// The grouping to sort the results by. Valid values are: count, sort the results by the number of findings in each group of results; and, groupKey, sort the results by the name of each group of results.
        public var attributeName: Macie2ClientTypes.FindingStatisticsSortAttributeName?
        /// The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            attributeName: Macie2ClientTypes.FindingStatisticsSortAttributeName? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension Macie2ClientTypes {
    /// The type of finding. For details about each type, see [Types of Amazon Macie findings](https://docs.aws.amazon.com/macie/latest/user/findings-types.html) in the Amazon Macie User Guide. Possible values are:
    public enum FindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyIamuserS3blockpublicaccessdisabled
        case policyIamuserS3bucketencryptiondisabled
        case policyIamuserS3bucketpublic
        case policyIamuserS3bucketreplicatedexternally
        case policyIamuserS3bucketsharedexternally
        case policyIamuserS3bucketsharedwithcloudfront
        case sensitivedataS3objectCredentials
        case sensitivedataS3objectCustomidentifier
        case sensitivedataS3objectFinancial
        case sensitivedataS3objectMultiple
        case sensitivedataS3objectPersonal
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingType] {
            return [
                .policyIamuserS3blockpublicaccessdisabled,
                .policyIamuserS3bucketencryptiondisabled,
                .policyIamuserS3bucketpublic,
                .policyIamuserS3bucketreplicatedexternally,
                .policyIamuserS3bucketsharedexternally,
                .policyIamuserS3bucketsharedwithcloudfront,
                .sensitivedataS3objectCredentials,
                .sensitivedataS3objectCustomidentifier,
                .sensitivedataS3objectFinancial,
                .sensitivedataS3objectMultiple,
                .sensitivedataS3objectPersonal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyIamuserS3blockpublicaccessdisabled: return "Policy:IAMUser/S3BlockPublicAccessDisabled"
            case .policyIamuserS3bucketencryptiondisabled: return "Policy:IAMUser/S3BucketEncryptionDisabled"
            case .policyIamuserS3bucketpublic: return "Policy:IAMUser/S3BucketPublic"
            case .policyIamuserS3bucketreplicatedexternally: return "Policy:IAMUser/S3BucketReplicatedExternally"
            case .policyIamuserS3bucketsharedexternally: return "Policy:IAMUser/S3BucketSharedExternally"
            case .policyIamuserS3bucketsharedwithcloudfront: return "Policy:IAMUser/S3BucketSharedWithCloudFront"
            case .sensitivedataS3objectCredentials: return "SensitiveData:S3Object/Credentials"
            case .sensitivedataS3objectCustomidentifier: return "SensitiveData:S3Object/CustomIdentifier"
            case .sensitivedataS3objectFinancial: return "SensitiveData:S3Object/Financial"
            case .sensitivedataS3objectMultiple: return "SensitiveData:S3Object/Multiple"
            case .sensitivedataS3objectPersonal: return "SensitiveData:S3Object/Personal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingType(rawValue: rawValue) ?? FindingType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The action to perform on findings that match the filter criteria. To suppress (automatically archive) findings that match the criteria, set this value to ARCHIVE. Valid values are:
    public enum FindingsFilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case noop
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingsFilterAction] {
            return [
                .archive,
                .noop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "ARCHIVE"
            case .noop: return "NOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingsFilterAction(rawValue: rawValue) ?? FindingsFilterAction.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.FindingsFilterListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case arn = "arn"
        case id = "id"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Provides information about a findings filter.
    public struct FindingsFilterListItem: Swift.Equatable {
        /// The action that's performed on findings that match the filter criteria. Possible values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.
        public var action: Macie2ClientTypes.FindingsFilterAction?
        /// The Amazon Resource Name (ARN) of the filter.
        public var arn: Swift.String?
        /// The unique identifier for the filter.
        public var id: Swift.String?
        /// The custom name of the filter.
        public var name: Swift.String?
        /// A map of key-value pairs that specifies which tags (keys and values) are associated with the filter.
        public var tags: [Swift.String:Swift.String]?

        public init(
            action: Macie2ClientTypes.FindingsFilterAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.id = id
            self.name = name
            self.tags = tags
        }
    }

}

extension GetAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/administrator"
    }
}

public struct GetAdministratorAccountInput: Swift.Equatable {

    public init() { }
}

struct GetAdministratorAccountInputBody: Swift.Equatable {
}

extension GetAdministratorAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAdministratorAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAdministratorAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutput: Swift.Equatable {
    /// The Amazon Web Services account ID for the administrator account. If the accounts are associated by an Amazon Macie membership invitation, this object also provides details about the invitation that was sent to establish the relationship between the accounts.
    public var administrator: Macie2ClientTypes.Invitation?

    public init(
        administrator: Macie2ClientTypes.Invitation? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputBody: Swift.Equatable {
    let administrator: Macie2ClientTypes.Invitation?
}

extension GetAdministratorAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrator = "administrator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Invitation.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

enum GetAdministratorAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAllowListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/allow-lists/\(id.urlPercentEncoding())"
    }
}

public struct GetAllowListInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetAllowListInputBody: Swift.Equatable {
}

extension GetAllowListInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAllowListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAllowListOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.criteria = output.criteria
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.criteria = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetAllowListOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the allow list.
    public var arn: Swift.String?
    /// The date and time, in UTC and extended ISO 8601 format, when the allow list was created in Amazon Macie.
    public var createdAt: ClientRuntime.Date?
    /// The criteria that specify the text or text pattern to ignore. The criteria can be the location and name of an S3 object that lists specific text to ignore (s3WordsList), or a regular expression (regex) that defines a text pattern to ignore.
    public var criteria: Macie2ClientTypes.AllowListCriteria?
    /// The custom description of the allow list.
    public var description: Swift.String?
    /// The unique identifier for the allow list.
    public var id: Swift.String?
    /// The custom name of the allow list.
    public var name: Swift.String?
    /// The current status of the allow list, which indicates whether Amazon Macie can access and use the list's criteria.
    public var status: Macie2ClientTypes.AllowListStatus?
    /// A map of key-value pairs that specifies which tags (keys and values) are associated with the allow list.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time, in UTC and extended ISO 8601 format, when the allow list's settings were most recently changed in Amazon Macie.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        criteria: Macie2ClientTypes.AllowListCriteria? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Macie2ClientTypes.AllowListStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.criteria = criteria
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetAllowListOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let criteria: Macie2ClientTypes.AllowListCriteria?
    let description: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let status: Macie2ClientTypes.AllowListStatus?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
}

extension GetAllowListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case criteria = "criteria"
        case description = "description"
        case id = "id"
        case name = "name"
        case status = "status"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowListCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowListStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetAllowListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAutomatedDiscoveryConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/automated-discovery/configuration"
    }
}

public struct GetAutomatedDiscoveryConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetAutomatedDiscoveryConfigurationInputBody: Swift.Equatable {
}

extension GetAutomatedDiscoveryConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAutomatedDiscoveryConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAutomatedDiscoveryConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.classificationScopeId = output.classificationScopeId
            self.disabledAt = output.disabledAt
            self.firstEnabledAt = output.firstEnabledAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.sensitivityInspectionTemplateId = output.sensitivityInspectionTemplateId
            self.status = output.status
        } else {
            self.classificationScopeId = nil
            self.disabledAt = nil
            self.firstEnabledAt = nil
            self.lastUpdatedAt = nil
            self.sensitivityInspectionTemplateId = nil
            self.status = nil
        }
    }
}

public struct GetAutomatedDiscoveryConfigurationOutput: Swift.Equatable {
    /// The unique identifier for the classification scope that's used when performing automated sensitive data discovery for the account. The classification scope specifies S3 buckets to exclude from automated sensitive data discovery.
    public var classificationScopeId: Swift.String?
    /// The date and time, in UTC and extended ISO 8601 format, when automated sensitive data discovery was most recently disabled for the account. This value is null if automated sensitive data discovery wasn't enabled and subsequently disabled for the account.
    public var disabledAt: ClientRuntime.Date?
    /// The date and time, in UTC and extended ISO 8601 format, when automated sensitive data discovery was initially enabled for the account. This value is null if automated sensitive data discovery has never been enabled for the account.
    public var firstEnabledAt: ClientRuntime.Date?
    /// The date and time, in UTC and extended ISO 8601 format, when automated sensitive data discovery was most recently enabled or disabled for the account.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The unique identifier for the sensitivity inspection template that's used when performing automated sensitive data discovery for the account. The template specifies which allow lists, custom data identifiers, and managed data identifiers to use when analyzing data.
    public var sensitivityInspectionTemplateId: Swift.String?
    /// The current status of the automated sensitive data discovery configuration for the account. Possible values are: ENABLED, use the specified settings to perform automated sensitive data discovery activities for the account; and, DISABLED, don't perform automated sensitive data discovery activities for the account.
    public var status: Macie2ClientTypes.AutomatedDiscoveryStatus?

    public init(
        classificationScopeId: Swift.String? = nil,
        disabledAt: ClientRuntime.Date? = nil,
        firstEnabledAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        sensitivityInspectionTemplateId: Swift.String? = nil,
        status: Macie2ClientTypes.AutomatedDiscoveryStatus? = nil
    )
    {
        self.classificationScopeId = classificationScopeId
        self.disabledAt = disabledAt
        self.firstEnabledAt = firstEnabledAt
        self.lastUpdatedAt = lastUpdatedAt
        self.sensitivityInspectionTemplateId = sensitivityInspectionTemplateId
        self.status = status
    }
}

struct GetAutomatedDiscoveryConfigurationOutputBody: Swift.Equatable {
    let classificationScopeId: Swift.String?
    let disabledAt: ClientRuntime.Date?
    let firstEnabledAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let sensitivityInspectionTemplateId: Swift.String?
    let status: Macie2ClientTypes.AutomatedDiscoveryStatus?
}

extension GetAutomatedDiscoveryConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classificationScopeId = "classificationScopeId"
        case disabledAt = "disabledAt"
        case firstEnabledAt = "firstEnabledAt"
        case lastUpdatedAt = "lastUpdatedAt"
        case sensitivityInspectionTemplateId = "sensitivityInspectionTemplateId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationScopeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classificationScopeId)
        classificationScopeId = classificationScopeIdDecoded
        let disabledAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .disabledAt)
        disabledAt = disabledAtDecoded
        let firstEnabledAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstEnabledAt)
        firstEnabledAt = firstEnabledAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let sensitivityInspectionTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sensitivityInspectionTemplateId)
        sensitivityInspectionTemplateId = sensitivityInspectionTemplateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AutomatedDiscoveryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetAutomatedDiscoveryConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBucketStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension GetBucketStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasources/s3/statistics"
    }
}

public struct GetBucketStatisticsInput: Swift.Equatable {
    /// The unique identifier for the Amazon Web Services account.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetBucketStatisticsInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension GetBucketStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetBucketStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucketCount = output.bucketCount
            self.bucketCountByEffectivePermission = output.bucketCountByEffectivePermission
            self.bucketCountByEncryptionType = output.bucketCountByEncryptionType
            self.bucketCountByObjectEncryptionRequirement = output.bucketCountByObjectEncryptionRequirement
            self.bucketCountBySharedAccessType = output.bucketCountBySharedAccessType
            self.bucketStatisticsBySensitivity = output.bucketStatisticsBySensitivity
            self.classifiableObjectCount = output.classifiableObjectCount
            self.classifiableSizeInBytes = output.classifiableSizeInBytes
            self.lastUpdated = output.lastUpdated
            self.objectCount = output.objectCount
            self.sizeInBytes = output.sizeInBytes
            self.sizeInBytesCompressed = output.sizeInBytesCompressed
            self.unclassifiableObjectCount = output.unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = output.unclassifiableObjectSizeInBytes
        } else {
            self.bucketCount = nil
            self.bucketCountByEffectivePermission = nil
            self.bucketCountByEncryptionType = nil
            self.bucketCountByObjectEncryptionRequirement = nil
            self.bucketCountBySharedAccessType = nil
            self.bucketStatisticsBySensitivity = nil
            self.classifiableObjectCount = nil
            self.classifiableSizeInBytes = nil
            self.lastUpdated = nil
            self.objectCount = nil
            self.sizeInBytes = nil
            self.sizeInBytesCompressed = nil
            self.unclassifiableObjectCount = nil
            self.unclassifiableObjectSizeInBytes = nil
        }
    }
}

public struct GetBucketStatisticsOutput: Swift.Equatable {
    /// The total number of buckets.
    public var bucketCount: Swift.Int?
    /// The total number of buckets that are publicly accessible due to a combination of permissions settings for each bucket.
    public var bucketCountByEffectivePermission: Macie2ClientTypes.BucketCountByEffectivePermission?
    /// The total number of buckets whose settings do or don't specify default server-side encryption behavior for objects that are added to the buckets.
    public var bucketCountByEncryptionType: Macie2ClientTypes.BucketCountByEncryptionType?
    /// The total number of buckets whose bucket policies do or don't require server-side encryption of objects when objects are added to the buckets.
    public var bucketCountByObjectEncryptionRequirement: Macie2ClientTypes.BucketCountPolicyAllowsUnencryptedObjectUploads?
    /// The total number of buckets that are or aren't shared with other Amazon Web Services accounts, Amazon CloudFront origin access identities (OAIs), or CloudFront origin access controls (OACs).
    public var bucketCountBySharedAccessType: Macie2ClientTypes.BucketCountBySharedAccessType?
    /// The aggregated sensitive data discovery statistics for the buckets. If automated sensitive data discovery is currently disabled for your account, the value for each statistic is 0.
    public var bucketStatisticsBySensitivity: Macie2ClientTypes.BucketStatisticsBySensitivity?
    /// The total number of objects that Amazon Macie can analyze in the buckets. These objects use a supported storage class and have a file name extension for a supported file or storage format.
    public var classifiableObjectCount: Swift.Int?
    /// The total storage size, in bytes, of all the objects that Amazon Macie can analyze in the buckets. These objects use a supported storage class and have a file name extension for a supported file or storage format. If versioning is enabled for any of the buckets, this value is based on the size of the latest version of each applicable object in the buckets. This value doesn't reflect the storage size of all versions of all applicable objects in the buckets.
    public var classifiableSizeInBytes: Swift.Int?
    /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently retrieved bucket or object metadata from Amazon S3 for the buckets.
    public var lastUpdated: ClientRuntime.Date?
    /// The total number of objects in the buckets.
    public var objectCount: Swift.Int?
    /// The total storage size, in bytes, of the buckets. If versioning is enabled for any of the buckets, this value is based on the size of the latest version of each object in the buckets. This value doesn't reflect the storage size of all versions of the objects in the buckets.
    public var sizeInBytes: Swift.Int?
    /// The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the buckets. If versioning is enabled for any of the buckets, this value is based on the size of the latest version of each applicable object in the buckets. This value doesn't reflect the storage size of all versions of the applicable objects in the buckets.
    public var sizeInBytesCompressed: Swift.Int?
    /// The total number of objects that Amazon Macie can't analyze in the buckets. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
    public var unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics?
    /// The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the buckets. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
    public var unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics?

    public init(
        bucketCount: Swift.Int? = nil,
        bucketCountByEffectivePermission: Macie2ClientTypes.BucketCountByEffectivePermission? = nil,
        bucketCountByEncryptionType: Macie2ClientTypes.BucketCountByEncryptionType? = nil,
        bucketCountByObjectEncryptionRequirement: Macie2ClientTypes.BucketCountPolicyAllowsUnencryptedObjectUploads? = nil,
        bucketCountBySharedAccessType: Macie2ClientTypes.BucketCountBySharedAccessType? = nil,
        bucketStatisticsBySensitivity: Macie2ClientTypes.BucketStatisticsBySensitivity? = nil,
        classifiableObjectCount: Swift.Int? = nil,
        classifiableSizeInBytes: Swift.Int? = nil,
        lastUpdated: ClientRuntime.Date? = nil,
        objectCount: Swift.Int? = nil,
        sizeInBytes: Swift.Int? = nil,
        sizeInBytesCompressed: Swift.Int? = nil,
        unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics? = nil,
        unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics? = nil
    )
    {
        self.bucketCount = bucketCount
        self.bucketCountByEffectivePermission = bucketCountByEffectivePermission
        self.bucketCountByEncryptionType = bucketCountByEncryptionType
        self.bucketCountByObjectEncryptionRequirement = bucketCountByObjectEncryptionRequirement
        self.bucketCountBySharedAccessType = bucketCountBySharedAccessType
        self.bucketStatisticsBySensitivity = bucketStatisticsBySensitivity
        self.classifiableObjectCount = classifiableObjectCount
        self.classifiableSizeInBytes = classifiableSizeInBytes
        self.lastUpdated = lastUpdated
        self.objectCount = objectCount
        self.sizeInBytes = sizeInBytes
        self.sizeInBytesCompressed = sizeInBytesCompressed
        self.unclassifiableObjectCount = unclassifiableObjectCount
        self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
    }
}

struct GetBucketStatisticsOutputBody: Swift.Equatable {
    let bucketCount: Swift.Int?
    let bucketCountByEffectivePermission: Macie2ClientTypes.BucketCountByEffectivePermission?
    let bucketCountByEncryptionType: Macie2ClientTypes.BucketCountByEncryptionType?
    let bucketCountByObjectEncryptionRequirement: Macie2ClientTypes.BucketCountPolicyAllowsUnencryptedObjectUploads?
    let bucketCountBySharedAccessType: Macie2ClientTypes.BucketCountBySharedAccessType?
    let bucketStatisticsBySensitivity: Macie2ClientTypes.BucketStatisticsBySensitivity?
    let classifiableObjectCount: Swift.Int?
    let classifiableSizeInBytes: Swift.Int?
    let lastUpdated: ClientRuntime.Date?
    let objectCount: Swift.Int?
    let sizeInBytes: Swift.Int?
    let sizeInBytesCompressed: Swift.Int?
    let unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics?
    let unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics?
}

extension GetBucketStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketCount = "bucketCount"
        case bucketCountByEffectivePermission = "bucketCountByEffectivePermission"
        case bucketCountByEncryptionType = "bucketCountByEncryptionType"
        case bucketCountByObjectEncryptionRequirement = "bucketCountByObjectEncryptionRequirement"
        case bucketCountBySharedAccessType = "bucketCountBySharedAccessType"
        case bucketStatisticsBySensitivity = "bucketStatisticsBySensitivity"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case lastUpdated = "lastUpdated"
        case objectCount = "objectCount"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bucketCount)
        bucketCount = bucketCountDecoded
        let bucketCountByEffectivePermissionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketCountByEffectivePermission.self, forKey: .bucketCountByEffectivePermission)
        bucketCountByEffectivePermission = bucketCountByEffectivePermissionDecoded
        let bucketCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketCountByEncryptionType.self, forKey: .bucketCountByEncryptionType)
        bucketCountByEncryptionType = bucketCountByEncryptionTypeDecoded
        let bucketCountByObjectEncryptionRequirementDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketCountPolicyAllowsUnencryptedObjectUploads.self, forKey: .bucketCountByObjectEncryptionRequirement)
        bucketCountByObjectEncryptionRequirement = bucketCountByObjectEncryptionRequirementDecoded
        let bucketCountBySharedAccessTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketCountBySharedAccessType.self, forKey: .bucketCountBySharedAccessType)
        bucketCountBySharedAccessType = bucketCountBySharedAccessTypeDecoded
        let bucketStatisticsBySensitivityDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketStatisticsBySensitivity.self, forKey: .bucketStatisticsBySensitivity)
        bucketStatisticsBySensitivity = bucketStatisticsBySensitivityDecoded
        let classifiableObjectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let objectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
    }
}

enum GetBucketStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClassificationExportConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/classification-export-configuration"
    }
}

public struct GetClassificationExportConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetClassificationExportConfigurationInputBody: Swift.Equatable {
}

extension GetClassificationExportConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetClassificationExportConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClassificationExportConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetClassificationExportConfigurationOutput: Swift.Equatable {
    /// The location where data classification results are stored, and the encryption settings that are used when storing results in that location.
    public var configuration: Macie2ClientTypes.ClassificationExportConfiguration?

    public init(
        configuration: Macie2ClientTypes.ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetClassificationExportConfigurationOutputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.ClassificationExportConfiguration?
}

extension GetClassificationExportConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetClassificationExportConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClassificationScopeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/classification-scopes/\(id.urlPercentEncoding())"
    }
}

public struct GetClassificationScopeInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetClassificationScopeInputBody: Swift.Equatable {
}

extension GetClassificationScopeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetClassificationScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClassificationScopeOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.s3 = output.s3
        } else {
            self.id = nil
            self.name = nil
            self.s3 = nil
        }
    }
}

public struct GetClassificationScopeOutput: Swift.Equatable {
    /// The unique identifier for the classification scope.
    public var id: Swift.String?
    /// The name of the classification scope: automated-sensitive-data-discovery.
    public var name: Swift.String?
    /// The S3 buckets that are excluded from automated sensitive data discovery.
    public var s3: Macie2ClientTypes.S3ClassificationScope?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        s3: Macie2ClientTypes.S3ClassificationScope? = nil
    )
    {
        self.id = id
        self.name = name
        self.s3 = s3
    }
}

struct GetClassificationScopeOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let s3: Macie2ClientTypes.S3ClassificationScope?
}

extension GetClassificationScopeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case name = "name"
        case s3 = "s3"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3Decoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3ClassificationScope.self, forKey: .s3)
        s3 = s3Decoded
    }
}

enum GetClassificationScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCustomDataIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/custom-data-identifiers/\(id.urlPercentEncoding())"
    }
}

public struct GetCustomDataIdentifierInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCustomDataIdentifierInputBody: Swift.Equatable {
}

extension GetCustomDataIdentifierInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCustomDataIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCustomDataIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deleted = output.deleted
            self.description = output.description
            self.id = output.id
            self.ignoreWords = output.ignoreWords
            self.keywords = output.keywords
            self.maximumMatchDistance = output.maximumMatchDistance
            self.name = output.name
            self.regex = output.regex
            self.severityLevels = output.severityLevels
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deleted = nil
            self.description = nil
            self.id = nil
            self.ignoreWords = nil
            self.keywords = nil
            self.maximumMatchDistance = nil
            self.name = nil
            self.regex = nil
            self.severityLevels = nil
            self.tags = nil
        }
    }
}

public struct GetCustomDataIdentifierOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom data identifier.
    public var arn: Swift.String?
    /// The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.
    public var createdAt: ClientRuntime.Date?
    /// Specifies whether the custom data identifier was deleted. If you delete a custom data identifier, Amazon Macie doesn't delete it permanently. Instead, it soft deletes the identifier.
    public var deleted: Swift.Bool?
    /// The custom description of the custom data identifier.
    public var description: Swift.String?
    /// The unique identifier for the custom data identifier.
    public var id: Swift.String?
    /// An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression contains any string in this array, Amazon Macie ignores it. Ignore words are case sensitive.
    public var ignoreWords: [Swift.String]?
    /// An array that lists specific character sequences (keywords), one of which must precede and be within proximity (maximumMatchDistance) of the regular expression to match. Keywords aren't case sensitive.
    public var keywords: [Swift.String]?
    /// The maximum number of characters that can exist between the end of at least one complete character sequence specified by the keywords array and the end of the text that matches the regex pattern. If a complete keyword precedes all the text that matches the pattern and the keyword is within the specified distance, Amazon Macie includes the result. Otherwise, Macie excludes the result.
    public var maximumMatchDistance: Swift.Int?
    /// The custom name of the custom data identifier.
    public var name: Swift.String?
    /// The regular expression (regex) that defines the pattern to match.
    public var regex: Swift.String?
    /// Specifies the severity that's assigned to findings that the custom data identifier produces, based on the number of occurrences of text that match the custom data identifier's detection criteria. By default, Amazon Macie creates findings for S3 objects that contain at least one occurrence of text that matches the detection criteria, and Macie assigns the MEDIUM severity to those findings.
    public var severityLevels: [Macie2ClientTypes.SeverityLevel]?
    /// A map of key-value pairs that identifies the tags (keys and values) that are associated with the custom data identifier.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deleted: Swift.Bool? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        ignoreWords: [Swift.String]? = nil,
        keywords: [Swift.String]? = nil,
        maximumMatchDistance: Swift.Int? = nil,
        name: Swift.String? = nil,
        regex: Swift.String? = nil,
        severityLevels: [Macie2ClientTypes.SeverityLevel]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deleted = deleted
        self.description = description
        self.id = id
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.name = name
        self.regex = regex
        self.severityLevels = severityLevels
        self.tags = tags
    }
}

struct GetCustomDataIdentifierOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let deleted: Swift.Bool?
    let description: Swift.String?
    let id: Swift.String?
    let ignoreWords: [Swift.String]?
    let keywords: [Swift.String]?
    let maximumMatchDistance: Swift.Int?
    let name: Swift.String?
    let regex: Swift.String?
    let severityLevels: [Macie2ClientTypes.SeverityLevel]?
    let tags: [Swift.String:Swift.String]?
}

extension GetCustomDataIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case deleted = "deleted"
        case description = "description"
        case id = "id"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case severityLevels = "severityLevels"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ignoreWordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[Swift.String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [Swift.String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let severityLevelsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SeverityLevel?].self, forKey: .severityLevels)
        var severityLevelsDecoded0:[Macie2ClientTypes.SeverityLevel]? = nil
        if let severityLevelsContainer = severityLevelsContainer {
            severityLevelsDecoded0 = [Macie2ClientTypes.SeverityLevel]()
            for structure0 in severityLevelsContainer {
                if let structure0 = structure0 {
                    severityLevelsDecoded0?.append(structure0)
                }
            }
        }
        severityLevels = severityLevelsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCustomDataIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case groupBy = "groupBy"
        case size = "size"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension GetFindingStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/statistics"
    }
}

public struct GetFindingStatisticsInput: Swift.Equatable {
    /// The criteria to use to filter the query results.
    public var findingCriteria: Macie2ClientTypes.FindingCriteria?
    /// The finding property to use to group the query results. Valid values are:
    ///
    /// * classificationDetails.jobId - The unique identifier for the classification job that produced the finding.
    ///
    /// * resourcesAffected.s3Bucket.name - The name of the S3 bucket that the finding applies to.
    ///
    /// * severity.description - The severity level of the finding, such as High or Medium.
    ///
    /// * type - The type of finding, such as Policy:IAMUser/S3BucketPublic and SensitiveData:S3Object/Personal.
    /// This member is required.
    public var groupBy: Macie2ClientTypes.GroupBy?
    /// The maximum number of items to include in each page of the response.
    public var size: Swift.Int?
    /// The criteria to use to sort the query results.
    public var sortCriteria: Macie2ClientTypes.FindingStatisticsSortCriteria?

    public init(
        findingCriteria: Macie2ClientTypes.FindingCriteria? = nil,
        groupBy: Macie2ClientTypes.GroupBy? = nil,
        size: Swift.Int? = nil,
        sortCriteria: Macie2ClientTypes.FindingStatisticsSortCriteria? = nil
    )
    {
        self.findingCriteria = findingCriteria
        self.groupBy = groupBy
        self.size = size
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingStatisticsInputBody: Swift.Equatable {
    let findingCriteria: Macie2ClientTypes.FindingCriteria?
    let groupBy: Macie2ClientTypes.GroupBy?
    let size: Swift.Int?
    let sortCriteria: Macie2ClientTypes.FindingStatisticsSortCriteria?
}

extension GetFindingStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case groupBy = "groupBy"
        case size = "size"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.GroupBy.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingStatisticsSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.countsByGroup = output.countsByGroup
        } else {
            self.countsByGroup = nil
        }
    }
}

public struct GetFindingStatisticsOutput: Swift.Equatable {
    /// An array of objects, one for each group of findings that matches the filter criteria specified in the request.
    public var countsByGroup: [Macie2ClientTypes.GroupCount]?

    public init(
        countsByGroup: [Macie2ClientTypes.GroupCount]? = nil
    )
    {
        self.countsByGroup = countsByGroup
    }
}

struct GetFindingStatisticsOutputBody: Swift.Equatable {
    let countsByGroup: [Macie2ClientTypes.GroupCount]?
}

extension GetFindingStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countsByGroup = "countsByGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countsByGroupContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.GroupCount?].self, forKey: .countsByGroup)
        var countsByGroupDecoded0:[Macie2ClientTypes.GroupCount]? = nil
        if let countsByGroupContainer = countsByGroupContainer {
            countsByGroupDecoded0 = [Macie2ClientTypes.GroupCount]()
            for structure0 in countsByGroupContainer {
                if let structure0 = structure0 {
                    countsByGroupDecoded0?.append(structure0)
                }
            }
        }
        countsByGroup = countsByGroupDecoded0
    }
}

enum GetFindingStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/findingsfilters/\(id.urlPercentEncoding())"
    }
}

public struct GetFindingsFilterInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFindingsFilterInputBody: Swift.Equatable {
}

extension GetFindingsFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.id = output.id
            self.name = output.name
            self.position = output.position
            self.tags = output.tags
        } else {
            self.action = nil
            self.arn = nil
            self.description = nil
            self.findingCriteria = nil
            self.id = nil
            self.name = nil
            self.position = nil
            self.tags = nil
        }
    }
}

public struct GetFindingsFilterOutput: Swift.Equatable {
    /// The action that's performed on findings that match the filter criteria (findingCriteria). Possible values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.
    public var action: Macie2ClientTypes.FindingsFilterAction?
    /// The Amazon Resource Name (ARN) of the filter.
    public var arn: Swift.String?
    /// The custom description of the filter.
    public var description: Swift.String?
    /// The criteria that's used to filter findings.
    public var findingCriteria: Macie2ClientTypes.FindingCriteria?
    /// The unique identifier for the filter.
    public var id: Swift.String?
    /// The custom name of the filter.
    public var name: Swift.String?
    /// The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.
    public var position: Swift.Int?
    /// A map of key-value pairs that specifies which tags (keys and values) are associated with the filter.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: Macie2ClientTypes.FindingsFilterAction? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        findingCriteria: Macie2ClientTypes.FindingCriteria? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        position: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.description = description
        self.findingCriteria = findingCriteria
        self.id = id
        self.name = name
        self.position = position
        self.tags = tags
    }
}

struct GetFindingsFilterOutputBody: Swift.Equatable {
    let action: Macie2ClientTypes.FindingsFilterAction?
    let arn: Swift.String?
    let description: Swift.String?
    let findingCriteria: Macie2ClientTypes.FindingCriteria?
    let id: Swift.String?
    let name: Swift.String?
    let position: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension GetFindingsFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case arn = "arn"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case id = "id"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .position)
        position = positionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetFindingsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for __string0 in findingIds {
                try findingIdsContainer.encode(__string0)
            }
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/describe"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// An array of strings that lists the unique identifiers for the findings to retrieve. You can specify as many as 50 unique identifiers in this array.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// The criteria for sorting the results of the request.
    public var sortCriteria: Macie2ClientTypes.SortCriteria?

    public init(
        findingIds: [Swift.String]? = nil,
        sortCriteria: Macie2ClientTypes.SortCriteria? = nil
    )
    {
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let sortCriteria: Macie2ClientTypes.SortCriteria?
}

extension GetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutput: Swift.Equatable {
    /// An array of objects, one for each finding that matches the criteria specified in the request.
    public var findings: [Macie2ClientTypes.Finding]?

    public init(
        findings: [Macie2ClientTypes.Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputBody: Swift.Equatable {
    let findings: [Macie2ClientTypes.Finding]?
}

extension GetFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "findings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[Macie2ClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Macie2ClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

enum GetFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsPublicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings-publication-configuration"
    }
}

public struct GetFindingsPublicationConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetFindingsPublicationConfigurationInputBody: Swift.Equatable {
}

extension GetFindingsPublicationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingsPublicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsPublicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityHubConfiguration = output.securityHubConfiguration
        } else {
            self.securityHubConfiguration = nil
        }
    }
}

public struct GetFindingsPublicationConfigurationOutput: Swift.Equatable {
    /// The configuration settings that determine which findings are published to Security Hub.
    public var securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration?

    public init(
        securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration? = nil
    )
    {
        self.securityHubConfiguration = securityHubConfiguration
    }
}

struct GetFindingsPublicationConfigurationOutputBody: Swift.Equatable {
    let securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration?
}

extension GetFindingsPublicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityHubConfigurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SecurityHubConfiguration.self, forKey: .securityHubConfiguration)
        securityHubConfiguration = securityHubConfigurationDecoded
    }
}

enum GetFindingsPublicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInvitationsCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/count"
    }
}

public struct GetInvitationsCountInput: Swift.Equatable {

    public init() { }
}

struct GetInvitationsCountInputBody: Swift.Equatable {
}

extension GetInvitationsCountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationsCountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInvitationsCountOutputBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = nil
        }
    }
}

public struct GetInvitationsCountOutput: Swift.Equatable {
    /// The total number of invitations that were received by the account, not including the currently accepted invitation.
    public var invitationsCount: Swift.Int?

    public init(
        invitationsCount: Swift.Int? = nil
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputBody: Swift.Equatable {
    let invitationsCount: Swift.Int?
}

extension GetInvitationsCountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invitationsCount)
        invitationsCount = invitationsCountDecoded
    }
}

enum GetInvitationsCountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMacieSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/macie"
    }
}

public struct GetMacieSessionInput: Swift.Equatable {

    public init() { }
}

struct GetMacieSessionInputBody: Swift.Equatable {
}

extension GetMacieSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMacieSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMacieSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct GetMacieSessionOutput: Swift.Equatable {
    /// The date and time, in UTC and extended ISO 8601 format, when the Amazon Macie account was created.
    public var createdAt: ClientRuntime.Date?
    /// The frequency with which Amazon Macie publishes updates to policy findings for the account. This includes publishing updates to Security Hub and Amazon EventBridge (formerly Amazon CloudWatch Events).
    public var findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    /// The Amazon Resource Name (ARN) of the service-linked role that allows Amazon Macie to monitor and analyze data in Amazon Web Services resources for the account.
    public var serviceRole: Swift.String?
    /// The current status of the Amazon Macie account. Possible values are: PAUSED, the account is enabled but all Macie activities are suspended (paused) for the account; and, ENABLED, the account is enabled and all Macie activities are enabled for the account.
    public var status: Macie2ClientTypes.MacieStatus?
    /// The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the Amazon Macie account.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency? = nil,
        serviceRole: Swift.String? = nil,
        status: Macie2ClientTypes.MacieStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct GetMacieSessionOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    let serviceRole: Swift.String?
    let status: Macie2ClientTypes.MacieStatus?
    let updatedAt: ClientRuntime.Date?
}

extension GetMacieSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MacieStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetMacieSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/master"
    }
}

public struct GetMasterAccountInput: Swift.Equatable {

    public init() { }
}

struct GetMasterAccountInputBody: Swift.Equatable {
}

extension GetMasterAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMasterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMasterAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutput: Swift.Equatable {
    /// (Deprecated) The Amazon Web Services account ID for the administrator account. If the accounts are associated by a Macie membership invitation, this object also provides details about the invitation that was sent to establish the relationship between the accounts.
    public var master: Macie2ClientTypes.Invitation?

    public init(
        master: Macie2ClientTypes.Invitation? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputBody: Swift.Equatable {
    let master: Macie2ClientTypes.Invitation?
}

extension GetMasterAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case master = "master"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Invitation.self, forKey: .master)
        master = masterDecoded
    }
}

enum GetMasterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/members/\(id.urlPercentEncoding())"
    }
}

public struct GetMemberInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMemberInputBody: Swift.Equatable {
}

extension GetMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.administratorAccountId = output.administratorAccountId
            self.arn = output.arn
            self.email = output.email
            self.invitedAt = output.invitedAt
            self.masterAccountId = output.masterAccountId
            self.relationshipStatus = output.relationshipStatus
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.accountId = nil
            self.administratorAccountId = nil
            self.arn = nil
            self.email = nil
            self.invitedAt = nil
            self.masterAccountId = nil
            self.relationshipStatus = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetMemberOutput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account.
    public var accountId: Swift.String?
    /// The Amazon Web Services account ID for the administrator account.
    public var administratorAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the account.
    public var arn: Swift.String?
    /// The email address for the account. This value is null if the account is associated with the administrator account through Organizations.
    public var email: Swift.String?
    /// The date and time, in UTC and extended ISO 8601 format, when an Amazon Macie membership invitation was last sent to the account. This value is null if a Macie membership invitation hasn't been sent to the account.
    public var invitedAt: ClientRuntime.Date?
    /// (Deprecated) The Amazon Web Services account ID for the administrator account. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.
    public var masterAccountId: Swift.String?
    /// The current status of the relationship between the account and the administrator account.
    public var relationshipStatus: Macie2ClientTypes.RelationshipStatus?
    /// A map of key-value pairs that specifies which tags (keys and values) are associated with the account in Amazon Macie.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the relationship between the account and the administrator account.
    public var updatedAt: ClientRuntime.Date?

    public init(
        accountId: Swift.String? = nil,
        administratorAccountId: Swift.String? = nil,
        arn: Swift.String? = nil,
        email: Swift.String? = nil,
        invitedAt: ClientRuntime.Date? = nil,
        masterAccountId: Swift.String? = nil,
        relationshipStatus: Macie2ClientTypes.RelationshipStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.accountId = accountId
        self.administratorAccountId = administratorAccountId
        self.arn = arn
        self.email = email
        self.invitedAt = invitedAt
        self.masterAccountId = masterAccountId
        self.relationshipStatus = relationshipStatus
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetMemberOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let administratorAccountId: Swift.String?
    let arn: Swift.String?
    let email: Swift.String?
    let invitedAt: ClientRuntime.Date?
    let masterAccountId: Swift.String?
    let relationshipStatus: Macie2ClientTypes.RelationshipStatus?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
}

extension GetMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case administratorAccountId = "administratorAccountId"
        case arn = "arn"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterAccountId = "masterAccountId"
        case relationshipStatus = "relationshipStatus"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let invitedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let masterAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterAccountId)
        masterAccountId = masterAccountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension GetResourceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-profiles"
    }
}

public struct GetResourceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 bucket that the request applies to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourceProfileInputBody: Swift.Equatable {
}

extension GetResourceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileUpdatedAt = output.profileUpdatedAt
            self.sensitivityScore = output.sensitivityScore
            self.sensitivityScoreOverridden = output.sensitivityScoreOverridden
            self.statistics = output.statistics
        } else {
            self.profileUpdatedAt = nil
            self.sensitivityScore = nil
            self.sensitivityScoreOverridden = nil
            self.statistics = nil
        }
    }
}

public struct GetResourceProfileOutput: Swift.Equatable {
    /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently recalculated sensitive data discovery statistics and details for the bucket. If the bucket's sensitivity score is calculated automatically, this includes the score.
    public var profileUpdatedAt: ClientRuntime.Date?
    /// The current sensitivity score for the bucket, ranging from -1 (classification error) to 100 (sensitive). By default, this score is calculated automatically based on the amount of data that Amazon Macie has analyzed in the bucket and the amount of sensitive data that Macie has found in the bucket.
    public var sensitivityScore: Swift.Int?
    /// Specifies whether the bucket's current sensitivity score was set manually. If this value is true, the score was manually changed to 100. If this value is false, the score was calculated automatically by Amazon Macie.
    public var sensitivityScoreOverridden: Swift.Bool?
    /// The sensitive data discovery statistics for the bucket. The statistics capture the results of automated sensitive data discovery activities that Amazon Macie has performed for the bucket.
    public var statistics: Macie2ClientTypes.ResourceStatistics?

    public init(
        profileUpdatedAt: ClientRuntime.Date? = nil,
        sensitivityScore: Swift.Int? = nil,
        sensitivityScoreOverridden: Swift.Bool? = nil,
        statistics: Macie2ClientTypes.ResourceStatistics? = nil
    )
    {
        self.profileUpdatedAt = profileUpdatedAt
        self.sensitivityScore = sensitivityScore
        self.sensitivityScoreOverridden = sensitivityScoreOverridden
        self.statistics = statistics
    }
}

struct GetResourceProfileOutputBody: Swift.Equatable {
    let profileUpdatedAt: ClientRuntime.Date?
    let sensitivityScore: Swift.Int?
    let sensitivityScoreOverridden: Swift.Bool?
    let statistics: Macie2ClientTypes.ResourceStatistics?
}

extension GetResourceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileUpdatedAt = "profileUpdatedAt"
        case sensitivityScore = "sensitivityScore"
        case sensitivityScoreOverridden = "sensitivityScoreOverridden"
        case statistics = "statistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .profileUpdatedAt)
        profileUpdatedAt = profileUpdatedAtDecoded
        let sensitivityScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sensitivityScore)
        sensitivityScore = sensitivityScoreDecoded
        let sensitivityScoreOverriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sensitivityScoreOverridden)
        sensitivityScoreOverridden = sensitivityScoreOverriddenDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ResourceStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

enum GetResourceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRevealConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reveal-configuration"
    }
}

public struct GetRevealConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetRevealConfigurationInputBody: Swift.Equatable {
}

extension GetRevealConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRevealConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRevealConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetRevealConfigurationOutput: Swift.Equatable {
    /// The current configuration settings and the status of the configuration for the account.
    public var configuration: Macie2ClientTypes.RevealConfiguration?

    public init(
        configuration: Macie2ClientTypes.RevealConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetRevealConfigurationOutputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.RevealConfiguration?
}

extension GetRevealConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RevealConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetRevealConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSensitiveDataOccurrencesAvailabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let findingId = findingId else {
            return nil
        }
        return "/findings/\(findingId.urlPercentEncoding())/reveal/availability"
    }
}

public struct GetSensitiveDataOccurrencesAvailabilityInput: Swift.Equatable {
    /// The unique identifier for the finding.
    /// This member is required.
    public var findingId: Swift.String?

    public init(
        findingId: Swift.String? = nil
    )
    {
        self.findingId = findingId
    }
}

struct GetSensitiveDataOccurrencesAvailabilityInputBody: Swift.Equatable {
}

extension GetSensitiveDataOccurrencesAvailabilityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSensitiveDataOccurrencesAvailabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSensitiveDataOccurrencesAvailabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.reasons = output.reasons
        } else {
            self.code = nil
            self.reasons = nil
        }
    }
}

public struct GetSensitiveDataOccurrencesAvailabilityOutput: Swift.Equatable {
    /// Specifies whether occurrences of sensitive data can be retrieved for the finding. Possible values are: AVAILABLE, the sensitive data can be retrieved; and, UNAVAILABLE, the sensitive data can't be retrieved. If this value is UNAVAILABLE, the reasons array indicates why the data can't be retrieved.
    public var code: Macie2ClientTypes.AvailabilityCode?
    /// Specifies why occurrences of sensitive data can't be retrieved for the finding. Possible values are:
    ///
    /// * INVALID_CLASSIFICATION_RESULT - Amazon Macie can't verify the location of the sensitive data to retrieve. There isn't a corresponding sensitive data discovery result for the finding. Or the sensitive data discovery result specified by the classificationDetails.detailedResultsLocation field of the finding isn't available, is malformed or corrupted, or uses an unsupported storage format.
    ///
    /// * OBJECT_EXCEEDS_SIZE_QUOTA - The storage size of the affected S3 object exceeds the size quota for retrieving occurrences of sensitive data.
    ///
    /// * OBJECT_UNAVAILABLE - The affected S3 object isn't available. The object might have been renamed, moved, or deleted. Or the object was changed after Macie created the finding.
    ///
    /// * UNSUPPORTED_FINDING_TYPE - The specified finding isn't a sensitive data finding.
    ///
    /// * UNSUPPORTED_OBJECT_TYPE - The affected S3 object uses a file or storage format that Macie doesn't support for retrieving occurrences of sensitive data.
    ///
    ///
    /// This value is null if sensitive data can be retrieved for the finding.
    public var reasons: [Macie2ClientTypes.UnavailabilityReasonCode]?

    public init(
        code: Macie2ClientTypes.AvailabilityCode? = nil,
        reasons: [Macie2ClientTypes.UnavailabilityReasonCode]? = nil
    )
    {
        self.code = code
        self.reasons = reasons
    }
}

struct GetSensitiveDataOccurrencesAvailabilityOutputBody: Swift.Equatable {
    let code: Macie2ClientTypes.AvailabilityCode?
    let reasons: [Macie2ClientTypes.UnavailabilityReasonCode]?
}

extension GetSensitiveDataOccurrencesAvailabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case reasons = "reasons"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AvailabilityCode.self, forKey: .code)
        code = codeDecoded
        let reasonsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UnavailabilityReasonCode?].self, forKey: .reasons)
        var reasonsDecoded0:[Macie2ClientTypes.UnavailabilityReasonCode]? = nil
        if let reasonsContainer = reasonsContainer {
            reasonsDecoded0 = [Macie2ClientTypes.UnavailabilityReasonCode]()
            for enum0 in reasonsContainer {
                if let enum0 = enum0 {
                    reasonsDecoded0?.append(enum0)
                }
            }
        }
        reasons = reasonsDecoded0
    }
}

enum GetSensitiveDataOccurrencesAvailabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSensitiveDataOccurrencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let findingId = findingId else {
            return nil
        }
        return "/findings/\(findingId.urlPercentEncoding())/reveal"
    }
}

public struct GetSensitiveDataOccurrencesInput: Swift.Equatable {
    /// The unique identifier for the finding.
    /// This member is required.
    public var findingId: Swift.String?

    public init(
        findingId: Swift.String? = nil
    )
    {
        self.findingId = findingId
    }
}

struct GetSensitiveDataOccurrencesInputBody: Swift.Equatable {
}

extension GetSensitiveDataOccurrencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSensitiveDataOccurrencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSensitiveDataOccurrencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.sensitiveDataOccurrences = output.sensitiveDataOccurrences
            self.status = output.status
        } else {
            self.error = nil
            self.sensitiveDataOccurrences = nil
            self.status = nil
        }
    }
}

public struct GetSensitiveDataOccurrencesOutput: Swift.Equatable {
    /// If an error occurred when Amazon Macie attempted to retrieve occurrences of sensitive data reported by the finding, a description of the error that occurred. This value is null if the status (status) of the request is PROCESSING or SUCCESS.
    public var error: Swift.String?
    /// A map that specifies 1-100 types of sensitive data reported by the finding and, for each type, 1-10 occurrences of sensitive data.
    public var sensitiveDataOccurrences: [Swift.String:[Macie2ClientTypes.DetectedDataDetails]]?
    /// The status of the request to retrieve occurrences of sensitive data reported by the finding. Possible values are:
    ///
    /// * ERROR - An error occurred when Amazon Macie attempted to locate, retrieve, or encrypt the sensitive data. The error value indicates the nature of the error that occurred.
    ///
    /// * PROCESSING - Macie is processing the request.
    ///
    /// * SUCCESS - Macie successfully located, retrieved, and encrypted the sensitive data.
    public var status: Macie2ClientTypes.RevealRequestStatus?

    public init(
        error: Swift.String? = nil,
        sensitiveDataOccurrences: [Swift.String:[Macie2ClientTypes.DetectedDataDetails]]? = nil,
        status: Macie2ClientTypes.RevealRequestStatus? = nil
    )
    {
        self.error = error
        self.sensitiveDataOccurrences = sensitiveDataOccurrences
        self.status = status
    }
}

struct GetSensitiveDataOccurrencesOutputBody: Swift.Equatable {
    let error: Swift.String?
    let sensitiveDataOccurrences: [Swift.String:[Macie2ClientTypes.DetectedDataDetails]]?
    let status: Macie2ClientTypes.RevealRequestStatus?
}

extension GetSensitiveDataOccurrencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "error"
        case sensitiveDataOccurrences = "sensitiveDataOccurrences"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sensitiveDataOccurrencesContainer = try containerValues.decodeIfPresent([Swift.String: [Macie2ClientTypes.DetectedDataDetails?]?].self, forKey: .sensitiveDataOccurrences)
        var sensitiveDataOccurrencesDecoded0: [Swift.String:[Macie2ClientTypes.DetectedDataDetails]]? = nil
        if let sensitiveDataOccurrencesContainer = sensitiveDataOccurrencesContainer {
            sensitiveDataOccurrencesDecoded0 = [Swift.String:[Macie2ClientTypes.DetectedDataDetails]]()
            for (key0, __listofdetecteddatadetails0) in sensitiveDataOccurrencesContainer {
                var __listofdetecteddatadetails0Decoded0: [Macie2ClientTypes.DetectedDataDetails]? = nil
                if let __listofdetecteddatadetails0 = __listofdetecteddatadetails0 {
                    __listofdetecteddatadetails0Decoded0 = [Macie2ClientTypes.DetectedDataDetails]()
                    for structure1 in __listofdetecteddatadetails0 {
                        if let structure1 = structure1 {
                            __listofdetecteddatadetails0Decoded0?.append(structure1)
                        }
                    }
                }
                sensitiveDataOccurrencesDecoded0?[key0] = __listofdetecteddatadetails0Decoded0
            }
        }
        sensitiveDataOccurrences = sensitiveDataOccurrencesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RevealRequestStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetSensitiveDataOccurrencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSensitivityInspectionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/templates/sensitivity-inspections/\(id.urlPercentEncoding())"
    }
}

public struct GetSensitivityInspectionTemplateInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSensitivityInspectionTemplateInputBody: Swift.Equatable {
}

extension GetSensitivityInspectionTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSensitivityInspectionTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSensitivityInspectionTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.excludes = output.excludes
            self.includes = output.includes
            self.name = output.name
            self.sensitivityInspectionTemplateId = output.sensitivityInspectionTemplateId
        } else {
            self.description = nil
            self.excludes = nil
            self.includes = nil
            self.name = nil
            self.sensitivityInspectionTemplateId = nil
        }
    }
}

public struct GetSensitivityInspectionTemplateOutput: Swift.Equatable {
    /// The custom description of the template.
    public var description: Swift.String?
    /// The managed data identifiers that are explicitly excluded (not used) when analyzing data.
    public var excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes?
    /// The allow lists, custom data identifiers, and managed data identifiers that are included (used) when analyzing data.
    public var includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes?
    /// The name of the template: automated-sensitive-data-discovery.
    public var name: Swift.String?
    /// The unique identifier for the template.
    public var sensitivityInspectionTemplateId: Swift.String?

    public init(
        description: Swift.String? = nil,
        excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes? = nil,
        includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes? = nil,
        name: Swift.String? = nil,
        sensitivityInspectionTemplateId: Swift.String? = nil
    )
    {
        self.description = description
        self.excludes = excludes
        self.includes = includes
        self.name = name
        self.sensitivityInspectionTemplateId = sensitivityInspectionTemplateId
    }
}

struct GetSensitivityInspectionTemplateOutputBody: Swift.Equatable {
    let description: Swift.String?
    let excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes?
    let includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes?
    let name: Swift.String?
    let sensitivityInspectionTemplateId: Swift.String?
}

extension GetSensitivityInspectionTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case excludes = "excludes"
        case includes = "includes"
        case name = "name"
        case sensitivityInspectionTemplateId = "sensitivityInspectionTemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityInspectionTemplateExcludes.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityInspectionTemplateIncludes.self, forKey: .includes)
        includes = includesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sensitivityInspectionTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sensitivityInspectionTemplateId)
        sensitivityInspectionTemplateId = sensitivityInspectionTemplateIdDecoded
    }
}

enum GetSensitivityInspectionTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy = "filterBy"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortBy = "sortBy"
        case timeRange = "timeRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterBy = filterBy {
            var filterByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBy)
            for usagestatisticsfilter0 in filterBy {
                try filterByContainer.encode(usagestatisticsfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timeRange = self.timeRange {
            try encodeContainer.encode(timeRange.rawValue, forKey: .timeRange)
        }
    }
}

extension GetUsageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usage/statistics"
    }
}

public struct GetUsageStatisticsInput: Swift.Equatable {
    /// An array of objects, one for each condition to use to filter the query results. If you specify more than one condition, Amazon Macie uses an AND operator to join the conditions.
    public var filterBy: [Macie2ClientTypes.UsageStatisticsFilter]?
    /// The maximum number of items to include in each page of the response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The criteria to use to sort the query results.
    public var sortBy: Macie2ClientTypes.UsageStatisticsSortBy?
    /// The inclusive time period to query usage data for. Valid values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days. If you don't specify a value, Amazon Macie provides usage data for the preceding 30 days.
    public var timeRange: Macie2ClientTypes.TimeRange?

    public init(
        filterBy: [Macie2ClientTypes.UsageStatisticsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Macie2ClientTypes.UsageStatisticsSortBy? = nil,
        timeRange: Macie2ClientTypes.TimeRange? = nil
    )
    {
        self.filterBy = filterBy
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timeRange = timeRange
    }
}

struct GetUsageStatisticsInputBody: Swift.Equatable {
    let filterBy: [Macie2ClientTypes.UsageStatisticsFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortBy: Macie2ClientTypes.UsageStatisticsSortBy?
    let timeRange: Macie2ClientTypes.TimeRange?
}

extension GetUsageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy = "filterBy"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortBy = "sortBy"
        case timeRange = "timeRange"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UsageStatisticsFilter?].self, forKey: .filterBy)
        var filterByDecoded0:[Macie2ClientTypes.UsageStatisticsFilter]? = nil
        if let filterByContainer = filterByContainer {
            filterByDecoded0 = [Macie2ClientTypes.UsageStatisticsFilter]()
            for structure0 in filterByContainer {
                if let structure0 = structure0 {
                    filterByDecoded0?.append(structure0)
                }
            }
        }
        filterBy = filterByDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageStatisticsSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let timeRangeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
    }
}

extension GetUsageStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.records = output.records
            self.timeRange = output.timeRange
        } else {
            self.nextToken = nil
            self.records = nil
            self.timeRange = nil
        }
    }
}

public struct GetUsageStatisticsOutput: Swift.Equatable {
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?
    /// An array of objects that contains the results of the query. Each object contains the data for an account that matches the filter criteria specified in the request.
    public var records: [Macie2ClientTypes.UsageRecord]?
    /// The inclusive time period that the usage data applies to. Possible values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days.
    public var timeRange: Macie2ClientTypes.TimeRange?

    public init(
        nextToken: Swift.String? = nil,
        records: [Macie2ClientTypes.UsageRecord]? = nil,
        timeRange: Macie2ClientTypes.TimeRange? = nil
    )
    {
        self.nextToken = nextToken
        self.records = records
        self.timeRange = timeRange
    }
}

struct GetUsageStatisticsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let records: [Macie2ClientTypes.UsageRecord]?
    let timeRange: Macie2ClientTypes.TimeRange?
}

extension GetUsageStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case records = "records"
        case timeRange = "timeRange"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recordsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UsageRecord?].self, forKey: .records)
        var recordsDecoded0:[Macie2ClientTypes.UsageRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Macie2ClientTypes.UsageRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let timeRangeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
    }
}

enum GetUsageStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageTotalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let timeRange = timeRange {
                let timeRangeQueryItem = ClientRuntime.URLQueryItem(name: "timeRange".urlPercentEncoding(), value: Swift.String(timeRange).urlPercentEncoding())
                items.append(timeRangeQueryItem)
            }
            return items
        }
    }
}

extension GetUsageTotalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usage"
    }
}

public struct GetUsageTotalsInput: Swift.Equatable {
    /// The inclusive time period to retrieve the data for. Valid values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days. If you don't specify a value for this parameter, Amazon Macie provides aggregated usage data for the preceding 30 days.
    public var timeRange: Swift.String?

    public init(
        timeRange: Swift.String? = nil
    )
    {
        self.timeRange = timeRange
    }
}

struct GetUsageTotalsInputBody: Swift.Equatable {
}

extension GetUsageTotalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsageTotalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageTotalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.timeRange = output.timeRange
            self.usageTotals = output.usageTotals
        } else {
            self.timeRange = nil
            self.usageTotals = nil
        }
    }
}

public struct GetUsageTotalsOutput: Swift.Equatable {
    /// The inclusive time period that the usage data applies to. Possible values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days.
    public var timeRange: Macie2ClientTypes.TimeRange?
    /// An array of objects that contains the results of the query. Each object contains the data for a specific usage metric.
    public var usageTotals: [Macie2ClientTypes.UsageTotal]?

    public init(
        timeRange: Macie2ClientTypes.TimeRange? = nil,
        usageTotals: [Macie2ClientTypes.UsageTotal]? = nil
    )
    {
        self.timeRange = timeRange
        self.usageTotals = usageTotals
    }
}

struct GetUsageTotalsOutputBody: Swift.Equatable {
    let timeRange: Macie2ClientTypes.TimeRange?
    let usageTotals: [Macie2ClientTypes.UsageTotal]?
}

extension GetUsageTotalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeRange = "timeRange"
        case usageTotals = "usageTotals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let usageTotalsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UsageTotal?].self, forKey: .usageTotals)
        var usageTotalsDecoded0:[Macie2ClientTypes.UsageTotal]? = nil
        if let usageTotalsContainer = usageTotalsContainer {
            usageTotalsDecoded0 = [Macie2ClientTypes.UsageTotal]()
            for structure0 in usageTotalsContainer {
                if let structure0 = structure0 {
                    usageTotalsDecoded0?.append(structure0)
                }
            }
        }
        usageTotals = usageTotalsDecoded0
    }
}

enum GetUsageTotalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes {
    public enum GroupBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case classificationdetailsJobid
        case resourcesaffectedS3bucketName
        case severityDescription
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupBy] {
            return [
                .classificationdetailsJobid,
                .resourcesaffectedS3bucketName,
                .severityDescription,
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .classificationdetailsJobid: return "classificationDetails.jobId"
            case .resourcesaffectedS3bucketName: return "resourcesAffected.s3Bucket.name"
            case .severityDescription: return "severity.description"
            case .type: return "type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupBy(rawValue: rawValue) ?? GroupBy.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.GroupCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "count"
        case groupKey = "groupKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupKey = self.groupKey {
            try encodeContainer.encode(groupKey, forKey: .groupKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let groupKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupKey)
        groupKey = groupKeyDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides a group of results for a query that retrieved aggregated statistical data about findings.
    public struct GroupCount: Swift.Equatable {
        /// The total number of findings in the group of query results.
        public var count: Swift.Int?
        /// The name of the property that defines the group in the query results, as specified by the groupBy property in the query request.
        public var groupKey: Swift.String?

        public init(
            count: Swift.Int? = nil,
            groupKey: Swift.String? = nil
        )
        {
            self.count = count
            self.groupKey = groupKey
        }
    }

}

extension Macie2ClientTypes.IamUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case userName = "userName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an Identity and Access Management (IAM) user who performed an action on an affected resource.
    public struct IamUser: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that's associated with the IAM user who performed the action.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the principal that performed the action. The last section of the ARN contains the name of the user who performed the action.
        public var arn: Swift.String?
        /// The unique identifier for the IAM user who performed the action.
        public var principalId: Swift.String?
        /// The username of the IAM user who performed the action.
        public var userName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.userName = userName
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to an unknown internal server error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.Invitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encodeTimestamp(invitedAt, format: .dateTime, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let invitedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an Amazon Macie membership invitation.
    public struct Invitation: Swift.Equatable {
        /// The Amazon Web Services account ID for the account that sent the invitation.
        public var accountId: Swift.String?
        /// The unique identifier for the invitation.
        public var invitationId: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the invitation was sent.
        public var invitedAt: ClientRuntime.Date?
        /// The status of the relationship between the account that sent the invitation and the account that received the invitation.
        public var relationshipStatus: Macie2ClientTypes.RelationshipStatus?

        public init(
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: ClientRuntime.Date? = nil,
            relationshipStatus: Macie2ClientTypes.RelationshipStatus? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension Macie2ClientTypes.IpAddressDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressV4 = "ipAddressV4"
        case ipCity = "ipCity"
        case ipCountry = "ipCountry"
        case ipGeoLocation = "ipGeoLocation"
        case ipOwner = "ipOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let ipCity = self.ipCity {
            try encodeContainer.encode(ipCity, forKey: .ipCity)
        }
        if let ipCountry = self.ipCountry {
            try encodeContainer.encode(ipCountry, forKey: .ipCountry)
        }
        if let ipGeoLocation = self.ipGeoLocation {
            try encodeContainer.encode(ipGeoLocation, forKey: .ipGeoLocation)
        }
        if let ipOwner = self.ipOwner {
            try encodeContainer.encode(ipOwner, forKey: .ipOwner)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let ipCityDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IpCity.self, forKey: .ipCity)
        ipCity = ipCityDecoded
        let ipCountryDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IpCountry.self, forKey: .ipCountry)
        ipCountry = ipCountryDecoded
        let ipGeoLocationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IpGeoLocation.self, forKey: .ipGeoLocation)
        ipGeoLocation = ipGeoLocationDecoded
        let ipOwnerDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IpOwner.self, forKey: .ipOwner)
        ipOwner = ipOwnerDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the IP address of the device that an entity used to perform an action on an affected resource.
    public struct IpAddressDetails: Swift.Equatable {
        /// The Internet Protocol version 4 (IPv4) address of the device.
        public var ipAddressV4: Swift.String?
        /// The city that the IP address originated from.
        public var ipCity: Macie2ClientTypes.IpCity?
        /// The country that the IP address originated from.
        public var ipCountry: Macie2ClientTypes.IpCountry?
        /// The geographic coordinates of the location that the IP address originated from.
        public var ipGeoLocation: Macie2ClientTypes.IpGeoLocation?
        /// The registered owner of the IP address.
        public var ipOwner: Macie2ClientTypes.IpOwner?

        public init(
            ipAddressV4: Swift.String? = nil,
            ipCity: Macie2ClientTypes.IpCity? = nil,
            ipCountry: Macie2ClientTypes.IpCountry? = nil,
            ipGeoLocation: Macie2ClientTypes.IpGeoLocation? = nil,
            ipOwner: Macie2ClientTypes.IpOwner? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
            self.ipCity = ipCity
            self.ipCountry = ipCountry
            self.ipGeoLocation = ipGeoLocation
            self.ipOwner = ipOwner
        }
    }

}

extension Macie2ClientTypes.IpCity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the city that an IP address originated from.
    public struct IpCity: Swift.Equatable {
        /// The name of the city.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension Macie2ClientTypes.IpCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the country that an IP address originated from.
    public struct IpCountry: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country that the IP address originated from. For example, US for the United States.
        public var code: Swift.String?
        /// The name of the country that the IP address originated from.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension Macie2ClientTypes.IpGeoLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lat = self.lat {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if let lon = self.lon {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lat)
        lat = latDecoded
        let lonDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lon)
        lon = lonDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides geographic coordinates that indicate where a specified IP address originated from.
    public struct IpGeoLocation: Swift.Equatable {
        /// The latitude coordinate of the location, rounded to four decimal places.
        public var lat: Swift.Double?
        /// The longitude coordinate of the location, rounded to four decimal places.
        public var lon: Swift.Double?

        public init(
            lat: Swift.Double? = nil,
            lon: Swift.Double? = nil
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension Macie2ClientTypes.IpOwner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = self.asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = self.asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = self.isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = self.org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the registered owner of an IP address.
    public struct IpOwner: Swift.Equatable {
        /// The autonomous system number (ASN) for the autonomous system that included the IP address.
        public var asn: Swift.String?
        /// The organization identifier that's associated with the autonomous system number (ASN) for the autonomous system that included the IP address.
        public var asnOrg: Swift.String?
        /// The name of the internet service provider (ISP) that owned the IP address.
        public var isp: Swift.String?
        /// The name of the organization that owned the IP address.
        public var org: Swift.String?

        public init(
            asn: Swift.String? = nil,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension Macie2ClientTypes {
    public enum IsDefinedInJob: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [IsDefinedInJob] {
            return [
                .false,
                .true,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IsDefinedInJob(rawValue: rawValue) ?? IsDefinedInJob.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    public enum IsMonitoredByJob: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [IsMonitoredByJob] {
            return [
                .false,
                .true,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IsMonitoredByJob(rawValue: rawValue) ?? IsMonitoredByJob.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The operator to use in a condition. Depending on the type of condition, possible values are:
    public enum JobComparator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case eq
        case gt
        case gte
        case lt
        case lte
        case ne
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [JobComparator] {
            return [
                .contains,
                .eq,
                .gt,
                .gte,
                .lt,
                .lte,
                .ne,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .eq: return "EQ"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case .ne: return "NE"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobComparator(rawValue: rawValue) ?? JobComparator.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.JobDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDefinedInJob = "isDefinedInJob"
        case isMonitoredByJob = "isMonitoredByJob"
        case lastJobId = "lastJobId"
        case lastJobRunTime = "lastJobRunTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isDefinedInJob = self.isDefinedInJob {
            try encodeContainer.encode(isDefinedInJob.rawValue, forKey: .isDefinedInJob)
        }
        if let isMonitoredByJob = self.isMonitoredByJob {
            try encodeContainer.encode(isMonitoredByJob.rawValue, forKey: .isMonitoredByJob)
        }
        if let lastJobId = self.lastJobId {
            try encodeContainer.encode(lastJobId, forKey: .lastJobId)
        }
        if let lastJobRunTime = self.lastJobRunTime {
            try encodeContainer.encodeTimestamp(lastJobRunTime, format: .dateTime, forKey: .lastJobRunTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isDefinedInJobDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IsDefinedInJob.self, forKey: .isDefinedInJob)
        isDefinedInJob = isDefinedInJobDecoded
        let isMonitoredByJobDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IsMonitoredByJob.self, forKey: .isMonitoredByJob)
        isMonitoredByJob = isMonitoredByJobDecoded
        let lastJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastJobId)
        lastJobId = lastJobIdDecoded
        let lastJobRunTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastJobRunTime)
        lastJobRunTime = lastJobRunTimeDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies whether any one-time or recurring classification jobs are configured to analyze data in an S3 bucket, and, if so, the details of the job that ran most recently.
    public struct JobDetails: Swift.Equatable {
        /// Specifies whether any one-time or recurring jobs are configured to analyze data in the bucket. Possible values are:
        ///
        /// * TRUE - The bucket is explicitly included in the bucket definition (S3BucketDefinitionForJob) for one or more jobs and at least one of those jobs has a status other than CANCELLED. Or the bucket matched the bucket criteria (S3BucketCriteriaForJob) for at least one job that previously ran.
        ///
        /// * FALSE - The bucket isn't explicitly included in the bucket definition (S3BucketDefinitionForJob) for any jobs, all the jobs that explicitly include the bucket in their bucket definitions have a status of CANCELLED, or the bucket didn't match the bucket criteria (S3BucketCriteriaForJob) for any jobs that previously ran.
        ///
        /// * UNKNOWN - An exception occurred when Amazon Macie attempted to retrieve job data for the bucket.
        public var isDefinedInJob: Macie2ClientTypes.IsDefinedInJob?
        /// Specifies whether any recurring jobs are configured to analyze data in the bucket. Possible values are:
        ///
        /// * TRUE - The bucket is explicitly included in the bucket definition (S3BucketDefinitionForJob) for one or more recurring jobs or the bucket matches the bucket criteria (S3BucketCriteriaForJob) for one or more recurring jobs. At least one of those jobs has a status other than CANCELLED.
        ///
        /// * FALSE - The bucket isn't explicitly included in the bucket definition (S3BucketDefinitionForJob) for any recurring jobs, the bucket doesn't match the bucket criteria (S3BucketCriteriaForJob) for any recurring jobs, or all the recurring jobs that are configured to analyze data in the bucket have a status of CANCELLED.
        ///
        /// * UNKNOWN - An exception occurred when Amazon Macie attempted to retrieve job data for the bucket.
        public var isMonitoredByJob: Macie2ClientTypes.IsMonitoredByJob?
        /// The unique identifier for the job that ran most recently and is configured to analyze data in the bucket, either the latest run of a recurring job or the only run of a one-time job. This value is typically null if the value for the isDefinedInJob property is FALSE or UNKNOWN.
        public var lastJobId: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the job (lastJobId) started. If the job is a recurring job, this value indicates when the most recent run started. This value is typically null if the value for the isDefinedInJob property is FALSE or UNKNOWN.
        public var lastJobRunTime: ClientRuntime.Date?

        public init(
            isDefinedInJob: Macie2ClientTypes.IsDefinedInJob? = nil,
            isMonitoredByJob: Macie2ClientTypes.IsMonitoredByJob? = nil,
            lastJobId: Swift.String? = nil,
            lastJobRunTime: ClientRuntime.Date? = nil
        )
        {
            self.isDefinedInJob = isDefinedInJob
            self.isMonitoredByJob = isMonitoredByJob
            self.lastJobId = lastJobId
            self.lastJobRunTime = lastJobRunTime
        }
    }

}

extension Macie2ClientTypes.JobScheduleFrequency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dailySchedule = "dailySchedule"
        case monthlySchedule = "monthlySchedule"
        case weeklySchedule = "weeklySchedule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dailySchedule = self.dailySchedule {
            try encodeContainer.encode(dailySchedule, forKey: .dailySchedule)
        }
        if let monthlySchedule = self.monthlySchedule {
            try encodeContainer.encode(monthlySchedule, forKey: .monthlySchedule)
        }
        if let weeklySchedule = self.weeklySchedule {
            try encodeContainer.encode(weeklySchedule, forKey: .weeklySchedule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dailyScheduleDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DailySchedule.self, forKey: .dailySchedule)
        dailySchedule = dailyScheduleDecoded
        let monthlyScheduleDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MonthlySchedule.self, forKey: .monthlySchedule)
        monthlySchedule = monthlyScheduleDecoded
        let weeklyScheduleDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.WeeklySchedule.self, forKey: .weeklySchedule)
        weeklySchedule = weeklyScheduleDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the recurrence pattern for running a classification job.
    public struct JobScheduleFrequency: Swift.Equatable {
        /// Specifies a daily recurrence pattern for running the job.
        public var dailySchedule: Macie2ClientTypes.DailySchedule?
        /// Specifies a monthly recurrence pattern for running the job.
        public var monthlySchedule: Macie2ClientTypes.MonthlySchedule?
        /// Specifies a weekly recurrence pattern for running the job.
        public var weeklySchedule: Macie2ClientTypes.WeeklySchedule?

        public init(
            dailySchedule: Macie2ClientTypes.DailySchedule? = nil,
            monthlySchedule: Macie2ClientTypes.MonthlySchedule? = nil,
            weeklySchedule: Macie2ClientTypes.WeeklySchedule? = nil
        )
        {
            self.dailySchedule = dailySchedule
            self.monthlySchedule = monthlySchedule
            self.weeklySchedule = weeklySchedule
        }
    }

}

extension Macie2ClientTypes.JobScopeTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleScopeTerm = "simpleScopeTerm"
        case tagScopeTerm = "tagScopeTerm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleScopeTerm = self.simpleScopeTerm {
            try encodeContainer.encode(simpleScopeTerm, forKey: .simpleScopeTerm)
        }
        if let tagScopeTerm = self.tagScopeTerm {
            try encodeContainer.encode(tagScopeTerm, forKey: .tagScopeTerm)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleScopeTermDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SimpleScopeTerm.self, forKey: .simpleScopeTerm)
        simpleScopeTerm = simpleScopeTermDecoded
        let tagScopeTermDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TagScopeTerm.self, forKey: .tagScopeTerm)
        tagScopeTerm = tagScopeTermDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a property- or tag-based condition that defines criteria for including or excluding S3 objects from a classification job. A JobScopeTerm object can contain only one simpleScopeTerm object or one tagScopeTerm object.
    public struct JobScopeTerm: Swift.Equatable {
        /// A property-based condition that defines a property, operator, and one or more values for including or excluding objects from the job.
        public var simpleScopeTerm: Macie2ClientTypes.SimpleScopeTerm?
        /// A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding objects from the job.
        public var tagScopeTerm: Macie2ClientTypes.TagScopeTerm?

        public init(
            simpleScopeTerm: Macie2ClientTypes.SimpleScopeTerm? = nil,
            tagScopeTerm: Macie2ClientTypes.TagScopeTerm? = nil
        )
        {
            self.simpleScopeTerm = simpleScopeTerm
            self.tagScopeTerm = tagScopeTerm
        }
    }

}

extension Macie2ClientTypes.JobScopingBlock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for jobscopeterm0 in and {
                try andContainer.encode(jobscopeterm0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.JobScopeTerm?].self, forKey: .and)
        var andDecoded0:[Macie2ClientTypes.JobScopeTerm]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [Macie2ClientTypes.JobScopeTerm]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 objects from a classification job.
    public struct JobScopingBlock: Swift.Equatable {
        /// An array of conditions, one for each property- or tag-based condition that determines which objects to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.
        public var and: [Macie2ClientTypes.JobScopeTerm]?

        public init(
            and: [Macie2ClientTypes.JobScopeTerm]? = nil
        )
        {
            self.and = and
        }
    }

}

extension Macie2ClientTypes {
    /// The status of a classification job. Possible values are:
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case complete
        case idle
        case paused
        case running
        case userPaused
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .complete,
                .idle,
                .paused,
                .running,
                .userPaused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .complete: return "COMPLETE"
            case .idle: return "IDLE"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case .userPaused: return "USER_PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketCriteria = "bucketCriteria"
        case bucketDefinitions = "bucketDefinitions"
        case createdAt = "createdAt"
        case jobId = "jobId"
        case jobStatus = "jobStatus"
        case jobType = "jobType"
        case lastRunErrorStatus = "lastRunErrorStatus"
        case name = "name"
        case userPausedDetails = "userPausedDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = self.bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if let bucketDefinitions = bucketDefinitions {
            var bucketDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketDefinitions)
            for s3bucketdefinitionforjob0 in bucketDefinitions {
                try bucketDefinitionsContainer.encode(s3bucketdefinitionforjob0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let lastRunErrorStatus = self.lastRunErrorStatus {
            try encodeContainer.encode(lastRunErrorStatus, forKey: .lastRunErrorStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let userPausedDetails = self.userPausedDetails {
            try encodeContainer.encode(userPausedDetails, forKey: .userPausedDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3BucketCriteriaForJob.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
        let bucketDefinitionsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.S3BucketDefinitionForJob?].self, forKey: .bucketDefinitions)
        var bucketDefinitionsDecoded0:[Macie2ClientTypes.S3BucketDefinitionForJob]? = nil
        if let bucketDefinitionsContainer = bucketDefinitionsContainer {
            bucketDefinitionsDecoded0 = [Macie2ClientTypes.S3BucketDefinitionForJob]()
            for structure0 in bucketDefinitionsContainer {
                if let structure0 = structure0 {
                    bucketDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        bucketDefinitions = bucketDefinitionsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let lastRunErrorStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.LastRunErrorStatus.self, forKey: .lastRunErrorStatus)
        lastRunErrorStatus = lastRunErrorStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let userPausedDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UserPausedDetails.self, forKey: .userPausedDetails)
        userPausedDetails = userPausedDetailsDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a classification job, including the current status of the job.
    public struct JobSummary: Swift.Equatable {
        /// The property- and tag-based conditions that determine which S3 buckets are included or excluded from the job's analysis. Each time the job runs, the job uses these criteria to determine which buckets to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.
        public var bucketCriteria: Macie2ClientTypes.S3BucketCriteriaForJob?
        /// An array of objects, one for each Amazon Web Services account that owns specific S3 buckets for the job to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.
        public var bucketDefinitions: [Macie2ClientTypes.S3BucketDefinitionForJob]?
        /// The date and time, in UTC and extended ISO 8601 format, when the job was created.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the job.
        public var jobId: Swift.String?
        /// The current status of the job. Possible values are:
        ///
        /// * CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.
        ///
        /// * COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.
        ///
        /// * IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.
        ///
        /// * PAUSED - Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.
        ///
        /// * RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.
        ///
        /// * USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.
        public var jobStatus: Macie2ClientTypes.JobStatus?
        /// The schedule for running the job. Possible values are:
        ///
        /// * ONE_TIME - The job runs only once.
        ///
        /// * SCHEDULED - The job runs on a daily, weekly, or monthly basis.
        public var jobType: Macie2ClientTypes.JobType?
        /// Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.
        public var lastRunErrorStatus: Macie2ClientTypes.LastRunErrorStatus?
        /// The custom name of the job.
        public var name: Swift.String?
        /// If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.
        public var userPausedDetails: Macie2ClientTypes.UserPausedDetails?

        public init(
            bucketCriteria: Macie2ClientTypes.S3BucketCriteriaForJob? = nil,
            bucketDefinitions: [Macie2ClientTypes.S3BucketDefinitionForJob]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobStatus: Macie2ClientTypes.JobStatus? = nil,
            jobType: Macie2ClientTypes.JobType? = nil,
            lastRunErrorStatus: Macie2ClientTypes.LastRunErrorStatus? = nil,
            name: Swift.String? = nil,
            userPausedDetails: Macie2ClientTypes.UserPausedDetails? = nil
        )
        {
            self.bucketCriteria = bucketCriteria
            self.bucketDefinitions = bucketDefinitions
            self.createdAt = createdAt
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.jobType = jobType
            self.lastRunErrorStatus = lastRunErrorStatus
            self.name = name
            self.userPausedDetails = userPausedDetails
        }
    }

}

extension Macie2ClientTypes {
    /// The schedule for running a classification job. Valid values are:
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneTime
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .oneTime,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneTime: return "ONE_TIME"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.KeyValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the tags that are associated with an S3 bucket or object. Each tag consists of a required tag key and an associated tag value.
    public struct KeyValuePair: Swift.Equatable {
        /// One part of a key-value pair that comprises a tag. A tag key is a general label that acts as a category for more specific tag values.
        public var key: Swift.String?
        /// One part of a key-value pair that comprises a tag. A tag value acts as a descriptor for a tag key. A tag value can be an empty string.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension Macie2ClientTypes.LastRunErrorStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.LastRunErrorStatusCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies whether any account- or bucket-level access errors occurred when a classification job ran. For information about using logging data to investigate these errors, see [Monitoring sensitive data discovery jobs](https://docs.aws.amazon.com/macie/latest/user/discovery-jobs-monitor-cw-logs.html) in the Amazon Macie User Guide.
    public struct LastRunErrorStatus: Swift.Equatable {
        /// Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run. Possible values are:
        ///
        /// * ERROR - One or more errors occurred. Amazon Macie didn't process all the data specified for the job.
        ///
        /// * NONE - No errors occurred. Macie processed all the data specified for the job.
        public var code: Macie2ClientTypes.LastRunErrorStatusCode?

        public init(
            code: Macie2ClientTypes.LastRunErrorStatusCode? = nil
        )
        {
            self.code = code
        }
    }

}

extension Macie2ClientTypes {
    /// Specifies whether any account- or bucket-level access errors occurred during the run of a one-time classification job or the most recent run of a recurring classification job. Possible values are:
    public enum LastRunErrorStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [LastRunErrorStatusCode] {
            return [
                .error,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastRunErrorStatusCode(rawValue: rawValue) ?? LastRunErrorStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension ListAllowListsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAllowListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/allow-lists"
    }
}

public struct ListAllowListsInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAllowListsInputBody: Swift.Equatable {
}

extension ListAllowListsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAllowListsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAllowListsOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowLists = output.allowLists
            self.nextToken = output.nextToken
        } else {
            self.allowLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListAllowListsOutput: Swift.Equatable {
    /// An array of objects, one for each allow list.
    public var allowLists: [Macie2ClientTypes.AllowListSummary]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        allowLists: [Macie2ClientTypes.AllowListSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.allowLists = allowLists
        self.nextToken = nextToken
    }
}

struct ListAllowListsOutputBody: Swift.Equatable {
    let allowLists: [Macie2ClientTypes.AllowListSummary]?
    let nextToken: Swift.String?
}

extension ListAllowListsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowLists = "allowLists"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowListsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.AllowListSummary?].self, forKey: .allowLists)
        var allowListsDecoded0:[Macie2ClientTypes.AllowListSummary]? = nil
        if let allowListsContainer = allowListsContainer {
            allowListsDecoded0 = [Macie2ClientTypes.AllowListSummary]()
            for structure0 in allowListsContainer {
                if let structure0 = structure0 {
                    allowListsDecoded0?.append(structure0)
                }
            }
        }
        allowLists = allowListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAllowListsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClassificationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListClassificationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs/list"
    }
}

public struct ListClassificationJobsInput: Swift.Equatable {
    /// The criteria to use to filter the results.
    public var filterCriteria: Macie2ClientTypes.ListJobsFilterCriteria?
    /// The maximum number of items to include in each page of the response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The criteria to use to sort the results.
    public var sortCriteria: Macie2ClientTypes.ListJobsSortCriteria?

    public init(
        filterCriteria: Macie2ClientTypes.ListJobsFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Macie2ClientTypes.ListJobsSortCriteria? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListClassificationJobsInputBody: Swift.Equatable {
    let filterCriteria: Macie2ClientTypes.ListJobsFilterCriteria?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortCriteria: Macie2ClientTypes.ListJobsSortCriteria?
}

extension ListClassificationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ListJobsFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ListJobsSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListClassificationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClassificationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListClassificationJobsOutput: Swift.Equatable {
    /// An array of objects, one for each job that matches the filter criteria specified in the request.
    public var items: [Macie2ClientTypes.JobSummary]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        items: [Macie2ClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListClassificationJobsOutputBody: Swift.Equatable {
    let items: [Macie2ClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListClassificationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.JobSummary?].self, forKey: .items)
        var itemsDecoded0:[Macie2ClientTypes.JobSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Macie2ClientTypes.JobSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClassificationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClassificationScopesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListClassificationScopesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/classification-scopes"
    }
}

public struct ListClassificationScopesInput: Swift.Equatable {
    /// The name of the classification scope to retrieve the unique identifier for.
    public var name: Swift.String?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListClassificationScopesInputBody: Swift.Equatable {
}

extension ListClassificationScopesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClassificationScopesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClassificationScopesOutputBody = try responseDecoder.decode(responseBody: data)
            self.classificationScopes = output.classificationScopes
            self.nextToken = output.nextToken
        } else {
            self.classificationScopes = nil
            self.nextToken = nil
        }
    }
}

public struct ListClassificationScopesOutput: Swift.Equatable {
    /// An array that specifies the unique identifier and name of the classification scope for the account.
    public var classificationScopes: [Macie2ClientTypes.ClassificationScopeSummary]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        classificationScopes: [Macie2ClientTypes.ClassificationScopeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.classificationScopes = classificationScopes
        self.nextToken = nextToken
    }
}

struct ListClassificationScopesOutputBody: Swift.Equatable {
    let classificationScopes: [Macie2ClientTypes.ClassificationScopeSummary]?
    let nextToken: Swift.String?
}

extension ListClassificationScopesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classificationScopes = "classificationScopes"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationScopesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.ClassificationScopeSummary?].self, forKey: .classificationScopes)
        var classificationScopesDecoded0:[Macie2ClientTypes.ClassificationScopeSummary]? = nil
        if let classificationScopesContainer = classificationScopesContainer {
            classificationScopesDecoded0 = [Macie2ClientTypes.ClassificationScopeSummary]()
            for structure0 in classificationScopesContainer {
                if let structure0 = structure0 {
                    classificationScopesDecoded0?.append(structure0)
                }
            }
        }
        classificationScopes = classificationScopesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClassificationScopesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomDataIdentifiersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomDataIdentifiersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-data-identifiers/list"
    }
}

public struct ListCustomDataIdentifiersInput: Swift.Equatable {
    /// The maximum number of items to include in each page of the response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomDataIdentifiersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomDataIdentifiersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomDataIdentifiersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomDataIdentifiersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomDataIdentifiersOutput: Swift.Equatable {
    /// An array of objects, one for each custom data identifier.
    public var items: [Macie2ClientTypes.CustomDataIdentifierSummary]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        items: [Macie2ClientTypes.CustomDataIdentifierSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListCustomDataIdentifiersOutputBody: Swift.Equatable {
    let items: [Macie2ClientTypes.CustomDataIdentifierSummary]?
    let nextToken: Swift.String?
}

extension ListCustomDataIdentifiersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.CustomDataIdentifierSummary?].self, forKey: .items)
        var itemsDecoded0:[Macie2ClientTypes.CustomDataIdentifierSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Macie2ClientTypes.CustomDataIdentifierSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomDataIdentifiersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingsFiltersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListFindingsFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findingsfilters"
    }
}

public struct ListFindingsFiltersInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingsFiltersInputBody: Swift.Equatable {
}

extension ListFindingsFiltersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFindingsFiltersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsFiltersOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingsFilterListItems = output.findingsFilterListItems
            self.nextToken = output.nextToken
        } else {
            self.findingsFilterListItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsFiltersOutput: Swift.Equatable {
    /// An array of objects, one for each filter that's associated with the account.
    public var findingsFilterListItems: [Macie2ClientTypes.FindingsFilterListItem]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        findingsFilterListItems: [Macie2ClientTypes.FindingsFilterListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingsFilterListItems = findingsFilterListItems
        self.nextToken = nextToken
    }
}

struct ListFindingsFiltersOutputBody: Swift.Equatable {
    let findingsFilterListItems: [Macie2ClientTypes.FindingsFilterListItem]?
    let nextToken: Swift.String?
}

extension ListFindingsFiltersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsFilterListItems = "findingsFilterListItems"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsFilterListItemsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.FindingsFilterListItem?].self, forKey: .findingsFilterListItems)
        var findingsFilterListItemsDecoded0:[Macie2ClientTypes.FindingsFilterListItem]? = nil
        if let findingsFilterListItemsContainer = findingsFilterListItemsContainer {
            findingsFilterListItemsDecoded0 = [Macie2ClientTypes.FindingsFilterListItem]()
            for structure0 in findingsFilterListItemsContainer {
                if let structure0 = structure0 {
                    findingsFilterListItemsDecoded0?.append(structure0)
                }
            }
        }
        findingsFilterListItems = findingsFilterListItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsFiltersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// The criteria to use to filter the results.
    public var findingCriteria: Macie2ClientTypes.FindingCriteria?
    /// The maximum number of items to include in each page of the response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The criteria to use to sort the results.
    public var sortCriteria: Macie2ClientTypes.SortCriteria?

    public init(
        findingCriteria: Macie2ClientTypes.FindingCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Macie2ClientTypes.SortCriteria? = nil
    )
    {
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let findingCriteria: Macie2ClientTypes.FindingCriteria?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortCriteria: Macie2ClientTypes.SortCriteria?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutput: Swift.Equatable {
    /// An array of strings, where each string is the unique identifier for a finding that matches the filter criteria specified in the request.
    public var findingIds: [Swift.String]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        findingIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
}

extension ListInvitationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutput: Swift.Equatable {
    /// An array of objects, one for each invitation that was received by the account.
    public var invitations: [Macie2ClientTypes.Invitation]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        invitations: [Macie2ClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputBody: Swift.Equatable {
    let invitations: [Macie2ClientTypes.Invitation]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[Macie2ClientTypes.Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [Macie2ClientTypes.Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.ListJobsFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = excludes {
            var excludesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludes)
            for listjobsfilterterm0 in excludes {
                try excludesContainer.encode(listjobsfilterterm0)
            }
        }
        if let includes = includes {
            var includesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includes)
            for listjobsfilterterm0 in includes {
                try includesContainer.encode(listjobsfilterterm0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.ListJobsFilterTerm?].self, forKey: .excludes)
        var excludesDecoded0:[Macie2ClientTypes.ListJobsFilterTerm]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [Macie2ClientTypes.ListJobsFilterTerm]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let includesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.ListJobsFilterTerm?].self, forKey: .includes)
        var includesDecoded0:[Macie2ClientTypes.ListJobsFilterTerm]? = nil
        if let includesContainer = includesContainer {
            includesDecoded0 = [Macie2ClientTypes.ListJobsFilterTerm]()
            for structure0 in includesContainer {
                if let structure0 = structure0 {
                    includesDecoded0?.append(structure0)
                }
            }
        }
        includes = includesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for filtering the results of a request for information about classification jobs.
    public struct ListJobsFilterCriteria: Swift.Equatable {
        /// An array of objects, one for each condition that determines which jobs to exclude from the results.
        public var excludes: [Macie2ClientTypes.ListJobsFilterTerm]?
        /// An array of objects, one for each condition that determines which jobs to include in the results.
        public var includes: [Macie2ClientTypes.ListJobsFilterTerm]?

        public init(
            excludes: [Macie2ClientTypes.ListJobsFilterTerm]? = nil,
            includes: [Macie2ClientTypes.ListJobsFilterTerm]? = nil
        )
        {
            self.excludes = excludes
            self.includes = includes
        }
    }

}

extension Macie2ClientTypes {
    /// The property to use to filter the results. Valid values are:
    public enum ListJobsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdat
        case jobstatus
        case jobtype
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ListJobsFilterKey] {
            return [
                .createdat,
                .jobstatus,
                .jobtype,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdat: return "createdAt"
            case .jobstatus: return "jobStatus"
            case .jobtype: return "jobType"
            case .name: return "name"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListJobsFilterKey(rawValue: rawValue) ?? ListJobsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.ListJobsFilterTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __string0 in values {
                try valuesContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ListJobsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a condition that filters the results of a request for information about classification jobs. Each condition consists of a property, an operator, and one or more values.
    public struct ListJobsFilterTerm: Swift.Equatable {
        /// The operator to use to filter the results.
        public var comparator: Macie2ClientTypes.JobComparator?
        /// The property to use to filter the results.
        public var key: Macie2ClientTypes.ListJobsFilterKey?
        /// An array that lists one or more values to use to filter the results.
        public var values: [Swift.String]?

        public init(
            comparator: Macie2ClientTypes.JobComparator? = nil,
            key: Macie2ClientTypes.ListJobsFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.values = values
        }
    }

}

extension Macie2ClientTypes {
    /// The property to sort the results by. Valid values are:
    public enum ListJobsSortAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdat
        case jobstatus
        case jobtype
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ListJobsSortAttributeName] {
            return [
                .createdat,
                .jobstatus,
                .jobtype,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdat: return "createdAt"
            case .jobstatus: return "jobStatus"
            case .jobtype: return "jobType"
            case .name: return "name"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListJobsSortAttributeName(rawValue: rawValue) ?? ListJobsSortAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.ListJobsSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ListJobsSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a request for information about classification jobs.
    public struct ListJobsSortCriteria: Swift.Equatable {
        /// The property to sort the results by.
        public var attributeName: Macie2ClientTypes.ListJobsSortAttributeName?
        /// The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            attributeName: Macie2ClientTypes.ListJobsSortAttributeName? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension ListManagedDataIdentifiersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListManagedDataIdentifiersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/managed-data-identifiers/list"
    }
}

public struct ListManagedDataIdentifiersInput: Swift.Equatable {
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListManagedDataIdentifiersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListManagedDataIdentifiersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedDataIdentifiersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedDataIdentifiersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedDataIdentifiersOutput: Swift.Equatable {
    /// An array of objects, one for each managed data identifier.
    public var items: [Macie2ClientTypes.ManagedDataIdentifierSummary]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        items: [Macie2ClientTypes.ManagedDataIdentifierSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListManagedDataIdentifiersOutputBody: Swift.Equatable {
    let items: [Macie2ClientTypes.ManagedDataIdentifierSummary]?
    let nextToken: Swift.String?
}

extension ListManagedDataIdentifiersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.ManagedDataIdentifierSummary?].self, forKey: .items)
        var itemsDecoded0:[Macie2ClientTypes.ManagedDataIdentifierSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Macie2ClientTypes.ManagedDataIdentifierSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedDataIdentifiersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let onlyAssociated = onlyAssociated {
                let onlyAssociatedQueryItem = ClientRuntime.URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
                items.append(onlyAssociatedQueryItem)
            }
            return items
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// Specifies which accounts to include in the response, based on the status of an account's relationship with the administrator account. By default, the response includes only current member accounts. To include all accounts, set this value to false.
    public var onlyAssociated: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutput: Swift.Equatable {
    /// An array of objects, one for each account that's associated with the administrator account and matches the criteria specified in the request.
    public var members: [Macie2ClientTypes.Member]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        members: [Macie2ClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputBody: Swift.Equatable {
    let members: [Macie2ClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[Macie2ClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Macie2ClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationAdminAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutput: Swift.Equatable {
    /// An array of objects, one for each delegated Amazon Macie administrator account for the organization. Only one of these accounts can have a status of ENABLED.
    public var adminAccounts: [Macie2ClientTypes.AdminAccount]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        adminAccounts: [Macie2ClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputBody: Swift.Equatable {
    let adminAccounts: [Macie2ClientTypes.AdminAccount]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[Macie2ClientTypes.AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [Macie2ClientTypes.AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceProfileArtifactsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListResourceProfileArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-profiles/artifacts"
    }
}

public struct ListResourceProfileArtifactsInput: Swift.Equatable {
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 bucket that the request applies to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListResourceProfileArtifactsInputBody: Swift.Equatable {
}

extension ListResourceProfileArtifactsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceProfileArtifactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceProfileArtifactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceProfileArtifactsOutput: Swift.Equatable {
    /// An array of objects, one for each of 1-100 S3 objects that Amazon Macie selected for analysis. If Macie has analyzed more than 100 objects in the bucket, Macie populates the array based on the value for the ResourceProfileArtifact.sensitive field for an object: true (sensitive), followed by false (not sensitive). Macie then populates any remaining items in the array with information about objects where the value for the ResourceProfileArtifact.classificationResultStatus field is SKIPPED.
    public var artifacts: [Macie2ClientTypes.ResourceProfileArtifact]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        artifacts: [Macie2ClientTypes.ResourceProfileArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListResourceProfileArtifactsOutputBody: Swift.Equatable {
    let artifacts: [Macie2ClientTypes.ResourceProfileArtifact]?
    let nextToken: Swift.String?
}

extension ListResourceProfileArtifactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts = "artifacts"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.ResourceProfileArtifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[Macie2ClientTypes.ResourceProfileArtifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [Macie2ClientTypes.ResourceProfileArtifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourceProfileArtifactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceProfileDetectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListResourceProfileDetectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-profiles/detections"
    }
}

public struct ListResourceProfileDetectionsInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 bucket that the request applies to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListResourceProfileDetectionsInputBody: Swift.Equatable {
}

extension ListResourceProfileDetectionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceProfileDetectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceProfileDetectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.detections = output.detections
            self.nextToken = output.nextToken
        } else {
            self.detections = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceProfileDetectionsOutput: Swift.Equatable {
    /// An array of objects, one for each type of sensitive data that Amazon Macie found in the bucket. Each object reports the number of occurrences of the specified type and provides information about the custom data identifier or managed data identifier that detected the data.
    public var detections: [Macie2ClientTypes.Detection]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        detections: [Macie2ClientTypes.Detection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detections = detections
        self.nextToken = nextToken
    }
}

struct ListResourceProfileDetectionsOutputBody: Swift.Equatable {
    let detections: [Macie2ClientTypes.Detection]?
    let nextToken: Swift.String?
}

extension ListResourceProfileDetectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detections = "detections"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectionsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Detection?].self, forKey: .detections)
        var detectionsDecoded0:[Macie2ClientTypes.Detection]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [Macie2ClientTypes.Detection]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourceProfileDetectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSensitivityInspectionTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSensitivityInspectionTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/templates/sensitivity-inspections"
    }
}

public struct ListSensitivityInspectionTemplatesInput: Swift.Equatable {
    /// The maximum number of items to include in each page of a paginated response.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSensitivityInspectionTemplatesInputBody: Swift.Equatable {
}

extension ListSensitivityInspectionTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSensitivityInspectionTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSensitivityInspectionTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sensitivityInspectionTemplates = output.sensitivityInspectionTemplates
        } else {
            self.nextToken = nil
            self.sensitivityInspectionTemplates = nil
        }
    }
}

public struct ListSensitivityInspectionTemplatesOutput: Swift.Equatable {
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?
    /// An array that specifies the unique identifier and name of the sensitivity inspection template for the account.
    public var sensitivityInspectionTemplates: [Macie2ClientTypes.SensitivityInspectionTemplatesEntry]?

    public init(
        nextToken: Swift.String? = nil,
        sensitivityInspectionTemplates: [Macie2ClientTypes.SensitivityInspectionTemplatesEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.sensitivityInspectionTemplates = sensitivityInspectionTemplates
    }
}

struct ListSensitivityInspectionTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sensitivityInspectionTemplates: [Macie2ClientTypes.SensitivityInspectionTemplatesEntry]?
}

extension ListSensitivityInspectionTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case sensitivityInspectionTemplates = "sensitivityInspectionTemplates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sensitivityInspectionTemplatesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SensitivityInspectionTemplatesEntry?].self, forKey: .sensitivityInspectionTemplates)
        var sensitivityInspectionTemplatesDecoded0:[Macie2ClientTypes.SensitivityInspectionTemplatesEntry]? = nil
        if let sensitivityInspectionTemplatesContainer = sensitivityInspectionTemplatesContainer {
            sensitivityInspectionTemplatesDecoded0 = [Macie2ClientTypes.SensitivityInspectionTemplatesEntry]()
            for structure0 in sensitivityInspectionTemplatesContainer {
                if let structure0 = structure0 {
                    sensitivityInspectionTemplatesDecoded0?.append(structure0)
                }
            }
        }
        sensitivityInspectionTemplates = sensitivityInspectionTemplatesDecoded0
    }
}

enum ListSensitivityInspectionTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of key-value pairs that specifies which tags (keys and values) are associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes {
    /// The status of an Amazon Macie account. Valid values are:
    public enum MacieStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case paused
        case sdkUnknown(Swift.String)

        public static var allCases: [MacieStatus] {
            return [
                .enabled,
                .paused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .paused: return "PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MacieStatus(rawValue: rawValue) ?? MacieStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The selection type that determines which managed data identifiers a classification job uses to analyze data. Valid values are:
    public enum ManagedDataIdentifierSelector: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case exclude
        case include
        case `none`
        case recommended
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagedDataIdentifierSelector] {
            return [
                .all,
                .exclude,
                .include,
                .none,
                .recommended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case .none: return "NONE"
            case .recommended: return "RECOMMENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManagedDataIdentifierSelector(rawValue: rawValue) ?? ManagedDataIdentifierSelector.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.ManagedDataIdentifierSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "category"
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitiveDataItemCategory.self, forKey: .category)
        category = categoryDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a managed data identifier. For additional information, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) in the Amazon Macie User Guide.
    public struct ManagedDataIdentifierSummary: Swift.Equatable {
        /// The category of sensitive data that the managed data identifier detects: CREDENTIALS, for credentials data such as private keys or Amazon Web Services secret access keys; FINANCIAL_INFORMATION, for financial data such as credit card numbers; or, PERSONAL_INFORMATION, for personal health information, such as health insurance identification numbers, or personally identifiable information, such as passport numbers.
        public var category: Macie2ClientTypes.SensitiveDataItemCategory?
        /// The unique identifier for the managed data identifier. This is a string that describes the type of sensitive data that the managed data identifier detects. For example: OPENSSH_PRIVATE_KEY for OpenSSH private keys, CREDIT_CARD_NUMBER for credit card numbers, or USA_PASSPORT_NUMBER for US passport numbers.
        public var id: Swift.String?

        public init(
            category: Macie2ClientTypes.SensitiveDataItemCategory? = nil,
            id: Swift.String? = nil
        )
        {
            self.category = category
            self.id = id
        }
    }

}

extension Macie2ClientTypes.MatchingBucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case bucketName = "bucketName"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case jobDetails = "jobDetails"
        case lastAutomatedDiscoveryTime = "lastAutomatedDiscoveryTime"
        case objectCount = "objectCount"
        case objectCountByEncryptionType = "objectCountByEncryptionType"
        case sensitivityScore = "sensitivityScore"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classifiableObjectCount = self.classifiableObjectCount {
            try encodeContainer.encode(classifiableObjectCount, forKey: .classifiableObjectCount)
        }
        if let classifiableSizeInBytes = self.classifiableSizeInBytes {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let jobDetails = self.jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let lastAutomatedDiscoveryTime = self.lastAutomatedDiscoveryTime {
            try encodeContainer.encodeTimestamp(lastAutomatedDiscoveryTime, format: .dateTime, forKey: .lastAutomatedDiscoveryTime)
        }
        if let objectCount = self.objectCount {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let objectCountByEncryptionType = self.objectCountByEncryptionType {
            try encodeContainer.encode(objectCountByEncryptionType, forKey: .objectCountByEncryptionType)
        }
        if let sensitivityScore = self.sensitivityScore {
            try encodeContainer.encode(sensitivityScore, forKey: .sensitivityScore)
        }
        if let sizeInBytes = self.sizeInBytes {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let sizeInBytesCompressed = self.sizeInBytesCompressed {
            try encodeContainer.encode(sizeInBytesCompressed, forKey: .sizeInBytesCompressed)
        }
        if let unclassifiableObjectCount = self.unclassifiableObjectCount {
            try encodeContainer.encode(unclassifiableObjectCount, forKey: .unclassifiableObjectCount)
        }
        if let unclassifiableObjectSizeInBytes = self.unclassifiableObjectSizeInBytes {
            try encodeContainer.encode(unclassifiableObjectSizeInBytes, forKey: .unclassifiableObjectSizeInBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let classifiableObjectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketMetadataErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let lastAutomatedDiscoveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAutomatedDiscoveryTime)
        lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTimeDecoded
        let objectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let objectCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectCountByEncryptionType.self, forKey: .objectCountByEncryptionType)
        objectCountByEncryptionType = objectCountByEncryptionTypeDecoded
        let sensitivityScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sensitivityScore)
        sensitivityScore = sensitivityScoreDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides statistical data and other information about an S3 bucket that Amazon Macie monitors and analyzes for your account. By default, object count and storage size values include data for object parts that are the result of incomplete multipart uploads. For more information, see [How Macie monitors Amazon S3 data security](https://docs.aws.amazon.com/macie/latest/user/monitoring-s3-how-it-works.html) in the Amazon Macie User Guide. If an error occurs when Macie attempts to retrieve and process information about the bucket or the bucket's objects, the value for most of these properties is null. Key exceptions are accountId and bucketName. To identify the cause of the error, refer to the errorCode and errorMessage values.
    public struct MatchingBucket: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that owns the bucket.
        public var accountId: Swift.String?
        /// The name of the bucket.
        public var bucketName: Swift.String?
        /// The total number of objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.
        public var classifiableObjectCount: Swift.Int?
        /// The total storage size, in bytes, of the objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format. If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.
        public var classifiableSizeInBytes: Swift.Int?
        /// The error code for an error that prevented Amazon Macie from retrieving and processing information about the bucket and the bucket's objects. If this value is ACCESS_DENIED, Macie doesn't have permission to retrieve the information. For example, the bucket has a restrictive bucket policy and Amazon S3 denied the request. If this value is null, Macie was able to retrieve and process the information.
        public var errorCode: Macie2ClientTypes.BucketMetadataErrorCode?
        /// A brief description of the error (errorCode) that prevented Amazon Macie from retrieving and processing information about the bucket and the bucket's objects. This value is null if Macie was able to retrieve and process the information.
        public var errorMessage: Swift.String?
        /// Specifies whether any one-time or recurring classification jobs are configured to analyze objects in the bucket, and, if so, the details of the job that ran most recently.
        public var jobDetails: Macie2ClientTypes.JobDetails?
        /// The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently analyzed data in the bucket while performing automated sensitive data discovery for your account. This value is null if automated sensitive data discovery is currently disabled for your account.
        public var lastAutomatedDiscoveryTime: ClientRuntime.Date?
        /// The total number of objects in the bucket.
        public var objectCount: Swift.Int?
        /// The total number of objects in the bucket, grouped by server-side encryption type. This includes a grouping that reports the total number of objects that aren't encrypted or use client-side encryption.
        public var objectCountByEncryptionType: Macie2ClientTypes.ObjectCountByEncryptionType?
        /// The current sensitivity score for the bucket, ranging from -1 (classification error) to 100 (sensitive). This value is null if automated sensitive data discovery is currently disabled for your account.
        public var sensitivityScore: Swift.Int?
        /// The total storage size, in bytes, of the bucket. If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each object in the bucket. This value doesn't reflect the storage size of all versions of each object in the bucket.
        public var sizeInBytes: Swift.Int?
        /// The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the bucket. If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.
        public var sizeInBytesCompressed: Swift.Int?
        /// The total number of objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
        public var unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics?
        /// The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.
        public var unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics?

        public init(
            accountId: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            classifiableObjectCount: Swift.Int? = nil,
            classifiableSizeInBytes: Swift.Int? = nil,
            errorCode: Macie2ClientTypes.BucketMetadataErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            jobDetails: Macie2ClientTypes.JobDetails? = nil,
            lastAutomatedDiscoveryTime: ClientRuntime.Date? = nil,
            objectCount: Swift.Int? = nil,
            objectCountByEncryptionType: Macie2ClientTypes.ObjectCountByEncryptionType? = nil,
            sensitivityScore: Swift.Int? = nil,
            sizeInBytes: Swift.Int? = nil,
            sizeInBytesCompressed: Swift.Int? = nil,
            unclassifiableObjectCount: Macie2ClientTypes.ObjectLevelStatistics? = nil,
            unclassifiableObjectSizeInBytes: Macie2ClientTypes.ObjectLevelStatistics? = nil
        )
        {
            self.accountId = accountId
            self.bucketName = bucketName
            self.classifiableObjectCount = classifiableObjectCount
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.jobDetails = jobDetails
            self.lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTime
            self.objectCount = objectCount
            self.objectCountByEncryptionType = objectCountByEncryptionType
            self.sensitivityScore = sensitivityScore
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.unclassifiableObjectCount = unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
        }
    }

}

extension Macie2ClientTypes.MatchingResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingBucket = "matchingBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingBucket = self.matchingBucket {
            try encodeContainer.encode(matchingBucket, forKey: .matchingBucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchingBucketDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MatchingBucket.self, forKey: .matchingBucket)
        matchingBucket = matchingBucketDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides statistical data and other information about an Amazon Web Services resource that Amazon Macie monitors and analyzes for your account.
    public struct MatchingResource: Swift.Equatable {
        /// The details of an S3 bucket that Amazon Macie monitors and analyzes.
        public var matchingBucket: Macie2ClientTypes.MatchingBucket?

        public init(
            matchingBucket: Macie2ClientTypes.MatchingBucket? = nil
        )
        {
            self.matchingBucket = matchingBucket
        }
    }

}

extension Macie2ClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case administratorAccountId = "administratorAccountId"
        case arn = "arn"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterAccountId = "masterAccountId"
        case relationshipStatus = "relationshipStatus"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorAccountId = self.administratorAccountId {
            try encodeContainer.encode(administratorAccountId, forKey: .administratorAccountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encodeTimestamp(invitedAt, format: .dateTime, forKey: .invitedAt)
        }
        if let masterAccountId = self.masterAccountId {
            try encodeContainer.encode(masterAccountId, forKey: .masterAccountId)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let invitedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let masterAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterAccountId)
        masterAccountId = masterAccountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an account that's associated with an Amazon Macie administrator account.
    public struct Member: Swift.Equatable {
        /// The Amazon Web Services account ID for the account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID for the administrator account.
        public var administratorAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the account.
        public var arn: Swift.String?
        /// The email address for the account. This value is null if the account is associated with the administrator account through Organizations.
        public var email: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when an Amazon Macie membership invitation was last sent to the account. This value is null if a Macie membership invitation hasn't been sent to the account.
        public var invitedAt: ClientRuntime.Date?
        /// (Deprecated) The Amazon Web Services account ID for the administrator account. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.
        public var masterAccountId: Swift.String?
        /// The current status of the relationship between the account and the administrator account.
        public var relationshipStatus: Macie2ClientTypes.RelationshipStatus?
        /// A map of key-value pairs that specifies which tags (keys and values) are associated with the account in Amazon Macie.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the relationship between the account and the administrator account.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            administratorAccountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: ClientRuntime.Date? = nil,
            masterAccountId: Swift.String? = nil,
            relationshipStatus: Macie2ClientTypes.RelationshipStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.administratorAccountId = administratorAccountId
            self.arn = arn
            self.email = email
            self.invitedAt = invitedAt
            self.masterAccountId = masterAccountId
            self.relationshipStatus = relationshipStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension Macie2ClientTypes.MonthlySchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "dayOfMonth"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a monthly recurrence pattern for running a classification job.
    public struct MonthlySchedule: Swift.Equatable {
        /// The numeric day of the month when Amazon Macie runs the job. This value can be an integer from 1 through 31. If this value exceeds the number of days in a certain month, Macie doesn't run the job that month. Macie runs the job only during months that have the specified day. For example, if this value is 31 and a month has only 30 days, Macie doesn't run the job that month. To run the job every month, specify a value that's less than 29.
        public var dayOfMonth: Swift.Int?

        public init(
            dayOfMonth: Swift.Int? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
        }
    }

}

extension Macie2ClientTypes.ObjectCountByEncryptionType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManaged = "customerManaged"
        case kmsManaged = "kmsManaged"
        case s3Managed = "s3Managed"
        case unencrypted = "unencrypted"
        case unknown = "unknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManaged = self.customerManaged {
            try encodeContainer.encode(customerManaged, forKey: .customerManaged)
        }
        if let kmsManaged = self.kmsManaged {
            try encodeContainer.encode(kmsManaged, forKey: .kmsManaged)
        }
        if let s3Managed = self.s3Managed {
            try encodeContainer.encode(s3Managed, forKey: .s3Managed)
        }
        if let unencrypted = self.unencrypted {
            try encodeContainer.encode(unencrypted, forKey: .unencrypted)
        }
        if let unknown = self.unknown {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customerManaged)
        customerManaged = customerManagedDecoded
        let kmsManagedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .kmsManaged)
        kmsManaged = kmsManagedDecoded
        let s3ManagedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .s3Managed)
        s3Managed = s3ManagedDecoded
        let unencryptedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unencrypted)
        unencrypted = unencryptedDecoded
        let unknownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the number of objects that are in an S3 bucket and use certain types of server-side encryption, use client-side encryption, or aren't encrypted.
    public struct ObjectCountByEncryptionType: Swift.Equatable {
        /// The total number of objects that are encrypted with a customer-provided key. The objects use customer-provided server-side encryption (SSE-C).
        public var customerManaged: Swift.Int?
        /// The total number of objects that are encrypted with an KMS key, either an Amazon Web Services managed key or a customer managed key. The objects use KMS encryption (SSE-KMS).
        public var kmsManaged: Swift.Int?
        /// The total number of objects that are encrypted with an Amazon S3 managed key. The objects use Amazon S3 managed encryption (SSE-S3).
        public var s3Managed: Swift.Int?
        /// The total number of objects that use client-side encryption or aren't encrypted.
        public var unencrypted: Swift.Int?
        /// The total number of objects that Amazon Macie doesn't have current encryption metadata for. Macie can't provide current data about the encryption settings for these objects.
        public var unknown: Swift.Int?

        public init(
            customerManaged: Swift.Int? = nil,
            kmsManaged: Swift.Int? = nil,
            s3Managed: Swift.Int? = nil,
            unencrypted: Swift.Int? = nil,
            unknown: Swift.Int? = nil
        )
        {
            self.customerManaged = customerManaged
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
            self.unknown = unknown
        }
    }

}

extension Macie2ClientTypes.ObjectLevelStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileType = "fileType"
        case storageClass = "storageClass"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType, forKey: .fileType)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the total storage size (in bytes) or number of objects that Amazon Macie can't analyze in one or more S3 buckets. In a BucketMetadata or MatchingBucket object, this data is for a specific bucket. In a GetBucketStatisticsResponse object, this data is aggregated for all the buckets in the query results. If versioning is enabled for a bucket, storage size values are based on the size of the latest version of each applicable object in the bucket.
    public struct ObjectLevelStatistics: Swift.Equatable {
        /// The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects don't have a file name extension for a supported file or storage format.
        public var fileType: Swift.Int?
        /// The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects use an unsupported storage class.
        public var storageClass: Swift.Int?
        /// The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects use an unsupported storage class or don't have a file name extension for a supported file or storage format.
        public var total: Swift.Int?

        public init(
            fileType: Swift.Int? = nil,
            storageClass: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.fileType = fileType
            self.storageClass = storageClass
            self.total = total
        }
    }

}

extension Macie2ClientTypes.Occurrences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case lineRanges = "lineRanges"
        case offsetRanges = "offsetRanges"
        case pages = "pages"
        case records = "records"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cell0 in cells {
                try cellsContainer.encode(cell0)
            }
        }
        if let lineRanges = lineRanges {
            var lineRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineRanges)
            for range0 in lineRanges {
                try lineRangesContainer.encode(range0)
            }
        }
        if let offsetRanges = offsetRanges {
            var offsetRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offsetRanges)
            for range0 in offsetRanges {
                try offsetRangesContainer.encode(range0)
            }
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for page0 in pages {
                try pagesContainer.encode(page0)
            }
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for record0 in records {
                try recordsContainer.encode(record0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Cell?].self, forKey: .cells)
        var cellsDecoded0:[Macie2ClientTypes.Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Macie2ClientTypes.Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
        let lineRangesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Range?].self, forKey: .lineRanges)
        var lineRangesDecoded0:[Macie2ClientTypes.Range]? = nil
        if let lineRangesContainer = lineRangesContainer {
            lineRangesDecoded0 = [Macie2ClientTypes.Range]()
            for structure0 in lineRangesContainer {
                if let structure0 = structure0 {
                    lineRangesDecoded0?.append(structure0)
                }
            }
        }
        lineRanges = lineRangesDecoded0
        let offsetRangesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Range?].self, forKey: .offsetRanges)
        var offsetRangesDecoded0:[Macie2ClientTypes.Range]? = nil
        if let offsetRangesContainer = offsetRangesContainer {
            offsetRangesDecoded0 = [Macie2ClientTypes.Range]()
            for structure0 in offsetRangesContainer {
                if let structure0 = structure0 {
                    offsetRangesDecoded0?.append(structure0)
                }
            }
        }
        offsetRanges = offsetRangesDecoded0
        let pagesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[Macie2ClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Macie2ClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
        let recordsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[Macie2ClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Macie2ClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies the location of 1-15 occurrences of sensitive data that was detected by a managed data identifier or a custom data identifier and produced a sensitive data finding.
    public struct Occurrences: Swift.Equatable {
        /// An array of objects, one for each occurrence of sensitive data in a Microsoft Excel workbook, CSV file, or TSV file. This value is null for all other types of files. Each Cell object specifies a cell or field that contains the sensitive data.
        public var cells: [Macie2ClientTypes.Cell]?
        /// An array of objects, one for each occurrence of sensitive data in an email message or a non-binary text file such as an HTML, TXT, or XML file. Each Range object specifies a line or inclusive range of lines that contains the sensitive data, and the position of the data on the specified line or lines. This value is often null for file types that are supported by Cell, Page, or Record objects. Exceptions are the location of sensitive data in: unstructured sections of an otherwise structured file, such as a comment in a file; a malformed file that Amazon Macie analyzes as plain text; and, a CSV or TSV file that has any column names that contain sensitive data.
        public var lineRanges: [Macie2ClientTypes.Range]?
        /// Reserved for future use.
        public var offsetRanges: [Macie2ClientTypes.Range]?
        /// An array of objects, one for each occurrence of sensitive data in an Adobe Portable Document Format file. This value is null for all other types of files. Each Page object specifies a page that contains the sensitive data.
        public var pages: [Macie2ClientTypes.Page]?
        /// An array of objects, one for each occurrence of sensitive data in an Apache Avro object container, Apache Parquet file, JSON file, or JSON Lines file. This value is null for all other types of files. For an Avro object container or Parquet file, each Record object specifies a record index and the path to a field in a record that contains the sensitive data. For a JSON or JSON Lines file, each Record object specifies the path to a field or array that contains the sensitive data. For a JSON Lines file, it also specifies the index of the line that contains the data.
        public var records: [Macie2ClientTypes.Record]?

        public init(
            cells: [Macie2ClientTypes.Cell]? = nil,
            lineRanges: [Macie2ClientTypes.Range]? = nil,
            offsetRanges: [Macie2ClientTypes.Range]? = nil,
            pages: [Macie2ClientTypes.Page]? = nil,
            records: [Macie2ClientTypes.Record]? = nil
        )
        {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }
    }

}

extension Macie2ClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// Specifies how Amazon Macie found the sensitive data that produced a finding. Possible values are:
    public enum OriginType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatedSensitiveDataDiscovery
        case sensitiveDataDiscoveryJob
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginType] {
            return [
                .automatedSensitiveDataDiscovery,
                .sensitiveDataDiscoveryJob,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatedSensitiveDataDiscovery: return "AUTOMATED_SENSITIVE_DATA_DISCOVERY"
            case .sensitiveDataDiscoveryJob: return "SENSITIVE_DATA_DISCOVERY_JOB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginType(rawValue: rawValue) ?? OriginType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.Page: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineRange = "lineRange"
        case offsetRange = "offsetRange"
        case pageNumber = "pageNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineRange = self.lineRange {
            try encodeContainer.encode(lineRange, forKey: .lineRange)
        }
        if let offsetRange = self.offsetRange {
            try encodeContainer.encode(offsetRange, forKey: .offsetRange)
        }
        if let pageNumber = self.pageNumber {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineRangeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Range.self, forKey: .lineRange)
        lineRange = lineRangeDecoded
        let offsetRangeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Range.self, forKey: .offsetRange)
        offsetRange = offsetRangeDecoded
        let pageNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the location of an occurrence of sensitive data in an Adobe Portable Document Format file.
    public struct Page: Swift.Equatable {
        /// Reserved for future use.
        public var lineRange: Macie2ClientTypes.Range?
        /// Reserved for future use.
        public var offsetRange: Macie2ClientTypes.Range?
        /// The page number of the page that contains the sensitive data.
        public var pageNumber: Swift.Int?

        public init(
            lineRange: Macie2ClientTypes.Range? = nil,
            offsetRange: Macie2ClientTypes.Range? = nil,
            pageNumber: Swift.Int? = nil
        )
        {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }
    }

}

extension Macie2ClientTypes.PolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case actor = "actor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let actor = self.actor {
            try encodeContainer.encode(actor, forKey: .actor)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingAction.self, forKey: .action)
        action = actionDecoded
        let actorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingActor.self, forKey: .actor)
        actor = actorDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides the details of a policy finding.
    public struct PolicyDetails: Swift.Equatable {
        /// The action that produced the finding.
        public var action: Macie2ClientTypes.FindingAction?
        /// The entity that performed the action that produced the finding.
        public var actor: Macie2ClientTypes.FindingActor?

        public init(
            action: Macie2ClientTypes.FindingAction? = nil,
            actor: Macie2ClientTypes.FindingActor? = nil
        )
        {
            self.action = action
            self.actor = actor
        }
    }

}

extension PutClassificationExportConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

extension PutClassificationExportConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/classification-export-configuration"
    }
}

public struct PutClassificationExportConfigurationInput: Swift.Equatable {
    /// The location to store data classification results in, and the encryption settings to use when storing results in that location.
    /// This member is required.
    public var configuration: Macie2ClientTypes.ClassificationExportConfiguration?

    public init(
        configuration: Macie2ClientTypes.ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct PutClassificationExportConfigurationInputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.ClassificationExportConfiguration?
}

extension PutClassificationExportConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutClassificationExportConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutClassificationExportConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct PutClassificationExportConfigurationOutput: Swift.Equatable {
    /// The location where the data classification results are stored, and the encryption settings that are used when storing results in that location.
    public var configuration: Macie2ClientTypes.ClassificationExportConfiguration?

    public init(
        configuration: Macie2ClientTypes.ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct PutClassificationExportConfigurationOutputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.ClassificationExportConfiguration?
}

extension PutClassificationExportConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum PutClassificationExportConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutFindingsPublicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityHubConfiguration = self.securityHubConfiguration {
            try encodeContainer.encode(securityHubConfiguration, forKey: .securityHubConfiguration)
        }
    }
}

extension PutFindingsPublicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings-publication-configuration"
    }
}

public struct PutFindingsPublicationConfigurationInput: Swift.Equatable {
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The configuration settings that determine which findings to publish to Security Hub.
    public var securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.securityHubConfiguration = securityHubConfiguration
    }
}

struct PutFindingsPublicationConfigurationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let securityHubConfiguration: Macie2ClientTypes.SecurityHubConfiguration?
}

extension PutFindingsPublicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let securityHubConfigurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SecurityHubConfiguration.self, forKey: .securityHubConfiguration)
        securityHubConfiguration = securityHubConfigurationDecoded
    }
}

extension PutFindingsPublicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutFindingsPublicationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutFindingsPublicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "end"
        case start = "start"
        case startColumn = "startColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
        if let startColumn = self.startColumn {
            try encodeContainer.encode(startColumn, forKey: .startColumn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let startColumnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startColumn)
        startColumn = startColumnDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the location of an occurrence of sensitive data in an email message or a non-binary text file such as an HTML, TXT, or XML file.
    public struct Range: Swift.Equatable {
        /// The number of lines from the beginning of the file to the end of the sensitive data.
        public var end: Swift.Int?
        /// The number of lines from the beginning of the file to the beginning of the sensitive data.
        public var start: Swift.Int?
        /// The number of characters, with spaces and starting from 1, from the beginning of the first line that contains the sensitive data (start) to the beginning of the sensitive data.
        public var startColumn: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil,
            startColumn: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }
    }

}

extension Macie2ClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonPath = "jsonPath"
        case recordIndex = "recordIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = self.jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let recordIndex = self.recordIndex {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let recordIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordIndex)
        recordIndex = recordIndexDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the location of an occurrence of sensitive data in an Apache Avro object container, Apache Parquet file, JSON file, or JSON Lines file.
    public struct Record: Swift.Equatable {
        /// The path, as a JSONPath expression, to the sensitive data. For an Avro object container or Parquet file, this is the path to the field in the record (recordIndex) that contains the data. For a JSON or JSON Lines file, this is the path to the field or array that contains the data. If the data is a value in an array, the path also indicates which value contains the data. If Amazon Macie detects sensitive data in the name of any element in the path, Macie omits this field. If the name of an element exceeds 20 characters, Macie truncates the name by removing characters from the beginning of the name. If the resulting full path exceeds 250 characters, Macie also truncates the path, starting with the first element in the path, until the path contains 250 or fewer characters.
        public var jsonPath: Swift.String?
        /// For an Avro object container or Parquet file, the record index, starting from 0, for the record that contains the sensitive data. For a JSON Lines file, the line index, starting from 0, for the line that contains the sensitive data. This value is always 0 for JSON files.
        public var recordIndex: Swift.Int?

        public init(
            jsonPath: Swift.String? = nil,
            recordIndex: Swift.Int? = nil
        )
        {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }
    }

}

extension Macie2ClientTypes {
    /// The current status of the relationship between an account and an associated Amazon Macie administrator account. Possible values are:
    public enum RelationshipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountsuspended
        case created
        case emailverificationfailed
        case emailverificationinprogress
        case enabled
        case invited
        case paused
        case regiondisabled
        case removed
        case resigned
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipStatus] {
            return [
                .accountsuspended,
                .created,
                .emailverificationfailed,
                .emailverificationinprogress,
                .enabled,
                .invited,
                .paused,
                .regiondisabled,
                .removed,
                .resigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountsuspended: return "AccountSuspended"
            case .created: return "Created"
            case .emailverificationfailed: return "EmailVerificationFailed"
            case .emailverificationinprogress: return "EmailVerificationInProgress"
            case .enabled: return "Enabled"
            case .invited: return "Invited"
            case .paused: return "Paused"
            case .regiondisabled: return "RegionDisabled"
            case .removed: return "Removed"
            case .resigned: return "Resigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipStatus(rawValue: rawValue) ?? RelationshipStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.ReplicationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicated = "replicated"
        case replicatedExternally = "replicatedExternally"
        case replicationAccounts = "replicationAccounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicated = self.replicated {
            try encodeContainer.encode(replicated, forKey: .replicated)
        }
        if let replicatedExternally = self.replicatedExternally {
            try encodeContainer.encode(replicatedExternally, forKey: .replicatedExternally)
        }
        if let replicationAccounts = replicationAccounts {
            var replicationAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationAccounts)
            for __string0 in replicationAccounts {
                try replicationAccountsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicated)
        replicated = replicatedDecoded
        let replicatedExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicatedExternally)
        replicatedExternally = replicatedExternallyDecoded
        let replicationAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationAccounts)
        var replicationAccountsDecoded0:[Swift.String]? = nil
        if let replicationAccountsContainer = replicationAccountsContainer {
            replicationAccountsDecoded0 = [Swift.String]()
            for string0 in replicationAccountsContainer {
                if let string0 = string0 {
                    replicationAccountsDecoded0?.append(string0)
                }
            }
        }
        replicationAccounts = replicationAccountsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Provides information about settings that define whether one or more objects in an S3 bucket are replicated to S3 buckets for other Amazon Web Services accounts and, if so, which accounts.
    public struct ReplicationDetails: Swift.Equatable {
        /// Specifies whether the bucket is configured to replicate one or more objects to any destination.
        public var replicated: Swift.Bool?
        /// Specifies whether the bucket is configured to replicate one or more objects to a bucket for an Amazon Web Services account that isn't part of your Amazon Macie organization. An Amazon Macie organization is a set of Macie accounts that are centrally managed as a group of related accounts through Organizations or by Macie invitation.
        public var replicatedExternally: Swift.Bool?
        /// An array of Amazon Web Services account IDs, one for each Amazon Web Services account that owns a bucket that the bucket is configured to replicate one or more objects to.
        public var replicationAccounts: [Swift.String]?

        public init(
            replicated: Swift.Bool? = nil,
            replicatedExternally: Swift.Bool? = nil,
            replicationAccounts: [Swift.String]? = nil
        )
        {
            self.replicated = replicated
            self.replicatedExternally = replicatedExternally
            self.replicationAccounts = replicationAccounts
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred because a specified resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.ResourceProfileArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case classificationResultStatus = "classificationResultStatus"
        case sensitive = "sensitive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let classificationResultStatus = self.classificationResultStatus {
            try encodeContainer.encode(classificationResultStatus, forKey: .classificationResultStatus)
        }
        if let sensitive = self.sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let classificationResultStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classificationResultStatus)
        classificationResultStatus = classificationResultStatusDecoded
        let sensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an S3 object that Amazon Macie selected for analysis while performing automated sensitive data discovery for an S3 bucket, and the status and results of the analysis. This information is available only if automated sensitive data discovery is currently enabled for your account.
    public struct ResourceProfileArtifact: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the object.
        /// This member is required.
        public var arn: Swift.String?
        /// The status of the analysis. Possible values are:
        ///
        /// * COMPLETE - Amazon Macie successfully completed its analysis of the object.
        ///
        /// * PARTIAL - Macie analyzed only a subset of data in the object. For example, the object is an archive file that contains files in an unsupported format.
        ///
        /// * SKIPPED - Macie wasn't able to analyze the object. For example, the object is a malformed file.
        /// This member is required.
        public var classificationResultStatus: Swift.String?
        /// Specifies whether Amazon Macie found sensitive data in the object.
        public var sensitive: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            classificationResultStatus: Swift.String? = nil,
            sensitive: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.classificationResultStatus = classificationResultStatus
            self.sensitive = sensitive
        }
    }

}

extension Macie2ClientTypes.ResourceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalBytesClassified = "totalBytesClassified"
        case totalDetections = "totalDetections"
        case totalDetectionsSuppressed = "totalDetectionsSuppressed"
        case totalItemsClassified = "totalItemsClassified"
        case totalItemsSensitive = "totalItemsSensitive"
        case totalItemsSkipped = "totalItemsSkipped"
        case totalItemsSkippedInvalidEncryption = "totalItemsSkippedInvalidEncryption"
        case totalItemsSkippedInvalidKms = "totalItemsSkippedInvalidKms"
        case totalItemsSkippedPermissionDenied = "totalItemsSkippedPermissionDenied"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalBytesClassified = self.totalBytesClassified {
            try encodeContainer.encode(totalBytesClassified, forKey: .totalBytesClassified)
        }
        if let totalDetections = self.totalDetections {
            try encodeContainer.encode(totalDetections, forKey: .totalDetections)
        }
        if let totalDetectionsSuppressed = self.totalDetectionsSuppressed {
            try encodeContainer.encode(totalDetectionsSuppressed, forKey: .totalDetectionsSuppressed)
        }
        if let totalItemsClassified = self.totalItemsClassified {
            try encodeContainer.encode(totalItemsClassified, forKey: .totalItemsClassified)
        }
        if let totalItemsSensitive = self.totalItemsSensitive {
            try encodeContainer.encode(totalItemsSensitive, forKey: .totalItemsSensitive)
        }
        if let totalItemsSkipped = self.totalItemsSkipped {
            try encodeContainer.encode(totalItemsSkipped, forKey: .totalItemsSkipped)
        }
        if let totalItemsSkippedInvalidEncryption = self.totalItemsSkippedInvalidEncryption {
            try encodeContainer.encode(totalItemsSkippedInvalidEncryption, forKey: .totalItemsSkippedInvalidEncryption)
        }
        if let totalItemsSkippedInvalidKms = self.totalItemsSkippedInvalidKms {
            try encodeContainer.encode(totalItemsSkippedInvalidKms, forKey: .totalItemsSkippedInvalidKms)
        }
        if let totalItemsSkippedPermissionDenied = self.totalItemsSkippedPermissionDenied {
            try encodeContainer.encode(totalItemsSkippedPermissionDenied, forKey: .totalItemsSkippedPermissionDenied)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalBytesClassifiedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBytesClassified)
        totalBytesClassified = totalBytesClassifiedDecoded
        let totalDetectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDetections)
        totalDetections = totalDetectionsDecoded
        let totalDetectionsSuppressedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDetectionsSuppressed)
        totalDetectionsSuppressed = totalDetectionsSuppressedDecoded
        let totalItemsClassifiedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsClassified)
        totalItemsClassified = totalItemsClassifiedDecoded
        let totalItemsSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsSensitive)
        totalItemsSensitive = totalItemsSensitiveDecoded
        let totalItemsSkippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsSkipped)
        totalItemsSkipped = totalItemsSkippedDecoded
        let totalItemsSkippedInvalidEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsSkippedInvalidEncryption)
        totalItemsSkippedInvalidEncryption = totalItemsSkippedInvalidEncryptionDecoded
        let totalItemsSkippedInvalidKmsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsSkippedInvalidKms)
        totalItemsSkippedInvalidKms = totalItemsSkippedInvalidKmsDecoded
        let totalItemsSkippedPermissionDeniedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalItemsSkippedPermissionDenied)
        totalItemsSkippedPermissionDenied = totalItemsSkippedPermissionDeniedDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides statistical data for sensitive data discovery metrics that apply to an S3 bucket that Amazon Macie monitors and analyzes for your account. The statistics capture the results of automated sensitive data discovery activities that Macie has performed for the bucket. The data is available only if automated sensitive data discovery is currently enabled for your account.
    public struct ResourceStatistics: Swift.Equatable {
        /// The total amount of data, in bytes, that Amazon Macie has analyzed in the bucket.
        public var totalBytesClassified: Swift.Int?
        /// The total number of occurrences of sensitive data that Amazon Macie has found in the bucket's objects. This includes occurrences that are currently suppressed by the sensitivity scoring settings for the bucket (totalDetectionsSuppressed).
        public var totalDetections: Swift.Int?
        /// The total number of occurrences of sensitive data that are currently suppressed by the sensitivity scoring settings for the bucket. These represent occurrences of sensitive data that Amazon Macie found in the bucket's objects, but the occurrences were manually suppressed. By default, suppressed occurrences are excluded from the bucket's sensitivity score.
        public var totalDetectionsSuppressed: Swift.Int?
        /// The total number of objects that Amazon Macie has analyzed in the bucket.
        public var totalItemsClassified: Swift.Int?
        /// The total number of the bucket's objects that Amazon Macie has found sensitive data in.
        public var totalItemsSensitive: Swift.Int?
        /// The total number of objects that Amazon Macie wasn't able to analyze in the bucket due to an object-level issue or error. For example, the object is a malformed file. This value includes objects that Macie wasn't able to analyze for reasons reported by other statistics in the ResourceStatistics object.
        public var totalItemsSkipped: Swift.Int?
        /// The total number of objects that Amazon Macie wasn't able to analyze in the bucket because the objects are encrypted with a key that Macie can't access. The objects use server-side encryption with customer-provided keys (SSE-C).
        public var totalItemsSkippedInvalidEncryption: Swift.Int?
        /// The total number of objects that Amazon Macie wasn't able to analyze in the bucket because the objects are encrypted with KMS keys that were disabled, are scheduled for deletion, or were deleted.
        public var totalItemsSkippedInvalidKms: Swift.Int?
        /// The total number of objects that Amazon Macie wasn't able to analyze in the bucket due to the permissions settings for the objects or the permissions settings for the keys that were used to encrypt the objects.
        public var totalItemsSkippedPermissionDenied: Swift.Int?

        public init(
            totalBytesClassified: Swift.Int? = nil,
            totalDetections: Swift.Int? = nil,
            totalDetectionsSuppressed: Swift.Int? = nil,
            totalItemsClassified: Swift.Int? = nil,
            totalItemsSensitive: Swift.Int? = nil,
            totalItemsSkipped: Swift.Int? = nil,
            totalItemsSkippedInvalidEncryption: Swift.Int? = nil,
            totalItemsSkippedInvalidKms: Swift.Int? = nil,
            totalItemsSkippedPermissionDenied: Swift.Int? = nil
        )
        {
            self.totalBytesClassified = totalBytesClassified
            self.totalDetections = totalDetections
            self.totalDetectionsSuppressed = totalDetectionsSuppressed
            self.totalItemsClassified = totalItemsClassified
            self.totalItemsSensitive = totalItemsSensitive
            self.totalItemsSkipped = totalItemsSkipped
            self.totalItemsSkippedInvalidEncryption = totalItemsSkippedInvalidEncryption
            self.totalItemsSkippedInvalidKms = totalItemsSkippedInvalidKms
            self.totalItemsSkippedPermissionDenied = totalItemsSkippedPermissionDenied
        }
    }

}

extension Macie2ClientTypes.ResourcesAffected: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "s3Bucket"
        case s3Object = "s3Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3Bucket.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3ObjectDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the resources that a finding applies to.
    public struct ResourcesAffected: Swift.Equatable {
        /// The details of the S3 bucket that the finding applies to.
        public var s3Bucket: Macie2ClientTypes.S3Bucket?
        /// The details of the S3 object that the finding applies to.
        public var s3Object: Macie2ClientTypes.S3Object?

        public init(
            s3Bucket: Macie2ClientTypes.S3Bucket? = nil,
            s3Object: Macie2ClientTypes.S3Object? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Object = s3Object
        }
    }

}

extension Macie2ClientTypes.RevealConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "kmsKeyId"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RevealStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the configuration settings for retrieving occurrences of sensitive data reported by findings, and the status of the configuration for an Amazon Macie account. When you enable the configuration for the first time, your request must specify an Key Management Service (KMS) key. Otherwise, an error occurs. Macie uses the specified key to encrypt the sensitive data that you retrieve.
    public struct RevealConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN), ID, or alias of the KMS key to use to encrypt sensitive data that's retrieved. The key must be an existing, customer managed, symmetric encryption key that's in the same Amazon Web Services Region as the Amazon Macie account. If this value specifies an alias, it must include the following prefix: alias/. If this value specifies a key that's owned by another Amazon Web Services account, it must specify the ARN of the key or the ARN of the key's alias.
        public var kmsKeyId: Swift.String?
        /// The status of the configuration for the Amazon Macie account. In a request, valid values are: ENABLED, enable the configuration for the account; and, DISABLED, disable the configuration for the account. In a response, possible values are: ENABLED, the configuration is currently enabled for the account; and, DISABLED, the configuration is currently disabled for the account.
        /// This member is required.
        public var status: Macie2ClientTypes.RevealStatus?

        public init(
            kmsKeyId: Swift.String? = nil,
            status: Macie2ClientTypes.RevealStatus? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.status = status
        }
    }

}

extension Macie2ClientTypes {
    /// The status of a request to retrieve occurrences of sensitive data reported by a finding. Possible values are:
    public enum RevealRequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RevealRequestStatus] {
            return [
                .error,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RevealRequestStatus(rawValue: rawValue) ?? RevealRequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The status of the configuration for retrieving occurrences of sensitive data reported by findings. Valid values are:
    public enum RevealStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RevealStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RevealStatus(rawValue: rawValue) ?? RevealStatus.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.S3Bucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowsUnencryptedObjectUploads = self.allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads.rawValue, forKey: .allowsUnencryptedObjectUploads)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = self.defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for keyvaluepair0 in tags {
                try tagsContainer.encode(keyvaluepair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowsUnencryptedObjectUploads.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3BucketOwner.self, forKey: .owner)
        owner = ownerDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.BucketPublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[Macie2ClientTypes.KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Macie2ClientTypes.KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Provides information about the S3 bucket that a finding applies to.
    public struct S3Bucket: Swift.Equatable {
        /// Specifies whether the bucket policy for the bucket requires server-side encryption of objects when objects are added to the bucket. Possible values are:
        ///
        /// * FALSE - The bucket policy requires server-side encryption of new objects. PutObject requests must include a valid server-side encryption header.
        ///
        /// * TRUE - The bucket doesn't have a bucket policy or it has a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, it doesn't require PutObject requests to include a valid server-side encryption header.
        ///
        /// * UNKNOWN - Amazon Macie can't determine whether the bucket policy requires server-side encryption of new objects.
        ///
        ///
        /// Valid server-side encryption headers are: x-amz-server-side-encryption with a value of AES256 or aws:kms, and x-amz-server-side-encryption-customer-algorithm with a value of AES256.
        public var allowsUnencryptedObjectUploads: Macie2ClientTypes.AllowsUnencryptedObjectUploads?
        /// The Amazon Resource Name (ARN) of the bucket.
        public var arn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the bucket was created. This value can also indicate when changes such as edits to the bucket's policy were most recently made to the bucket, relative to when the finding was created or last updated.
        public var createdAt: ClientRuntime.Date?
        /// The default server-side encryption settings for the bucket.
        public var defaultServerSideEncryption: Macie2ClientTypes.ServerSideEncryption?
        /// The name of the bucket.
        public var name: Swift.String?
        /// The display name and canonical user ID for the Amazon Web Services account that owns the bucket.
        public var owner: Macie2ClientTypes.S3BucketOwner?
        /// The permissions settings that determine whether the bucket is publicly accessible.
        public var publicAccess: Macie2ClientTypes.BucketPublicAccess?
        /// The tags that are associated with the bucket.
        public var tags: [Macie2ClientTypes.KeyValuePair]?

        public init(
            allowsUnencryptedObjectUploads: Macie2ClientTypes.AllowsUnencryptedObjectUploads? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            defaultServerSideEncryption: Macie2ClientTypes.ServerSideEncryption? = nil,
            name: Swift.String? = nil,
            owner: Macie2ClientTypes.S3BucketOwner? = nil,
            publicAccess: Macie2ClientTypes.BucketPublicAccess? = nil,
            tags: [Macie2ClientTypes.KeyValuePair]? = nil
        )
        {
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
        }
    }

}

extension Macie2ClientTypes.S3BucketCriteriaForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = self.includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.CriteriaBlockForJob.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.CriteriaBlockForJob.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies property- and tag-based conditions that define criteria for including or excluding S3 buckets from a classification job. Exclude conditions take precedence over include conditions.
    public struct S3BucketCriteriaForJob: Swift.Equatable {
        /// The property- and tag-based conditions that determine which buckets to exclude from the job.
        public var excludes: Macie2ClientTypes.CriteriaBlockForJob?
        /// The property- and tag-based conditions that determine which buckets to include in the job.
        public var includes: Macie2ClientTypes.CriteriaBlockForJob?

        public init(
            excludes: Macie2ClientTypes.CriteriaBlockForJob? = nil,
            includes: Macie2ClientTypes.CriteriaBlockForJob? = nil
        )
        {
            self.excludes = excludes
            self.includes = includes
        }
    }

}

extension Macie2ClientTypes.S3BucketDefinitionForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case buckets = "buckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let buckets = buckets {
            var bucketsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buckets)
            for __string0 in buckets {
                try bucketsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buckets)
        var bucketsDecoded0:[Swift.String]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [Swift.String]()
            for string0 in bucketsContainer {
                if let string0 = string0 {
                    bucketsDecoded0?.append(string0)
                }
            }
        }
        buckets = bucketsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies an Amazon Web Services account that owns S3 buckets for a classification job to analyze, and one or more specific buckets to analyze for that account.
    public struct S3BucketDefinitionForJob: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that owns the buckets.
        /// This member is required.
        public var accountId: Swift.String?
        /// An array that lists the names of the buckets.
        /// This member is required.
        public var buckets: [Swift.String]?

        public init(
            accountId: Swift.String? = nil,
            buckets: [Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.buckets = buckets
        }
    }

}

extension Macie2ClientTypes.S3BucketOwner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "displayName"
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the Amazon Web Services account that owns an S3 bucket.
    public struct S3BucketOwner: Swift.Equatable {
        /// The display name of the account that owns the bucket.
        public var displayName: Swift.String?
        /// The canonical user ID for the account that owns the bucket.
        public var id: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.id = id
        }
    }

}

extension Macie2ClientTypes.S3ClassificationScope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3ClassificationScopeExclusion.self, forKey: .excludes)
        excludes = excludesDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies the S3 buckets that are excluded from automated sensitive data discovery for an Amazon Macie account.
    public struct S3ClassificationScope: Swift.Equatable {
        /// The S3 buckets that are excluded.
        /// This member is required.
        public var excludes: Macie2ClientTypes.S3ClassificationScopeExclusion?

        public init(
            excludes: Macie2ClientTypes.S3ClassificationScopeExclusion? = nil
        )
        {
            self.excludes = excludes
        }
    }

}

extension Macie2ClientTypes.S3ClassificationScopeExclusion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketNames = "bucketNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketNames = bucketNames {
            var bucketNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketNames)
            for s3bucketname0 in bucketNames {
                try bucketNamesContainer.encode(s3bucketname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bucketNames)
        var bucketNamesDecoded0:[Swift.String]? = nil
        if let bucketNamesContainer = bucketNamesContainer {
            bucketNamesDecoded0 = [Swift.String]()
            for string0 in bucketNamesContainer {
                if let string0 = string0 {
                    bucketNamesDecoded0?.append(string0)
                }
            }
        }
        bucketNames = bucketNamesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies the names of the S3 buckets that are excluded from automated sensitive data discovery.
    public struct S3ClassificationScopeExclusion: Swift.Equatable {
        /// An array of strings, one for each S3 bucket that is excluded. Each string is the full name of an excluded bucket.
        /// This member is required.
        public var bucketNames: [Swift.String]?

        public init(
            bucketNames: [Swift.String]? = nil
        )
        {
            self.bucketNames = bucketNames
        }
    }

}

extension Macie2ClientTypes.S3ClassificationScopeExclusionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketNames = "bucketNames"
        case operation = "operation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketNames = bucketNames {
            var bucketNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketNames)
            for s3bucketname0 in bucketNames {
                try bucketNamesContainer.encode(s3bucketname0)
            }
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bucketNames)
        var bucketNamesDecoded0:[Swift.String]? = nil
        if let bucketNamesContainer = bucketNamesContainer {
            bucketNamesDecoded0 = [Swift.String]()
            for string0 in bucketNamesContainer {
                if let string0 = string0 {
                    bucketNamesDecoded0?.append(string0)
                }
            }
        }
        bucketNames = bucketNamesDecoded0
        let operationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ClassificationScopeUpdateOperation.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies S3 buckets to add or remove from the exclusion list defined by the classification scope for an Amazon Macie account.
    public struct S3ClassificationScopeExclusionUpdate: Swift.Equatable {
        /// Depending on the value specified for the update operation (ClassificationScopeUpdateOperation), an array of strings that: lists the names of buckets to add or remove from the list, or specifies a new set of bucket names that overwrites all existing names in the list. Each string must be the full name of an S3 bucket. Values are case sensitive.
        /// This member is required.
        public var bucketNames: [Swift.String]?
        /// Specifies how to apply the changes to the exclusion list. Valid values are:
        ///
        /// * ADD - Append the specified bucket names to the current list.
        ///
        /// * REMOVE - Remove the specified bucket names from the current list.
        ///
        /// * REPLACE - Overwrite the current list with the specified list of bucket names. If you specify this value, Amazon Macie removes all existing names from the list and adds all the specified names to the list.
        /// This member is required.
        public var operation: Macie2ClientTypes.ClassificationScopeUpdateOperation?

        public init(
            bucketNames: [Swift.String]? = nil,
            operation: Macie2ClientTypes.ClassificationScopeUpdateOperation? = nil
        )
        {
            self.bucketNames = bucketNames
            self.operation = operation
        }
    }

}

extension Macie2ClientTypes.S3ClassificationScopeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3ClassificationScopeExclusionUpdate.self, forKey: .excludes)
        excludes = excludesDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies changes to the list of S3 buckets that are excluded from automated sensitive data discovery for an Amazon Macie account.
    public struct S3ClassificationScopeUpdate: Swift.Equatable {
        /// The names of the S3 buckets to add or remove from the list.
        /// This member is required.
        public var excludes: Macie2ClientTypes.S3ClassificationScopeExclusionUpdate?

        public init(
            excludes: Macie2ClientTypes.S3ClassificationScopeExclusionUpdate? = nil
        )
        {
            self.excludes = excludes
        }
    }

}

extension Macie2ClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case keyPrefix = "keyPrefix"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let keyPrefix = self.keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies an S3 bucket to store data classification results in, and the encryption settings to use when storing results in that bucket.
    public struct S3Destination: Swift.Equatable {
        /// The name of the bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The path prefix to use in the path to the location in the bucket. This prefix specifies where to store classification results in the bucket.
        public var keyPrefix: Swift.String?
        /// The Amazon Resource Name (ARN) of the customer managed KMS key to use for encryption of the results. This must be the ARN of an existing, symmetric encryption KMS key that's in the same Amazon Web Services Region as the bucket.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension Macie2ClientTypes.S3JobDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketCriteria = "bucketCriteria"
        case bucketDefinitions = "bucketDefinitions"
        case scoping = "scoping"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = self.bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if let bucketDefinitions = bucketDefinitions {
            var bucketDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketDefinitions)
            for s3bucketdefinitionforjob0 in bucketDefinitions {
                try bucketDefinitionsContainer.encode(s3bucketdefinitionforjob0)
            }
        }
        if let scoping = self.scoping {
            try encodeContainer.encode(scoping, forKey: .scoping)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3BucketCriteriaForJob.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
        let bucketDefinitionsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.S3BucketDefinitionForJob?].self, forKey: .bucketDefinitions)
        var bucketDefinitionsDecoded0:[Macie2ClientTypes.S3BucketDefinitionForJob]? = nil
        if let bucketDefinitionsContainer = bucketDefinitionsContainer {
            bucketDefinitionsDecoded0 = [Macie2ClientTypes.S3BucketDefinitionForJob]()
            for structure0 in bucketDefinitionsContainer {
                if let structure0 = structure0 {
                    bucketDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        bucketDefinitions = bucketDefinitionsDecoded0
        let scopingDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Scoping.self, forKey: .scoping)
        scoping = scopingDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies which S3 buckets contain the objects that a classification job analyzes, and the scope of that analysis. The bucket specification can be static (bucketDefinitions) or dynamic (bucketCriteria). If it's static, the job analyzes objects in the same predefined set of buckets each time the job runs. If it's dynamic, the job analyzes objects in any buckets that match the specified criteria each time the job starts to run.
    public struct S3JobDefinition: Swift.Equatable {
        /// The property- and tag-based conditions that determine which S3 buckets to include or exclude from the analysis. Each time the job runs, the job uses these criteria to determine which buckets contain objects to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.
        public var bucketCriteria: Macie2ClientTypes.S3BucketCriteriaForJob?
        /// An array of objects, one for each Amazon Web Services account that owns specific S3 buckets to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.
        public var bucketDefinitions: [Macie2ClientTypes.S3BucketDefinitionForJob]?
        /// The property- and tag-based conditions that determine which S3 objects to include or exclude from the analysis. Each time the job runs, the job uses these criteria to determine which objects to analyze.
        public var scoping: Macie2ClientTypes.Scoping?

        public init(
            bucketCriteria: Macie2ClientTypes.S3BucketCriteriaForJob? = nil,
            bucketDefinitions: [Macie2ClientTypes.S3BucketDefinitionForJob]? = nil,
            scoping: Macie2ClientTypes.Scoping? = nil
        )
        {
            self.bucketCriteria = bucketCriteria
            self.bucketDefinitions = bucketDefinitions
            self.scoping = scoping
        }
    }

}

extension Macie2ClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "bucketArn"
        case eTag = "eTag"
        case `extension` = "extension"
        case key = "key"
        case lastModified = "lastModified"
        case path = "path"
        case publicAccess = "publicAccess"
        case serverSideEncryption = "serverSideEncryption"
        case size = "size"
        case storageClass = "storageClass"
        case tags = "tags"
        case versionId = "versionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let `extension` = self.`extension` {
            try encodeContainer.encode(`extension`, forKey: .`extension`)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .dateTime, forKey: .lastModified)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let serverSideEncryption = self.serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for keyvaluepair0 in tags {
                try tagsContainer.encode(keyvaluepair0)
            }
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let extensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extension)
        `extension` = extensionDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ServerSideEncryption.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[Macie2ClientTypes.KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Macie2ClientTypes.KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the S3 object that a finding applies to.
    public struct S3Object: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the bucket that contains the object.
        public var bucketArn: Swift.String?
        /// The entity tag (ETag) that identifies the affected version of the object. If the object was overwritten or changed after Amazon Macie produced the finding, this value might be different from the current ETag for the object.
        public var eTag: Swift.String?
        /// The file name extension of the object. If the object doesn't have a file name extension, this value is "".
        public var `extension`: Swift.String?
        /// The full name (key) of the object, including the object's prefix if applicable.
        public var key: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the object was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The full path to the affected object, including the name of the affected bucket and the object's name (key).
        public var path: Swift.String?
        /// Specifies whether the object is publicly accessible due to the combination of permissions settings that apply to the object.
        public var publicAccess: Swift.Bool?
        /// The type of server-side encryption that was used to encrypt the object.
        public var serverSideEncryption: Macie2ClientTypes.ServerSideEncryption?
        /// The total storage size, in bytes, of the object.
        public var size: Swift.Int?
        /// The storage class of the object.
        public var storageClass: Macie2ClientTypes.StorageClass?
        /// The tags that are associated with the object.
        public var tags: [Macie2ClientTypes.KeyValuePair]?
        /// The identifier for the affected version of the object.
        public var versionId: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            eTag: Swift.String? = nil,
            `extension`: Swift.String? = nil,
            key: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            publicAccess: Swift.Bool? = nil,
            serverSideEncryption: Macie2ClientTypes.ServerSideEncryption? = nil,
            size: Swift.Int? = nil,
            storageClass: Macie2ClientTypes.StorageClass? = nil,
            tags: [Macie2ClientTypes.KeyValuePair]? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.eTag = eTag
            self.`extension` = `extension`
            self.key = key
            self.lastModified = lastModified
            self.path = path
            self.publicAccess = publicAccess
            self.serverSideEncryption = serverSideEncryption
            self.size = size
            self.storageClass = storageClass
            self.tags = tags
            self.versionId = versionId
        }
    }

}

extension Macie2ClientTypes.S3WordsList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case objectKey = "objectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an S3 object that lists specific text to ignore.
    public struct S3WordsList: Swift.Equatable {
        /// The full name of the S3 bucket that contains the object.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The full name (key) of the object.
        /// This member is required.
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension Macie2ClientTypes {
    /// The property to use in a condition that determines whether an S3 object is included or excluded from a classification job. Valid values are:
    public enum ScopeFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case objectExtension
        case objectKey
        case objectLastModifiedDate
        case objectSize
        case sdkUnknown(Swift.String)

        public static var allCases: [ScopeFilterKey] {
            return [
                .objectExtension,
                .objectKey,
                .objectLastModifiedDate,
                .objectSize,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .objectExtension: return "OBJECT_EXTENSION"
            case .objectKey: return "OBJECT_KEY"
            case .objectLastModifiedDate: return "OBJECT_LAST_MODIFIED_DATE"
            case .objectSize: return "OBJECT_SIZE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScopeFilterKey(rawValue: rawValue) ?? ScopeFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.Scoping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = self.includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobScopingBlock.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobScopingBlock.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 objects from a classification job. Exclude conditions take precedence over include conditions.
    public struct Scoping: Swift.Equatable {
        /// The property- and tag-based conditions that determine which objects to exclude from the analysis.
        public var excludes: Macie2ClientTypes.JobScopingBlock?
        /// The property- and tag-based conditions that determine which objects to include in the analysis.
        public var includes: Macie2ClientTypes.JobScopingBlock?

        public init(
            excludes: Macie2ClientTypes.JobScopingBlock? = nil,
            includes: Macie2ClientTypes.JobScopingBlock? = nil
        )
        {
            self.excludes = excludes
            self.includes = includes
        }
    }

}

extension Macie2ClientTypes.SearchResourcesBucketCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = self.includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesCriteriaBlock.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesCriteriaBlock.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies property- and tag-based conditions that define filter criteria for including or excluding S3 buckets from the query results. Exclude conditions take precedence over include conditions.
    public struct SearchResourcesBucketCriteria: Swift.Equatable {
        /// The property- and tag-based conditions that determine which buckets to exclude from the results.
        public var excludes: Macie2ClientTypes.SearchResourcesCriteriaBlock?
        /// The property- and tag-based conditions that determine which buckets to include in the results.
        public var includes: Macie2ClientTypes.SearchResourcesCriteriaBlock?

        public init(
            excludes: Macie2ClientTypes.SearchResourcesCriteriaBlock? = nil,
            includes: Macie2ClientTypes.SearchResourcesCriteriaBlock? = nil
        )
        {
            self.excludes = excludes
            self.includes = includes
        }
    }

}

extension Macie2ClientTypes {
    /// The operator to use in a condition that filters the results of a query. Valid values are:
    public enum SearchResourcesComparator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eq
        case ne
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchResourcesComparator] {
            return [
                .eq,
                .ne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case .ne: return "NE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchResourcesComparator(rawValue: rawValue) ?? SearchResourcesComparator.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SearchResourcesCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleCriterion = "simpleCriterion"
        case tagCriterion = "tagCriterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleCriterion = self.simpleCriterion {
            try encodeContainer.encode(simpleCriterion, forKey: .simpleCriterion)
        }
        if let tagCriterion = self.tagCriterion {
            try encodeContainer.encode(tagCriterion, forKey: .tagCriterion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleCriterionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesSimpleCriterion.self, forKey: .simpleCriterion)
        simpleCriterion = simpleCriterionDecoded
        let tagCriterionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesTagCriterion.self, forKey: .tagCriterion)
        tagCriterion = tagCriterionDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a property- or tag-based filter condition for including or excluding Amazon Web Services resources from the query results.
    public struct SearchResourcesCriteria: Swift.Equatable {
        /// A property-based condition that defines a property, operator, and one or more values for including or excluding resources from the results.
        public var simpleCriterion: Macie2ClientTypes.SearchResourcesSimpleCriterion?
        /// A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding resources from the results.
        public var tagCriterion: Macie2ClientTypes.SearchResourcesTagCriterion?

        public init(
            simpleCriterion: Macie2ClientTypes.SearchResourcesSimpleCriterion? = nil,
            tagCriterion: Macie2ClientTypes.SearchResourcesTagCriterion? = nil
        )
        {
            self.simpleCriterion = simpleCriterion
            self.tagCriterion = tagCriterion
        }
    }

}

extension Macie2ClientTypes.SearchResourcesCriteriaBlock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for searchresourcescriteria0 in and {
                try andContainer.encode(searchresourcescriteria0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SearchResourcesCriteria?].self, forKey: .and)
        var andDecoded0:[Macie2ClientTypes.SearchResourcesCriteria]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [Macie2ClientTypes.SearchResourcesCriteria]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies property- and tag-based conditions that define filter criteria for including or excluding Amazon Web Services resources from the query results.
    public struct SearchResourcesCriteriaBlock: Swift.Equatable {
        /// An array of objects, one for each property- or tag-based condition that includes or excludes resources from the query results. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.
        public var and: [Macie2ClientTypes.SearchResourcesCriteria]?

        public init(
            and: [Macie2ClientTypes.SearchResourcesCriteria]? = nil
        )
        {
            self.and = and
        }
    }

}

extension SearchResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketCriteria = "bucketCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = self.bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension SearchResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasources/search-resources"
    }
}

public struct SearchResourcesInput: Swift.Equatable {
    /// The filter conditions that determine which S3 buckets to include or exclude from the query results.
    public var bucketCriteria: Macie2ClientTypes.SearchResourcesBucketCriteria?
    /// The maximum number of items to include in each page of the response. The default value is 50.
    public var maxResults: Swift.Int?
    /// The nextToken string that specifies which page of results to return in a paginated response.
    public var nextToken: Swift.String?
    /// The criteria to use to sort the results.
    public var sortCriteria: Macie2ClientTypes.SearchResourcesSortCriteria?

    public init(
        bucketCriteria: Macie2ClientTypes.SearchResourcesBucketCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Macie2ClientTypes.SearchResourcesSortCriteria? = nil
    )
    {
        self.bucketCriteria = bucketCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchResourcesInputBody: Swift.Equatable {
    let bucketCriteria: Macie2ClientTypes.SearchResourcesBucketCriteria?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortCriteria: Macie2ClientTypes.SearchResourcesSortCriteria?
}

extension SearchResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketCriteria = "bucketCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesBucketCriteria.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension SearchResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchingResources = output.matchingResources
            self.nextToken = output.nextToken
        } else {
            self.matchingResources = nil
            self.nextToken = nil
        }
    }
}

public struct SearchResourcesOutput: Swift.Equatable {
    /// An array of objects, one for each resource that matches the filter criteria specified in the request.
    public var matchingResources: [Macie2ClientTypes.MatchingResource]?
    /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
    public var nextToken: Swift.String?

    public init(
        matchingResources: [Macie2ClientTypes.MatchingResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.matchingResources = matchingResources
        self.nextToken = nextToken
    }
}

struct SearchResourcesOutputBody: Swift.Equatable {
    let matchingResources: [Macie2ClientTypes.MatchingResource]?
    let nextToken: Swift.String?
}

extension SearchResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingResources = "matchingResources"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchingResourcesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.MatchingResource?].self, forKey: .matchingResources)
        var matchingResourcesDecoded0:[Macie2ClientTypes.MatchingResource]? = nil
        if let matchingResourcesContainer = matchingResourcesContainer {
            matchingResourcesDecoded0 = [Macie2ClientTypes.MatchingResource]()
            for structure0 in matchingResourcesContainer {
                if let structure0 = structure0 {
                    matchingResourcesDecoded0?.append(structure0)
                }
            }
        }
        matchingResources = matchingResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.SearchResourcesSimpleCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __string0 in values {
                try valuesContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesSimpleCriterionKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a property-based filter condition that determines which Amazon Web Services resources are included or excluded from the query results.
    public struct SearchResourcesSimpleCriterion: Swift.Equatable {
        /// The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).
        public var comparator: Macie2ClientTypes.SearchResourcesComparator?
        /// The property to use in the condition.
        public var key: Macie2ClientTypes.SearchResourcesSimpleCriterionKey?
        /// An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:
        ///
        /// * ACCOUNT_ID - A string that represents the unique identifier for the Amazon Web Services account that owns the resource.
        ///
        /// * S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the [BucketPublicAccess.effectivePermission](https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission) property of an S3 bucket.
        ///
        /// * S3_BUCKET_NAME - A string that represents the name of an S3 bucket.
        ///
        /// * S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the [BucketMetadata.sharedAccess](https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess) property of an S3 bucket.
        ///
        ///
        /// Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in values.
        public var values: [Swift.String]?

        public init(
            comparator: Macie2ClientTypes.SearchResourcesComparator? = nil,
            key: Macie2ClientTypes.SearchResourcesSimpleCriterionKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.values = values
        }
    }

}

extension Macie2ClientTypes {
    /// The property to use in a condition that filters the query results. Valid values are:
    public enum SearchResourcesSimpleCriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case s3BucketEffectivePermission
        case s3BucketName
        case s3BucketSharedAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchResourcesSimpleCriterionKey] {
            return [
                .accountId,
                .s3BucketEffectivePermission,
                .s3BucketName,
                .s3BucketSharedAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .s3BucketEffectivePermission: return "S3_BUCKET_EFFECTIVE_PERMISSION"
            case .s3BucketName: return "S3_BUCKET_NAME"
            case .s3BucketSharedAccess: return "S3_BUCKET_SHARED_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchResourcesSimpleCriterionKey(rawValue: rawValue) ?? SearchResourcesSimpleCriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The property to sort the query results by. Valid values are:
    public enum SearchResourcesSortAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case resourceName
        case s3ClassifiableObjectCount
        case s3ClassifiableSizeInBytes
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchResourcesSortAttributeName] {
            return [
                .accountId,
                .resourceName,
                .s3ClassifiableObjectCount,
                .s3ClassifiableSizeInBytes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .resourceName: return "RESOURCE_NAME"
            case .s3ClassifiableObjectCount: return "S3_CLASSIFIABLE_OBJECT_COUNT"
            case .s3ClassifiableSizeInBytes: return "S3_CLASSIFIABLE_SIZE_IN_BYTES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchResourcesSortAttributeName(rawValue: rawValue) ?? SearchResourcesSortAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SearchResourcesSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a query for information about Amazon Web Services resources that Amazon Macie monitors and analyzes.
    public struct SearchResourcesSortCriteria: Swift.Equatable {
        /// The property to sort the results by.
        public var attributeName: Macie2ClientTypes.SearchResourcesSortAttributeName?
        /// The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            attributeName: Macie2ClientTypes.SearchResourcesSortAttributeName? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension Macie2ClientTypes.SearchResourcesTagCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case tagValues = "tagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for searchresourcestagcriterionpair0 in tagValues {
                try tagValuesContainer.encode(searchresourcestagcriterionpair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SearchResourcesComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SearchResourcesTagCriterionPair?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Macie2ClientTypes.SearchResourcesTagCriterionPair]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Macie2ClientTypes.SearchResourcesTagCriterionPair]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag-based filter condition that determines which Amazon Web Services resources are included or excluded from the query results.
    public struct SearchResourcesTagCriterion: Swift.Equatable {
        /// The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).
        public var comparator: Macie2ClientTypes.SearchResourcesComparator?
        /// The tag keys, tag values, or tag key and value pairs to use in the condition.
        public var tagValues: [Macie2ClientTypes.SearchResourcesTagCriterionPair]?

        public init(
            comparator: Macie2ClientTypes.SearchResourcesComparator? = nil,
            tagValues: [Macie2ClientTypes.SearchResourcesTagCriterionPair]? = nil
        )
        {
            self.comparator = comparator
            self.tagValues = tagValues
        }
    }

}

extension Macie2ClientTypes.SearchResourcesTagCriterionPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag key, a tag value, or a tag key and value (as a pair) to use in a tag-based filter condition for a query. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based filter conditions.
    public struct SearchResourcesTagCriterionPair: Swift.Equatable {
        /// The value for the tag key to use in the condition.
        public var key: Swift.String?
        /// The tag value to use in the condition.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension Macie2ClientTypes.SecurityHubConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishClassificationFindings = "publishClassificationFindings"
        case publishPolicyFindings = "publishPolicyFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishClassificationFindings = self.publishClassificationFindings {
            try encodeContainer.encode(publishClassificationFindings, forKey: .publishClassificationFindings)
        }
        if let publishPolicyFindings = self.publishPolicyFindings {
            try encodeContainer.encode(publishPolicyFindings, forKey: .publishPolicyFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishClassificationFindingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishClassificationFindings)
        publishClassificationFindings = publishClassificationFindingsDecoded
        let publishPolicyFindingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishPolicyFindings)
        publishPolicyFindings = publishPolicyFindingsDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies configuration settings that determine which findings are published to Security Hub automatically. For information about how Macie publishes findings to Security Hub, see [Amazon Macie integration with Security Hub](https://docs.aws.amazon.com/macie/latest/user/securityhub-integration.html) in the Amazon Macie User Guide.
    public struct SecurityHubConfiguration: Swift.Equatable {
        /// Specifies whether to publish sensitive data findings to Security Hub. If you set this value to true, Amazon Macie automatically publishes all sensitive data findings that weren't suppressed by a findings filter. The default value is false.
        /// This member is required.
        public var publishClassificationFindings: Swift.Bool?
        /// Specifies whether to publish policy findings to Security Hub. If you set this value to true, Amazon Macie automatically publishes all new and updated policy findings that weren't suppressed by a findings filter. The default value is true.
        /// This member is required.
        public var publishPolicyFindings: Swift.Bool?

        public init(
            publishClassificationFindings: Swift.Bool? = nil,
            publishPolicyFindings: Swift.Bool? = nil
        )
        {
            self.publishClassificationFindings = publishClassificationFindings
            self.publishPolicyFindings = publishPolicyFindings
        }
    }

}

extension Macie2ClientTypes.SensitiveDataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "category"
        case detections = "detections"
        case totalCount = "totalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for defaultdetection0 in detections {
                try detectionsContainer.encode(defaultdetection0)
            }
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitiveDataItemCategory.self, forKey: .category)
        category = categoryDecoded
        let detectionsContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.DefaultDetection?].self, forKey: .detections)
        var detectionsDecoded0:[Macie2ClientTypes.DefaultDetection]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [Macie2ClientTypes.DefaultDetection]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the category, types, and occurrences of sensitive data that produced a sensitive data finding.
    public struct SensitiveDataItem: Swift.Equatable {
        /// The category of sensitive data that was detected. For example: CREDENTIALS, for credentials data such as private keys or Amazon Web Services secret access keys; FINANCIAL_INFORMATION, for financial data such as credit card numbers; or, PERSONAL_INFORMATION, for personal health information, such as health insurance identification numbers, or personally identifiable information, such as passport numbers.
        public var category: Macie2ClientTypes.SensitiveDataItemCategory?
        /// An array of objects, one for each type of sensitive data that was detected. Each object reports the number of occurrences of a specific type of sensitive data that was detected, and the location of up to 15 of those occurrences.
        public var detections: [Macie2ClientTypes.DefaultDetection]?
        /// The total number of occurrences of the sensitive data that was detected.
        public var totalCount: Swift.Int?

        public init(
            category: Macie2ClientTypes.SensitiveDataItemCategory? = nil,
            detections: [Macie2ClientTypes.DefaultDetection]? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension Macie2ClientTypes {
    /// For a finding, the category of sensitive data that was detected and produced the finding. For a managed data identifier, the category of sensitive data that the managed data identifier detects. Possible values are:
    public enum SensitiveDataItemCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case credentials
        case customIdentifier
        case financialInformation
        case personalInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [SensitiveDataItemCategory] {
            return [
                .credentials,
                .customIdentifier,
                .financialInformation,
                .personalInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .credentials: return "CREDENTIALS"
            case .customIdentifier: return "CUSTOM_IDENTIFIER"
            case .financialInformation: return "FINANCIAL_INFORMATION"
            case .personalInformation: return "PERSONAL_INFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SensitiveDataItemCategory(rawValue: rawValue) ?? SensitiveDataItemCategory.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SensitivityAggregations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case publiclyAccessibleCount = "publiclyAccessibleCount"
        case totalCount = "totalCount"
        case totalSizeInBytes = "totalSizeInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifiableSizeInBytes = self.classifiableSizeInBytes {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let publiclyAccessibleCount = self.publiclyAccessibleCount {
            try encodeContainer.encode(publiclyAccessibleCount, forKey: .publiclyAccessibleCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
        if let totalSizeInBytes = self.totalSizeInBytes {
            try encodeContainer.encode(totalSizeInBytes, forKey: .totalSizeInBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classifiableSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let publiclyAccessibleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publiclyAccessibleCount)
        publiclyAccessibleCount = publiclyAccessibleCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides aggregated statistical data for sensitive data discovery metrics that apply to S3 buckets. Each field contains aggregated data for all the buckets that have a sensitivity score (sensitivityScore) of a specified value or within a specified range (BucketStatisticsBySensitivity). If automated sensitive data discovery is currently disabled for your account, the value for each field is 0.
    public struct SensitivityAggregations: Swift.Equatable {
        /// The total storage size, in bytes, of all the objects that Amazon Macie can analyze in the buckets. These objects use a supported storage class and have a file name extension for a supported file or storage format. If versioning is enabled for any of the buckets, this value is based on the size of the latest version of each applicable object in the buckets. This value doesn't reflect the storage size of all versions of all applicable objects in the buckets.
        public var classifiableSizeInBytes: Swift.Int?
        /// The total number of buckets that are publicly accessible due to a combination of permissions settings for each bucket.
        public var publiclyAccessibleCount: Swift.Int?
        /// The total number of buckets.
        public var totalCount: Swift.Int?
        /// The total storage size, in bytes, of the buckets. If versioning is enabled for any of the buckets, this value is based on the size of the latest version of each object in the buckets. This value doesn't reflect the storage size of all versions of the objects in the buckets.
        public var totalSizeInBytes: Swift.Int?

        public init(
            classifiableSizeInBytes: Swift.Int? = nil,
            publiclyAccessibleCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil,
            totalSizeInBytes: Swift.Int? = nil
        )
        {
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.publiclyAccessibleCount = publiclyAccessibleCount
            self.totalCount = totalCount
            self.totalSizeInBytes = totalSizeInBytes
        }
    }

}

extension Macie2ClientTypes.SensitivityInspectionTemplateExcludes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managedDataIdentifierIds = "managedDataIdentifierIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedDataIdentifierIds = managedDataIdentifierIds {
            var managedDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedDataIdentifierIds)
            for __string0 in managedDataIdentifierIds {
                try managedDataIdentifierIdsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedDataIdentifierIds)
        var managedDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let managedDataIdentifierIdsContainer = managedDataIdentifierIdsContainer {
            managedDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in managedDataIdentifierIdsContainer {
                if let string0 = string0 {
                    managedDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        managedDataIdentifierIds = managedDataIdentifierIdsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies managed data identifiers to exclude (not use) when performing automated sensitive data discovery for an Amazon Macie account. For information about the managed data identifiers that Amazon Macie currently provides, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) in the Amazon Macie User Guide.
    public struct SensitivityInspectionTemplateExcludes: Swift.Equatable {
        /// An array of unique identifiers, one for each managed data identifier to exclude. To retrieve a list of valid values, use the ListManagedDataIdentifiers operation.
        public var managedDataIdentifierIds: [Swift.String]?

        public init(
            managedDataIdentifierIds: [Swift.String]? = nil
        )
        {
            self.managedDataIdentifierIds = managedDataIdentifierIds
        }
    }

}

extension Macie2ClientTypes.SensitivityInspectionTemplateIncludes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowListIds = "allowListIds"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case managedDataIdentifierIds = "managedDataIdentifierIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowListIds = allowListIds {
            var allowListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowListIds)
            for __string0 in allowListIds {
                try allowListIdsContainer.encode(__string0)
            }
        }
        if let customDataIdentifierIds = customDataIdentifierIds {
            var customDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDataIdentifierIds)
            for __string0 in customDataIdentifierIds {
                try customDataIdentifierIdsContainer.encode(__string0)
            }
        }
        if let managedDataIdentifierIds = managedDataIdentifierIds {
            var managedDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedDataIdentifierIds)
            for __string0 in managedDataIdentifierIds {
                try managedDataIdentifierIdsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowListIds)
        var allowListIdsDecoded0:[Swift.String]? = nil
        if let allowListIdsContainer = allowListIdsContainer {
            allowListIdsDecoded0 = [Swift.String]()
            for string0 in allowListIdsContainer {
                if let string0 = string0 {
                    allowListIdsDecoded0?.append(string0)
                }
            }
        }
        allowListIds = allowListIdsDecoded0
        let customDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customDataIdentifierIds)
        var customDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let customDataIdentifierIdsContainer = customDataIdentifierIdsContainer {
            customDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in customDataIdentifierIdsContainer {
                if let string0 = string0 {
                    customDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        customDataIdentifierIds = customDataIdentifierIdsDecoded0
        let managedDataIdentifierIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedDataIdentifierIds)
        var managedDataIdentifierIdsDecoded0:[Swift.String]? = nil
        if let managedDataIdentifierIdsContainer = managedDataIdentifierIdsContainer {
            managedDataIdentifierIdsDecoded0 = [Swift.String]()
            for string0 in managedDataIdentifierIdsContainer {
                if let string0 = string0 {
                    managedDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        managedDataIdentifierIds = managedDataIdentifierIdsDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies the allow lists, custom data identifiers, and managed data identifiers to include (use) when performing automated sensitive data discovery for an Amazon Macie account. The configuration must specify at least one custom data identifier or managed data identifier. For information about the managed data identifiers that Amazon Macie currently provides, see [Using managed data identifiers](https://docs.aws.amazon.com/macie/latest/user/managed-data-identifiers.html) in the Amazon Macie User Guide.
    public struct SensitivityInspectionTemplateIncludes: Swift.Equatable {
        /// An array of unique identifiers, one for each allow list to include.
        public var allowListIds: [Swift.String]?
        /// An array of unique identifiers, one for each custom data identifier to include.
        public var customDataIdentifierIds: [Swift.String]?
        /// An array of unique identifiers, one for each managed data identifier to include. Amazon Macie uses these managed data identifiers in addition to managed data identifiers that are subsequently released and recommended for automated sensitive data discovery. To retrieve a list of valid values for the managed data identifiers that are currently available, use the ListManagedDataIdentifiers operation.
        public var managedDataIdentifierIds: [Swift.String]?

        public init(
            allowListIds: [Swift.String]? = nil,
            customDataIdentifierIds: [Swift.String]? = nil,
            managedDataIdentifierIds: [Swift.String]? = nil
        )
        {
            self.allowListIds = allowListIds
            self.customDataIdentifierIds = customDataIdentifierIds
            self.managedDataIdentifierIds = managedDataIdentifierIds
        }
    }

}

extension Macie2ClientTypes.SensitivityInspectionTemplatesEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the sensitivity inspection template for an Amazon Macie account. Macie uses the template's settings when it performs automated sensitive data discovery for the account.
    public struct SensitivityInspectionTemplatesEntry: Swift.Equatable {
        /// The unique identifier for the sensitivity inspection template.
        public var id: Swift.String?
        /// The name of the sensitivity inspection template: automated-sensitive-data-discovery.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension Macie2ClientTypes.ServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyId = "kmsMasterKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsMasterKeyId = self.kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the default server-side encryption settings for an S3 bucket or the encryption settings for an S3 object.
    public struct ServerSideEncryption: Swift.Equatable {
        /// The server-side encryption algorithm that's used when storing data in the bucket or object. If default encryption settings aren't configured for the bucket or the object isn't encrypted using server-side encryption, this value is NONE.
        public var encryptionType: Macie2ClientTypes.EncryptionType?
        /// The Amazon Resource Name (ARN) or unique identifier (key ID) for the KMS key that's used to encrypt data in the bucket or the object. This value is null if an KMS key isn't used to encrypt the data.
        public var kmsMasterKeyId: Swift.String?

        public init(
            encryptionType: Macie2ClientTypes.EncryptionType? = nil,
            kmsMasterKeyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsMasterKeyId = kmsMasterKeyId
        }
    }

}

extension Macie2ClientTypes.ServiceLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isServiceLimited = "isServiceLimited"
        case unit = "unit"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isServiceLimited = self.isServiceLimited {
            try encodeContainer.encode(isServiceLimited, forKey: .isServiceLimited)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isServiceLimitedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isServiceLimited)
        isServiceLimited = isServiceLimitedDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a current quota for an Amazon Macie account.
    public struct ServiceLimit: Swift.Equatable {
        /// Specifies whether the account has met the quota that corresponds to the metric specified by the UsageByAccount.type field in the response.
        public var isServiceLimited: Swift.Bool?
        /// The unit of measurement for the value specified by the value field.
        public var unit: Macie2ClientTypes.Unit?
        /// The value for the metric specified by the UsageByAccount.type field in the response.
        public var value: Swift.Int?

        public init(
            isServiceLimited: Swift.Bool? = nil,
            unit: Macie2ClientTypes.Unit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.isServiceLimited = isServiceLimited
            self.unit = unit
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to one or more service quotas for an account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.SessionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case sessionIssuer = "sessionIssuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let sessionIssuer = self.sessionIssuer {
            try encodeContainer.encode(sessionIssuer, forKey: .sessionIssuer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SessionContextAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let sessionIssuerDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SessionIssuer.self, forKey: .sessionIssuer)
        sessionIssuer = sessionIssuerDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about a session that was created for an entity that performed an action by using temporary security credentials.
    public struct SessionContext: Swift.Equatable {
        /// The date and time when the credentials were issued, and whether the credentials were authenticated with a multi-factor authentication (MFA) device.
        public var attributes: Macie2ClientTypes.SessionContextAttributes?
        /// The source and type of credentials that were issued to the entity.
        public var sessionIssuer: Macie2ClientTypes.SessionIssuer?

        public init(
            attributes: Macie2ClientTypes.SessionContextAttributes? = nil,
            sessionIssuer: Macie2ClientTypes.SessionIssuer? = nil
        )
        {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }
    }

}

extension Macie2ClientTypes.SessionContextAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "creationDate"
        case mfaAuthenticated = "mfaAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .dateTime, forKey: .creationDate)
        }
        if let mfaAuthenticated = self.mfaAuthenticated {
            try encodeContainer.encode(mfaAuthenticated, forKey: .mfaAuthenticated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let mfaAuthenticatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mfaAuthenticated)
        mfaAuthenticated = mfaAuthenticatedDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the context in which temporary security credentials were issued to an entity.
    public struct SessionContextAttributes: Swift.Equatable {
        /// The date and time, in UTC and ISO 8601 format, when the credentials were issued.
        public var creationDate: ClientRuntime.Date?
        /// Specifies whether the credentials were authenticated with a multi-factor authentication (MFA) device.
        public var mfaAuthenticated: Swift.Bool?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            mfaAuthenticated: Swift.Bool? = nil
        )
        {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }
    }

}

extension Macie2ClientTypes.SessionIssuer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case type = "type"
        case userName = "userName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the source and type of temporary security credentials that were issued to an entity.
    public struct SessionIssuer: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that owns the entity that was used to get the credentials.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the source account, Identity and Access Management (IAM) user, or role that was used to get the credentials.
        public var arn: Swift.String?
        /// The unique identifier for the entity that was used to get the credentials.
        public var principalId: Swift.String?
        /// The source of the temporary security credentials, such as Root, IAMUser, or Role.
        public var type: Swift.String?
        /// The name or alias of the user or role that issued the session. This value is null if the credentials were obtained from a root account that doesn't have an alias.
        public var userName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            type: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }
    }

}

extension Macie2ClientTypes.Severity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case score = "score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description.rawValue, forKey: .description)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SeverityDescription.self, forKey: .description)
        description = descriptionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score)
        score = scoreDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides the numerical and qualitative representations of a finding's severity.
    public struct Severity: Swift.Equatable {
        /// The qualitative representation of the finding's severity, ranging from Low (least severe) to High (most severe).
        public var description: Macie2ClientTypes.SeverityDescription?
        /// The numerical representation of the finding's severity, ranging from 1 (least severe) to 3 (most severe).
        public var score: Swift.Int?

        public init(
            description: Macie2ClientTypes.SeverityDescription? = nil,
            score: Swift.Int? = nil
        )
        {
            self.description = description
            self.score = score
        }
    }

}

extension Macie2ClientTypes {
    /// The qualitative representation of the finding's severity. Possible values are:
    public enum SeverityDescription: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityDescription] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SeverityDescription(rawValue: rawValue) ?? SeverityDescription.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SeverityLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case occurrencesThreshold = "occurrencesThreshold"
        case severity = "severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let occurrencesThreshold = self.occurrencesThreshold {
            try encodeContainer.encode(occurrencesThreshold, forKey: .occurrencesThreshold)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let occurrencesThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .occurrencesThreshold)
        occurrencesThreshold = occurrencesThresholdDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DataIdentifierSeverity.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a severity level for findings that a custom data identifier produces. A severity level determines which severity is assigned to the findings, based on the number of occurrences of text that match the custom data identifier's detection criteria.
    public struct SeverityLevel: Swift.Equatable {
        /// The minimum number of occurrences of text that must match the custom data identifier's detection criteria in order to produce a finding with the specified severity (severity).
        /// This member is required.
        public var occurrencesThreshold: Swift.Int?
        /// The severity to assign to a finding: if the number of occurrences is greater than or equal to the specified threshold (occurrencesThreshold); and, if applicable, the number of occurrences is less than the threshold for the next consecutive severity level for the custom data identifier, moving from LOW to HIGH.
        /// This member is required.
        public var severity: Macie2ClientTypes.DataIdentifierSeverity?

        public init(
            occurrencesThreshold: Swift.Int? = nil,
            severity: Macie2ClientTypes.DataIdentifierSeverity? = nil
        )
        {
            self.occurrencesThreshold = occurrencesThreshold
            self.severity = severity
        }
    }

}

extension Macie2ClientTypes {
    public enum SharedAccess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case external
        case `internal`
        case notShared
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SharedAccess] {
            return [
                .external,
                .internal,
                .notShared,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .external: return "EXTERNAL"
            case .internal: return "INTERNAL"
            case .notShared: return "NOT_SHARED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SharedAccess(rawValue: rawValue) ?? SharedAccess.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SimpleCriterionForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __string0 in values {
                try valuesContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SimpleCriterionKeyForJob.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a property-based condition that determines whether an S3 bucket is included or excluded from a classification job.
    public struct SimpleCriterionForJob: Swift.Equatable {
        /// The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).
        public var comparator: Macie2ClientTypes.JobComparator?
        /// The property to use in the condition.
        public var key: Macie2ClientTypes.SimpleCriterionKeyForJob?
        /// An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:
        ///
        /// * ACCOUNT_ID - A string that represents the unique identifier for the Amazon Web Services account that owns the bucket.
        ///
        /// * S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the [BucketPublicAccess.effectivePermission](https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission) property of a bucket.
        ///
        /// * S3_BUCKET_NAME - A string that represents the name of a bucket.
        ///
        /// * S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the [BucketMetadata.sharedAccess](https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess) property of a bucket.
        ///
        ///
        /// Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in these values.
        public var values: [Swift.String]?

        public init(
            comparator: Macie2ClientTypes.JobComparator? = nil,
            key: Macie2ClientTypes.SimpleCriterionKeyForJob? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.values = values
        }
    }

}

extension Macie2ClientTypes {
    /// The property to use in a condition that determines whether an S3 bucket is included or excluded from a classification job. Valid values are:
    public enum SimpleCriterionKeyForJob: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case s3BucketEffectivePermission
        case s3BucketName
        case s3BucketSharedAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [SimpleCriterionKeyForJob] {
            return [
                .accountId,
                .s3BucketEffectivePermission,
                .s3BucketName,
                .s3BucketSharedAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .s3BucketEffectivePermission: return "S3_BUCKET_EFFECTIVE_PERMISSION"
            case .s3BucketName: return "S3_BUCKET_NAME"
            case .s3BucketSharedAccess: return "S3_BUCKET_SHARED_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimpleCriterionKeyForJob(rawValue: rawValue) ?? SimpleCriterionKeyForJob.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SimpleScopeTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __string0 in values {
                try valuesContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ScopeFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a property-based condition that determines whether an S3 object is included or excluded from a classification job.
    public struct SimpleScopeTerm: Swift.Equatable {
        /// The operator to use in the condition. Valid values for each supported property (key) are:
        ///
        /// * OBJECT_EXTENSION - EQ (equals) or NE (not equals)
        ///
        /// * OBJECT_KEY - STARTS_WITH
        ///
        /// * OBJECT_LAST_MODIFIED_DATE - Any operator except CONTAINS
        ///
        /// * OBJECT_SIZE - Any operator except CONTAINS
        public var comparator: Macie2ClientTypes.JobComparator?
        /// The object property to use in the condition.
        public var key: Macie2ClientTypes.ScopeFilterKey?
        /// An array that lists the values to use in the condition. If the value for the key property is OBJECT_EXTENSION or OBJECT_KEY, this array can specify multiple values and Amazon Macie uses OR logic to join the values. Otherwise, this array can specify only one value. Valid values for each supported property (key) are:
        ///
        /// * OBJECT_EXTENSION - A string that represents the file name extension of an object. For example: docx or pdf
        ///
        /// * OBJECT_KEY - A string that represents the key prefix (folder name or path) of an object. For example: logs or awslogs/eventlogs. This value applies a condition to objects whose keys (names) begin with the specified value.
        ///
        /// * OBJECT_LAST_MODIFIED_DATE - The date and time (in UTC and extended ISO 8601 format) when an object was created or last changed, whichever is latest. For example: 2020-09-28T14:31:13Z
        ///
        /// * OBJECT_SIZE - An integer that represents the storage size (in bytes) of an object.
        ///
        ///
        /// Macie doesn't support use of wildcard characters in these values. Also, string values are case sensitive.
        public var values: [Swift.String]?

        public init(
            comparator: Macie2ClientTypes.JobComparator? = nil,
            key: Macie2ClientTypes.ScopeFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.values = values
        }
    }

}

extension Macie2ClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a request for findings.
    public struct SortCriteria: Swift.Equatable {
        /// The name of the property to sort the results by. Valid values are: count, createdAt, policyDetails.action.apiCallDetails.firstSeen, policyDetails.action.apiCallDetails.lastSeen, resourcesAffected, severity.score, type, and updatedAt.
        public var attributeName: Swift.String?
        /// The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            attributeName: Swift.String? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension Macie2ClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateNumberOfObjectsToProcess = "approximateNumberOfObjectsToProcess"
        case numberOfRuns = "numberOfRuns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateNumberOfObjectsToProcess = self.approximateNumberOfObjectsToProcess {
            try encodeContainer.encode(approximateNumberOfObjectsToProcess, forKey: .approximateNumberOfObjectsToProcess)
        }
        if let numberOfRuns = self.numberOfRuns {
            try encodeContainer.encode(numberOfRuns, forKey: .numberOfRuns)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateNumberOfObjectsToProcessDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .approximateNumberOfObjectsToProcess)
        approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcessDecoded
        let numberOfRunsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .numberOfRuns)
        numberOfRuns = numberOfRunsDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides processing statistics for a classification job.
    public struct Statistics: Swift.Equatable {
        /// The approximate number of objects that the job has yet to process during its current run.
        public var approximateNumberOfObjectsToProcess: Swift.Double?
        /// The number of times that the job has run.
        public var numberOfRuns: Swift.Double?

        public init(
            approximateNumberOfObjectsToProcess: Swift.Double? = nil,
            numberOfRuns: Swift.Double? = nil
        )
        {
            self.approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcess
            self.numberOfRuns = numberOfRuns
        }
    }

}

extension Macie2ClientTypes {
    /// The storage class of the S3 object. Possible values are:
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.SuppressDataIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DataIdentifierType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a custom data identifier or managed data identifier that detected a type of sensitive data to start excluding or including in an S3 bucket's sensitivity score.
    public struct SuppressDataIdentifier: Swift.Equatable {
        /// The unique identifier for the custom data identifier or managed data identifier that detected the type of sensitive data to exclude or include in the score.
        public var id: Swift.String?
        /// The type of data identifier that detected the sensitive data. Possible values are: CUSTOM, for a custom data identifier; and, MANAGED, for a managed data identifier.
        public var type: Macie2ClientTypes.DataIdentifierType?

        public init(
            id: Swift.String? = nil,
            type: Macie2ClientTypes.DataIdentifierType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension Macie2ClientTypes.TagCriterionForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case tagValues = "tagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagcriterionpairforjob0 in tagValues {
                try tagValuesContainer.encode(tagcriterionpairforjob0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.TagCriterionPairForJob?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Macie2ClientTypes.TagCriterionPairForJob]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Macie2ClientTypes.TagCriterionPairForJob]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag-based condition that determines whether an S3 bucket is included or excluded from a classification job.
    public struct TagCriterionForJob: Swift.Equatable {
        /// The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).
        public var comparator: Macie2ClientTypes.JobComparator?
        /// The tag keys, tag values, or tag key and value pairs to use in the condition.
        public var tagValues: [Macie2ClientTypes.TagCriterionPairForJob]?

        public init(
            comparator: Macie2ClientTypes.JobComparator? = nil,
            tagValues: [Macie2ClientTypes.TagCriterionPairForJob]? = nil
        )
        {
            self.comparator = comparator
            self.tagValues = tagValues
        }
    }

}

extension Macie2ClientTypes.TagCriterionPairForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag key, a tag value, or a tag key and value (as a pair) to use in a tag-based condition that determines whether an S3 bucket is included or excluded from a classification job. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based conditions.
    public struct TagCriterionPairForJob: Swift.Equatable {
        /// The value for the tag key to use in the condition.
        public var key: Swift.String?
        /// The tag value to use in the condition.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of key-value pairs that specifies the tags to associate with the resource. A resource can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.TagScopeTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case tagValues = "tagValues"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluepair0 in tagValues {
                try tagValuesContainer.encode(tagvaluepair0)
            }
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.TagValuePair?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Macie2ClientTypes.TagValuePair]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Macie2ClientTypes.TagValuePair]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.TagTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag-based condition that determines whether an S3 object is included or excluded from a classification job.
    public struct TagScopeTerm: Swift.Equatable {
        /// The operator to use in the condition. Valid values are EQ (equals) or NE (not equals).
        public var comparator: Macie2ClientTypes.JobComparator?
        /// The object property to use in the condition. The only valid value is TAG.
        public var key: Swift.String?
        /// The tag keys or tag key and value pairs to use in the condition. To specify only tag keys in a condition, specify the keys in this array and set the value for each associated tag value to an empty string.
        public var tagValues: [Macie2ClientTypes.TagValuePair]?
        /// The type of object to apply the condition to.
        public var target: Macie2ClientTypes.TagTarget?

        public init(
            comparator: Macie2ClientTypes.JobComparator? = nil,
            key: Swift.String? = nil,
            tagValues: [Macie2ClientTypes.TagValuePair]? = nil,
            target: Macie2ClientTypes.TagTarget? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.tagValues = tagValues
            self.target = target
        }
    }

}

extension Macie2ClientTypes {
    /// The type of object to apply a tag-based condition to. Valid values are:
    public enum TagTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3Object
        case sdkUnknown(Swift.String)

        public static var allCases: [TagTarget] {
            return [
                .s3Object,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3Object: return "S3_OBJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TagTarget(rawValue: rawValue) ?? TagTarget.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.TagValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a tag key or tag key and value pair to use in a tag-based condition that determines whether an S3 object is included or excluded from a classification job. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based conditions.
    public struct TagValuePair: Swift.Equatable {
        /// The value for the tag key to use in the condition.
        public var key: Swift.String?
        /// The tag value, associated with the specified tag key (key), to use in the condition. To specify only a tag key for a condition, specify the tag key for the key property and set this value to an empty string.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TestCustomDataIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case regex = "regex"
        case sampleText = "sampleText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreWords = ignoreWords {
            var ignoreWordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ignoreWords)
            for __string0 in ignoreWords {
                try ignoreWordsContainer.encode(__string0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for __string0 in keywords {
                try keywordsContainer.encode(__string0)
            }
        }
        if let maximumMatchDistance = self.maximumMatchDistance {
            try encodeContainer.encode(maximumMatchDistance, forKey: .maximumMatchDistance)
        }
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
        if let sampleText = self.sampleText {
            try encodeContainer.encode(sampleText, forKey: .sampleText)
        }
    }
}

extension TestCustomDataIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-data-identifiers/test"
    }
}

public struct TestCustomDataIdentifierInput: Swift.Equatable {
    /// An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression contains any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4-90 UTF-8 characters. Ignore words are case sensitive.
    public var ignoreWords: [Swift.String]?
    /// An array that lists specific character sequences (keywords), one of which must precede and be within proximity (maximumMatchDistance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3-90 UTF-8 characters. Keywords aren't case sensitive.
    public var keywords: [Swift.String]?
    /// The maximum number of characters that can exist between the end of at least one complete character sequence specified by the keywords array and the end of the text that matches the regex pattern. If a complete keyword precedes all the text that matches the pattern and the keyword is within the specified distance, Amazon Macie includes the result. The distance can be 1-300 characters. The default value is 50.
    public var maximumMatchDistance: Swift.Int?
    /// The regular expression (regex) that defines the pattern to match. The expression can contain as many as 512 characters.
    /// This member is required.
    public var regex: Swift.String?
    /// The sample text to inspect by using the custom data identifier. The text can contain as many as 1,000 characters.
    /// This member is required.
    public var sampleText: Swift.String?

    public init(
        ignoreWords: [Swift.String]? = nil,
        keywords: [Swift.String]? = nil,
        maximumMatchDistance: Swift.Int? = nil,
        regex: Swift.String? = nil,
        sampleText: Swift.String? = nil
    )
    {
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.regex = regex
        self.sampleText = sampleText
    }
}

struct TestCustomDataIdentifierInputBody: Swift.Equatable {
    let ignoreWords: [Swift.String]?
    let keywords: [Swift.String]?
    let maximumMatchDistance: Swift.Int?
    let regex: Swift.String?
    let sampleText: Swift.String?
}

extension TestCustomDataIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case regex = "regex"
        case sampleText = "sampleText"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignoreWordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[Swift.String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [Swift.String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let sampleTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleText)
        sampleText = sampleTextDecoded
    }
}

extension TestCustomDataIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestCustomDataIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchCount = output.matchCount
        } else {
            self.matchCount = nil
        }
    }
}

public struct TestCustomDataIdentifierOutput: Swift.Equatable {
    /// The number of occurrences of sample text that matched the criteria specified by the custom data identifier.
    public var matchCount: Swift.Int?

    public init(
        matchCount: Swift.Int? = nil
    )
    {
        self.matchCount = matchCount
    }
}

struct TestCustomDataIdentifierOutputBody: Swift.Equatable {
    let matchCount: Swift.Int?
}

extension TestCustomDataIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchCount = "matchCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchCount)
        matchCount = matchCountDecoded
    }
}

enum TestCustomDataIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred because too many requests were sent during a certain amount of time.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes {
    /// An inclusive time period that Amazon Macie usage data applies to. Possible values are:
    public enum TimeRange: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case monthToDate
        case past30Days
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeRange] {
            return [
                .monthToDate,
                .past30Days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .monthToDate: return "MONTH_TO_DATE"
            case .past30Days: return "PAST_30_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeRange(rawValue: rawValue) ?? TimeRange.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case `none`
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .aes256,
                .none,
                .awsKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .none: return "NONE"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// Specifies why occurrences of sensitive data can't be retrieved for a finding. Possible values are:
    public enum UnavailabilityReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidClassificationResult
        case objectExceedsSizeQuota
        case objectUnavailable
        case unsupportedFindingType
        case unsupportedObjectType
        case sdkUnknown(Swift.String)

        public static var allCases: [UnavailabilityReasonCode] {
            return [
                .invalidClassificationResult,
                .objectExceedsSizeQuota,
                .objectUnavailable,
                .unsupportedFindingType,
                .unsupportedObjectType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidClassificationResult: return "INVALID_CLASSIFICATION_RESULT"
            case .objectExceedsSizeQuota: return "OBJECT_EXCEEDS_SIZE_QUOTA"
            case .objectUnavailable: return "OBJECT_UNAVAILABLE"
            case .unsupportedFindingType: return "UNSUPPORTED_FINDING_TYPE"
            case .unsupportedObjectType: return "UNSUPPORTED_OBJECT_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnavailabilityReasonCode(rawValue: rawValue) ?? UnavailabilityReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case terabytes
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .terabytes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .terabytes: return "TERABYTES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to an unprocessable entity.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The type of error that occurred and prevented Amazon Macie from retrieving occurrences of sensitive data reported by the finding. Possible values are:
        ///
        /// * INVALID_CLASSIFICATION_RESULT - Amazon Macie can't verify the location of the sensitive data to retrieve. There isn't a corresponding sensitive data discovery result for the finding. Or the sensitive data discovery result specified by the classificationDetails.detailedResultsLocation field of the finding isn't available, is malformed or corrupted, or uses an unsupported storage format.
        ///
        /// * OBJECT_EXCEEDS_SIZE_QUOTA - The storage size of the affected S3 object exceeds the size quota for retrieving occurrences of sensitive data.
        ///
        /// * OBJECT_UNAVAILABLE - The affected S3 object isn't available. The object might have been renamed, moved, or deleted. Or the object was changed after Macie created the finding.
        ///
        /// * UNSUPPORTED_FINDING_TYPE - The specified finding isn't a sensitive data finding.
        ///
        /// * UNSUPPORTED_OBJECT_TYPE - The affected S3 object uses a file or storage format that Macie doesn't support for retrieving occurrences of sensitive data.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.UnprocessedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an account-related request that hasn't been processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The Amazon Web Services account ID for the account that the request applies to.
        public var accountId: Swift.String?
        /// The source of the issue or delay in processing the request.
        public var errorCode: Macie2ClientTypes.ErrorCode?
        /// The reason why the request hasn't been processed.
        public var errorMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            errorCode: Macie2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags (keys) to remove from the resource. In an HTTP request to remove multiple tags, append the tagKeys parameter and argument for each tag to remove, separated by an ampersand (&).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAllowListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria = "criteria"
        case description = "description"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = self.criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAllowListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/allow-lists/\(id.urlPercentEncoding())"
    }
}

public struct UpdateAllowListInput: Swift.Equatable {
    /// The criteria that specify the text or text pattern to ignore. The criteria can be the location and name of an S3 object that lists specific text to ignore (s3WordsList), or a regular expression that defines a text pattern to ignore (regex). You can change a list's underlying criteria, such as the name of the S3 object or the regular expression to use. However, you can't change the type from s3WordsList to regex or the other way around.
    /// This member is required.
    public var criteria: Macie2ClientTypes.AllowListCriteria?
    /// A custom description of the allow list. The description can contain as many as 512 characters.
    public var description: Swift.String?
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// A custom name for the allow list. The name can contain as many as 128 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        criteria: Macie2ClientTypes.AllowListCriteria? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.criteria = criteria
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateAllowListInputBody: Swift.Equatable {
    let criteria: Macie2ClientTypes.AllowListCriteria?
    let description: Swift.String?
    let name: Swift.String?
}

extension UpdateAllowListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria = "criteria"
        case description = "description"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AllowListCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAllowListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAllowListOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct UpdateAllowListOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the allow list.
    public var arn: Swift.String?
    /// The unique identifier for the allow list.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct UpdateAllowListOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension UpdateAllowListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum UpdateAllowListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAutomatedDiscoveryConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAutomatedDiscoveryConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/automated-discovery/configuration"
    }
}

public struct UpdateAutomatedDiscoveryConfigurationInput: Swift.Equatable {
    /// The new status of automated sensitive data discovery for the account. Valid values are: ENABLED, start or resume automated sensitive data discovery activities for the account; and, DISABLED, stop performing automated sensitive data discovery activities for the account. When you enable automated sensitive data discovery for the first time, Amazon Macie uses default configuration settings to determine which data sources to analyze and which managed data identifiers to use. To change these settings, use the UpdateClassificationScope and UpdateSensitivityInspectionTemplate operations, respectively. If you change the settings and subsequently disable the configuration, Amazon Macie retains your changes.
    /// This member is required.
    public var status: Macie2ClientTypes.AutomatedDiscoveryStatus?

    public init(
        status: Macie2ClientTypes.AutomatedDiscoveryStatus? = nil
    )
    {
        self.status = status
    }
}

struct UpdateAutomatedDiscoveryConfigurationInputBody: Swift.Equatable {
    let status: Macie2ClientTypes.AutomatedDiscoveryStatus?
}

extension UpdateAutomatedDiscoveryConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AutomatedDiscoveryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAutomatedDiscoveryConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAutomatedDiscoveryConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAutomatedDiscoveryConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClassificationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus = "jobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }
}

extension UpdateClassificationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct UpdateClassificationJobInput: Swift.Equatable {
    /// The unique identifier for the classification job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new status for the job. Valid values are:
    ///
    /// * CANCELLED - Stops the job permanently and cancels it. This value is valid only if the job's current status is IDLE, PAUSED, RUNNING, or USER_PAUSED. If you specify this value and the job's current status is RUNNING, Amazon Macie immediately begins to stop all processing tasks for the job. You can't resume or restart a job after you cancel it.
    ///
    /// * RUNNING - Resumes the job. This value is valid only if the job's current status is USER_PAUSED. If you paused the job while it was actively running and you specify this value less than 30 days after you paused the job, Macie immediately resumes processing from the point where you paused the job. Otherwise, Macie resumes the job according to the schedule and other settings for the job.
    ///
    /// * USER_PAUSED - Pauses the job temporarily. This value is valid only if the job's current status is IDLE, PAUSED, or RUNNING. If you specify this value and the job's current status is RUNNING, Macie immediately begins to pause all processing tasks for the job. If you pause a one-time job and you don't resume it within 30 days, the job expires and Macie cancels the job. If you pause a recurring job when its status is RUNNING and you don't resume it within 30 days, the job run expires and Macie cancels the run. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.
    /// This member is required.
    public var jobStatus: Macie2ClientTypes.JobStatus?

    public init(
        jobId: Swift.String? = nil,
        jobStatus: Macie2ClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct UpdateClassificationJobInputBody: Swift.Equatable {
    let jobStatus: Macie2ClientTypes.JobStatus?
}

extension UpdateClassificationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus = "jobStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension UpdateClassificationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateClassificationJobOutput: Swift.Equatable {

    public init() { }
}

enum UpdateClassificationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClassificationScopeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "s3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }
}

extension UpdateClassificationScopeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/classification-scopes/\(id.urlPercentEncoding())"
    }
}

public struct UpdateClassificationScopeInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// The S3 buckets to add or remove from the exclusion list defined by the classification scope.
    public var s3: Macie2ClientTypes.S3ClassificationScopeUpdate?

    public init(
        id: Swift.String? = nil,
        s3: Macie2ClientTypes.S3ClassificationScopeUpdate? = nil
    )
    {
        self.id = id
        self.s3 = s3
    }
}

struct UpdateClassificationScopeInputBody: Swift.Equatable {
    let s3: Macie2ClientTypes.S3ClassificationScopeUpdate?
}

extension UpdateClassificationScopeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "s3"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(Macie2ClientTypes.S3ClassificationScopeUpdate.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension UpdateClassificationScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateClassificationScopeOutput: Swift.Equatable {

    public init() { }
}

enum UpdateClassificationScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFindingsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
    }
}

extension UpdateFindingsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/findingsfilters/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFindingsFilterInput: Swift.Equatable {
    /// The action to perform on findings that match the filter criteria (findingCriteria). Valid values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.
    public var action: Macie2ClientTypes.FindingsFilterAction?
    /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// A custom description of the filter. The description can contain as many as 512 characters. We strongly recommend that you avoid including any sensitive data in the description of a filter. Other users of your account might be able to see this description, depending on the actions that they're allowed to perform in Amazon Macie.
    public var description: Swift.String?
    /// The criteria to use to filter findings.
    public var findingCriteria: Macie2ClientTypes.FindingCriteria?
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// A custom name for the filter. The name must contain at least 3 characters and can contain as many as 64 characters. We strongly recommend that you avoid including any sensitive data in the name of a filter. Other users of your account might be able to see this name, depending on the actions that they're allowed to perform in Amazon Macie.
    public var name: Swift.String?
    /// The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.
    public var position: Swift.Int?

    public init(
        action: Macie2ClientTypes.FindingsFilterAction? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        findingCriteria: Macie2ClientTypes.FindingCriteria? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        position: Swift.Int? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.findingCriteria = findingCriteria
        self.id = id
        self.name = name
        self.position = position
    }
}

struct UpdateFindingsFilterInputBody: Swift.Equatable {
    let action: Macie2ClientTypes.FindingsFilterAction?
    let clientToken: Swift.String?
    let description: Swift.String?
    let findingCriteria: Macie2ClientTypes.FindingCriteria?
    let name: Swift.String?
    let position: Swift.Int?
}

extension UpdateFindingsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .position)
        position = positionDecoded
    }
}

extension UpdateFindingsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFindingsFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct UpdateFindingsFilterOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the filter that was updated.
    public var arn: Swift.String?
    /// The unique identifier for the filter that was updated.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct UpdateFindingsFilterOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension UpdateFindingsFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum UpdateFindingsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMacieSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateMacieSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/macie"
    }
}

public struct UpdateMacieSessionInput: Swift.Equatable {
    /// Specifies how often to publish updates to policy findings for the account. This includes publishing updates to Security Hub and Amazon EventBridge (formerly Amazon CloudWatch Events).
    public var findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    /// Specifies a new status for the account. Valid values are: ENABLED, resume all Amazon Macie activities for the account; and, PAUSED, suspend all Macie activities for the account.
    public var status: Macie2ClientTypes.MacieStatus?

    public init(
        findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency? = nil,
        status: Macie2ClientTypes.MacieStatus? = nil
    )
    {
        self.findingPublishingFrequency = findingPublishingFrequency
        self.status = status
    }
}

struct UpdateMacieSessionInputBody: Swift.Equatable {
    let findingPublishingFrequency: Macie2ClientTypes.FindingPublishingFrequency?
    let status: Macie2ClientTypes.MacieStatus?
}

extension UpdateMacieSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateMacieSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMacieSessionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMacieSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMemberSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateMemberSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/macie/members/\(id.urlPercentEncoding())"
    }
}

public struct UpdateMemberSessionInput: Swift.Equatable {
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the new status for the account. Valid values are: ENABLED, resume all Amazon Macie activities for the account; and, PAUSED, suspend all Macie activities for the account.
    /// This member is required.
    public var status: Macie2ClientTypes.MacieStatus?

    public init(
        id: Swift.String? = nil,
        status: Macie2ClientTypes.MacieStatus? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

struct UpdateMemberSessionInputBody: Swift.Equatable {
    let status: Macie2ClientTypes.MacieStatus?
}

extension UpdateMemberSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateMemberSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMemberSessionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMemberSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/configuration"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Specifies whether to enable Amazon Macie automatically for an account when the account is added to the organization in Organizations.
    /// This member is required.
    public var autoEnable: Swift.Bool?

    public init(
        autoEnable: Swift.Bool? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Swift.Bool?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateOrganizationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceProfileDetectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suppressDataIdentifiers = "suppressDataIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suppressDataIdentifiers = suppressDataIdentifiers {
            var suppressDataIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suppressDataIdentifiers)
            for suppressdataidentifier0 in suppressDataIdentifiers {
                try suppressDataIdentifiersContainer.encode(suppressdataidentifier0)
            }
        }
    }
}

extension UpdateResourceProfileDetectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UpdateResourceProfileDetectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-profiles/detections"
    }
}

public struct UpdateResourceProfileDetectionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 bucket that the request applies to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of objects, one for each custom data identifier or managed data identifier that detected the type of sensitive data to start excluding or including in the bucket's score. To start including all sensitive data types in the score, don't specify any values for this array.
    public var suppressDataIdentifiers: [Macie2ClientTypes.SuppressDataIdentifier]?

    public init(
        resourceArn: Swift.String? = nil,
        suppressDataIdentifiers: [Macie2ClientTypes.SuppressDataIdentifier]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.suppressDataIdentifiers = suppressDataIdentifiers
    }
}

struct UpdateResourceProfileDetectionsInputBody: Swift.Equatable {
    let suppressDataIdentifiers: [Macie2ClientTypes.SuppressDataIdentifier]?
}

extension UpdateResourceProfileDetectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suppressDataIdentifiers = "suppressDataIdentifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressDataIdentifiersContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.SuppressDataIdentifier?].self, forKey: .suppressDataIdentifiers)
        var suppressDataIdentifiersDecoded0:[Macie2ClientTypes.SuppressDataIdentifier]? = nil
        if let suppressDataIdentifiersContainer = suppressDataIdentifiersContainer {
            suppressDataIdentifiersDecoded0 = [Macie2ClientTypes.SuppressDataIdentifier]()
            for structure0 in suppressDataIdentifiersContainer {
                if let structure0 = structure0 {
                    suppressDataIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        suppressDataIdentifiers = suppressDataIdentifiersDecoded0
    }
}

extension UpdateResourceProfileDetectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceProfileDetectionsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceProfileDetectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sensitivityScoreOverride = "sensitivityScoreOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sensitivityScoreOverride = self.sensitivityScoreOverride {
            try encodeContainer.encode(sensitivityScoreOverride, forKey: .sensitivityScoreOverride)
        }
    }
}

extension UpdateResourceProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UpdateResourceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-profiles"
    }
}

public struct UpdateResourceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 bucket that the request applies to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new sensitivity score for the bucket. Valid values are: 100, assign the maximum score and apply the Sensitive label to the bucket; and, null (empty), assign a score that Amazon Macie calculates automatically after you submit the request.
    public var sensitivityScoreOverride: Swift.Int?

    public init(
        resourceArn: Swift.String? = nil,
        sensitivityScoreOverride: Swift.Int? = nil
    )
    {
        self.resourceArn = resourceArn
        self.sensitivityScoreOverride = sensitivityScoreOverride
    }
}

struct UpdateResourceProfileInputBody: Swift.Equatable {
    let sensitivityScoreOverride: Swift.Int?
}

extension UpdateResourceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sensitivityScoreOverride = "sensitivityScoreOverride"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sensitivityScoreOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sensitivityScoreOverride)
        sensitivityScoreOverride = sensitivityScoreOverrideDecoded
    }
}

extension UpdateResourceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRevealConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

extension UpdateRevealConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reveal-configuration"
    }
}

public struct UpdateRevealConfigurationInput: Swift.Equatable {
    /// The new configuration settings and the status of the configuration for the account.
    /// This member is required.
    public var configuration: Macie2ClientTypes.RevealConfiguration?

    public init(
        configuration: Macie2ClientTypes.RevealConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct UpdateRevealConfigurationInputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.RevealConfiguration?
}

extension UpdateRevealConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RevealConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateRevealConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRevealConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct UpdateRevealConfigurationOutput: Swift.Equatable {
    /// The new configuration settings and the status of the configuration for the account.
    public var configuration: Macie2ClientTypes.RevealConfiguration?

    public init(
        configuration: Macie2ClientTypes.RevealConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct UpdateRevealConfigurationOutputBody: Swift.Equatable {
    let configuration: Macie2ClientTypes.RevealConfiguration?
}

extension UpdateRevealConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.RevealConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum UpdateRevealConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSensitivityInspectionTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludes = self.excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = self.includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }
}

extension UpdateSensitivityInspectionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/templates/sensitivity-inspections/\(id.urlPercentEncoding())"
    }
}

public struct UpdateSensitivityInspectionTemplateInput: Swift.Equatable {
    /// A custom description of the template. The description can contain as many as 200 characters.
    public var description: Swift.String?
    /// The managed data identifiers to explicitly exclude (not use) when analyzing data. To exclude an allow list or custom data identifier that's currently included by the template, update the values for the SensitivityInspectionTemplateIncludes.allowListIds and SensitivityInspectionTemplateIncludes.customDataIdentifierIds properties, respectively.
    public var excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes?
    /// The unique identifier for the Amazon Macie resource that the request applies to.
    /// This member is required.
    public var id: Swift.String?
    /// The allow lists, custom data identifiers, and managed data identifiers to include (use) when analyzing data.
    public var includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes?

    public init(
        description: Swift.String? = nil,
        excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes? = nil,
        id: Swift.String? = nil,
        includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes? = nil
    )
    {
        self.description = description
        self.excludes = excludes
        self.id = id
        self.includes = includes
    }
}

struct UpdateSensitivityInspectionTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
    let excludes: Macie2ClientTypes.SensitivityInspectionTemplateExcludes?
    let includes: Macie2ClientTypes.SensitivityInspectionTemplateIncludes?
}

extension UpdateSensitivityInspectionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case excludes = "excludes"
        case includes = "includes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let excludesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityInspectionTemplateExcludes.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.SensitivityInspectionTemplateIncludes.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension UpdateSensitivityInspectionTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSensitivityInspectionTemplateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSensitivityInspectionTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Macie2ClientTypes.UsageByAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency = "currency"
        case estimatedCost = "estimatedCost"
        case serviceLimit = "serviceLimit"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let estimatedCost = self.estimatedCost {
            try encodeContainer.encode(estimatedCost, forKey: .estimatedCost)
        }
        if let serviceLimit = self.serviceLimit {
            try encodeContainer.encode(serviceLimit, forKey: .serviceLimit)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Currency.self, forKey: .currency)
        currency = currencyDecoded
        let estimatedCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedCost)
        estimatedCost = estimatedCostDecoded
        let serviceLimitDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.ServiceLimit.self, forKey: .serviceLimit)
        serviceLimit = serviceLimitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides data for a specific usage metric and the corresponding quota for an Amazon Macie account.
    public struct UsageByAccount: Swift.Equatable {
        /// The type of currency that the value for the metric (estimatedCost) is reported in.
        public var currency: Macie2ClientTypes.Currency?
        /// The estimated value for the metric.
        public var estimatedCost: Swift.String?
        /// The current value for the quota that corresponds to the metric specified by the type field.
        public var serviceLimit: Macie2ClientTypes.ServiceLimit?
        /// The name of the metric. Possible values are: AUTOMATED_OBJECT_MONITORING, to monitor S3 objects for automated sensitive data discovery; AUTOMATED_SENSITIVE_DATA_DISCOVERY, to analyze S3 objects for automated sensitive data discovery; DATA_INVENTORY_EVALUATION, to monitor S3 buckets; and, SENSITIVE_DATA_DISCOVERY, to run classification jobs.
        public var type: Macie2ClientTypes.UsageType?

        public init(
            currency: Macie2ClientTypes.Currency? = nil,
            estimatedCost: Swift.String? = nil,
            serviceLimit: Macie2ClientTypes.ServiceLimit? = nil,
            type: Macie2ClientTypes.UsageType? = nil
        )
        {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.serviceLimit = serviceLimit
            self.type = type
        }
    }

}

extension Macie2ClientTypes.UsageRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case automatedDiscoveryFreeTrialStartDate = "automatedDiscoveryFreeTrialStartDate"
        case freeTrialStartDate = "freeTrialStartDate"
        case usage = "usage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let automatedDiscoveryFreeTrialStartDate = self.automatedDiscoveryFreeTrialStartDate {
            try encodeContainer.encodeTimestamp(automatedDiscoveryFreeTrialStartDate, format: .dateTime, forKey: .automatedDiscoveryFreeTrialStartDate)
        }
        if let freeTrialStartDate = self.freeTrialStartDate {
            try encodeContainer.encodeTimestamp(freeTrialStartDate, format: .dateTime, forKey: .freeTrialStartDate)
        }
        if let usage = usage {
            var usageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usage)
            for usagebyaccount0 in usage {
                try usageContainer.encode(usagebyaccount0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let automatedDiscoveryFreeTrialStartDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .automatedDiscoveryFreeTrialStartDate)
        automatedDiscoveryFreeTrialStartDate = automatedDiscoveryFreeTrialStartDateDecoded
        let freeTrialStartDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .freeTrialStartDate)
        freeTrialStartDate = freeTrialStartDateDecoded
        let usageContainer = try containerValues.decodeIfPresent([Macie2ClientTypes.UsageByAccount?].self, forKey: .usage)
        var usageDecoded0:[Macie2ClientTypes.UsageByAccount]? = nil
        if let usageContainer = usageContainer {
            usageDecoded0 = [Macie2ClientTypes.UsageByAccount]()
            for structure0 in usageContainer {
                if let structure0 = structure0 {
                    usageDecoded0?.append(structure0)
                }
            }
        }
        usage = usageDecoded0
    }
}

extension Macie2ClientTypes {
    /// Provides quota and aggregated usage data for an Amazon Macie account.
    public struct UsageRecord: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account that the data applies to.
        public var accountId: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when the free trial of automated sensitive data discovery started for the account. If the account is a member account in an organization, this value is the same as the value for the organization's Amazon Macie administrator account.
        public var automatedDiscoveryFreeTrialStartDate: ClientRuntime.Date?
        /// The date and time, in UTC and extended ISO 8601 format, when the Amazon Macie free trial started for the account.
        public var freeTrialStartDate: ClientRuntime.Date?
        /// An array of objects that contains usage data and quotas for the account. Each object contains the data for a specific usage metric and the corresponding quota.
        public var usage: [Macie2ClientTypes.UsageByAccount]?

        public init(
            accountId: Swift.String? = nil,
            automatedDiscoveryFreeTrialStartDate: ClientRuntime.Date? = nil,
            freeTrialStartDate: ClientRuntime.Date? = nil,
            usage: [Macie2ClientTypes.UsageByAccount]? = nil
        )
        {
            self.accountId = accountId
            self.automatedDiscoveryFreeTrialStartDate = automatedDiscoveryFreeTrialStartDate
            self.freeTrialStartDate = freeTrialStartDate
            self.usage = usage
        }
    }

}

extension Macie2ClientTypes.UsageStatisticsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __string0 in values {
                try valuesContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageStatisticsFilterComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageStatisticsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Macie2ClientTypes {
    /// Specifies a condition for filtering the results of a query for quota and usage data for one or more Amazon Macie accounts.
    public struct UsageStatisticsFilter: Swift.Equatable {
        /// The operator to use in the condition. If the value for the key property is accountId, this value must be CONTAINS. If the value for the key property is any other supported field, this value can be EQ, GT, GTE, LT, LTE, or NE.
        public var comparator: Macie2ClientTypes.UsageStatisticsFilterComparator?
        /// The field to use in the condition.
        public var key: Macie2ClientTypes.UsageStatisticsFilterKey?
        /// An array that lists values to use in the condition, based on the value for the field specified by the key property. If the value for the key property is accountId, this array can specify multiple values. Otherwise, this array can specify only one value. Valid values for each supported field are:
        ///
        /// * accountId - The unique identifier for an Amazon Web Services account.
        ///
        /// * freeTrialStartDate - The date and time, in UTC and extended ISO 8601 format, when the Amazon Macie free trial started for an account.
        ///
        /// * serviceLimit - A Boolean (true or false) value that indicates whether an account has reached its monthly quota.
        ///
        /// * total - A string that represents the current estimated cost for an account.
        public var values: [Swift.String]?

        public init(
            comparator: Macie2ClientTypes.UsageStatisticsFilterComparator? = nil,
            key: Macie2ClientTypes.UsageStatisticsFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.values = values
        }
    }

}

extension Macie2ClientTypes {
    /// The operator to use in a condition that filters the results of a query for Amazon Macie account quotas and usage data. Valid values are:
    public enum UsageStatisticsFilterComparator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case eq
        case gt
        case gte
        case lt
        case lte
        case ne
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticsFilterComparator] {
            return [
                .contains,
                .eq,
                .gt,
                .gte,
                .lt,
                .lte,
                .ne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .eq: return "EQ"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case .ne: return "NE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticsFilterComparator(rawValue: rawValue) ?? UsageStatisticsFilterComparator.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes {
    /// The field to use in a condition that filters the results of a query for Amazon Macie account quotas and usage data. Valid values are:
    public enum UsageStatisticsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountid
        case freetrialstartdate
        case servicelimit
        case total
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticsFilterKey] {
            return [
                .accountid,
                .freetrialstartdate,
                .servicelimit,
                .total,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountid: return "accountId"
            case .freetrialstartdate: return "freeTrialStartDate"
            case .servicelimit: return "serviceLimit"
            case .total: return "total"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticsFilterKey(rawValue: rawValue) ?? UsageStatisticsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.UsageStatisticsSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageStatisticsSortKey.self, forKey: .key)
        key = keyDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies criteria for sorting the results of a query for Amazon Macie account quotas and usage data.
    public struct UsageStatisticsSortBy: Swift.Equatable {
        /// The field to sort the results by.
        public var key: Macie2ClientTypes.UsageStatisticsSortKey?
        /// The sort order to apply to the results, based on the value for the field specified by the key property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.
        public var orderBy: Macie2ClientTypes.OrderBy?

        public init(
            key: Macie2ClientTypes.UsageStatisticsSortKey? = nil,
            orderBy: Macie2ClientTypes.OrderBy? = nil
        )
        {
            self.key = key
            self.orderBy = orderBy
        }
    }

}

extension Macie2ClientTypes {
    /// The field to use to sort the results of a query for Amazon Macie account quotas and usage data. Valid values are:
    public enum UsageStatisticsSortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountid
        case freetrialstartdate
        case servicelimitvalue
        case total
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticsSortKey] {
            return [
                .accountid,
                .freetrialstartdate,
                .servicelimitvalue,
                .total,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountid: return "accountId"
            case .freetrialstartdate: return "freeTrialStartDate"
            case .servicelimitvalue: return "serviceLimitValue"
            case .total: return "total"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticsSortKey(rawValue: rawValue) ?? UsageStatisticsSortKey.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.UsageTotal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency = "currency"
        case estimatedCost = "estimatedCost"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let estimatedCost = self.estimatedCost {
            try encodeContainer.encode(estimatedCost, forKey: .estimatedCost)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.Currency.self, forKey: .currency)
        currency = currencyDecoded
        let estimatedCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedCost)
        estimatedCost = estimatedCostDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UsageType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides aggregated data for an Amazon Macie usage metric. The value for the metric reports estimated usage data for an account for the preceding 30 days or the current calendar month to date, depending on the time period (timeRange) specified in the request.
    public struct UsageTotal: Swift.Equatable {
        /// The type of currency that the value for the metric (estimatedCost) is reported in.
        public var currency: Macie2ClientTypes.Currency?
        /// The estimated value for the metric.
        public var estimatedCost: Swift.String?
        /// The name of the metric. Possible values are: AUTOMATED_OBJECT_MONITORING, to monitor S3 objects for automated sensitive data discovery; AUTOMATED_SENSITIVE_DATA_DISCOVERY, to analyze S3 objects for automated sensitive data discovery; DATA_INVENTORY_EVALUATION, to monitor S3 buckets; and, SENSITIVE_DATA_DISCOVERY, to run classification jobs.
        public var type: Macie2ClientTypes.UsageType?

        public init(
            currency: Macie2ClientTypes.Currency? = nil,
            estimatedCost: Swift.String? = nil,
            type: Macie2ClientTypes.UsageType? = nil
        )
        {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.type = type
        }
    }

}

extension Macie2ClientTypes {
    /// The name of an Amazon Macie usage metric for an account. Possible values are:
    public enum UsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatedObjectMonitoring
        case automatedSensitiveDataDiscovery
        case dataInventoryEvaluation
        case sensitiveDataDiscovery
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .automatedObjectMonitoring,
                .automatedSensitiveDataDiscovery,
                .dataInventoryEvaluation,
                .sensitiveDataDiscovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatedObjectMonitoring: return "AUTOMATED_OBJECT_MONITORING"
            case .automatedSensitiveDataDiscovery: return "AUTOMATED_SENSITIVE_DATA_DISCOVERY"
            case .dataInventoryEvaluation: return "DATA_INVENTORY_EVALUATION"
            case .sensitiveDataDiscovery: return "SENSITIVE_DATA_DISCOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageType(rawValue: rawValue) ?? UsageType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRole = "assumedRole"
        case awsAccount = "awsAccount"
        case awsService = "awsService"
        case federatedUser = "federatedUser"
        case iamUser = "iamUser"
        case root = "root"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assumedRole = self.assumedRole {
            try encodeContainer.encode(assumedRole, forKey: .assumedRole)
        }
        if let awsAccount = self.awsAccount {
            try encodeContainer.encode(awsAccount, forKey: .awsAccount)
        }
        if let awsService = self.awsService {
            try encodeContainer.encode(awsService, forKey: .awsService)
        }
        if let federatedUser = self.federatedUser {
            try encodeContainer.encode(federatedUser, forKey: .federatedUser)
        }
        if let iamUser = self.iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let root = self.root {
            try encodeContainer.encode(root, forKey: .root)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumedRoleDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AssumedRole.self, forKey: .assumedRole)
        assumedRole = assumedRoleDecoded
        let awsAccountDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AwsAccount.self, forKey: .awsAccount)
        awsAccount = awsAccountDecoded
        let awsServiceDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.AwsService.self, forKey: .awsService)
        awsService = awsServiceDecoded
        let federatedUserDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.FederatedUser.self, forKey: .federatedUser)
        federatedUser = federatedUserDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.IamUser.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let rootDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UserIdentityRoot.self, forKey: .root)
        root = rootDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.UserIdentityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about the type and other characteristics of an entity that performed an action on an affected resource.
    public struct UserIdentity: Swift.Equatable {
        /// If the action was performed with temporary security credentials that were obtained using the AssumeRole operation of the Security Token Service (STS) API, the identifiers, session context, and other details about the identity.
        public var assumedRole: Macie2ClientTypes.AssumedRole?
        /// If the action was performed using the credentials for another Amazon Web Services account, the details of that account.
        public var awsAccount: Macie2ClientTypes.AwsAccount?
        /// If the action was performed by an Amazon Web Services account that belongs to an Amazon Web Service, the name of the service.
        public var awsService: Macie2ClientTypes.AwsService?
        /// If the action was performed with temporary security credentials that were obtained using the GetFederationToken operation of the Security Token Service (STS) API, the identifiers, session context, and other details about the identity.
        public var federatedUser: Macie2ClientTypes.FederatedUser?
        /// If the action was performed using the credentials for an Identity and Access Management (IAM) user, the name and other details about the user.
        public var iamUser: Macie2ClientTypes.IamUser?
        /// If the action was performed using the credentials for your Amazon Web Services account, the details of your account.
        public var root: Macie2ClientTypes.UserIdentityRoot?
        /// The type of entity that performed the action.
        public var type: Macie2ClientTypes.UserIdentityType?

        public init(
            assumedRole: Macie2ClientTypes.AssumedRole? = nil,
            awsAccount: Macie2ClientTypes.AwsAccount? = nil,
            awsService: Macie2ClientTypes.AwsService? = nil,
            federatedUser: Macie2ClientTypes.FederatedUser? = nil,
            iamUser: Macie2ClientTypes.IamUser? = nil,
            root: Macie2ClientTypes.UserIdentityRoot? = nil,
            type: Macie2ClientTypes.UserIdentityType? = nil
        )
        {
            self.assumedRole = assumedRole
            self.awsAccount = awsAccount
            self.awsService = awsService
            self.federatedUser = federatedUser
            self.iamUser = iamUser
            self.root = root
            self.type = type
        }
    }

}

extension Macie2ClientTypes.UserIdentityRoot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about an Amazon Web Services account and entity that performed an action on an affected resource. The action was performed using the credentials for your Amazon Web Services account.
    public struct UserIdentityRoot: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the principal that performed the action. The last section of the ARN contains the name of the user or role that performed the action.
        public var arn: Swift.String?
        /// The unique identifier for the entity that performed the action.
        public var principalId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
        }
    }

}

extension Macie2ClientTypes {
    /// The type of entity that performed the action on the affected resource. Possible values are:
    public enum UserIdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsaccount
        case awsservice
        case assumedrole
        case federateduser
        case iamuser
        case root
        case sdkUnknown(Swift.String)

        public static var allCases: [UserIdentityType] {
            return [
                .awsaccount,
                .awsservice,
                .assumedrole,
                .federateduser,
                .iamuser,
                .root,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsaccount: return "AWSAccount"
            case .awsservice: return "AWSService"
            case .assumedrole: return "AssumedRole"
            case .federateduser: return "FederatedUser"
            case .iamuser: return "IAMUser"
            case .root: return "Root"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserIdentityType(rawValue: rawValue) ?? UserIdentityType.sdkUnknown(rawValue)
        }
    }
}

extension Macie2ClientTypes.UserPausedDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobExpiresAt = "jobExpiresAt"
        case jobImminentExpirationHealthEventArn = "jobImminentExpirationHealthEventArn"
        case jobPausedAt = "jobPausedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExpiresAt = self.jobExpiresAt {
            try encodeContainer.encodeTimestamp(jobExpiresAt, format: .dateTime, forKey: .jobExpiresAt)
        }
        if let jobImminentExpirationHealthEventArn = self.jobImminentExpirationHealthEventArn {
            try encodeContainer.encode(jobImminentExpirationHealthEventArn, forKey: .jobImminentExpirationHealthEventArn)
        }
        if let jobPausedAt = self.jobPausedAt {
            try encodeContainer.encodeTimestamp(jobPausedAt, format: .dateTime, forKey: .jobPausedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobExpiresAt)
        jobExpiresAt = jobExpiresAtDecoded
        let jobImminentExpirationHealthEventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobImminentExpirationHealthEventArn)
        jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArnDecoded
        let jobPausedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobPausedAt)
        jobPausedAt = jobPausedAtDecoded
    }
}

extension Macie2ClientTypes {
    /// Provides information about when a classification job was paused. For a one-time job, this object also specifies when the job will expire and be cancelled if it isn't resumed. For a recurring job, this object also specifies when the paused job run will expire and be cancelled if it isn't resumed. This object is present only if a job's current status (jobStatus) is USER_PAUSED. The information in this object applies only to a job that was paused while it had a status of RUNNING.
    public struct UserPausedDetails: Swift.Equatable {
        /// The date and time, in UTC and extended ISO 8601 format, when the job or job run will expire and be cancelled if you don't resume it first.
        public var jobExpiresAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Health event that Amazon Macie sent to notify you of the job or job run's pending expiration and cancellation. This value is null if a job has been paused for less than 23 days.
        public var jobImminentExpirationHealthEventArn: Swift.String?
        /// The date and time, in UTC and extended ISO 8601 format, when you paused the job.
        public var jobPausedAt: ClientRuntime.Date?

        public init(
            jobExpiresAt: ClientRuntime.Date? = nil,
            jobImminentExpirationHealthEventArn: Swift.String? = nil,
            jobPausedAt: ClientRuntime.Date? = nil
        )
        {
            self.jobExpiresAt = jobExpiresAt
            self.jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArn
            self.jobPausedAt = jobPausedAt
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provides information about an error that occurred due to a syntax error in a request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The explanation of the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Macie2ClientTypes.WeeklySchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfWeek = "dayOfWeek"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Macie2ClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
    }
}

extension Macie2ClientTypes {
    /// Specifies a weekly recurrence pattern for running a classification job.
    public struct WeeklySchedule: Swift.Equatable {
        /// The day of the week when Amazon Macie runs the job.
        public var dayOfWeek: Macie2ClientTypes.DayOfWeek?

        public init(
            dayOfWeek: Macie2ClientTypes.DayOfWeek? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
        }
    }

}
