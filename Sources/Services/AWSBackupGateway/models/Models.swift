// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation cannot proceed because you have insufficient permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of why you have insufficient permissions.
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateGatewayToServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case serverArn = "ServerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let serverArn = self.serverArn {
            try encodeContainer.encode(serverArn, forKey: .serverArn)
        }
    }
}

extension AssociateGatewayToServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateGatewayToServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the server that hosts your virtual machines.
    /// This member is required.
    public var serverArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil,
        serverArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.serverArn = serverArn
    }
}

struct AssociateGatewayToServerInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let serverArn: Swift.String?
}

extension AssociateGatewayToServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case serverArn = "ServerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let serverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverArn)
        serverArn = serverArnDecoded
    }
}

extension AssociateGatewayToServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateGatewayToServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateGatewayToServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateGatewayToServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateGatewayToServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct AssociateGatewayToServerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a gateway.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct AssociateGatewayToServerOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension AssociateGatewayToServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension BackupGatewayClientTypes.BandwidthRateLimitInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case daysOfWeek = "DaysOfWeek"
        case endHourOfDay = "EndHourOfDay"
        case endMinuteOfHour = "EndMinuteOfHour"
        case startHourOfDay = "StartHourOfDay"
        case startMinuteOfHour = "StartMinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageUploadRateLimitInBitsPerSec = self.averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let daysOfWeek = daysOfWeek {
            var daysOfWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfWeek)
            for dayofweek0 in daysOfWeek {
                try daysOfWeekContainer.encode(dayofweek0)
            }
        }
        if let endHourOfDay = self.endHourOfDay {
            try encodeContainer.encode(endHourOfDay, forKey: .endHourOfDay)
        }
        if let endMinuteOfHour = self.endMinuteOfHour {
            try encodeContainer.encode(endMinuteOfHour, forKey: .endMinuteOfHour)
        }
        if let startHourOfDay = self.startHourOfDay {
            try encodeContainer.encode(startHourOfDay, forKey: .startHourOfDay)
        }
        if let startMinuteOfHour = self.startMinuteOfHour {
            try encodeContainer.encode(startMinuteOfHour, forKey: .startMinuteOfHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let startHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startHourOfDay)
        startHourOfDay = startHourOfDayDecoded
        let endHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endHourOfDay)
        endHourOfDay = endHourOfDayDecoded
        let startMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startMinuteOfHour)
        startMinuteOfHour = startMinuteOfHourDecoded
        let endMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endMinuteOfHour)
        endMinuteOfHour = endMinuteOfHourDecoded
        let daysOfWeekContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .daysOfWeek)
        var daysOfWeekDecoded0:[Swift.Int]? = nil
        if let daysOfWeekContainer = daysOfWeekContainer {
            daysOfWeekDecoded0 = [Swift.Int]()
            for integer0 in daysOfWeekContainer {
                if let integer0 = integer0 {
                    daysOfWeekDecoded0?.append(integer0)
                }
            }
        }
        daysOfWeek = daysOfWeekDecoded0
    }
}

extension BackupGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval: Swift.Equatable {
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set. For Backup Gateway, the minimum value is (Value).
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init (
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation cannot proceed because it is not supported.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of why the operation is not supported.
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = self.activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGatewayInput: Swift.Equatable {
    /// The activation key of the created gateway.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The display name of the created gateway.
    /// This member is required.
    public var gatewayDisplayName: Swift.String?
    /// The type of created gateway.
    /// This member is required.
    public var gatewayType: BackupGatewayClientTypes.GatewayType?
    /// A list of up to 50 tags to assign to the gateway. Each tag is a key-value pair.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init (
        activationKey: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil,
        gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayDisplayName = gatewayDisplayName
        self.gatewayType = gatewayType
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    let activationKey: Swift.String?
    let gatewayDisplayName: Swift.String?
    let gatewayType: BackupGatewayClientTypes.GatewayType?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGatewayOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct CreateGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you create.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct CreateGatewayOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension CreateGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DeleteGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DeleteGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DeleteGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGatewayOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct DeleteGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you deleted.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DeleteGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DeleteHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension DeleteHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteHypervisorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor to delete.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct DeleteHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension DeleteHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension DeleteHypervisorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHypervisorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteHypervisorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHypervisorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteHypervisorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct DeleteHypervisorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you deleted.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct DeleteHypervisorOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension DeleteHypervisorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension DisassociateGatewayFromServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension DisassociateGatewayFromServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateGatewayFromServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to disassociate.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DisassociateGatewayFromServerInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DisassociateGatewayFromServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DisassociateGatewayFromServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateGatewayFromServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateGatewayFromServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateGatewayFromServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateGatewayFromServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct DisassociateGatewayFromServerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you disassociated.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DisassociateGatewayFromServerOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DisassociateGatewayFromServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension BackupGatewayClientTypes.Gateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case hypervisorId = "HypervisorId"
        case lastSeenTime = "LastSeenTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastSeenTime = self.lastSeenTime {
            try encodeContainer.encodeTimestamp(lastSeenTime, format: .epochSeconds, forKey: .lastSeenTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let lastSeenTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeenTime)
        lastSeenTime = lastSeenTimeDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A gateway is an Backup Gateway appliance that runs on the customer's network to provide seamless connectivity to backup storage in the Amazon Web Services Cloud.
    public struct Gateway: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// The last time Backup gateway communicated with the gateway, in Unix format and UTC time.
        public var lastSeenTime: ClientRuntime.Date?

        public init (
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: ClientRuntime.Date? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
        }
    }

}

extension BackupGatewayClientTypes.GatewayDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case hypervisorId = "HypervisorId"
        case lastSeenTime = "LastSeenTime"
        case maintenanceStartTime = "MaintenanceStartTime"
        case nextUpdateAvailabilityTime = "NextUpdateAvailabilityTime"
        case vpcEndpoint = "VpcEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastSeenTime = self.lastSeenTime {
            try encodeContainer.encodeTimestamp(lastSeenTime, format: .epochSeconds, forKey: .lastSeenTime)
        }
        if let maintenanceStartTime = self.maintenanceStartTime {
            try encodeContainer.encode(maintenanceStartTime, forKey: .maintenanceStartTime)
        }
        if let nextUpdateAvailabilityTime = self.nextUpdateAvailabilityTime {
            try encodeContainer.encodeTimestamp(nextUpdateAvailabilityTime, format: .epochSeconds, forKey: .nextUpdateAvailabilityTime)
        }
        if let vpcEndpoint = self.vpcEndpoint {
            try encodeContainer.encode(vpcEndpoint, forKey: .vpcEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let lastSeenTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeenTime)
        lastSeenTime = lastSeenTimeDecoded
        let maintenanceStartTimeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.MaintenanceStartTime.self, forKey: .maintenanceStartTime)
        maintenanceStartTime = maintenanceStartTimeDecoded
        let nextUpdateAvailabilityTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextUpdateAvailabilityTime)
        nextUpdateAvailabilityTime = nextUpdateAvailabilityTimeDecoded
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

extension BackupGatewayClientTypes {
    /// The details of gateway.
    public struct GatewayDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway type.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// Details showing the last time Backup gateway communicated with the cloud, in Unix format and UTC time.
        public var lastSeenTime: ClientRuntime.Date?
        /// Returns your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
        public var maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime?
        /// Details showing the next update availability time of the gateway.
        public var nextUpdateAvailabilityTime: ClientRuntime.Date?
        /// The DNS name for the virtual private cloud (VPC) endpoint the gateway uses to connect to the cloud for backup gateway.
        public var vpcEndpoint: Swift.String?

        public init (
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: ClientRuntime.Date? = nil,
            maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime? = nil,
            nextUpdateAvailabilityTime: ClientRuntime.Date? = nil,
            vpcEndpoint: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
            self.maintenanceStartTime = maintenanceStartTime
            self.nextUpdateAvailabilityTime = nextUpdateAvailabilityTime
            self.vpcEndpoint = vpcEndpoint
        }
    }

}

extension BackupGatewayClientTypes {
    public enum GatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupVm
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .backupVm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupVm: return "BACKUP_VM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayType(rawValue: rawValue) ?? GatewayType.sdkUnknown(rawValue)
        }
    }
}

extension GetBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthRateLimitIntervals = output.bandwidthRateLimitIntervals
            self.gatewayArn = output.gatewayArn
        } else {
            self.bandwidthRateLimitIntervals = nil
            self.gatewayArn = nil
        }
    }
}

public struct GetBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

struct GetBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension GetBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BackupGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension GetGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGatewayOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct GetGatewayOutputResponse: Swift.Equatable {
    /// By providing the ARN (Amazon Resource Name), this API returns the gateway.
    public var gateway: BackupGatewayClientTypes.GatewayDetails?

    public init (
        gateway: BackupGatewayClientTypes.GatewayDetails? = nil
    )
    {
        self.gateway = gateway
    }
}

struct GetGatewayOutputResponseBody: Swift.Equatable {
    let gateway: BackupGatewayClientTypes.GatewayDetails?
}

extension GetGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "Gateway"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayDetails.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

extension GetHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension GetHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetHypervisorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct GetHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension GetHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension GetHypervisorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHypervisorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetHypervisorOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHypervisorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetHypervisorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisor = output.hypervisor
        } else {
            self.hypervisor = nil
        }
    }
}

public struct GetHypervisorOutputResponse: Swift.Equatable {
    /// Details about the requested hypervisor.
    public var hypervisor: BackupGatewayClientTypes.HypervisorDetails?

    public init (
        hypervisor: BackupGatewayClientTypes.HypervisorDetails? = nil
    )
    {
        self.hypervisor = hypervisor
    }
}

struct GetHypervisorOutputResponseBody: Swift.Equatable {
    let hypervisor: BackupGatewayClientTypes.HypervisorDetails?
}

extension GetHypervisorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisor = "Hypervisor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorDetails.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
    }
}

extension GetHypervisorPropertyMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension GetHypervisorPropertyMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetHypervisorPropertyMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct GetHypervisorPropertyMappingsInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension GetHypervisorPropertyMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension GetHypervisorPropertyMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHypervisorPropertyMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetHypervisorPropertyMappingsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHypervisorPropertyMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetHypervisorPropertyMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
            self.iamRoleArn = output.iamRoleArn
            self.vmwareToAwsTagMappings = output.vmwareToAwsTagMappings
        } else {
            self.hypervisorArn = nil
            self.iamRoleArn = nil
            self.vmwareToAwsTagMappings = nil
        }
    }
}

public struct GetHypervisorPropertyMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    public var iamRoleArn: Swift.String?
    /// This is a display of the mappings of on-premises VMware tags to the Amazon Web Services tags.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init (
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

struct GetHypervisorPropertyMappingsOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?
    let iamRoleArn: Swift.String?
}

extension GetHypervisorPropertyMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let vmwareToAwsTagMappingsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareToAwsTagMapping?].self, forKey: .vmwareToAwsTagMappings)
        var vmwareToAwsTagMappingsDecoded0:[BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
        if let vmwareToAwsTagMappingsContainer = vmwareToAwsTagMappingsContainer {
            vmwareToAwsTagMappingsDecoded0 = [BackupGatewayClientTypes.VmwareToAwsTagMapping]()
            for structure0 in vmwareToAwsTagMappingsContainer {
                if let structure0 = structure0 {
                    vmwareToAwsTagMappingsDecoded0?.append(structure0)
                }
            }
        }
        vmwareToAwsTagMappings = vmwareToAwsTagMappingsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension GetVirtualMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetVirtualMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVirtualMachineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual machine.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetVirtualMachineInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetVirtualMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetVirtualMachineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVirtualMachineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVirtualMachineOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVirtualMachineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVirtualMachineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualMachine = output.virtualMachine
        } else {
            self.virtualMachine = nil
        }
    }
}

public struct GetVirtualMachineOutputResponse: Swift.Equatable {
    /// This object contains the basic attributes of VirtualMachine contained by the output of GetVirtualMachine
    public var virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?

    public init (
        virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails? = nil
    )
    {
        self.virtualMachine = virtualMachine
    }
}

struct GetVirtualMachineOutputResponseBody: Swift.Equatable {
    let virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?
}

extension GetVirtualMachineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualMachine = "VirtualMachine"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualMachineDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.VirtualMachineDetails.self, forKey: .virtualMachine)
        virtualMachine = virtualMachineDecoded
    }
}

extension BackupGatewayClientTypes.Hypervisor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorState.self, forKey: .state)
        state = stateDecoded
    }
}

extension BackupGatewayClientTypes {
    /// Represents the hypervisor's permissions to which the gateway will connect. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct Hypervisor: Swift.Equatable {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// The name of the hypervisor.
        public var name: Swift.String?
        /// The state of the hypervisor.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init (
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes.HypervisorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case kmsKeyArn = "KmsKeyArn"
        case lastSuccessfulMetadataSyncTime = "LastSuccessfulMetadataSyncTime"
        case latestMetadataSyncStatus = "LatestMetadataSyncStatus"
        case latestMetadataSyncStatusMessage = "LatestMetadataSyncStatusMessage"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastSuccessfulMetadataSyncTime = self.lastSuccessfulMetadataSyncTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulMetadataSyncTime, format: .epochSeconds, forKey: .lastSuccessfulMetadataSyncTime)
        }
        if let latestMetadataSyncStatus = self.latestMetadataSyncStatus {
            try encodeContainer.encode(latestMetadataSyncStatus.rawValue, forKey: .latestMetadataSyncStatus)
        }
        if let latestMetadataSyncStatusMessage = self.latestMetadataSyncStatusMessage {
            try encodeContainer.encode(latestMetadataSyncStatusMessage, forKey: .latestMetadataSyncStatusMessage)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorState.self, forKey: .state)
        state = stateDecoded
        let lastSuccessfulMetadataSyncTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulMetadataSyncTime)
        lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTimeDecoded
        let latestMetadataSyncStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestMetadataSyncStatusMessage)
        latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessageDecoded
        let latestMetadataSyncStatusDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.SyncMetadataStatus.self, forKey: .latestMetadataSyncStatus)
        latestMetadataSyncStatus = latestMetadataSyncStatusDecoded
    }
}

extension BackupGatewayClientTypes {
    /// These are the details of the specified hypervisor. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct HypervisorDetails: Swift.Equatable {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// This is the time when the most recent successful sync of metadata occurred.
        public var lastSuccessfulMetadataSyncTime: ClientRuntime.Date?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatusMessage: Swift.String?
        /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
        public var logGroupArn: Swift.String?
        /// This is the name of the specified hypervisor.
        public var name: Swift.String?
        /// This is the current state of the specified hypervisor. The possible states are PENDING, ONLINE, OFFLINE, or ERROR.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init (
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastSuccessfulMetadataSyncTime: ClientRuntime.Date? = nil,
            latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus? = nil,
            latestMetadataSyncStatusMessage: Swift.String? = nil,
            logGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTime
            self.latestMetadataSyncStatus = latestMetadataSyncStatus
            self.latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessage
            self.logGroupArn = logGroupArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes {
    public enum HypervisorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case offline
        case online
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [HypervisorState] {
            return [
                .error,
                .offline,
                .online,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HypervisorState(rawValue: rawValue) ?? HypervisorState.sdkUnknown(rawValue)
        }
    }
}

extension ImportHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHypervisorConfigurationInput(host: \(Swift.String(describing: host)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ImportHypervisorConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case password = "Password"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension ImportHypervisorConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportHypervisorConfigurationInput: Swift.Equatable {
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The Key Management Service for the hypervisor.
    public var kmsKeyArn: Swift.String?
    /// The name of the hypervisor.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The tags of the hypervisor configuration to import.
    public var tags: [BackupGatewayClientTypes.Tag]?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init (
        host: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.password = password
        self.tags = tags
        self.username = username
    }
}

struct ImportHypervisorConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let kmsKeyArn: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension ImportHypervisorConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case password = "Password"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportHypervisorConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportHypervisorConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportHypervisorConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportHypervisorConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportHypervisorConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct ImportHypervisorConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you disassociated.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct ImportHypervisorConfigurationOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension ImportHypervisorConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

/// The operation did not succeed because an internal error occurred. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A description of which internal error occured.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension ListGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of gateways to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// A list of your gateways.
    public var gateways: [BackupGatewayClientTypes.Gateway]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        gateways: [BackupGatewayClientTypes.Gateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    let gateways: [BackupGatewayClientTypes.Gateway]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Gateway?].self, forKey: .gateways)
        var gatewaysDecoded0:[BackupGatewayClientTypes.Gateway]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [BackupGatewayClientTypes.Gateway]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHypervisorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHypervisorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHypervisorsInput: Swift.Equatable {
    /// The maximum number of hypervisors to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHypervisorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListHypervisorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHypervisorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHypervisorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListHypervisorsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHypervisorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListHypervisorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisors = output.hypervisors
            self.nextToken = output.nextToken
        } else {
            self.hypervisors = nil
            self.nextToken = nil
        }
    }
}

public struct ListHypervisorsOutputResponse: Swift.Equatable {
    /// A list of your Hypervisor objects, ordered by their Amazon Resource Names (ARNs).
    public var hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        hypervisors: [BackupGatewayClientTypes.Hypervisor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisors = hypervisors
        self.nextToken = nextToken
    }
}

struct ListHypervisorsOutputResponseBody: Swift.Equatable {
    let hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    let nextToken: Swift.String?
}

extension ListHypervisorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisors = "Hypervisors"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Hypervisor?].self, forKey: .hypervisors)
        var hypervisorsDecoded0:[BackupGatewayClientTypes.Hypervisor]? = nil
        if let hypervisorsContainer = hypervisorsContainer {
            hypervisorsDecoded0 = [BackupGatewayClientTypes.Hypervisor]()
            for structure0 in hypervisorsContainer {
                if let structure0 = structure0 {
                    hypervisorsDecoded0?.append(structure0)
                }
            }
        }
        hypervisors = hypervisorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource's tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource's tags that you listed.
    public var resourceArn: Swift.String?
    /// A list of the resource's tags.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVirtualMachinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListVirtualMachinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVirtualMachinesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor connected to your virtual machine.
    public var hypervisorArn: Swift.String?
    /// The maximum number of virtual machines to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVirtualMachinesInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVirtualMachinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualMachinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualMachinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualMachinesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualMachinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualMachinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualMachines = output.virtualMachines
        } else {
            self.nextToken = nil
            self.virtualMachines = nil
        }
    }
}

public struct ListVirtualMachinesOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// A list of your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public var virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?

    public init (
        nextToken: Swift.String? = nil,
        virtualMachines: [BackupGatewayClientTypes.VirtualMachine]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualMachines = virtualMachines
    }
}

struct ListVirtualMachinesOutputResponseBody: Swift.Equatable {
    let virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?
    let nextToken: Swift.String?
}

extension ListVirtualMachinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case virtualMachines = "VirtualMachines"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualMachinesContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VirtualMachine?].self, forKey: .virtualMachines)
        var virtualMachinesDecoded0:[BackupGatewayClientTypes.VirtualMachine]? = nil
        if let virtualMachinesContainer = virtualMachinesContainer {
            virtualMachinesDecoded0 = [BackupGatewayClientTypes.VirtualMachine]()
            for structure0 in virtualMachinesContainer {
                if let structure0 = structure0 {
                    virtualMachinesDecoded0?.append(structure0)
                }
            }
        }
        virtualMachines = virtualMachinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BackupGatewayClientTypes.MaintenanceStartTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let hourOfDay = self.hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = self.minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
    }
}

extension BackupGatewayClientTypes {
    /// This is your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
    public struct MaintenanceStartTime: Swift.Equatable {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        public var dayOfMonth: Swift.Int?
        /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
        public var dayOfWeek: Swift.Int?
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        /// This member is required.
        public var hourOfDay: Swift.Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
        /// This member is required.
        public var minuteOfHour: Swift.Int?

        public init (
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: Swift.Int? = nil,
            hourOfDay: Swift.Int? = nil,
            minuteOfHour: Swift.Int? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension PutBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthRateLimitIntervals = bandwidthRateLimitIntervals {
            var bandwidthRateLimitIntervalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandwidthRateLimitIntervals)
            for bandwidthratelimitinterval0 in bandwidthRateLimitIntervals {
                try bandwidthRateLimitIntervalsContainer.encode(bandwidthratelimitinterval0)
            }
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension PutBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

struct PutBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension PutBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BackupGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension PutBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct PutBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct PutBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension PutBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension PutHypervisorPropertyMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let vmwareToAwsTagMappings = vmwareToAwsTagMappings {
            var vmwareToAwsTagMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmwareToAwsTagMappings)
            for vmwaretoawstagmapping0 in vmwareToAwsTagMappings {
                try vmwareToAwsTagMappingsContainer.encode(vmwaretoawstagmapping0)
            }
        }
    }
}

extension PutHypervisorPropertyMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutHypervisorPropertyMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// This action requests the mappings of on-premises VMware tags to the Amazon Web Services tags.
    /// This member is required.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init (
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

struct PutHypervisorPropertyMappingsInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?
    let iamRoleArn: Swift.String?
}

extension PutHypervisorPropertyMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let vmwareToAwsTagMappingsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareToAwsTagMapping?].self, forKey: .vmwareToAwsTagMappings)
        var vmwareToAwsTagMappingsDecoded0:[BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
        if let vmwareToAwsTagMappingsContainer = vmwareToAwsTagMappingsContainer {
            vmwareToAwsTagMappingsDecoded0 = [BackupGatewayClientTypes.VmwareToAwsTagMapping]()
            for structure0 in vmwareToAwsTagMappingsContainer {
                if let structure0 = structure0 {
                    vmwareToAwsTagMappingsDecoded0?.append(structure0)
                }
            }
        }
        vmwareToAwsTagMappings = vmwareToAwsTagMappingsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension PutHypervisorPropertyMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutHypervisorPropertyMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutHypervisorPropertyMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutHypervisorPropertyMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutHypervisorPropertyMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct PutHypervisorPropertyMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct PutHypervisorPropertyMappingsOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension PutHypervisorPropertyMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension PutMaintenanceStartTimeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayArn = "GatewayArn"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let hourOfDay = self.hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = self.minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }
}

extension PutMaintenanceStartTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMaintenanceStartTimeInput: Swift.Equatable {
    /// The day of the month start maintenance on a gateway. Valid values range from Sunday to Saturday.
    public var dayOfMonth: Swift.Int?
    /// The day of the week to start maintenance on a gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) for the gateway, used to specify its maintenance start time.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The hour of the day to start maintenance on a gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute of the hour to start maintenance on a gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init (
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayArn: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayArn = gatewayArn
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

struct PutMaintenanceStartTimeInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let hourOfDay: Swift.Int?
    let minuteOfHour: Swift.Int?
    let dayOfWeek: Swift.Int?
    let dayOfMonth: Swift.Int?
}

extension PutMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayArn = "GatewayArn"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension PutMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMaintenanceStartTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMaintenanceStartTimeOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMaintenanceStartTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct PutMaintenanceStartTimeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a gateway for which you set the maintenance start time.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct PutMaintenanceStartTimeOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension PutMaintenanceStartTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is required for the action wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of which resource wasn't found.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartVirtualMachinesMetadataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension StartVirtualMachinesMetadataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartVirtualMachinesMetadataSyncInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct StartVirtualMachinesMetadataSyncInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension StartVirtualMachinesMetadataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension StartVirtualMachinesMetadataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartVirtualMachinesMetadataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartVirtualMachinesMetadataSyncOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartVirtualMachinesMetadataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartVirtualMachinesMetadataSyncOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct StartVirtualMachinesMetadataSyncOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct StartVirtualMachinesMetadataSyncOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension StartVirtualMachinesMetadataSyncOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension BackupGatewayClientTypes {
    public enum SyncMetadataStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case partiallyFailed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncMetadataStatus] {
            return [
                .created,
                .failed,
                .partiallyFailed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partiallyFailed: return "PARTIALLY_FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncMetadataStatus(rawValue: rawValue) ?? SyncMetadataStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupGatewayClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// The key part of a tag's key-value pair. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// The value part of a tag's key-value pair.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to assign to the resource.
    /// This member is required.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you tagged.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension TestHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestHypervisorConfigurationInput(gatewayArn: \(Swift.String(describing: gatewayArn)), host: \(Swift.String(describing: host)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension TestHypervisorConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case host = "Host"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension TestHypervisorConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestHypervisorConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to the hypervisor to test.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil,
        host: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.host = host
        self.password = password
        self.username = username
    }
}

struct TestHypervisorConfigurationInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
}

extension TestHypervisorConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case host = "Host"
        case password = "Password"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension TestHypervisorConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestHypervisorConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestHypervisorConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestHypervisorConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TestHypervisorConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

/// TPS has been limited to protect against intentional or unintentional high request volumes.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error: TPS has been limited to protect against intentional or unintentional high request volumes.
    /// This member is required.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys specifying which tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you removed tags.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension UpdateGatewayInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
    }
}

extension UpdateGatewayInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated display name of the gateway.
    public var gatewayDisplayName: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayDisplayName = gatewayDisplayName
    }
}

struct UpdateGatewayInformationInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let gatewayDisplayName: Swift.String?
}

extension UpdateGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
    }
}

extension UpdateGatewayInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewayInformationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct UpdateGatewayInformationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewayInformationOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewayInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension UpdateGatewaySoftwareNowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension UpdateGatewaySoftwareNowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewaySoftwareNowInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to be updated.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewaySoftwareNowInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewaySoftwareNowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension UpdateGatewaySoftwareNowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewaySoftwareNowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewaySoftwareNowOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewaySoftwareNowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGatewaySoftwareNowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct UpdateGatewaySoftwareNowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewaySoftwareNowOutputResponseBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewaySoftwareNowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension UpdateHypervisorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHypervisorInput(host: \(Swift.String(describing: host)), hypervisorArn: \(Swift.String(describing: hypervisorArn)), logGroupArn: \(Swift.String(describing: logGroupArn)), name: \(Swift.String(describing: name)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension UpdateHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension UpdateHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateHypervisorInput: Swift.Equatable {
    /// The updated host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    public var host: Swift.String?
    /// The Amazon Resource Name (ARN) of the hypervisor to update.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
    public var logGroupArn: Swift.String?
    /// The updated name for the hypervisor
    public var name: Swift.String?
    /// The updated password for the hypervisor.
    public var password: Swift.String?
    /// The updated username for the hypervisor.
    public var username: Swift.String?

    public init (
        host: Swift.String? = nil,
        hypervisorArn: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.hypervisorArn = hypervisorArn
        self.logGroupArn = logGroupArn
        self.name = name
        self.password = password
        self.username = username
    }
}

struct UpdateHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let name: Swift.String?
    let logGroupArn: Swift.String?
}

extension UpdateHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case password = "Password"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension UpdateHypervisorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHypervisorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateHypervisorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHypervisorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateHypervisorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct UpdateHypervisorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you updated.
    public var hypervisorArn: Swift.String?

    public init (
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct UpdateHypervisorOutputResponseBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension UpdateHypervisorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

/// The operation did not succeed because a validation error occurred.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of what caused the validation error.
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension BackupGatewayClientTypes.VirtualMachine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case hypervisorId = "HypervisorId"
        case lastBackupDate = "LastBackupDate"
        case name = "Name"
        case path = "Path"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastBackupDate = self.lastBackupDate {
            try encodeContainer.encodeTimestamp(lastBackupDate, format: .epochSeconds, forKey: .lastBackupDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let lastBackupDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupDate)
        lastBackupDate = lastBackupDateDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A virtual machine that is on a hypervisor.
    public struct VirtualMachine: Swift.Equatable {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: ClientRuntime.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?

        public init (
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
        }
    }

}

extension BackupGatewayClientTypes.VirtualMachineDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case hypervisorId = "HypervisorId"
        case lastBackupDate = "LastBackupDate"
        case name = "Name"
        case path = "Path"
        case resourceArn = "ResourceArn"
        case vmwareTags = "VmwareTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastBackupDate = self.lastBackupDate {
            try encodeContainer.encodeTimestamp(lastBackupDate, format: .epochSeconds, forKey: .lastBackupDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let vmwareTags = vmwareTags {
            var vmwareTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmwareTags)
            for vmwaretag0 in vmwareTags {
                try vmwareTagsContainer.encode(vmwaretag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let lastBackupDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupDate)
        lastBackupDate = lastBackupDateDecoded
        let vmwareTagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareTag?].self, forKey: .vmwareTags)
        var vmwareTagsDecoded0:[BackupGatewayClientTypes.VmwareTag]? = nil
        if let vmwareTagsContainer = vmwareTagsContainer {
            vmwareTagsDecoded0 = [BackupGatewayClientTypes.VmwareTag]()
            for structure0 in vmwareTagsContainer {
                if let structure0 = structure0 {
                    vmwareTagsDecoded0?.append(structure0)
                }
            }
        }
        vmwareTags = vmwareTagsDecoded0
    }
}

extension BackupGatewayClientTypes {
    /// Your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public struct VirtualMachineDetails: Swift.Equatable {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: ClientRuntime.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?
        /// These are the details of the VMware tags associated with the specified virtual machine.
        public var vmwareTags: [BackupGatewayClientTypes.VmwareTag]?

        public init (
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            vmwareTags: [BackupGatewayClientTypes.VmwareTag]? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
            self.vmwareTags = vmwareTags
        }
    }

}

extension BackupGatewayClientTypes.VmwareTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vmwareCategory = "VmwareCategory"
        case vmwareTagDescription = "VmwareTagDescription"
        case vmwareTagName = "VmwareTagName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmwareCategory = self.vmwareCategory {
            try encodeContainer.encode(vmwareCategory, forKey: .vmwareCategory)
        }
        if let vmwareTagDescription = self.vmwareTagDescription {
            try encodeContainer.encode(vmwareTagDescription, forKey: .vmwareTagDescription)
        }
        if let vmwareTagName = self.vmwareTagName {
            try encodeContainer.encode(vmwareTagName, forKey: .vmwareTagName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmwareCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareCategory)
        vmwareCategory = vmwareCategoryDecoded
        let vmwareTagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagName)
        vmwareTagName = vmwareTagNameDecoded
        let vmwareTagDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagDescription)
        vmwareTagDescription = vmwareTagDescriptionDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A VMware tag is a tag attached to a specific virtual machine. A [tag](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_Tag.html) is a key-value pair you can use to manage, filter, and search for your resources. The content of VMware tags can be matched to Amazon Web Services tags.
    public struct VmwareTag: Swift.Equatable {
        /// The is the category of VMware.
        public var vmwareCategory: Swift.String?
        /// This is a user-defined description of a VMware tag.
        public var vmwareTagDescription: Swift.String?
        /// This is the user-defined name of a VMware tag.
        public var vmwareTagName: Swift.String?

        public init (
            vmwareCategory: Swift.String? = nil,
            vmwareTagDescription: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.vmwareCategory = vmwareCategory
            self.vmwareTagDescription = vmwareTagDescription
            self.vmwareTagName = vmwareTagName
        }
    }

}

extension BackupGatewayClientTypes.VmwareToAwsTagMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsTagKey = "AwsTagKey"
        case awsTagValue = "AwsTagValue"
        case vmwareCategory = "VmwareCategory"
        case vmwareTagName = "VmwareTagName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsTagKey = self.awsTagKey {
            try encodeContainer.encode(awsTagKey, forKey: .awsTagKey)
        }
        if let awsTagValue = self.awsTagValue {
            try encodeContainer.encode(awsTagValue, forKey: .awsTagValue)
        }
        if let vmwareCategory = self.vmwareCategory {
            try encodeContainer.encode(vmwareCategory, forKey: .vmwareCategory)
        }
        if let vmwareTagName = self.vmwareTagName {
            try encodeContainer.encode(vmwareTagName, forKey: .vmwareTagName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmwareCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareCategory)
        vmwareCategory = vmwareCategoryDecoded
        let vmwareTagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagName)
        vmwareTagName = vmwareTagNameDecoded
        let awsTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsTagKey)
        awsTagKey = awsTagKeyDecoded
        let awsTagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsTagValue)
        awsTagValue = awsTagValueDecoded
    }
}

extension BackupGatewayClientTypes {
    /// This displays the mapping of on-premises VMware tags to the corresponding Amazon Web Services tags.
    public struct VmwareToAwsTagMapping: Swift.Equatable {
        /// The key part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagKey: Swift.String?
        /// The value part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagValue: Swift.String?
        /// The is the category of VMware.
        /// This member is required.
        public var vmwareCategory: Swift.String?
        /// This is the user-defined name of a VMware tag.
        /// This member is required.
        public var vmwareTagName: Swift.String?

        public init (
            awsTagKey: Swift.String? = nil,
            awsTagValue: Swift.String? = nil,
            vmwareCategory: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.awsTagKey = awsTagKey
            self.awsTagValue = awsTagValue
            self.vmwareCategory = vmwareCategory
            self.vmwareTagName = vmwareTagName
        }
    }

}
