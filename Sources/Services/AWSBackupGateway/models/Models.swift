// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation cannot proceed because you have insufficient permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why you have insufficient permissions.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateGatewayToServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case serverArn = "ServerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let serverArn = self.serverArn {
            try encodeContainer.encode(serverArn, forKey: .serverArn)
        }
    }
}

extension AssociateGatewayToServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateGatewayToServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the server that hosts your virtual machines.
    /// This member is required.
    public var serverArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        serverArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.serverArn = serverArn
    }
}

struct AssociateGatewayToServerInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let serverArn: Swift.String?
}

extension AssociateGatewayToServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case serverArn = "ServerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let serverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverArn)
        serverArn = serverArnDecoded
    }
}

extension AssociateGatewayToServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateGatewayToServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct AssociateGatewayToServerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a gateway.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct AssociateGatewayToServerOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension AssociateGatewayToServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum AssociateGatewayToServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupGatewayClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension BackupGatewayClientTypes.BandwidthRateLimitInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case daysOfWeek = "DaysOfWeek"
        case endHourOfDay = "EndHourOfDay"
        case endMinuteOfHour = "EndMinuteOfHour"
        case startHourOfDay = "StartHourOfDay"
        case startMinuteOfHour = "StartMinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageUploadRateLimitInBitsPerSec = self.averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let daysOfWeek = daysOfWeek {
            var daysOfWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfWeek)
            for dayofweek0 in daysOfWeek {
                try daysOfWeekContainer.encode(dayofweek0)
            }
        }
        if let endHourOfDay = self.endHourOfDay {
            try encodeContainer.encode(endHourOfDay, forKey: .endHourOfDay)
        }
        if let endMinuteOfHour = self.endMinuteOfHour {
            try encodeContainer.encode(endMinuteOfHour, forKey: .endMinuteOfHour)
        }
        if let startHourOfDay = self.startHourOfDay {
            try encodeContainer.encode(startHourOfDay, forKey: .startHourOfDay)
        }
        if let startMinuteOfHour = self.startMinuteOfHour {
            try encodeContainer.encode(startMinuteOfHour, forKey: .startMinuteOfHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let startHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startHourOfDay)
        startHourOfDay = startHourOfDayDecoded
        let endHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endHourOfDay)
        endHourOfDay = endHourOfDayDecoded
        let startMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startMinuteOfHour)
        startMinuteOfHour = startMinuteOfHourDecoded
        let endMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endMinuteOfHour)
        endMinuteOfHour = endMinuteOfHourDecoded
        let daysOfWeekContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .daysOfWeek)
        var daysOfWeekDecoded0:[Swift.Int]? = nil
        if let daysOfWeekContainer = daysOfWeekContainer {
            daysOfWeekDecoded0 = [Swift.Int]()
            for integer0 in daysOfWeekContainer {
                if let integer0 = integer0 {
                    daysOfWeekDecoded0?.append(integer0)
                }
            }
        }
        daysOfWeek = daysOfWeekDecoded0
    }
}

extension BackupGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval: Swift.Equatable {
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set. For Backup Gateway, the minimum value is (Value).
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init(
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation cannot proceed because it is not supported.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why the operation is not supported.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = self.activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGatewayInput: Swift.Equatable {
    /// The activation key of the created gateway.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The display name of the created gateway.
    /// This member is required.
    public var gatewayDisplayName: Swift.String?
    /// The type of created gateway.
    /// This member is required.
    public var gatewayType: BackupGatewayClientTypes.GatewayType?
    /// A list of up to 50 tags to assign to the gateway. Each tag is a key-value pair.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        activationKey: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil,
        gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayDisplayName = gatewayDisplayName
        self.gatewayType = gatewayType
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    let activationKey: Swift.String?
    let gatewayDisplayName: Swift.String?
    let gatewayType: BackupGatewayClientTypes.GatewayType?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct CreateGatewayOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you create.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct CreateGatewayOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension CreateGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum CreateGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DeleteGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DeleteGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct DeleteGatewayOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DeleteGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum DeleteGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension DeleteHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteHypervisorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor to delete.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct DeleteHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension DeleteHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension DeleteHypervisorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteHypervisorOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct DeleteHypervisorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you deleted.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct DeleteHypervisorOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension DeleteHypervisorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

enum DeleteHypervisorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateGatewayFromServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension DisassociateGatewayFromServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateGatewayFromServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to disassociate.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DisassociateGatewayFromServerInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DisassociateGatewayFromServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension DisassociateGatewayFromServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateGatewayFromServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct DisassociateGatewayFromServerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you disassociated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DisassociateGatewayFromServerOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DisassociateGatewayFromServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum DisassociateGatewayFromServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupGatewayClientTypes.Gateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case hypervisorId = "HypervisorId"
        case lastSeenTime = "LastSeenTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastSeenTime = self.lastSeenTime {
            try encodeContainer.encodeTimestamp(lastSeenTime, format: .epochSeconds, forKey: .lastSeenTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let lastSeenTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeenTime)
        lastSeenTime = lastSeenTimeDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A gateway is an Backup Gateway appliance that runs on the customer's network to provide seamless connectivity to backup storage in the Amazon Web Services Cloud.
    public struct Gateway: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// The last time Backup gateway communicated with the gateway, in Unix format and UTC time.
        public var lastSeenTime: ClientRuntime.Date?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: ClientRuntime.Date? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
        }
    }

}

extension BackupGatewayClientTypes.GatewayDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
        case gatewayType = "GatewayType"
        case hypervisorId = "HypervisorId"
        case lastSeenTime = "LastSeenTime"
        case maintenanceStartTime = "MaintenanceStartTime"
        case nextUpdateAvailabilityTime = "NextUpdateAvailabilityTime"
        case vpcEndpoint = "VpcEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType.rawValue, forKey: .gatewayType)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastSeenTime = self.lastSeenTime {
            try encodeContainer.encodeTimestamp(lastSeenTime, format: .epochSeconds, forKey: .lastSeenTime)
        }
        if let maintenanceStartTime = self.maintenanceStartTime {
            try encodeContainer.encode(maintenanceStartTime, forKey: .maintenanceStartTime)
        }
        if let nextUpdateAvailabilityTime = self.nextUpdateAvailabilityTime {
            try encodeContainer.encodeTimestamp(nextUpdateAvailabilityTime, format: .epochSeconds, forKey: .nextUpdateAvailabilityTime)
        }
        if let vpcEndpoint = self.vpcEndpoint {
            try encodeContainer.encode(vpcEndpoint, forKey: .vpcEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayType.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let lastSeenTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeenTime)
        lastSeenTime = lastSeenTimeDecoded
        let maintenanceStartTimeDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.MaintenanceStartTime.self, forKey: .maintenanceStartTime)
        maintenanceStartTime = maintenanceStartTimeDecoded
        let nextUpdateAvailabilityTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextUpdateAvailabilityTime)
        nextUpdateAvailabilityTime = nextUpdateAvailabilityTimeDecoded
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
    }
}

extension BackupGatewayClientTypes {
    /// The details of gateway.
    public struct GatewayDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway type.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// Details showing the last time Backup gateway communicated with the cloud, in Unix format and UTC time.
        public var lastSeenTime: ClientRuntime.Date?
        /// Returns your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
        public var maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime?
        /// Details showing the next update availability time of the gateway.
        public var nextUpdateAvailabilityTime: ClientRuntime.Date?
        /// The DNS name for the virtual private cloud (VPC) endpoint the gateway uses to connect to the cloud for backup gateway.
        public var vpcEndpoint: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: ClientRuntime.Date? = nil,
            maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime? = nil,
            nextUpdateAvailabilityTime: ClientRuntime.Date? = nil,
            vpcEndpoint: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
            self.maintenanceStartTime = maintenanceStartTime
            self.nextUpdateAvailabilityTime = nextUpdateAvailabilityTime
            self.vpcEndpoint = vpcEndpoint
        }
    }

}

extension BackupGatewayClientTypes {
    public enum GatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupVm
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .backupVm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupVm: return "BACKUP_VM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayType(rawValue: rawValue) ?? GatewayType.sdkUnknown(rawValue)
        }
    }
}

extension GetBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetBandwidthRateLimitScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBandwidthRateLimitScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthRateLimitIntervals = output.bandwidthRateLimitIntervals
            self.gatewayArn = output.gatewayArn
        } else {
            self.bandwidthRateLimitIntervals = nil
            self.gatewayArn = nil
        }
    }
}

public struct GetBandwidthRateLimitScheduleOutput: Swift.Equatable {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

struct GetBandwidthRateLimitScheduleOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension GetBandwidthRateLimitScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BackupGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

enum GetBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct GetGatewayOutput: Swift.Equatable {
    /// By providing the ARN (Amazon Resource Name), this API returns the gateway.
    public var gateway: BackupGatewayClientTypes.GatewayDetails?

    public init(
        gateway: BackupGatewayClientTypes.GatewayDetails? = nil
    )
    {
        self.gateway = gateway
    }
}

struct GetGatewayOutputBody: Swift.Equatable {
    let gateway: BackupGatewayClientTypes.GatewayDetails?
}

extension GetGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "Gateway"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.GatewayDetails.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

enum GetGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension GetHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetHypervisorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct GetHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension GetHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension GetHypervisorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetHypervisorOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisor = output.hypervisor
        } else {
            self.hypervisor = nil
        }
    }
}

public struct GetHypervisorOutput: Swift.Equatable {
    /// Details about the requested hypervisor.
    public var hypervisor: BackupGatewayClientTypes.HypervisorDetails?

    public init(
        hypervisor: BackupGatewayClientTypes.HypervisorDetails? = nil
    )
    {
        self.hypervisor = hypervisor
    }
}

struct GetHypervisorOutputBody: Swift.Equatable {
    let hypervisor: BackupGatewayClientTypes.HypervisorDetails?
}

extension GetHypervisorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisor = "Hypervisor"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorDetails.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
    }
}

enum GetHypervisorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetHypervisorPropertyMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension GetHypervisorPropertyMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetHypervisorPropertyMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct GetHypervisorPropertyMappingsInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension GetHypervisorPropertyMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension GetHypervisorPropertyMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetHypervisorPropertyMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
            self.iamRoleArn = output.iamRoleArn
            self.vmwareToAwsTagMappings = output.vmwareToAwsTagMappings
        } else {
            self.hypervisorArn = nil
            self.iamRoleArn = nil
            self.vmwareToAwsTagMappings = nil
        }
    }
}

public struct GetHypervisorPropertyMappingsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    public var iamRoleArn: Swift.String?
    /// This is a display of the mappings of on-premises VMware tags to the Amazon Web Services tags.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

struct GetHypervisorPropertyMappingsOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?
    let iamRoleArn: Swift.String?
}

extension GetHypervisorPropertyMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let vmwareToAwsTagMappingsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareToAwsTagMapping?].self, forKey: .vmwareToAwsTagMappings)
        var vmwareToAwsTagMappingsDecoded0:[BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
        if let vmwareToAwsTagMappingsContainer = vmwareToAwsTagMappingsContainer {
            vmwareToAwsTagMappingsDecoded0 = [BackupGatewayClientTypes.VmwareToAwsTagMapping]()
            for structure0 in vmwareToAwsTagMappingsContainer {
                if let structure0 = structure0 {
                    vmwareToAwsTagMappingsDecoded0?.append(structure0)
                }
            }
        }
        vmwareToAwsTagMappings = vmwareToAwsTagMappingsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

enum GetHypervisorPropertyMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVirtualMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetVirtualMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVirtualMachineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual machine.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetVirtualMachineInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetVirtualMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetVirtualMachineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVirtualMachineOutputBody = try responseDecoder.decode(responseBody: data)
            self.virtualMachine = output.virtualMachine
        } else {
            self.virtualMachine = nil
        }
    }
}

public struct GetVirtualMachineOutput: Swift.Equatable {
    /// This object contains the basic attributes of VirtualMachine contained by the output of GetVirtualMachine
    public var virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?

    public init(
        virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails? = nil
    )
    {
        self.virtualMachine = virtualMachine
    }
}

struct GetVirtualMachineOutputBody: Swift.Equatable {
    let virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?
}

extension GetVirtualMachineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualMachine = "VirtualMachine"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualMachineDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.VirtualMachineDetails.self, forKey: .virtualMachine)
        virtualMachine = virtualMachineDecoded
    }
}

enum GetVirtualMachineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupGatewayClientTypes.Hypervisor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorState.self, forKey: .state)
        state = stateDecoded
    }
}

extension BackupGatewayClientTypes {
    /// Represents the hypervisor's permissions to which the gateway will connect. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct Hypervisor: Swift.Equatable {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// The name of the hypervisor.
        public var name: Swift.String?
        /// The state of the hypervisor.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes.HypervisorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case kmsKeyArn = "KmsKeyArn"
        case lastSuccessfulMetadataSyncTime = "LastSuccessfulMetadataSyncTime"
        case latestMetadataSyncStatus = "LatestMetadataSyncStatus"
        case latestMetadataSyncStatusMessage = "LatestMetadataSyncStatusMessage"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastSuccessfulMetadataSyncTime = self.lastSuccessfulMetadataSyncTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulMetadataSyncTime, format: .epochSeconds, forKey: .lastSuccessfulMetadataSyncTime)
        }
        if let latestMetadataSyncStatus = self.latestMetadataSyncStatus {
            try encodeContainer.encode(latestMetadataSyncStatus.rawValue, forKey: .latestMetadataSyncStatus)
        }
        if let latestMetadataSyncStatusMessage = self.latestMetadataSyncStatusMessage {
            try encodeContainer.encode(latestMetadataSyncStatusMessage, forKey: .latestMetadataSyncStatusMessage)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.HypervisorState.self, forKey: .state)
        state = stateDecoded
        let lastSuccessfulMetadataSyncTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulMetadataSyncTime)
        lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTimeDecoded
        let latestMetadataSyncStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestMetadataSyncStatusMessage)
        latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessageDecoded
        let latestMetadataSyncStatusDecoded = try containerValues.decodeIfPresent(BackupGatewayClientTypes.SyncMetadataStatus.self, forKey: .latestMetadataSyncStatus)
        latestMetadataSyncStatus = latestMetadataSyncStatusDecoded
    }
}

extension BackupGatewayClientTypes {
    /// These are the details of the specified hypervisor. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct HypervisorDetails: Swift.Equatable {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// This is the time when the most recent successful sync of metadata occurred.
        public var lastSuccessfulMetadataSyncTime: ClientRuntime.Date?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatusMessage: Swift.String?
        /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
        public var logGroupArn: Swift.String?
        /// This is the name of the specified hypervisor.
        public var name: Swift.String?
        /// This is the current state of the specified hypervisor. The possible states are PENDING, ONLINE, OFFLINE, or ERROR.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastSuccessfulMetadataSyncTime: ClientRuntime.Date? = nil,
            latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus? = nil,
            latestMetadataSyncStatusMessage: Swift.String? = nil,
            logGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTime
            self.latestMetadataSyncStatus = latestMetadataSyncStatus
            self.latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessage
            self.logGroupArn = logGroupArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes {
    public enum HypervisorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case offline
        case online
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [HypervisorState] {
            return [
                .error,
                .offline,
                .online,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HypervisorState(rawValue: rawValue) ?? HypervisorState.sdkUnknown(rawValue)
        }
    }
}

extension ImportHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHypervisorConfigurationInput(host: \(Swift.String(describing: host)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ImportHypervisorConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case password = "Password"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension ImportHypervisorConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportHypervisorConfigurationInput: Swift.Equatable {
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The Key Management Service for the hypervisor.
    public var kmsKeyArn: Swift.String?
    /// The name of the hypervisor.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The tags of the hypervisor configuration to import.
    public var tags: [BackupGatewayClientTypes.Tag]?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.password = password
        self.tags = tags
        self.username = username
    }
}

struct ImportHypervisorConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let kmsKeyArn: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension ImportHypervisorConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case password = "Password"
        case tags = "Tags"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportHypervisorConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportHypervisorConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct ImportHypervisorConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you disassociated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct ImportHypervisorConfigurationOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension ImportHypervisorConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

enum ImportHypervisorConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because an internal error occurred. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which internal error occured.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of gateways to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutput: Swift.Equatable {
    /// A list of your gateways.
    public var gateways: [BackupGatewayClientTypes.Gateway]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        gateways: [BackupGatewayClientTypes.Gateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputBody: Swift.Equatable {
    let gateways: [BackupGatewayClientTypes.Gateway]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Gateway?].self, forKey: .gateways)
        var gatewaysDecoded0:[BackupGatewayClientTypes.Gateway]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [BackupGatewayClientTypes.Gateway]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHypervisorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListHypervisorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListHypervisorsInput: Swift.Equatable {
    /// The maximum number of hypervisors to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHypervisorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListHypervisorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHypervisorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHypervisorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisors = output.hypervisors
            self.nextToken = output.nextToken
        } else {
            self.hypervisors = nil
            self.nextToken = nil
        }
    }
}

public struct ListHypervisorsOutput: Swift.Equatable {
    /// A list of your Hypervisor objects, ordered by their Amazon Resource Names (ARNs).
    public var hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisors: [BackupGatewayClientTypes.Hypervisor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisors = hypervisors
        self.nextToken = nextToken
    }
}

struct ListHypervisorsOutputBody: Swift.Equatable {
    let hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    let nextToken: Swift.String?
}

extension ListHypervisorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisors = "Hypervisors"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Hypervisor?].self, forKey: .hypervisors)
        var hypervisorsDecoded0:[BackupGatewayClientTypes.Hypervisor]? = nil
        if let hypervisorsContainer = hypervisorsContainer {
            hypervisorsDecoded0 = [BackupGatewayClientTypes.Hypervisor]()
            for structure0 in hypervisorsContainer {
                if let structure0 = structure0 {
                    hypervisorsDecoded0?.append(structure0)
                }
            }
        }
        hypervisors = hypervisorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHypervisorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource's tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource's tags that you listed.
    public var resourceArn: Swift.String?
    /// A list of the resource's tags.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVirtualMachinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListVirtualMachinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVirtualMachinesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor connected to your virtual machine.
    public var hypervisorArn: Swift.String?
    /// The maximum number of virtual machines to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVirtualMachinesInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVirtualMachinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualMachinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVirtualMachinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualMachines = output.virtualMachines
        } else {
            self.nextToken = nil
            self.virtualMachines = nil
        }
    }
}

public struct ListVirtualMachinesOutput: Swift.Equatable {
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// A list of your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public var virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?

    public init(
        nextToken: Swift.String? = nil,
        virtualMachines: [BackupGatewayClientTypes.VirtualMachine]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualMachines = virtualMachines
    }
}

struct ListVirtualMachinesOutputBody: Swift.Equatable {
    let virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?
    let nextToken: Swift.String?
}

extension ListVirtualMachinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case virtualMachines = "VirtualMachines"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualMachinesContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VirtualMachine?].self, forKey: .virtualMachines)
        var virtualMachinesDecoded0:[BackupGatewayClientTypes.VirtualMachine]? = nil
        if let virtualMachinesContainer = virtualMachinesContainer {
            virtualMachinesDecoded0 = [BackupGatewayClientTypes.VirtualMachine]()
            for structure0 in virtualMachinesContainer {
                if let structure0 = structure0 {
                    virtualMachinesDecoded0?.append(structure0)
                }
            }
        }
        virtualMachines = virtualMachinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVirtualMachinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupGatewayClientTypes.MaintenanceStartTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let hourOfDay = self.hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = self.minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
    }
}

extension BackupGatewayClientTypes {
    /// This is your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
    public struct MaintenanceStartTime: Swift.Equatable {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        public var dayOfMonth: Swift.Int?
        /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
        public var dayOfWeek: Swift.Int?
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        /// This member is required.
        public var hourOfDay: Swift.Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
        /// This member is required.
        public var minuteOfHour: Swift.Int?

        public init(
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: Swift.Int? = nil,
            hourOfDay: Swift.Int? = nil,
            minuteOfHour: Swift.Int? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension PutBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthRateLimitIntervals = bandwidthRateLimitIntervals {
            var bandwidthRateLimitIntervalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandwidthRateLimitIntervals)
            for bandwidthratelimitinterval0 in bandwidthRateLimitIntervals {
                try bandwidthRateLimitIntervalsContainer.encode(bandwidthratelimitinterval0)
            }
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension PutBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

struct PutBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension PutBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BackupGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension PutBandwidthRateLimitScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutBandwidthRateLimitScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct PutBandwidthRateLimitScheduleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct PutBandwidthRateLimitScheduleOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension PutBandwidthRateLimitScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum PutBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutHypervisorPropertyMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let vmwareToAwsTagMappings = vmwareToAwsTagMappings {
            var vmwareToAwsTagMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmwareToAwsTagMappings)
            for vmwaretoawstagmapping0 in vmwareToAwsTagMappings {
                try vmwareToAwsTagMappingsContainer.encode(vmwaretoawstagmapping0)
            }
        }
    }
}

extension PutHypervisorPropertyMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutHypervisorPropertyMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// This action requests the mappings of on-premises VMware tags to the Amazon Web Services tags.
    /// This member is required.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

struct PutHypervisorPropertyMappingsInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?
    let iamRoleArn: Swift.String?
}

extension PutHypervisorPropertyMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
        case iamRoleArn = "IamRoleArn"
        case vmwareToAwsTagMappings = "VmwareToAwsTagMappings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let vmwareToAwsTagMappingsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareToAwsTagMapping?].self, forKey: .vmwareToAwsTagMappings)
        var vmwareToAwsTagMappingsDecoded0:[BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
        if let vmwareToAwsTagMappingsContainer = vmwareToAwsTagMappingsContainer {
            vmwareToAwsTagMappingsDecoded0 = [BackupGatewayClientTypes.VmwareToAwsTagMapping]()
            for structure0 in vmwareToAwsTagMappingsContainer {
                if let structure0 = structure0 {
                    vmwareToAwsTagMappingsDecoded0?.append(structure0)
                }
            }
        }
        vmwareToAwsTagMappings = vmwareToAwsTagMappingsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension PutHypervisorPropertyMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutHypervisorPropertyMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct PutHypervisorPropertyMappingsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct PutHypervisorPropertyMappingsOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension PutHypervisorPropertyMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

enum PutHypervisorPropertyMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMaintenanceStartTimeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayArn = "GatewayArn"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let hourOfDay = self.hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = self.minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }
}

extension PutMaintenanceStartTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMaintenanceStartTimeInput: Swift.Equatable {
    /// The day of the month start maintenance on a gateway. Valid values range from Sunday to Saturday.
    public var dayOfMonth: Swift.Int?
    /// The day of the week to start maintenance on a gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) for the gateway, used to specify its maintenance start time.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The hour of the day to start maintenance on a gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute of the hour to start maintenance on a gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init(
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayArn: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayArn = gatewayArn
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

struct PutMaintenanceStartTimeInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let hourOfDay: Swift.Int?
    let minuteOfHour: Swift.Int?
    let dayOfWeek: Swift.Int?
    let dayOfMonth: Swift.Int?
}

extension PutMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayArn = "GatewayArn"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension PutMaintenanceStartTimeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutMaintenanceStartTimeOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct PutMaintenanceStartTimeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a gateway for which you set the maintenance start time.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct PutMaintenanceStartTimeOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension PutMaintenanceStartTimeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum PutMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource that is required for the action wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which resource wasn't found.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartVirtualMachinesMetadataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
    }
}

extension StartVirtualMachinesMetadataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartVirtualMachinesMetadataSyncInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct StartVirtualMachinesMetadataSyncInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension StartVirtualMachinesMetadataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

extension StartVirtualMachinesMetadataSyncOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVirtualMachinesMetadataSyncOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct StartVirtualMachinesMetadataSyncOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct StartVirtualMachinesMetadataSyncOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension StartVirtualMachinesMetadataSyncOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

enum StartVirtualMachinesMetadataSyncOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupGatewayClientTypes {
    public enum SyncMetadataStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case partiallyFailed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncMetadataStatus] {
            return [
                .created,
                .failed,
                .partiallyFailed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partiallyFailed: return "PARTIALLY_FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncMetadataStatus(rawValue: rawValue) ?? SyncMetadataStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupGatewayClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// The key part of a tag's key-value pair. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// The value part of a tag's key-value pair.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to assign to the resource.
    /// This member is required.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [BackupGatewayClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BackupGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BackupGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

public struct TagResourceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you tagged.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct TagResourceOutputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension TagResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestHypervisorConfigurationInput(gatewayArn: \(Swift.String(describing: gatewayArn)), host: \(Swift.String(describing: host)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension TestHypervisorConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case host = "Host"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension TestHypervisorConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestHypervisorConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to the hypervisor to test.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        host: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.host = host
        self.password = password
        self.username = username
    }
}

struct TestHypervisorConfigurationInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
}

extension TestHypervisorConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case host = "Host"
        case password = "Password"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension TestHypervisorConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TestHypervisorConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum TestHypervisorConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// TPS has been limited to protect against intentional or unintentional high request volumes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error: TPS has been limited to protect against intentional or unintentional high request volumes.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys specifying which tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UntagResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

public struct UntagResourceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you removed tags.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct UntagResourceOutputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension UntagResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewayInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayDisplayName = self.gatewayDisplayName {
            try encodeContainer.encode(gatewayDisplayName, forKey: .gatewayDisplayName)
        }
    }
}

extension UpdateGatewayInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated display name of the gateway.
    public var gatewayDisplayName: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayDisplayName = gatewayDisplayName
    }
}

struct UpdateGatewayInformationInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let gatewayDisplayName: Swift.String?
}

extension UpdateGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
        case gatewayDisplayName = "GatewayDisplayName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayDisplayName)
        gatewayDisplayName = gatewayDisplayNameDecoded
    }
}

extension UpdateGatewayInformationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGatewayInformationOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct UpdateGatewayInformationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewayInformationOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewayInformationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum UpdateGatewayInformationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewaySoftwareNowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension UpdateGatewaySoftwareNowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewaySoftwareNowInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway to be updated.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewaySoftwareNowInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewaySoftwareNowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension UpdateGatewaySoftwareNowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGatewaySoftwareNowOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct UpdateGatewaySoftwareNowOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct UpdateGatewaySoftwareNowOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension UpdateGatewaySoftwareNowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum UpdateGatewaySoftwareNowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateHypervisorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHypervisorInput(host: \(Swift.String(describing: host)), hypervisorArn: \(Swift.String(describing: hypervisorArn)), logGroupArn: \(Swift.String(describing: logGroupArn)), name: \(Swift.String(describing: name)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension UpdateHypervisorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let hypervisorArn = self.hypervisorArn {
            try encodeContainer.encode(hypervisorArn, forKey: .hypervisorArn)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension UpdateHypervisorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateHypervisorInput: Swift.Equatable {
    /// The updated host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    public var host: Swift.String?
    /// The Amazon Resource Name (ARN) of the hypervisor to update.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
    public var logGroupArn: Swift.String?
    /// The updated name for the hypervisor
    public var name: Swift.String?
    /// The updated password for the hypervisor.
    public var password: Swift.String?
    /// The updated username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        hypervisorArn: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.hypervisorArn = hypervisorArn
        self.logGroupArn = logGroupArn
        self.name = name
        self.password = password
        self.username = username
    }
}

struct UpdateHypervisorInputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
    let host: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let name: Swift.String?
    let logGroupArn: Swift.String?
}

extension UpdateHypervisorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case hypervisorArn = "HypervisorArn"
        case logGroupArn = "LogGroupArn"
        case name = "Name"
        case password = "Password"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension UpdateHypervisorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateHypervisorOutputBody = try responseDecoder.decode(responseBody: data)
            self.hypervisorArn = output.hypervisorArn
        } else {
            self.hypervisorArn = nil
        }
    }
}

public struct UpdateHypervisorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hypervisor you updated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

struct UpdateHypervisorOutputBody: Swift.Equatable {
    let hypervisorArn: Swift.String?
}

extension UpdateHypervisorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hypervisorArn = "HypervisorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hypervisorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorArn)
        hypervisorArn = hypervisorArnDecoded
    }
}

enum UpdateHypervisorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await BackupGatewayClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because a validation error occurred.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of what caused the validation error.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupGatewayClientTypes.VirtualMachine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case hypervisorId = "HypervisorId"
        case lastBackupDate = "LastBackupDate"
        case name = "Name"
        case path = "Path"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastBackupDate = self.lastBackupDate {
            try encodeContainer.encodeTimestamp(lastBackupDate, format: .epochSeconds, forKey: .lastBackupDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let lastBackupDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupDate)
        lastBackupDate = lastBackupDateDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A virtual machine that is on a hypervisor.
    public struct VirtualMachine: Swift.Equatable {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: ClientRuntime.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
        }
    }

}

extension BackupGatewayClientTypes.VirtualMachineDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName = "HostName"
        case hypervisorId = "HypervisorId"
        case lastBackupDate = "LastBackupDate"
        case name = "Name"
        case path = "Path"
        case resourceArn = "ResourceArn"
        case vmwareTags = "VmwareTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hypervisorId = self.hypervisorId {
            try encodeContainer.encode(hypervisorId, forKey: .hypervisorId)
        }
        if let lastBackupDate = self.lastBackupDate {
            try encodeContainer.encodeTimestamp(lastBackupDate, format: .epochSeconds, forKey: .lastBackupDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let vmwareTags = vmwareTags {
            var vmwareTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmwareTags)
            for vmwaretag0 in vmwareTags {
                try vmwareTagsContainer.encode(vmwaretag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hypervisorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hypervisorId)
        hypervisorId = hypervisorIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let lastBackupDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastBackupDate)
        lastBackupDate = lastBackupDateDecoded
        let vmwareTagsContainer = try containerValues.decodeIfPresent([BackupGatewayClientTypes.VmwareTag?].self, forKey: .vmwareTags)
        var vmwareTagsDecoded0:[BackupGatewayClientTypes.VmwareTag]? = nil
        if let vmwareTagsContainer = vmwareTagsContainer {
            vmwareTagsDecoded0 = [BackupGatewayClientTypes.VmwareTag]()
            for structure0 in vmwareTagsContainer {
                if let structure0 = structure0 {
                    vmwareTagsDecoded0?.append(structure0)
                }
            }
        }
        vmwareTags = vmwareTagsDecoded0
    }
}

extension BackupGatewayClientTypes {
    /// Your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public struct VirtualMachineDetails: Swift.Equatable {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: ClientRuntime.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?
        /// These are the details of the VMware tags associated with the specified virtual machine.
        public var vmwareTags: [BackupGatewayClientTypes.VmwareTag]?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            vmwareTags: [BackupGatewayClientTypes.VmwareTag]? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
            self.vmwareTags = vmwareTags
        }
    }

}

extension BackupGatewayClientTypes.VmwareTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vmwareCategory = "VmwareCategory"
        case vmwareTagDescription = "VmwareTagDescription"
        case vmwareTagName = "VmwareTagName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmwareCategory = self.vmwareCategory {
            try encodeContainer.encode(vmwareCategory, forKey: .vmwareCategory)
        }
        if let vmwareTagDescription = self.vmwareTagDescription {
            try encodeContainer.encode(vmwareTagDescription, forKey: .vmwareTagDescription)
        }
        if let vmwareTagName = self.vmwareTagName {
            try encodeContainer.encode(vmwareTagName, forKey: .vmwareTagName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmwareCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareCategory)
        vmwareCategory = vmwareCategoryDecoded
        let vmwareTagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagName)
        vmwareTagName = vmwareTagNameDecoded
        let vmwareTagDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagDescription)
        vmwareTagDescription = vmwareTagDescriptionDecoded
    }
}

extension BackupGatewayClientTypes {
    /// A VMware tag is a tag attached to a specific virtual machine. A [tag](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_Tag.html) is a key-value pair you can use to manage, filter, and search for your resources. The content of VMware tags can be matched to Amazon Web Services tags.
    public struct VmwareTag: Swift.Equatable {
        /// The is the category of VMware.
        public var vmwareCategory: Swift.String?
        /// This is a user-defined description of a VMware tag.
        public var vmwareTagDescription: Swift.String?
        /// This is the user-defined name of a VMware tag.
        public var vmwareTagName: Swift.String?

        public init(
            vmwareCategory: Swift.String? = nil,
            vmwareTagDescription: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.vmwareCategory = vmwareCategory
            self.vmwareTagDescription = vmwareTagDescription
            self.vmwareTagName = vmwareTagName
        }
    }

}

extension BackupGatewayClientTypes.VmwareToAwsTagMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsTagKey = "AwsTagKey"
        case awsTagValue = "AwsTagValue"
        case vmwareCategory = "VmwareCategory"
        case vmwareTagName = "VmwareTagName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsTagKey = self.awsTagKey {
            try encodeContainer.encode(awsTagKey, forKey: .awsTagKey)
        }
        if let awsTagValue = self.awsTagValue {
            try encodeContainer.encode(awsTagValue, forKey: .awsTagValue)
        }
        if let vmwareCategory = self.vmwareCategory {
            try encodeContainer.encode(vmwareCategory, forKey: .vmwareCategory)
        }
        if let vmwareTagName = self.vmwareTagName {
            try encodeContainer.encode(vmwareTagName, forKey: .vmwareTagName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmwareCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareCategory)
        vmwareCategory = vmwareCategoryDecoded
        let vmwareTagNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmwareTagName)
        vmwareTagName = vmwareTagNameDecoded
        let awsTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsTagKey)
        awsTagKey = awsTagKeyDecoded
        let awsTagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsTagValue)
        awsTagValue = awsTagValueDecoded
    }
}

extension BackupGatewayClientTypes {
    /// This displays the mapping of on-premises VMware tags to the corresponding Amazon Web Services tags.
    public struct VmwareToAwsTagMapping: Swift.Equatable {
        /// The key part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagKey: Swift.String?
        /// The value part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagValue: Swift.String?
        /// The is the category of VMware.
        /// This member is required.
        public var vmwareCategory: Swift.String?
        /// This is the user-defined name of a VMware tag.
        /// This member is required.
        public var vmwareTagName: Swift.String?

        public init(
            awsTagKey: Swift.String? = nil,
            awsTagValue: Swift.String? = nil,
            vmwareCategory: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.awsTagKey = awsTagKey
            self.awsTagValue = awsTagValue
            self.vmwareCategory = vmwareCategory
            self.vmwareTagName = vmwareTagName
        }
    }

}
