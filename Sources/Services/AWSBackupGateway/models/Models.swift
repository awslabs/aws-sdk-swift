// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import Foundation
import SmithyHTTPAPI
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation cannot proceed because you have insufficient permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why you have insufficient permissions.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension AssociateGatewayToServerInput {

    static func urlPathProvider(_ value: AssociateGatewayToServerInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateGatewayToServerInput {

    static func write(value: AssociateGatewayToServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["ServerArn"].write(value.serverArn)
    }
}

public struct AssociateGatewayToServerInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the server that hosts your virtual machines.
    /// This member is required.
    public var serverArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        serverArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.serverArn = serverArn
    }
}

extension AssociateGatewayToServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> AssociateGatewayToServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateGatewayToServerOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct AssociateGatewayToServerOutput {
    /// The Amazon Resource Name (ARN) of a gateway.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum AssociateGatewayToServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

public enum BackupGatewayClientTypes {}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

extension BackupGatewayClientTypes.BandwidthRateLimitInterval {

    static func write(value: BackupGatewayClientTypes.BandwidthRateLimitInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageUploadRateLimitInBitsPerSec"].write(value.averageUploadRateLimitInBitsPerSec)
        try writer["DaysOfWeek"].writeList(value.daysOfWeek, memberWritingClosure: Swift.Int.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndHourOfDay"].write(value.endHourOfDay)
        try writer["EndMinuteOfHour"].write(value.endMinuteOfHour)
        try writer["StartHourOfDay"].write(value.startHourOfDay)
        try writer["StartMinuteOfHour"].write(value.startMinuteOfHour)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.BandwidthRateLimitInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.BandwidthRateLimitInterval()
        value.averageUploadRateLimitInBitsPerSec = try reader["AverageUploadRateLimitInBitsPerSec"].readIfPresent()
        value.startHourOfDay = try reader["StartHourOfDay"].readIfPresent()
        value.endHourOfDay = try reader["EndHourOfDay"].readIfPresent()
        value.startMinuteOfHour = try reader["StartMinuteOfHour"].readIfPresent()
        value.endMinuteOfHour = try reader["EndMinuteOfHour"].readIfPresent()
        value.daysOfWeek = try reader["DaysOfWeek"].readListIfPresent(memberReadingClosure: Swift.Int.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval {
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set. For Backup Gateway, the minimum value is (Value).
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init(
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation cannot proceed because it is not supported.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why the operation is not supported.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationKey"].write(value.activationKey)
        try writer["GatewayDisplayName"].write(value.gatewayDisplayName)
        try writer["GatewayType"].write(value.gatewayType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateGatewayInput {
    /// The activation key of the created gateway.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The display name of the created gateway.
    /// This member is required.
    public var gatewayDisplayName: Swift.String?
    /// The type of created gateway.
    /// This member is required.
    public var gatewayType: BackupGatewayClientTypes.GatewayType?
    /// A list of up to 50 tags to assign to the gateway. Each tag is a key-value pair.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        activationKey: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil,
        gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayDisplayName = gatewayDisplayName
        self.gatewayType = gatewayType
        self.tags = tags
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct CreateGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway you create.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGatewayInput {

    static func write(value: DeleteGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct DeleteGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct DeleteGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway you deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteHypervisorInput {

    static func urlPathProvider(_ value: DeleteHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteHypervisorInput {

    static func write(value: DeleteHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

public struct DeleteHypervisorInput {
    /// The Amazon Resource Name (ARN) of the hypervisor to delete.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension DeleteHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DeleteHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteHypervisorOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

public struct DeleteHypervisorOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you deleted.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

enum DeleteHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateGatewayFromServerInput {

    static func urlPathProvider(_ value: DisassociateGatewayFromServerInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateGatewayFromServerInput {

    static func write(value: DisassociateGatewayFromServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct DisassociateGatewayFromServerInput {
    /// The Amazon Resource Name (ARN) of the gateway to disassociate.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension DisassociateGatewayFromServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DisassociateGatewayFromServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateGatewayFromServerOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct DisassociateGatewayFromServerOutput {
    /// The Amazon Resource Name (ARN) of the gateway you disassociated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum DisassociateGatewayFromServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BackupGatewayClientTypes.Gateway {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Gateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Gateway()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        value.gatewayDisplayName = try reader["GatewayDisplayName"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.lastSeenTime = try reader["LastSeenTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension BackupGatewayClientTypes {
    /// A gateway is an Backup Gateway appliance that runs on the customer's network to provide seamless connectivity to backup storage in the Amazon Web Services Cloud.
    public struct Gateway {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// The last time Backup gateway communicated with the gateway, in Unix format and UTC time.
        public var lastSeenTime: Foundation.Date?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: Foundation.Date? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
        }
    }

}

extension BackupGatewayClientTypes.GatewayDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.GatewayDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.GatewayDetails()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        value.gatewayDisplayName = try reader["GatewayDisplayName"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.lastSeenTime = try reader["LastSeenTime"].readTimestampIfPresent(format: .epochSeconds)
        value.maintenanceStartTime = try reader["MaintenanceStartTime"].readIfPresent(with: BackupGatewayClientTypes.MaintenanceStartTime.read(from:))
        value.nextUpdateAvailabilityTime = try reader["NextUpdateAvailabilityTime"].readTimestampIfPresent(format: .epochSeconds)
        value.vpcEndpoint = try reader["VpcEndpoint"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// The details of gateway.
    public struct GatewayDetails {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway type.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// Details showing the last time Backup gateway communicated with the cloud, in Unix format and UTC time.
        public var lastSeenTime: Foundation.Date?
        /// Returns your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
        public var maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime?
        /// Details showing the next update availability time of the gateway.
        public var nextUpdateAvailabilityTime: Foundation.Date?
        /// The DNS name for the virtual private cloud (VPC) endpoint the gateway uses to connect to the cloud for backup gateway.
        public var vpcEndpoint: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: Foundation.Date? = nil,
            maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime? = nil,
            nextUpdateAvailabilityTime: Foundation.Date? = nil,
            vpcEndpoint: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
            self.maintenanceStartTime = maintenanceStartTime
            self.nextUpdateAvailabilityTime = nextUpdateAvailabilityTime
            self.vpcEndpoint = vpcEndpoint
        }
    }

}

extension BackupGatewayClientTypes {

    public enum GatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backupVm
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .backupVm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backupVm: return "BACKUP_VM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: GetBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension GetBandwidthRateLimitScheduleInput {

    static func write(value: GetBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct GetBandwidthRateLimitScheduleInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension GetBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBandwidthRateLimitScheduleOutput()
        value.bandwidthRateLimitIntervals = try reader["BandwidthRateLimitIntervals"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.BandwidthRateLimitInterval.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct GetBandwidthRateLimitScheduleOutput {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

enum GetBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGatewayInput {

    static func urlPathProvider(_ value: GetGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension GetGatewayInput {

    static func write(value: GetGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct GetGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension GetGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayOutput()
        value.gateway = try reader["Gateway"].readIfPresent(with: BackupGatewayClientTypes.GatewayDetails.read(from:))
        return value
    }
}

public struct GetGatewayOutput {
    /// By providing the ARN (Amazon Resource Name), this API returns the gateway.
    public var gateway: BackupGatewayClientTypes.GatewayDetails?

    public init(
        gateway: BackupGatewayClientTypes.GatewayDetails? = nil
    )
    {
        self.gateway = gateway
    }
}

enum GetGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetHypervisorInput {

    static func urlPathProvider(_ value: GetHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension GetHypervisorInput {

    static func write(value: GetHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

public struct GetHypervisorInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension GetHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHypervisorOutput()
        value.hypervisor = try reader["Hypervisor"].readIfPresent(with: BackupGatewayClientTypes.HypervisorDetails.read(from:))
        return value
    }
}

public struct GetHypervisorOutput {
    /// Details about the requested hypervisor.
    public var hypervisor: BackupGatewayClientTypes.HypervisorDetails?

    public init(
        hypervisor: BackupGatewayClientTypes.HypervisorDetails? = nil
    )
    {
        self.hypervisor = hypervisor
    }
}

enum GetHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetHypervisorPropertyMappingsInput {

    static func urlPathProvider(_ value: GetHypervisorPropertyMappingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetHypervisorPropertyMappingsInput {

    static func write(value: GetHypervisorPropertyMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

public struct GetHypervisorPropertyMappingsInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension GetHypervisorPropertyMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetHypervisorPropertyMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHypervisorPropertyMappingsOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.vmwareToAwsTagMappings = try reader["VmwareToAwsTagMappings"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VmwareToAwsTagMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetHypervisorPropertyMappingsOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    public var iamRoleArn: Swift.String?
    /// This is a display of the mappings of on-premises VMware tags to the Amazon Web Services tags.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

enum GetHypervisorPropertyMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetVirtualMachineInput {

    static func urlPathProvider(_ value: GetVirtualMachineInput) -> Swift.String? {
        return "/"
    }
}

extension GetVirtualMachineInput {

    static func write(value: GetVirtualMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

public struct GetVirtualMachineInput {
    /// The Amazon Resource Name (ARN) of the virtual machine.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension GetVirtualMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetVirtualMachineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVirtualMachineOutput()
        value.virtualMachine = try reader["VirtualMachine"].readIfPresent(with: BackupGatewayClientTypes.VirtualMachineDetails.read(from:))
        return value
    }
}

public struct GetVirtualMachineOutput {
    /// This object contains the basic attributes of VirtualMachine contained by the output of GetVirtualMachine
    public var virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?

    public init(
        virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails? = nil
    )
    {
        self.virtualMachine = virtualMachine
    }
}

enum GetVirtualMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BackupGatewayClientTypes.Hypervisor {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Hypervisor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Hypervisor()
        value.host = try reader["Host"].readIfPresent()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// Represents the hypervisor's permissions to which the gateway will connect. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct Hypervisor {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// The name of the hypervisor.
        public var name: Swift.String?
        /// The state of the hypervisor.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes.HypervisorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.HypervisorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.HypervisorDetails()
        value.host = try reader["Host"].readIfPresent()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.lastSuccessfulMetadataSyncTime = try reader["LastSuccessfulMetadataSyncTime"].readTimestampIfPresent(format: .epochSeconds)
        value.latestMetadataSyncStatusMessage = try reader["LatestMetadataSyncStatusMessage"].readIfPresent()
        value.latestMetadataSyncStatus = try reader["LatestMetadataSyncStatus"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// These are the details of the specified hypervisor. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct HypervisorDetails {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// This is the time when the most recent successful sync of metadata occurred.
        public var lastSuccessfulMetadataSyncTime: Foundation.Date?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatusMessage: Swift.String?
        /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
        public var logGroupArn: Swift.String?
        /// This is the name of the specified hypervisor.
        public var name: Swift.String?
        /// This is the current state of the specified hypervisor. The possible states are PENDING, ONLINE, OFFLINE, or ERROR.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastSuccessfulMetadataSyncTime: Foundation.Date? = nil,
            latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus? = nil,
            latestMetadataSyncStatusMessage: Swift.String? = nil,
            logGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTime
            self.latestMetadataSyncStatus = latestMetadataSyncStatus
            self.latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessage
            self.logGroupArn = logGroupArn
            self.name = name
            self.state = state
        }
    }

}

extension BackupGatewayClientTypes {

    public enum HypervisorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case offline
        case online
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [HypervisorState] {
            return [
                .error,
                .offline,
                .online,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImportHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHypervisorConfigurationInput(host: \(Swift.String(describing: host)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ImportHypervisorConfigurationInput {

    static func urlPathProvider(_ value: ImportHypervisorConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ImportHypervisorConfigurationInput {

    static func write(value: ImportHypervisorConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["Name"].write(value.name)
        try writer["Password"].write(value.password)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Username"].write(value.username)
    }
}

public struct ImportHypervisorConfigurationInput {
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The Key Management Service for the hypervisor.
    public var kmsKeyArn: Swift.String?
    /// The name of the hypervisor.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The tags of the hypervisor configuration to import.
    public var tags: [BackupGatewayClientTypes.Tag]?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.password = password
        self.tags = tags
        self.username = username
    }
}

extension ImportHypervisorConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ImportHypervisorConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportHypervisorConfigurationOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

public struct ImportHypervisorConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you disassociated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

enum ImportHypervisorConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation did not succeed because an internal error occurred. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which internal error occured.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension ListGatewaysInput {

    static func write(value: ListGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListGatewaysInput {
    /// The maximum number of gateways to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["Gateways"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Gateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGatewaysOutput {
    /// A list of your gateways.
    public var gateways: [BackupGatewayClientTypes.Gateway]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        gateways: [BackupGatewayClientTypes.Gateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListHypervisorsInput {

    static func urlPathProvider(_ value: ListHypervisorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListHypervisorsInput {

    static func write(value: ListHypervisorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListHypervisorsInput {
    /// The maximum number of hypervisors to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListHypervisorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListHypervisorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHypervisorsOutput()
        value.hypervisors = try reader["Hypervisors"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Hypervisor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListHypervisorsOutput {
    /// A list of your Hypervisor objects, ordered by their Amazon Resource Names (ARNs).
    public var hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisors: [BackupGatewayClientTypes.Hypervisor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisors = hypervisors
        self.nextToken = nextToken
    }
}

enum ListHypervisorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource's tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource's tags that you listed.
    public var resourceArn: Swift.String?
    /// A list of the resource's tags.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListVirtualMachinesInput {

    static func urlPathProvider(_ value: ListVirtualMachinesInput) -> Swift.String? {
        return "/"
    }
}

extension ListVirtualMachinesInput {

    static func write(value: ListVirtualMachinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListVirtualMachinesInput {
    /// The Amazon Resource Name (ARN) of the hypervisor connected to your virtual machine.
    public var hypervisorArn: Swift.String?
    /// The maximum number of virtual machines to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListVirtualMachinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListVirtualMachinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualMachinesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.virtualMachines = try reader["VirtualMachines"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VirtualMachine.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListVirtualMachinesOutput {
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// A list of your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public var virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?

    public init(
        nextToken: Swift.String? = nil,
        virtualMachines: [BackupGatewayClientTypes.VirtualMachine]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualMachines = virtualMachines
    }
}

enum ListVirtualMachinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BackupGatewayClientTypes.MaintenanceStartTime {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.MaintenanceStartTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.MaintenanceStartTime()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.hourOfDay = try reader["HourOfDay"].readIfPresent()
        value.minuteOfHour = try reader["MinuteOfHour"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// This is your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
    public struct MaintenanceStartTime {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        public var dayOfMonth: Swift.Int?
        /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
        public var dayOfWeek: Swift.Int?
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        /// This member is required.
        public var hourOfDay: Swift.Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
        /// This member is required.
        public var minuteOfHour: Swift.Int?

        public init(
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: Swift.Int? = nil,
            hourOfDay: Swift.Int? = nil,
            minuteOfHour: Swift.Int? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension PutBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: PutBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension PutBandwidthRateLimitScheduleInput {

    static func write(value: PutBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthRateLimitIntervals"].writeList(value.bandwidthRateLimitIntervals, memberWritingClosure: BackupGatewayClientTypes.BandwidthRateLimitInterval.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct PutBandwidthRateLimitScheduleInput {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

extension PutBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> PutBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutBandwidthRateLimitScheduleOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct PutBandwidthRateLimitScheduleOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum PutBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutHypervisorPropertyMappingsInput {

    static func urlPathProvider(_ value: PutHypervisorPropertyMappingsInput) -> Swift.String? {
        return "/"
    }
}

extension PutHypervisorPropertyMappingsInput {

    static func write(value: PutHypervisorPropertyMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["VmwareToAwsTagMappings"].writeList(value.vmwareToAwsTagMappings, memberWritingClosure: BackupGatewayClientTypes.VmwareToAwsTagMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct PutHypervisorPropertyMappingsInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// This action requests the mappings of on-premises VMware tags to the Amazon Web Services tags.
    /// This member is required.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

extension PutHypervisorPropertyMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> PutHypervisorPropertyMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutHypervisorPropertyMappingsOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

public struct PutHypervisorPropertyMappingsOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

enum PutHypervisorPropertyMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutMaintenanceStartTimeInput {

    static func urlPathProvider(_ value: PutMaintenanceStartTimeInput) -> Swift.String? {
        return "/"
    }
}

extension PutMaintenanceStartTimeInput {

    static func write(value: PutMaintenanceStartTimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["HourOfDay"].write(value.hourOfDay)
        try writer["MinuteOfHour"].write(value.minuteOfHour)
    }
}

public struct PutMaintenanceStartTimeInput {
    /// The day of the month start maintenance on a gateway. Valid values range from Sunday to Saturday.
    public var dayOfMonth: Swift.Int?
    /// The day of the week to start maintenance on a gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) for the gateway, used to specify its maintenance start time.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The hour of the day to start maintenance on a gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute of the hour to start maintenance on a gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init(
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayArn: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayArn = gatewayArn
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

extension PutMaintenanceStartTimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> PutMaintenanceStartTimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutMaintenanceStartTimeOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct PutMaintenanceStartTimeOutput {
    /// The Amazon Resource Name (ARN) of a gateway for which you set the maintenance start time.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum PutMaintenanceStartTimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A resource that is required for the action wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which resource wasn't found.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension StartVirtualMachinesMetadataSyncInput {

    static func urlPathProvider(_ value: StartVirtualMachinesMetadataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension StartVirtualMachinesMetadataSyncInput {

    static func write(value: StartVirtualMachinesMetadataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

public struct StartVirtualMachinesMetadataSyncInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension StartVirtualMachinesMetadataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> StartVirtualMachinesMetadataSyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartVirtualMachinesMetadataSyncOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

public struct StartVirtualMachinesMetadataSyncOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

enum StartVirtualMachinesMetadataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BackupGatewayClientTypes {

    public enum SyncMetadataStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case partiallyFailed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncMetadataStatus] {
            return [
                .created,
                .failed,
                .partiallyFailed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partiallyFailed: return "PARTIALLY_FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupGatewayClientTypes.Tag {

    static func write(value: BackupGatewayClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// A key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public struct Tag {
        /// The key part of a tag's key-value pair. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// The value part of a tag's key-value pair.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to assign to the resource.
    /// This member is required.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> TagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

public struct TagResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource you tagged.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TestHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestHypervisorConfigurationInput(gatewayArn: \(Swift.String(describing: gatewayArn)), host: \(Swift.String(describing: host)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension TestHypervisorConfigurationInput {

    static func urlPathProvider(_ value: TestHypervisorConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension TestHypervisorConfigurationInput {

    static func write(value: TestHypervisorConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["Host"].write(value.host)
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

public struct TestHypervisorConfigurationInput {
    /// The Amazon Resource Name (ARN) of the gateway to the hypervisor to test.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        host: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.host = host
        self.password = password
        self.username = username
    }
}

extension TestHypervisorConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> TestHypervisorConfigurationOutput {
        return TestHypervisorConfigurationOutput()
    }
}

public struct TestHypervisorConfigurationOutput {

    public init() { }
}

enum TestHypervisorConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// TPS has been limited to protect against intentional or unintentional high request volumes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error: TPS has been limited to protect against intentional or unintentional high request volumes.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys specifying which tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UntagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UntagResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

public struct UntagResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource from which you removed tags.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGatewayInformationInput {

    static func urlPathProvider(_ value: UpdateGatewayInformationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewayInformationInput {

    static func write(value: UpdateGatewayInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["GatewayDisplayName"].write(value.gatewayDisplayName)
    }
}

public struct UpdateGatewayInformationInput {
    /// The Amazon Resource Name (ARN) of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated display name of the gateway.
    public var gatewayDisplayName: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayDisplayName = gatewayDisplayName
    }
}

extension UpdateGatewayInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateGatewayInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayInformationOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct UpdateGatewayInformationOutput {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum UpdateGatewayInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func urlPathProvider(_ value: UpdateGatewaySoftwareNowInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func write(value: UpdateGatewaySoftwareNowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct UpdateGatewaySoftwareNowInput {
    /// The Amazon Resource Name (ARN) of the gateway to be updated.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension UpdateGatewaySoftwareNowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateGatewaySoftwareNowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewaySoftwareNowOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

public struct UpdateGatewaySoftwareNowOutput {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

enum UpdateGatewaySoftwareNowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateHypervisorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHypervisorInput(host: \(Swift.String(describing: host)), hypervisorArn: \(Swift.String(describing: hypervisorArn)), logGroupArn: \(Swift.String(describing: logGroupArn)), name: \(Swift.String(describing: name)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension UpdateHypervisorInput {

    static func urlPathProvider(_ value: UpdateHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateHypervisorInput {

    static func write(value: UpdateHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["LogGroupArn"].write(value.logGroupArn)
        try writer["Name"].write(value.name)
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

public struct UpdateHypervisorInput {
    /// The updated host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    public var host: Swift.String?
    /// The Amazon Resource Name (ARN) of the hypervisor to update.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
    public var logGroupArn: Swift.String?
    /// The updated name for the hypervisor
    public var name: Swift.String?
    /// The updated password for the hypervisor.
    public var password: Swift.String?
    /// The updated username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        hypervisorArn: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.hypervisorArn = hypervisorArn
        self.logGroupArn = logGroupArn
        self.name = name
        self.password = password
        self.username = username
    }
}

extension UpdateHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateHypervisorOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

public struct UpdateHypervisorOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you updated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

enum UpdateHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation did not succeed because a validation error occurred.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of what caused the validation error.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension BackupGatewayClientTypes.VirtualMachine {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VirtualMachine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VirtualMachine()
        value.hostName = try reader["HostName"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.lastBackupDate = try reader["LastBackupDate"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension BackupGatewayClientTypes {
    /// A virtual machine that is on a hypervisor.
    public struct VirtualMachine {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: Foundation.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
        }
    }

}

extension BackupGatewayClientTypes.VirtualMachineDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VirtualMachineDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VirtualMachineDetails()
        value.hostName = try reader["HostName"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.lastBackupDate = try reader["LastBackupDate"].readTimestampIfPresent(format: .epochSeconds)
        value.vmwareTags = try reader["VmwareTags"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VmwareTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupGatewayClientTypes {
    /// Your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public struct VirtualMachineDetails {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: Foundation.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?
        /// These are the details of the VMware tags associated with the specified virtual machine.
        public var vmwareTags: [BackupGatewayClientTypes.VmwareTag]?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            vmwareTags: [BackupGatewayClientTypes.VmwareTag]? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
            self.vmwareTags = vmwareTags
        }
    }

}

extension BackupGatewayClientTypes.VmwareTag {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VmwareTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VmwareTag()
        value.vmwareCategory = try reader["VmwareCategory"].readIfPresent()
        value.vmwareTagName = try reader["VmwareTagName"].readIfPresent()
        value.vmwareTagDescription = try reader["VmwareTagDescription"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// A VMware tag is a tag attached to a specific virtual machine. A [tag](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_Tag.html) is a key-value pair you can use to manage, filter, and search for your resources. The content of VMware tags can be matched to Amazon Web Services tags.
    public struct VmwareTag {
        /// The is the category of VMware.
        public var vmwareCategory: Swift.String?
        /// This is a user-defined description of a VMware tag.
        public var vmwareTagDescription: Swift.String?
        /// This is the user-defined name of a VMware tag.
        public var vmwareTagName: Swift.String?

        public init(
            vmwareCategory: Swift.String? = nil,
            vmwareTagDescription: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.vmwareCategory = vmwareCategory
            self.vmwareTagDescription = vmwareTagDescription
            self.vmwareTagName = vmwareTagName
        }
    }

}

extension BackupGatewayClientTypes.VmwareToAwsTagMapping {

    static func write(value: BackupGatewayClientTypes.VmwareToAwsTagMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsTagKey"].write(value.awsTagKey)
        try writer["AwsTagValue"].write(value.awsTagValue)
        try writer["VmwareCategory"].write(value.vmwareCategory)
        try writer["VmwareTagName"].write(value.vmwareTagName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VmwareToAwsTagMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VmwareToAwsTagMapping()
        value.vmwareCategory = try reader["VmwareCategory"].readIfPresent()
        value.vmwareTagName = try reader["VmwareTagName"].readIfPresent()
        value.awsTagKey = try reader["AwsTagKey"].readIfPresent()
        value.awsTagValue = try reader["AwsTagValue"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes {
    /// This displays the mapping of on-premises VMware tags to the corresponding Amazon Web Services tags.
    public struct VmwareToAwsTagMapping {
        /// The key part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagKey: Swift.String?
        /// The value part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagValue: Swift.String?
        /// The is the category of VMware.
        /// This member is required.
        public var vmwareCategory: Swift.String?
        /// This is the user-defined name of a VMware tag.
        /// This member is required.
        public var vmwareTagName: Swift.String?

        public init(
            awsTagKey: Swift.String? = nil,
            awsTagValue: Swift.String? = nil,
            vmwareCategory: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.awsTagKey = awsTagKey
            self.awsTagValue = awsTagValue
            self.vmwareCategory = vmwareCategory
            self.vmwareTagName = vmwareTagName
        }
    }

}
