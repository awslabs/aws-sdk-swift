//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// The operation cannot proceed because you have insufficient permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why you have insufficient permissions.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The operation cannot proceed because it is not supported.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of why the operation is not supported.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct AssociateGatewayToServerInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the server that hosts your virtual machines.
    /// This member is required.
    public var serverArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        serverArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.serverArn = serverArn
    }
}

public struct AssociateGatewayToServerOutput {
    /// The Amazon Resource Name (ARN) of a gateway.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

/// A resource that is required for the action wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which resource wasn't found.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct GetBandwidthRateLimitScheduleInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension BackupGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval {
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set. For Backup Gateway, the minimum value is (Value).
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init(
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

public struct GetBandwidthRateLimitScheduleOutput {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

public struct PutBandwidthRateLimitScheduleInput {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [BackupGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayArn: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayArn = gatewayArn
    }
}

public struct PutBandwidthRateLimitScheduleOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_ListGateways.html) operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension BackupGatewayClientTypes {

    public enum GatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backupVm
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .backupVm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backupVm: return "BACKUP_VM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupGatewayClientTypes {
    /// A key-value pair you can use to manage, filter, and search for your resources. Allowed characters include UTF-8 letters, numbers, spaces, and the following characters: + - = . _ : /.
    public struct Tag {
        /// The key part of a tag's key-value pair. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// The value part of a tag's key-value pair.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateGatewayInput {
    /// The activation key of the created gateway.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The display name of the created gateway.
    /// This member is required.
    public var gatewayDisplayName: Swift.String?
    /// The type of created gateway.
    /// This member is required.
    public var gatewayType: BackupGatewayClientTypes.GatewayType?
    /// A list of up to 50 tags to assign to the gateway. Each tag is a key-value pair.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        activationKey: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil,
        gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayDisplayName = gatewayDisplayName
        self.gatewayType = gatewayType
        self.tags = tags
    }
}

public struct CreateGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway you create.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway you deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DisassociateGatewayFromServerInput {
    /// The Amazon Resource Name (ARN) of the gateway to disassociate.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DisassociateGatewayFromServerOutput {
    /// The Amazon Resource Name (ARN) of the gateway you disassociated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct GetGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension BackupGatewayClientTypes {
    /// This is your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
    public struct MaintenanceStartTime {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        public var dayOfMonth: Swift.Int?
        /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
        public var dayOfWeek: Swift.Int?
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        /// This member is required.
        public var hourOfDay: Swift.Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
        /// This member is required.
        public var minuteOfHour: Swift.Int?

        public init(
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: Swift.Int? = nil,
            hourOfDay: Swift.Int? = nil,
            minuteOfHour: Swift.Int? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension BackupGatewayClientTypes {
    /// The details of gateway.
    public struct GatewayDetails {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway type.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// Details showing the last time Backup gateway communicated with the cloud, in Unix format and UTC time.
        public var lastSeenTime: Foundation.Date?
        /// Returns your gateway's weekly maintenance start time including the day and time of the week. Note that values are in terms of the gateway's time zone. Can be weekly or monthly.
        public var maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime?
        /// Details showing the next update availability time of the gateway.
        public var nextUpdateAvailabilityTime: Foundation.Date?
        /// The DNS name for the virtual private cloud (VPC) endpoint the gateway uses to connect to the cloud for backup gateway.
        public var vpcEndpoint: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: Foundation.Date? = nil,
            maintenanceStartTime: BackupGatewayClientTypes.MaintenanceStartTime? = nil,
            nextUpdateAvailabilityTime: Foundation.Date? = nil,
            vpcEndpoint: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
            self.maintenanceStartTime = maintenanceStartTime
            self.nextUpdateAvailabilityTime = nextUpdateAvailabilityTime
            self.vpcEndpoint = vpcEndpoint
        }
    }

}

public struct GetGatewayOutput {
    /// By providing the ARN (Amazon Resource Name), this API returns the gateway.
    public var gateway: BackupGatewayClientTypes.GatewayDetails?

    public init(
        gateway: BackupGatewayClientTypes.GatewayDetails? = nil
    )
    {
        self.gateway = gateway
    }
}

public struct ListGatewaysInput {
    /// The maximum number of gateways to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupGatewayClientTypes {
    /// A gateway is an Backup Gateway appliance that runs on the customer's network to provide seamless connectivity to backup storage in the Amazon Web Services Cloud.
    public struct Gateway {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayArn: Swift.String?
        /// The display name of the gateway.
        public var gatewayDisplayName: Swift.String?
        /// The type of the gateway.
        public var gatewayType: BackupGatewayClientTypes.GatewayType?
        /// The hypervisor ID of the gateway.
        public var hypervisorId: Swift.String?
        /// The last time Backup gateway communicated with the gateway, in Unix format and UTC time.
        public var lastSeenTime: Foundation.Date?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayDisplayName: Swift.String? = nil,
            gatewayType: BackupGatewayClientTypes.GatewayType? = nil,
            hypervisorId: Swift.String? = nil,
            lastSeenTime: Foundation.Date? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayDisplayName = gatewayDisplayName
            self.gatewayType = gatewayType
            self.hypervisorId = hypervisorId
            self.lastSeenTime = lastSeenTime
        }
    }

}

public struct ListGatewaysOutput {
    /// A list of your gateways.
    public var gateways: [BackupGatewayClientTypes.Gateway]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        gateways: [BackupGatewayClientTypes.Gateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

public struct PutMaintenanceStartTimeInput {
    /// The day of the month start maintenance on a gateway. Valid values range from Sunday to Saturday.
    public var dayOfMonth: Swift.Int?
    /// The day of the week to start maintenance on a gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) for the gateway, used to specify its maintenance start time.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The hour of the day to start maintenance on a gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute of the hour to start maintenance on a gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init(
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayArn: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayArn = gatewayArn
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

public struct PutMaintenanceStartTimeOutput {
    /// The Amazon Resource Name (ARN) of a gateway for which you set the maintenance start time.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct TestHypervisorConfigurationInput {
    /// The Amazon Resource Name (ARN) of the gateway to the hypervisor to test.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        host: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.host = host
        self.password = password
        self.username = username
    }
}

extension TestHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestHypervisorConfigurationInput(gatewayArn: \(Swift.String(describing: gatewayArn)), host: \(Swift.String(describing: host)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct TestHypervisorConfigurationOutput {

    public init() { }
}

public struct UpdateGatewayInformationInput {
    /// The Amazon Resource Name (ARN) of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated display name of the gateway.
    public var gatewayDisplayName: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        gatewayDisplayName: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayDisplayName = gatewayDisplayName
    }
}

public struct UpdateGatewayInformationOutput {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct UpdateGatewaySoftwareNowInput {
    /// The Amazon Resource Name (ARN) of the gateway to be updated.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct UpdateGatewaySoftwareNowOutput {
    /// The Amazon Resource Name (ARN) of the gateway you updated.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteHypervisorInput {
    /// The Amazon Resource Name (ARN) of the hypervisor to delete.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct DeleteHypervisorOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you deleted.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct GetHypervisorInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension BackupGatewayClientTypes {

    public enum SyncMetadataStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case partiallyFailed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncMetadataStatus] {
            return [
                .created,
                .failed,
                .partiallyFailed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .partiallyFailed: return "PARTIALLY_FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupGatewayClientTypes {

    public enum HypervisorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case offline
        case online
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [HypervisorState] {
            return [
                .error,
                .offline,
                .online,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BackupGatewayClientTypes {
    /// These are the details of the specified hypervisor. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct HypervisorDetails {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// This is the time when the most recent successful sync of metadata occurred.
        public var lastSuccessfulMetadataSyncTime: Foundation.Date?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus?
        /// This is the most recent status for the indicated metadata sync.
        public var latestMetadataSyncStatusMessage: Swift.String?
        /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
        public var logGroupArn: Swift.String?
        /// This is the name of the specified hypervisor.
        public var name: Swift.String?
        /// This is the current state of the specified hypervisor. The possible states are PENDING, ONLINE, OFFLINE, or ERROR.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastSuccessfulMetadataSyncTime: Foundation.Date? = nil,
            latestMetadataSyncStatus: BackupGatewayClientTypes.SyncMetadataStatus? = nil,
            latestMetadataSyncStatusMessage: Swift.String? = nil,
            logGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.lastSuccessfulMetadataSyncTime = lastSuccessfulMetadataSyncTime
            self.latestMetadataSyncStatus = latestMetadataSyncStatus
            self.latestMetadataSyncStatusMessage = latestMetadataSyncStatusMessage
            self.logGroupArn = logGroupArn
            self.name = name
            self.state = state
        }
    }

}

public struct GetHypervisorOutput {
    /// Details about the requested hypervisor.
    public var hypervisor: BackupGatewayClientTypes.HypervisorDetails?

    public init(
        hypervisor: BackupGatewayClientTypes.HypervisorDetails? = nil
    )
    {
        self.hypervisor = hypervisor
    }
}

public struct GetHypervisorPropertyMappingsInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

extension BackupGatewayClientTypes {
    /// This displays the mapping of on-premises VMware tags to the corresponding Amazon Web Services tags.
    public struct VmwareToAwsTagMapping {
        /// The key part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagKey: Swift.String?
        /// The value part of the Amazon Web Services tag's key-value pair.
        /// This member is required.
        public var awsTagValue: Swift.String?
        /// The is the category of VMware.
        /// This member is required.
        public var vmwareCategory: Swift.String?
        /// This is the user-defined name of a VMware tag.
        /// This member is required.
        public var vmwareTagName: Swift.String?

        public init(
            awsTagKey: Swift.String? = nil,
            awsTagValue: Swift.String? = nil,
            vmwareCategory: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.awsTagKey = awsTagKey
            self.awsTagValue = awsTagValue
            self.vmwareCategory = vmwareCategory
            self.vmwareTagName = vmwareTagName
        }
    }

}

public struct GetHypervisorPropertyMappingsOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    public var iamRoleArn: Swift.String?
    /// This is a display of the mappings of on-premises VMware tags to the Amazon Web Services tags.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

public struct PutHypervisorPropertyMappingsInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// This action requests the mappings of on-premises VMware tags to the Amazon Web Services tags.
    /// This member is required.
    public var vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]?

    public init(
        hypervisorArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        vmwareToAwsTagMappings: [BackupGatewayClientTypes.VmwareToAwsTagMapping]? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.iamRoleArn = iamRoleArn
        self.vmwareToAwsTagMappings = vmwareToAwsTagMappings
    }
}

public struct PutHypervisorPropertyMappingsOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct ImportHypervisorConfigurationInput {
    /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    /// This member is required.
    public var host: Swift.String?
    /// The Key Management Service for the hypervisor.
    public var kmsKeyArn: Swift.String?
    /// The name of the hypervisor.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the hypervisor.
    public var password: Swift.String?
    /// The tags of the hypervisor configuration to import.
    public var tags: [BackupGatewayClientTypes.Tag]?
    /// The username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.password = password
        self.tags = tags
        self.username = username
    }
}

extension ImportHypervisorConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportHypervisorConfigurationInput(host: \(Swift.String(describing: host)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct ImportHypervisorConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you disassociated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct ListHypervisorsInput {
    /// The maximum number of hypervisors to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupGatewayClientTypes {
    /// Represents the hypervisor's permissions to which the gateway will connect. A hypervisor is hardware, software, or firmware that creates and manages virtual machines, and allocates resources to them.
    public struct Hypervisor {
        /// The server host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
        public var host: Swift.String?
        /// The Amazon Resource Name (ARN) of the hypervisor.
        public var hypervisorArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service used to encrypt the hypervisor.
        public var kmsKeyArn: Swift.String?
        /// The name of the hypervisor.
        public var name: Swift.String?
        /// The state of the hypervisor.
        public var state: BackupGatewayClientTypes.HypervisorState?

        public init(
            host: Swift.String? = nil,
            hypervisorArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: BackupGatewayClientTypes.HypervisorState? = nil
        )
        {
            self.host = host
            self.hypervisorArn = hypervisorArn
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.state = state
        }
    }

}

public struct ListHypervisorsOutput {
    /// A list of your Hypervisor objects, ordered by their Amazon Resource Names (ARNs).
    public var hypervisors: [BackupGatewayClientTypes.Hypervisor]?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisors: [BackupGatewayClientTypes.Hypervisor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisors = hypervisors
        self.nextToken = nextToken
    }
}

public struct StartVirtualMachinesMetadataSyncInput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    /// This member is required.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct StartVirtualMachinesMetadataSyncOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

public struct UpdateHypervisorInput {
    /// The updated host of the hypervisor. This can be either an IP address or a fully-qualified domain name (FQDN).
    public var host: Swift.String?
    /// The Amazon Resource Name (ARN) of the hypervisor to update.
    /// This member is required.
    public var hypervisorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the group of gateways within the requested log.
    public var logGroupArn: Swift.String?
    /// The updated name for the hypervisor
    public var name: Swift.String?
    /// The updated password for the hypervisor.
    public var password: Swift.String?
    /// The updated username for the hypervisor.
    public var username: Swift.String?

    public init(
        host: Swift.String? = nil,
        hypervisorArn: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.host = host
        self.hypervisorArn = hypervisorArn
        self.logGroupArn = logGroupArn
        self.name = name
        self.password = password
        self.username = username
    }
}

extension UpdateHypervisorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHypervisorInput(host: \(Swift.String(describing: host)), hypervisorArn: \(Swift.String(describing: hypervisorArn)), logGroupArn: \(Swift.String(describing: logGroupArn)), name: \(Swift.String(describing: name)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct UpdateHypervisorOutput {
    /// The Amazon Resource Name (ARN) of the hypervisor you updated.
    public var hypervisorArn: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
    }
}

/// The operation did not succeed because an internal error occurred. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of which internal error occured.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource's tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource's tags that you listed.
    public var resourceArn: Swift.String?
    /// A list of the resource's tags.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to assign to the resource.
    /// This member is required.
    public var tags: [BackupGatewayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BackupGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource you tagged.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

/// TPS has been limited to protect against intentional or unintentional high request volumes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error: TPS has been limited to protect against intentional or unintentional high request volumes.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys specifying which tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource from which you removed tags.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

/// The operation did not succeed because a validation error occurred.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of what caused the validation error.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct GetVirtualMachineInput {
    /// The Amazon Resource Name (ARN) of the virtual machine.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension BackupGatewayClientTypes {
    /// A VMware tag is a tag attached to a specific virtual machine. A [tag](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BGW_Tag.html) is a key-value pair you can use to manage, filter, and search for your resources. The content of VMware tags can be matched to Amazon Web Services tags.
    public struct VmwareTag {
        /// The is the category of VMware.
        public var vmwareCategory: Swift.String?
        /// This is a user-defined description of a VMware tag.
        public var vmwareTagDescription: Swift.String?
        /// This is the user-defined name of a VMware tag.
        public var vmwareTagName: Swift.String?

        public init(
            vmwareCategory: Swift.String? = nil,
            vmwareTagDescription: Swift.String? = nil,
            vmwareTagName: Swift.String? = nil
        )
        {
            self.vmwareCategory = vmwareCategory
            self.vmwareTagDescription = vmwareTagDescription
            self.vmwareTagName = vmwareTagName
        }
    }

}

extension BackupGatewayClientTypes {
    /// Your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public struct VirtualMachineDetails {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: Foundation.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?
        /// These are the details of the VMware tags associated with the specified virtual machine.
        public var vmwareTags: [BackupGatewayClientTypes.VmwareTag]?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            vmwareTags: [BackupGatewayClientTypes.VmwareTag]? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
            self.vmwareTags = vmwareTags
        }
    }

}

public struct GetVirtualMachineOutput {
    /// This object contains the basic attributes of VirtualMachine contained by the output of GetVirtualMachine
    public var virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails?

    public init(
        virtualMachine: BackupGatewayClientTypes.VirtualMachineDetails? = nil
    )
    {
        self.virtualMachine = virtualMachine
    }
}

public struct ListVirtualMachinesInput {
    /// The Amazon Resource Name (ARN) of the hypervisor connected to your virtual machine.
    public var hypervisorArn: Swift.String?
    /// The maximum number of virtual machines to list.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init(
        hypervisorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hypervisorArn = hypervisorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BackupGatewayClientTypes {
    /// A virtual machine that is on a hypervisor.
    public struct VirtualMachine {
        /// The host name of the virtual machine.
        public var hostName: Swift.String?
        /// The ID of the virtual machine's hypervisor.
        public var hypervisorId: Swift.String?
        /// The most recent date a virtual machine was backed up, in Unix format and UTC time.
        public var lastBackupDate: Foundation.Date?
        /// The name of the virtual machine.
        public var name: Swift.String?
        /// The path of the virtual machine.
        public var path: Swift.String?
        /// The Amazon Resource Name (ARN) of the virtual machine. For example, arn:aws:backup-gateway:us-west-1:0000000000000:vm/vm-0000ABCDEFGIJKL.
        public var resourceArn: Swift.String?

        public init(
            hostName: Swift.String? = nil,
            hypervisorId: Swift.String? = nil,
            lastBackupDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.hostName = hostName
            self.hypervisorId = hypervisorId
            self.lastBackupDate = lastBackupDate
            self.name = name
            self.path = path
            self.resourceArn = resourceArn
        }
    }

}

public struct ListVirtualMachinesOutput {
    /// The next item following a partial list of returned resources. For example, if a request is made to return maxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// A list of your VirtualMachine objects, ordered by their Amazon Resource Names (ARNs).
    public var virtualMachines: [BackupGatewayClientTypes.VirtualMachine]?

    public init(
        nextToken: Swift.String? = nil,
        virtualMachines: [BackupGatewayClientTypes.VirtualMachine]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualMachines = virtualMachines
    }
}

extension AssociateGatewayToServerInput {

    static func urlPathProvider(_ value: AssociateGatewayToServerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteHypervisorInput {

    static func urlPathProvider(_ value: DeleteHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateGatewayFromServerInput {

    static func urlPathProvider(_ value: DisassociateGatewayFromServerInput) -> Swift.String? {
        return "/"
    }
}

extension GetBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: GetBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension GetGatewayInput {

    static func urlPathProvider(_ value: GetGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension GetHypervisorInput {

    static func urlPathProvider(_ value: GetHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension GetHypervisorPropertyMappingsInput {

    static func urlPathProvider(_ value: GetHypervisorPropertyMappingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetVirtualMachineInput {

    static func urlPathProvider(_ value: GetVirtualMachineInput) -> Swift.String? {
        return "/"
    }
}

extension ImportHypervisorConfigurationInput {

    static func urlPathProvider(_ value: ImportHypervisorConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension ListHypervisorsInput {

    static func urlPathProvider(_ value: ListHypervisorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListVirtualMachinesInput {

    static func urlPathProvider(_ value: ListVirtualMachinesInput) -> Swift.String? {
        return "/"
    }
}

extension PutBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: PutBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension PutHypervisorPropertyMappingsInput {

    static func urlPathProvider(_ value: PutHypervisorPropertyMappingsInput) -> Swift.String? {
        return "/"
    }
}

extension PutMaintenanceStartTimeInput {

    static func urlPathProvider(_ value: PutMaintenanceStartTimeInput) -> Swift.String? {
        return "/"
    }
}

extension StartVirtualMachinesMetadataSyncInput {

    static func urlPathProvider(_ value: StartVirtualMachinesMetadataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestHypervisorConfigurationInput {

    static func urlPathProvider(_ value: TestHypervisorConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewayInformationInput {

    static func urlPathProvider(_ value: UpdateGatewayInformationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func urlPathProvider(_ value: UpdateGatewaySoftwareNowInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateHypervisorInput {

    static func urlPathProvider(_ value: UpdateHypervisorInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateGatewayToServerInput {

    static func write(value: AssociateGatewayToServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["ServerArn"].write(value.serverArn)
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationKey"].write(value.activationKey)
        try writer["GatewayDisplayName"].write(value.gatewayDisplayName)
        try writer["GatewayType"].write(value.gatewayType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteGatewayInput {

    static func write(value: DeleteGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension DeleteHypervisorInput {

    static func write(value: DeleteHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

extension DisassociateGatewayFromServerInput {

    static func write(value: DisassociateGatewayFromServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension GetBandwidthRateLimitScheduleInput {

    static func write(value: GetBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension GetGatewayInput {

    static func write(value: GetGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension GetHypervisorInput {

    static func write(value: GetHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

extension GetHypervisorPropertyMappingsInput {

    static func write(value: GetHypervisorPropertyMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

extension GetVirtualMachineInput {

    static func write(value: GetVirtualMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ImportHypervisorConfigurationInput {

    static func write(value: ImportHypervisorConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["Name"].write(value.name)
        try writer["Password"].write(value.password)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Username"].write(value.username)
    }
}

extension ListGatewaysInput {

    static func write(value: ListGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListHypervisorsInput {

    static func write(value: ListHypervisorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListVirtualMachinesInput {

    static func write(value: ListVirtualMachinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutBandwidthRateLimitScheduleInput {

    static func write(value: PutBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthRateLimitIntervals"].writeList(value.bandwidthRateLimitIntervals, memberWritingClosure: BackupGatewayClientTypes.BandwidthRateLimitInterval.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension PutHypervisorPropertyMappingsInput {

    static func write(value: PutHypervisorPropertyMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["VmwareToAwsTagMappings"].writeList(value.vmwareToAwsTagMappings, memberWritingClosure: BackupGatewayClientTypes.VmwareToAwsTagMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutMaintenanceStartTimeInput {

    static func write(value: PutMaintenanceStartTimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["HourOfDay"].write(value.hourOfDay)
        try writer["MinuteOfHour"].write(value.minuteOfHour)
    }
}

extension StartVirtualMachinesMetadataSyncInput {

    static func write(value: StartVirtualMachinesMetadataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HypervisorArn"].write(value.hypervisorArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: BackupGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestHypervisorConfigurationInput {

    static func write(value: TestHypervisorConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["Host"].write(value.host)
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGatewayInformationInput {

    static func write(value: UpdateGatewayInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["GatewayDisplayName"].write(value.gatewayDisplayName)
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func write(value: UpdateGatewaySoftwareNowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

extension UpdateHypervisorInput {

    static func write(value: UpdateHypervisorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["HypervisorArn"].write(value.hypervisorArn)
        try writer["LogGroupArn"].write(value.logGroupArn)
        try writer["Name"].write(value.name)
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

extension AssociateGatewayToServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateGatewayToServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateGatewayToServerOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension DeleteHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteHypervisorOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

extension DisassociateGatewayFromServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateGatewayFromServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateGatewayFromServerOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension GetBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBandwidthRateLimitScheduleOutput()
        value.bandwidthRateLimitIntervals = try reader["BandwidthRateLimitIntervals"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.BandwidthRateLimitInterval.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension GetGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayOutput()
        value.gateway = try reader["Gateway"].readIfPresent(with: BackupGatewayClientTypes.GatewayDetails.read(from:))
        return value
    }
}

extension GetHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHypervisorOutput()
        value.hypervisor = try reader["Hypervisor"].readIfPresent(with: BackupGatewayClientTypes.HypervisorDetails.read(from:))
        return value
    }
}

extension GetHypervisorPropertyMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHypervisorPropertyMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHypervisorPropertyMappingsOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.vmwareToAwsTagMappings = try reader["VmwareToAwsTagMappings"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VmwareToAwsTagMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetVirtualMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVirtualMachineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVirtualMachineOutput()
        value.virtualMachine = try reader["VirtualMachine"].readIfPresent(with: BackupGatewayClientTypes.VirtualMachineDetails.read(from:))
        return value
    }
}

extension ImportHypervisorConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportHypervisorConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportHypervisorConfigurationOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["Gateways"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Gateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListHypervisorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHypervisorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHypervisorsOutput()
        value.hypervisors = try reader["Hypervisors"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Hypervisor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVirtualMachinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualMachinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualMachinesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.virtualMachines = try reader["VirtualMachines"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VirtualMachine.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutBandwidthRateLimitScheduleOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension PutHypervisorPropertyMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutHypervisorPropertyMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutHypervisorPropertyMappingsOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

extension PutMaintenanceStartTimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMaintenanceStartTimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutMaintenanceStartTimeOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension StartVirtualMachinesMetadataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartVirtualMachinesMetadataSyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartVirtualMachinesMetadataSyncOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

extension TestHypervisorConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestHypervisorConfigurationOutput {
        return TestHypervisorConfigurationOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UntagResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

extension UpdateGatewayInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayInformationOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension UpdateGatewaySoftwareNowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewaySoftwareNowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewaySoftwareNowOutput()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        return value
    }
}

extension UpdateHypervisorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateHypervisorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateHypervisorOutput()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum AssociateGatewayToServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateGatewayFromServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHypervisorPropertyMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVirtualMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportHypervisorConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHypervisorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualMachinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutHypervisorPropertyMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMaintenanceStartTimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartVirtualMachinesMetadataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestHypervisorConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewaySoftwareNowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateHypervisorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BackupGatewayClientTypes.BandwidthRateLimitInterval {

    static func write(value: BackupGatewayClientTypes.BandwidthRateLimitInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageUploadRateLimitInBitsPerSec"].write(value.averageUploadRateLimitInBitsPerSec)
        try writer["DaysOfWeek"].writeList(value.daysOfWeek, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndHourOfDay"].write(value.endHourOfDay)
        try writer["EndMinuteOfHour"].write(value.endMinuteOfHour)
        try writer["StartHourOfDay"].write(value.startHourOfDay)
        try writer["StartMinuteOfHour"].write(value.startMinuteOfHour)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.BandwidthRateLimitInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.BandwidthRateLimitInterval()
        value.averageUploadRateLimitInBitsPerSec = try reader["AverageUploadRateLimitInBitsPerSec"].readIfPresent()
        value.startHourOfDay = try reader["StartHourOfDay"].readIfPresent() ?? 0
        value.endHourOfDay = try reader["EndHourOfDay"].readIfPresent() ?? 0
        value.startMinuteOfHour = try reader["StartMinuteOfHour"].readIfPresent() ?? 0
        value.endMinuteOfHour = try reader["EndMinuteOfHour"].readIfPresent() ?? 0
        value.daysOfWeek = try reader["DaysOfWeek"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BackupGatewayClientTypes.GatewayDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.GatewayDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.GatewayDetails()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        value.gatewayDisplayName = try reader["GatewayDisplayName"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.lastSeenTime = try reader["LastSeenTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maintenanceStartTime = try reader["MaintenanceStartTime"].readIfPresent(with: BackupGatewayClientTypes.MaintenanceStartTime.read(from:))
        value.nextUpdateAvailabilityTime = try reader["NextUpdateAvailabilityTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcEndpoint = try reader["VpcEndpoint"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes.MaintenanceStartTime {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.MaintenanceStartTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.MaintenanceStartTime()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.hourOfDay = try reader["HourOfDay"].readIfPresent() ?? 0
        value.minuteOfHour = try reader["MinuteOfHour"].readIfPresent() ?? 0
        return value
    }
}

extension BackupGatewayClientTypes.HypervisorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.HypervisorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.HypervisorDetails()
        value.host = try reader["Host"].readIfPresent()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.lastSuccessfulMetadataSyncTime = try reader["LastSuccessfulMetadataSyncTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestMetadataSyncStatusMessage = try reader["LatestMetadataSyncStatusMessage"].readIfPresent()
        value.latestMetadataSyncStatus = try reader["LatestMetadataSyncStatus"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes.VmwareToAwsTagMapping {

    static func write(value: BackupGatewayClientTypes.VmwareToAwsTagMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsTagKey"].write(value.awsTagKey)
        try writer["AwsTagValue"].write(value.awsTagValue)
        try writer["VmwareCategory"].write(value.vmwareCategory)
        try writer["VmwareTagName"].write(value.vmwareTagName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VmwareToAwsTagMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VmwareToAwsTagMapping()
        value.vmwareCategory = try reader["VmwareCategory"].readIfPresent() ?? ""
        value.vmwareTagName = try reader["VmwareTagName"].readIfPresent() ?? ""
        value.awsTagKey = try reader["AwsTagKey"].readIfPresent() ?? ""
        value.awsTagValue = try reader["AwsTagValue"].readIfPresent() ?? ""
        return value
    }
}

extension BackupGatewayClientTypes.VirtualMachineDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VirtualMachineDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VirtualMachineDetails()
        value.hostName = try reader["HostName"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.lastBackupDate = try reader["LastBackupDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vmwareTags = try reader["VmwareTags"].readListIfPresent(memberReadingClosure: BackupGatewayClientTypes.VmwareTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BackupGatewayClientTypes.VmwareTag {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VmwareTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VmwareTag()
        value.vmwareCategory = try reader["VmwareCategory"].readIfPresent()
        value.vmwareTagName = try reader["VmwareTagName"].readIfPresent()
        value.vmwareTagDescription = try reader["VmwareTagDescription"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes.Gateway {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Gateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Gateway()
        value.gatewayArn = try reader["GatewayArn"].readIfPresent()
        value.gatewayDisplayName = try reader["GatewayDisplayName"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.lastSeenTime = try reader["LastSeenTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BackupGatewayClientTypes.Hypervisor {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Hypervisor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Hypervisor()
        value.host = try reader["Host"].readIfPresent()
        value.hypervisorArn = try reader["HypervisorArn"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension BackupGatewayClientTypes.Tag {

    static func write(value: BackupGatewayClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension BackupGatewayClientTypes.VirtualMachine {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupGatewayClientTypes.VirtualMachine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupGatewayClientTypes.VirtualMachine()
        value.hostName = try reader["HostName"].readIfPresent()
        value.hypervisorId = try reader["HypervisorId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.lastBackupDate = try reader["LastBackupDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

public enum BackupGatewayClientTypes {}
