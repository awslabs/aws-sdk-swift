// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmpClientTypes.AlertManagerDefinitionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case data
        case modifiedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension AmpClientTypes {
    /// The details of an alert manager definition.
    public struct AlertManagerDefinitionDescription: Swift.Equatable {
        /// The date and time that the alert manager definition was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The actual alert manager definition. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The date and time that the alert manager definition was most recently changed.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// A structure that displays the current status of the alert manager definition..
        /// This member is required.
        public var status: AmpClientTypes.AlertManagerDefinitionStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            data: ClientRuntime.Data? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }
    }

}

extension AmpClientTypes.AlertManagerDefinitionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AmpClientTypes {
    /// The status of the alert manager.
    public struct AlertManagerDefinitionStatus: Swift.Equatable {
        /// The current status of the alert manager.
        /// This member is required.
        public var statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension AmpClientTypes {
    /// State of an AlertManagerDefinition.
    public enum AlertManagerDefinitionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Definition creation failed.
        case creationFailed
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Definition update failed.
        case updateFailed
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertManagerDefinitionStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertManagerDefinitionStatusCode(rawValue: rawValue) ?? AlertManagerDefinitionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.AmpConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceArn = self.workspaceArn {
            try encodeContainer.encode(workspaceArn, forKey: .workspaceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceArn)
        workspaceArn = workspaceArnDecoded
    }
}

extension AmpClientTypes {
    /// The AmpConfiguration structure defines the Amazon Managed Service for Prometheus instance a scraper should send metrics to.
    public struct AmpConfiguration: Swift.Equatable {
        /// ARN of the Amazon Managed Service for Prometheus workspace.
        /// This member is required.
        public var workspaceArn: Swift.String?

        public init(
            workspaceArn: Swift.String? = nil
        )
        {
            self.workspaceArn = workspaceArn
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAlertManagerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

extension CreateAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: CreateAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

/// Represents the input of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The alert manager definition to add. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The ID of the workspace to add the alert manager definition to.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

struct CreateAlertManagerDefinitionInputBody: Swift.Equatable {
    let data: ClientRuntime.Data?
    let clientToken: Swift.String?
}

extension CreateAlertManagerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAlertManagerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAlertManagerDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionOutput: Swift.Equatable {
    /// A structure that displays the current status of the alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init(
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateAlertManagerDefinitionOutputBody: Swift.Equatable {
    let status: AmpClientTypes.AlertManagerDefinitionStatus?
}

extension CreateAlertManagerDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }
}

extension CreateLoggingConfigurationInput {

    static func urlPathProvider(_ value: CreateLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

/// Represents the input of a CreateLoggingConfiguration operation.
public struct CreateLoggingConfigurationInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist prior to calling this API.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the workspace to create the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.logGroupArn = logGroupArn
        self.workspaceId = workspaceId
    }
}

struct CreateLoggingConfigurationInputBody: Swift.Equatable {
    let logGroupArn: Swift.String?
    let clientToken: Swift.String?
}

extension CreateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case logGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of a CreateLoggingConfiguration operation.
public struct CreateLoggingConfigurationOutput: Swift.Equatable {
    /// A structure that displays the current status of the logging configuration.
    /// This member is required.
    public var status: AmpClientTypes.LoggingConfigurationStatus?

    public init(
        status: AmpClientTypes.LoggingConfigurationStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateLoggingConfigurationOutputBody: Swift.Equatable {
    let status: AmpClientTypes.LoggingConfigurationStatus?
}

extension CreateLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.LoggingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRuleGroupsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: CreateRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
    }
}

/// Represents the input of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The rules file to use in the new namespace. Contains the base64-encoded version of the YAML rules file. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The name for the new rule groups namespace.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tag keys and values to associate with the rule groups namespace.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace to add the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateRuleGroupsNamespaceInputBody: Swift.Equatable {
    let name: Swift.String?
    let data: ClientRuntime.Data?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRuleGroupsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleGroupsNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRuleGroupsNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

/// Represents the output of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the new rule groups namespace.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that returns the current status of the rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The list of tag keys and values that are associated with the namespace.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct CreateRuleGroupsNamespaceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let status: AmpClientTypes.RuleGroupsNamespaceStatus?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRuleGroupsNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateScraperInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case destination
        case scrapeConfiguration
        case source
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let scrapeConfiguration = self.scrapeConfiguration {
            try encodeContainer.encode(scrapeConfiguration, forKey: .scrapeConfiguration)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateScraperInput {

    static func urlPathProvider(_ value: CreateScraperInput) -> Swift.String? {
        return "/scrapers"
    }
}

/// Represents the input of a CreateScraper operation.
public struct CreateScraperInput: Swift.Equatable {
    /// (optional) a name to associate with the scraper. This is for your use, and does not need to be unique.
    public var alias: Swift.String?
    /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Managed Service for Prometheus workspace to send metrics to.
    /// This member is required.
    public var destination: AmpClientTypes.Destination?
    /// The configuration file to use in the new scraper. For more information, see [Scraper configuration] in the Amazon Managed Service for Prometheus User Guide.
    /// This member is required.
    public var scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
    /// The Amazon EKS cluster from which the scraper will collect metrics.
    /// This member is required.
    public var source: AmpClientTypes.Source?
    /// (Optional) The list of tag keys and values to associate with the scraper.
    public var tags: [Swift.String:Swift.String]?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destination: AmpClientTypes.Destination? = nil,
        scrapeConfiguration: AmpClientTypes.ScrapeConfiguration? = nil,
        source: AmpClientTypes.Source? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.destination = destination
        self.scrapeConfiguration = scrapeConfiguration
        self.source = source
        self.tags = tags
    }
}

struct CreateScraperInputBody: Swift.Equatable {
    let alias: Swift.String?
    let scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
    let source: AmpClientTypes.Source?
    let destination: AmpClientTypes.Destination?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateScraperInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case destination
        case scrapeConfiguration
        case source
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let scrapeConfigurationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScrapeConfiguration.self, forKey: .scrapeConfiguration)
        scrapeConfiguration = scrapeConfigurationDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateScraperOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateScraperOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.scraperId = output.scraperId
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.scraperId = nil
            self.status = nil
            self.tags = nil
        }
    }
}

/// Represents the output of a CreateScraper operation.
public struct CreateScraperOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new scraper.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the new scraper.
    /// This member is required.
    public var scraperId: Swift.String?
    /// A structure that displays the current status of the scraper.
    /// This member is required.
    public var status: AmpClientTypes.ScraperStatus?
    /// The list of tag keys and values that are associated with the scraper.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        scraperId: Swift.String? = nil,
        status: AmpClientTypes.ScraperStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.scraperId = scraperId
        self.status = status
        self.tags = tags
    }
}

struct CreateScraperOutputBody: Swift.Equatable {
    let scraperId: Swift.String?
    let arn: Swift.String?
    let status: AmpClientTypes.ScraperStatus?
    let tags: [Swift.String:Swift.String]?
}

extension CreateScraperOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case scraperId
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scraperIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scraperId)
        scraperId = scraperIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateScraperOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case kmsKeyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkspaceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInput) -> Swift.String? {
        return "/workspaces"
    }
}

/// Represents the input of a CreateWorkspace operation.
public struct CreateWorkspaceInput: Swift.Equatable {
    /// An alias that you assign to this workspace to help you identify it. It does not need to be unique. Blank spaces at the beginning or end of the alias that you specify will be trimmed from the value used.
    public var alias: Swift.String?
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// (optional) The ARN for a customer managed KMS key to use for encrypting data within your workspace. For more information about using your own key in your workspace, see [Encryption at rest](https://docs.aws.amazon.com/prometheus/latest/userguide/encryption-at-rest-Amazon-Service-Prometheus.html) in the Amazon Managed Service for Prometheus User Guide.
    public var kmsKeyArn: Swift.String?
    /// The list of tag keys and values to associate with the workspace.
    public var tags: [Swift.String:Swift.String]?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let alias: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyArn: Swift.String?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case kmsKeyArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CreateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.kmsKeyArn = output.kmsKeyArn
            self.status = output.status
            self.tags = output.tags
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.kmsKeyArn = nil
            self.status = nil
            self.tags = nil
            self.workspaceId = nil
        }
    }
}

/// Represents the output of a CreateWorkspace operation.
public struct CreateWorkspaceOutput: Swift.Equatable {
    /// The ARN for the new workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
    public var kmsKeyArn: Swift.String?
    /// The current status of the new workspace. Immediately after you create the workspace, the status is usually CREATING.
    /// This member is required.
    public var status: AmpClientTypes.WorkspaceStatus?
    /// The list of tag keys and values that are associated with the workspace.
    public var tags: [Swift.String:Swift.String]?
    /// The unique ID for the new workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        status: AmpClientTypes.WorkspaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.kmsKeyArn = kmsKeyArn
        self.status = status
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let status: AmpClientTypes.WorkspaceStatus?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyArn: Swift.String?
}

extension CreateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case kmsKeyArn
        case status
        case tags
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

enum CreateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAlertManagerDefinitionInput {

    static func queryItemProvider(_ value: DeleteAlertManagerDefinitionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: DeleteAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

/// Represents the input of a DeleteAlertManagerDefinition operation.
public struct DeleteAlertManagerDefinitionInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to delete the alert manager definition from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteAlertManagerDefinitionInputBody: Swift.Equatable {
}

extension DeleteAlertManagerDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAlertManagerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAlertManagerDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLoggingConfigurationInput {

    static func queryItemProvider(_ value: DeleteLoggingConfigurationInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

/// Represents the input of a DeleteLoggingConfiguration operation.
public struct DeleteLoggingConfigurationInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace containing the logging configuration to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteLoggingConfigurationInputBody: Swift.Equatable {
}

extension DeleteLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLoggingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRuleGroupsNamespaceInput {

    static func queryItemProvider(_ value: DeleteRuleGroupsNamespaceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: DeleteRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

/// Represents the input of a DeleteRuleGroupsNamespace operation.
public struct DeleteRuleGroupsNamespaceInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The name of the rule groups namespace to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace containing the rule groups namespace and definition to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct DeleteRuleGroupsNamespaceInputBody: Swift.Equatable {
}

extension DeleteRuleGroupsNamespaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleGroupsNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRuleGroupsNamespaceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteScraperInput {

    static func queryItemProvider(_ value: DeleteScraperInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteScraperInput {

    static func urlPathProvider(_ value: DeleteScraperInput) -> Swift.String? {
        guard let scraperId = value.scraperId else {
            return nil
        }
        return "/scrapers/\(scraperId.urlPercentEncoding())"
    }
}

/// Represents the input of a DeleteScraper operation.
public struct DeleteScraperInput: Swift.Equatable {
    /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the scraper to delete.
    /// This member is required.
    public var scraperId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        scraperId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.scraperId = scraperId
    }
}

struct DeleteScraperInputBody: Swift.Equatable {
}

extension DeleteScraperInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteScraperOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteScraperOutputBody = try responseDecoder.decode(responseBody: data)
            self.scraperId = output.scraperId
            self.status = output.status
        } else {
            self.scraperId = nil
            self.status = nil
        }
    }
}

/// Represents the output of a DeleteScraper operation.
public struct DeleteScraperOutput: Swift.Equatable {
    /// The ID of the scraper to delete.
    /// This member is required.
    public var scraperId: Swift.String?
    /// The current status of the scraper.
    /// This member is required.
    public var status: AmpClientTypes.ScraperStatus?

    public init(
        scraperId: Swift.String? = nil,
        status: AmpClientTypes.ScraperStatus? = nil
    )
    {
        self.scraperId = scraperId
        self.status = status
    }
}

struct DeleteScraperOutputBody: Swift.Equatable {
    let scraperId: Swift.String?
    let status: AmpClientTypes.ScraperStatus?
}

extension DeleteScraperOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scraperId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scraperIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scraperId)
        scraperId = scraperIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteScraperOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkspaceInput {

    static func queryItemProvider(_ value: DeleteWorkspaceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteWorkspaceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

/// Represents the input of a DeleteWorkspace operation.
public struct DeleteWorkspaceInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkspaceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: DescribeAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

/// Represents the input of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionInput: Swift.Equatable {
    /// The ID of the workspace to retrieve the alert manager definition from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeAlertManagerDefinitionInputBody: Swift.Equatable {
}

extension DescribeAlertManagerDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlertManagerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAlertManagerDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.alertManagerDefinition = output.alertManagerDefinition
        } else {
            self.alertManagerDefinition = nil
        }
    }
}

/// Represents the output of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionOutput: Swift.Equatable {
    /// The alert manager definition.
    /// This member is required.
    public var alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription?

    public init(
        alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription? = nil
    )
    {
        self.alertManagerDefinition = alertManagerDefinition
    }
}

struct DescribeAlertManagerDefinitionOutputBody: Swift.Equatable {
    let alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription?
}

extension DescribeAlertManagerDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertManagerDefinition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertManagerDefinitionDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionDescription.self, forKey: .alertManagerDefinition)
        alertManagerDefinition = alertManagerDefinitionDecoded
    }
}

enum DescribeAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLoggingConfigurationInput {

    static func urlPathProvider(_ value: DescribeLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

/// Represents the input of a DescribeLoggingConfiguration operation.
public struct DescribeLoggingConfigurationInput: Swift.Equatable {
    /// The ID of the workspace to describe the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeLoggingConfigurationInputBody: Swift.Equatable {
}

extension DescribeLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

/// Represents the output of a DescribeLoggingConfiguration operation.
public struct DescribeLoggingConfigurationOutput: Swift.Equatable {
    /// A structure that displays the information about the logging configuration.
    /// This member is required.
    public var loggingConfiguration: AmpClientTypes.LoggingConfigurationMetadata?

    public init(
        loggingConfiguration: AmpClientTypes.LoggingConfigurationMetadata? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct DescribeLoggingConfigurationOutputBody: Swift.Equatable {
    let loggingConfiguration: AmpClientTypes.LoggingConfigurationMetadata?
}

extension DescribeLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.LoggingConfigurationMetadata.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

enum DescribeLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: DescribeRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

/// Represents the input of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceInput: Swift.Equatable {
    /// The name of the rule groups namespace that you want information for.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace containing the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct DescribeRuleGroupsNamespaceInputBody: Swift.Equatable {
}

extension DescribeRuleGroupsNamespaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRuleGroupsNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRuleGroupsNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.ruleGroupsNamespace = output.ruleGroupsNamespace
        } else {
            self.ruleGroupsNamespace = nil
        }
    }
}

/// Represents the output of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceOutput: Swift.Equatable {
    /// The information about the rule groups namespace.
    /// This member is required.
    public var ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription?

    public init(
        ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription? = nil
    )
    {
        self.ruleGroupsNamespace = ruleGroupsNamespace
    }
}

struct DescribeRuleGroupsNamespaceOutputBody: Swift.Equatable {
    let ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription?
}

extension DescribeRuleGroupsNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleGroupsNamespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupsNamespaceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceDescription.self, forKey: .ruleGroupsNamespace)
        ruleGroupsNamespace = ruleGroupsNamespaceDecoded
    }
}

enum DescribeRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeScraperInput {

    static func urlPathProvider(_ value: DescribeScraperInput) -> Swift.String? {
        guard let scraperId = value.scraperId else {
            return nil
        }
        return "/scrapers/\(scraperId.urlPercentEncoding())"
    }
}

/// Represents the input of a DescribeScraper operation.
public struct DescribeScraperInput: Swift.Equatable {
    /// The ID of the scraper to describe.
    /// This member is required.
    public var scraperId: Swift.String?

    public init(
        scraperId: Swift.String? = nil
    )
    {
        self.scraperId = scraperId
    }
}

struct DescribeScraperInputBody: Swift.Equatable {
}

extension DescribeScraperInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeScraperOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeScraperOutputBody = try responseDecoder.decode(responseBody: data)
            self.scraper = output.scraper
        } else {
            self.scraper = nil
        }
    }
}

/// Represents the output of a DescribeScraper operation.
public struct DescribeScraperOutput: Swift.Equatable {
    /// Contains details about the scraper.
    /// This member is required.
    public var scraper: AmpClientTypes.ScraperDescription?

    public init(
        scraper: AmpClientTypes.ScraperDescription? = nil
    )
    {
        self.scraper = scraper
    }
}

struct DescribeScraperOutputBody: Swift.Equatable {
    let scraper: AmpClientTypes.ScraperDescription?
}

extension DescribeScraperOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scraper
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scraperDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperDescription.self, forKey: .scraper)
        scraper = scraperDecoded
    }
}

enum DescribeScraperOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceInput {

    static func urlPathProvider(_ value: DescribeWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

/// Represents the input of a DescribeWorkspace operation.
public struct DescribeWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to describe.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceInputBody: Swift.Equatable {
}

extension DescribeWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

/// Represents the output of a DescribeWorkspace operation.
public struct DescribeWorkspaceOutput: Swift.Equatable {
    /// A structure that contains details about the workspace.
    /// This member is required.
    public var workspace: AmpClientTypes.WorkspaceDescription?

    public init(
        workspace: AmpClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DescribeWorkspaceOutputBody: Swift.Equatable {
    let workspace: AmpClientTypes.WorkspaceDescription?
}

extension DescribeWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum DescribeWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmpClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ampconfiguration = "ampConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ampconfiguration(ampconfiguration):
                try container.encode(ampconfiguration, forKey: .ampconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ampconfigurationDecoded = try values.decodeIfPresent(AmpClientTypes.AmpConfiguration.self, forKey: .ampconfiguration)
        if let ampconfiguration = ampconfigurationDecoded {
            self = .ampconfiguration(ampconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmpClientTypes {
    /// Where to send the metrics from a scraper.
    public enum Destination: Swift.Equatable {
        /// The Amazon Managed Service for Prometheusworkspace to send metrics to.
        case ampconfiguration(AmpClientTypes.AmpConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension AmpClientTypes.EksConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension AmpClientTypes {
    /// The EksConfiguration structure describes the connection to the Amazon EKS cluster from which a scraper collects metrics.
    public struct EksConfiguration: Swift.Equatable {
        /// ARN of the Amazon EKS cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// A list of the security group IDs for the Amazon EKS cluster VPC configuration.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs for the Amazon EKS cluster VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            clusterArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.clusterArn = clusterArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GetDefaultScraperConfigurationInput {

    static func urlPathProvider(_ value: GetDefaultScraperConfigurationInput) -> Swift.String? {
        return "/scraperconfiguration"
    }
}

/// Represents the input of a GetDefaultScraperConfiguration operation.
public struct GetDefaultScraperConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetDefaultScraperConfigurationInputBody: Swift.Equatable {
}

extension GetDefaultScraperConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDefaultScraperConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDefaultScraperConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

/// Represents the output of a GetDefaultScraperConfiguration operation.
public struct GetDefaultScraperConfigurationOutput: Swift.Equatable {
    /// The configuration file. Base 64 encoded. For more information, see [Scraper configuration](https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-collector-how-to.html#AMP-collector-configuration)in the Amazon Managed Service for Prometheus User Guide.
    /// This member is required.
    public var configuration: ClientRuntime.Data?

    public init(
        configuration: ClientRuntime.Data? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetDefaultScraperConfigurationOutputBody: Swift.Equatable {
    let configuration: ClientRuntime.Data?
}

extension GetDefaultScraperConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetDefaultScraperConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred during the processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRuleGroupsNamespacesInput {

    static func queryItemProvider(_ value: ListRuleGroupsNamespacesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListRuleGroupsNamespacesInput {

    static func urlPathProvider(_ value: ListRuleGroupsNamespacesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
    }
}

/// Represents the input of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesInput: Swift.Equatable {
    /// The maximum number of results to return. The default is 100.
    public var maxResults: Swift.Int?
    /// Use this parameter to filter the rule groups namespaces that are returned. Only the namespaces with names that begin with the value that you specify are returned.
    public var name: Swift.String?
    /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 rule groups namespaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 namespaces.
    public var nextToken: Swift.String?
    /// The ID of the workspace containing the rule groups namespaces.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListRuleGroupsNamespacesInputBody: Swift.Equatable {
}

extension ListRuleGroupsNamespacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRuleGroupsNamespacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRuleGroupsNamespacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleGroupsNamespaces = output.ruleGroupsNamespaces
        } else {
            self.nextToken = nil
            self.ruleGroupsNamespaces = nil
        }
    }
}

/// Represents the output of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesOutput: Swift.Equatable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListRuleGroupsNamespaces request to retrieve those results.
    public var nextToken: Swift.String?
    /// The returned list of rule groups namespaces.
    /// This member is required.
    public var ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleGroupsNamespaces = ruleGroupsNamespaces
    }
}

struct ListRuleGroupsNamespacesOutputBody: Swift.Equatable {
    let ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]?
    let nextToken: Swift.String?
}

extension ListRuleGroupsNamespacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case ruleGroupsNamespaces
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupsNamespacesContainer = try containerValues.decodeIfPresent([AmpClientTypes.RuleGroupsNamespaceSummary?].self, forKey: .ruleGroupsNamespaces)
        var ruleGroupsNamespacesDecoded0:[AmpClientTypes.RuleGroupsNamespaceSummary]? = nil
        if let ruleGroupsNamespacesContainer = ruleGroupsNamespacesContainer {
            ruleGroupsNamespacesDecoded0 = [AmpClientTypes.RuleGroupsNamespaceSummary]()
            for structure0 in ruleGroupsNamespacesContainer {
                if let structure0 = structure0 {
                    ruleGroupsNamespacesDecoded0?.append(structure0)
                }
            }
        }
        ruleGroupsNamespaces = ruleGroupsNamespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRuleGroupsNamespacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScrapersInput {

    static func queryItemProvider(_ value: ListScrapersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filters = value.filters {
            let currentQueryItemNames = items.map({$0.name})
            filters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    value0.forEach { value1 in
                        let queryItem = ClientRuntime.SDKURLQueryItem(name: key0.urlPercentEncoding(), value: value1.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
        }
        return items
    }
}

extension ListScrapersInput {

    static func urlPathProvider(_ value: ListScrapersInput) -> Swift.String? {
        return "/scrapers"
    }
}

/// Represents the input of a ListScrapers operation.
public struct ListScrapersInput: Swift.Equatable {
    /// (Optional) A list of key-value pairs to filter the list of scrapers returned. Keys include status, sourceArn, destinationArn, and alias. Filters on the same key are OR'd together, and filters on different keys are AND'd together. For example, status=ACTIVE&status=CREATING&alias=Test, will return all scrapers that have the alias Test, and are either in status ACTIVE or CREATING. To find all active scrapers that are sending metrics to a specific Amazon Managed Service for Prometheus workspace, you would use the ARN of the workspace in a query: status=ACTIVE&destinationArn=arn:aws:aps:us-east-1:123456789012:workspace/ws-example1-1234-abcd-56ef-123456789012 If this is included, it filters the results to only the scrapers that match the filter.
    public var filters: [Swift.String:[Swift.String]]?
    /// Optional) The maximum number of scrapers to return in one ListScrapers operation. The range is 1-1000. If you omit this parameter, the default of 100 is used.
    public var maxResults: Swift.Int?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScrapersInputBody: Swift.Equatable {
}

extension ListScrapersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListScrapersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScrapersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scrapers = output.scrapers
        } else {
            self.nextToken = nil
            self.scrapers = nil
        }
    }
}

/// Represents the output of a ListScrapers operation.
public struct ListScrapersOutput: Swift.Equatable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListScrapers operation to retrieve those results.
    public var nextToken: Swift.String?
    /// A list of ScraperSummary structures giving information about scrapers in the account that match the filters provided.
    /// This member is required.
    public var scrapers: [AmpClientTypes.ScraperSummary]?

    public init(
        nextToken: Swift.String? = nil,
        scrapers: [AmpClientTypes.ScraperSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.scrapers = scrapers
    }
}

struct ListScrapersOutputBody: Swift.Equatable {
    let scrapers: [AmpClientTypes.ScraperSummary]?
    let nextToken: Swift.String?
}

extension ListScrapersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case scrapers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scrapersContainer = try containerValues.decodeIfPresent([AmpClientTypes.ScraperSummary?].self, forKey: .scrapers)
        var scrapersDecoded0:[AmpClientTypes.ScraperSummary]? = nil
        if let scrapersContainer = scrapersContainer {
            scrapersDecoded0 = [AmpClientTypes.ScraperSummary]()
            for structure0 in scrapersContainer {
                if let structure0 = structure0 {
                    scrapersDecoded0?.append(structure0)
                }
            }
        }
        scrapers = scrapersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListScrapersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to list tages for. Must be a workspace or rule groups namespace resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tag keys and values associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkspacesInput {

    static func queryItemProvider(_ value: ListWorkspacesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let alias = value.alias {
            let aliasQueryItem = ClientRuntime.SDKURLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        return items
    }
}

extension ListWorkspacesInput {

    static func urlPathProvider(_ value: ListWorkspacesInput) -> Swift.String? {
        return "/workspaces"
    }
}

/// Represents the input of a ListWorkspaces operation.
public struct ListWorkspacesInput: Swift.Equatable {
    /// If this is included, it filters the results to only the workspaces with names that start with the value that you specify here. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    public var alias: Swift.String?
    /// The maximum number of workspaces to return per request. The default is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 workspaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 workspaces.
    public var nextToken: Swift.String?

    public init(
        alias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alias = alias
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
}

extension ListWorkspacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

/// Represents the output of a ListWorkspaces operation.
public struct ListWorkspacesOutput: Swift.Equatable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListWorkspaces request to retrieve those results.
    public var nextToken: Swift.String?
    /// An array of WorkspaceSummary structures containing information about the workspaces requested.
    /// This member is required.
    public var workspaces: [AmpClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [AmpClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct ListWorkspacesOutputBody: Swift.Equatable {
    let workspaces: [AmpClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaces
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([AmpClientTypes.WorkspaceSummary?].self, forKey: .workspaces)
        var workspacesDecoded0:[AmpClientTypes.WorkspaceSummary]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [AmpClientTypes.WorkspaceSummary]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmpClientTypes.LoggingConfigurationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case logGroupArn
        case modifiedAt
        case status
        case workspace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workspace = self.workspace {
            try encodeContainer.encode(workspace, forKey: .workspace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.LoggingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let workspaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspace)
        workspace = workspaceDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension AmpClientTypes {
    /// Contains information about the logging configuration.
    public struct LoggingConfigurationMetadata: Swift.Equatable {
        /// The date and time that the logging configuration was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the CloudWatch log group to which the vended log data will be published.
        /// This member is required.
        public var logGroupArn: Swift.String?
        /// The date and time that the logging configuration was most recently changed.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The current status of the logging configuration.
        /// This member is required.
        public var status: AmpClientTypes.LoggingConfigurationStatus?
        /// The ID of the workspace the logging configuration is for.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            logGroupArn: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            status: AmpClientTypes.LoggingConfigurationStatus? = nil,
            workspace: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.logGroupArn = logGroupArn
            self.modifiedAt = modifiedAt
            self.status = status
            self.workspace = workspace
        }
    }

}

extension AmpClientTypes.LoggingConfigurationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.LoggingConfigurationStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AmpClientTypes {
    /// The status of the logging configuration.
    public struct LoggingConfigurationStatus: Swift.Equatable {
        /// The current status of the logging configuration.
        /// This member is required.
        public var statusCode: AmpClientTypes.LoggingConfigurationStatusCode?
        /// If failed, the reason for the failure.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.LoggingConfigurationStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension AmpClientTypes {
    /// State of a logging configuration.
    public enum LoggingConfigurationStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Logging configuration has been created/updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case active
        /// Logging configuration is being created. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Logging configuration creation failed.
        case creationFailed
        /// Logging configuration is being deleting. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Logging configuration update failed.
        case updateFailed
        /// Logging configuration is being updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingConfigurationStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingConfigurationStatusCode(rawValue: rawValue) ?? LoggingConfigurationStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension PutAlertManagerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

extension PutAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: PutAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

/// Represents the input of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The alert manager definition to use. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The ID of the workspace to update the alert manager definition in.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

struct PutAlertManagerDefinitionInputBody: Swift.Equatable {
    let data: ClientRuntime.Data?
    let clientToken: Swift.String?
}

extension PutAlertManagerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutAlertManagerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAlertManagerDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionOutput: Swift.Equatable {
    /// A structure that returns the current status of the alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init(
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

struct PutAlertManagerDefinitionOutputBody: Swift.Equatable {
    let status: AmpClientTypes.AlertManagerDefinitionStatus?
}

extension PutAlertManagerDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum PutAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRuleGroupsNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

extension PutRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: PutRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

/// Represents the input of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The new rules file to use in the namespace. A base64-encoded version of the YAML rule groups file. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The name of the rule groups namespace that you are updating.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace where you are updating the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct PutRuleGroupsNamespaceInputBody: Swift.Equatable {
    let data: ClientRuntime.Data?
    let clientToken: Swift.String?
}

extension PutRuleGroupsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutRuleGroupsNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRuleGroupsNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

/// Represents the output of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceOutput: Swift.Equatable {
    /// The ARN of the rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the rule groups namespace that was updated.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that includes the current status of the rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The list of tag keys and values that are associated with the namespace.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct PutRuleGroupsNamespaceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let status: AmpClientTypes.RuleGroupsNamespaceStatus?
    let tags: [Swift.String:Swift.String]?
}

extension PutRuleGroupsNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum PutRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resources that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AmpClientTypes.RuleGroupsNamespaceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case data
        case modifiedAt
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes {
    /// The details about one rule groups namespace.
    public struct RuleGroupsNamespaceDescription: Swift.Equatable {
        /// The ARN of the rule groups namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the rule groups namespace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The rule groups file used in the namespace. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The date and time that the rule groups namespace was most recently changed.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the rule groups namespace.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            data: ClientRuntime.Data? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension AmpClientTypes.RuleGroupsNamespaceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AmpClientTypes {
    /// The status information about a rule groups namespace.
    public struct RuleGroupsNamespaceStatus: Swift.Equatable {
        /// The current status of the namespace.
        /// This member is required.
        public var statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode?
        /// The reason for the failure, if any.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension AmpClientTypes {
    /// State of a namespace.
    public enum RuleGroupsNamespaceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Namespace creation failed.
        case creationFailed
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Namespace update failed.
        case updateFailed
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleGroupsNamespaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleGroupsNamespaceStatusCode(rawValue: rawValue) ?? RuleGroupsNamespaceStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.RuleGroupsNamespaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case modifiedAt
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes {
    /// The high-level information about a rule groups namespace. To retrieve more information, use DescribeRuleGroupsNamespace.
    public struct RuleGroupsNamespaceSummary: Swift.Equatable {
        /// The ARN of the rule groups namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the rule groups namespace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The date and time that the rule groups namespace was most recently changed.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the rule groups namespace.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that displays the current status of the rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension AmpClientTypes.ScrapeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationblob = "configurationBlob"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .configurationblob(configurationblob):
                try container.encode(configurationblob.base64EncodedString(), forKey: .configurationblob)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let configurationblobDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .configurationblob)
        if let configurationblob = configurationblobDecoded {
            self = .configurationblob(configurationblob)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmpClientTypes {
    /// A scrape configuration for a scraper, base 64 encoded. For more information, see [Scraper configuration] in the Amazon Managed Service for Prometheus User Guide.
    public enum ScrapeConfiguration: Swift.Equatable {
        /// The base 64 encoded scrape configuration file.
        case configurationblob(ClientRuntime.Data)
        case sdkUnknown(Swift.String)
    }

}

extension AmpClientTypes.ScraperDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case destination
        case lastModifiedAt
        case roleArn
        case scrapeConfiguration
        case scraperId
        case source
        case status
        case statusReason
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scrapeConfiguration = self.scrapeConfiguration {
            try encodeContainer.encode(scrapeConfiguration, forKey: .scrapeConfiguration)
        }
        if let scraperId = self.scraperId {
            try encodeContainer.encode(scraperId, forKey: .scraperId)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let scraperIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scraperId)
        scraperId = scraperIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let scrapeConfigurationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScrapeConfiguration.self, forKey: .scrapeConfiguration)
        scrapeConfiguration = scrapeConfigurationDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AmpClientTypes {
    /// The ScraperDescription structure contains the full details about one scraper in your account.
    public struct ScraperDescription: Swift.Equatable {
        /// (Optional) A name associated with the scraper.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the scraper.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the scraper was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        /// This member is required.
        public var destination: AmpClientTypes.Destination?
        /// The date and time that the scraper was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to discover and collect metrics on your behalf.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The configuration file in use by the scraper.
        /// This member is required.
        public var scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
        /// The ID of the scraper.
        /// This member is required.
        public var scraperId: Swift.String?
        /// The Amazon EKS cluster from which the scraper collects metrics.
        /// This member is required.
        public var source: AmpClientTypes.Source?
        /// A structure that contains the current status of the scraper.
        /// This member is required.
        public var status: AmpClientTypes.ScraperStatus?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public var tags: [Swift.String:Swift.String]?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destination: AmpClientTypes.Destination? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            scrapeConfiguration: AmpClientTypes.ScrapeConfiguration? = nil,
            scraperId: Swift.String? = nil,
            source: AmpClientTypes.Source? = nil,
            status: AmpClientTypes.ScraperStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scrapeConfiguration = scrapeConfiguration
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }
    }

}

extension AmpClientTypes.ScraperStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension AmpClientTypes {
    /// The ScraperStatus structure contains status information about the scraper.
    public struct ScraperStatus: Swift.Equatable {
        /// The current status of the scraper.
        /// This member is required.
        public var statusCode: AmpClientTypes.ScraperStatusCode?

        public init(
            statusCode: AmpClientTypes.ScraperStatusCode? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension AmpClientTypes {
    /// State of a scraper.
    public enum ScraperStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Scraper has been created and is usable.
        case active
        /// Scraper is being created. Deletion is disallowed until status is ACTIVE.
        case creating
        /// Scraper creation failed.
        case creationFailed
        /// Scraper is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting
        /// Scraper deletion failed.
        case deletionFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ScraperStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .deletionFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScraperStatusCode(rawValue: rawValue) ?? ScraperStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.ScraperSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case destination
        case lastModifiedAt
        case roleArn
        case scraperId
        case source
        case status
        case statusReason
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scraperId = self.scraperId {
            try encodeContainer.encode(scraperId, forKey: .scraperId)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let scraperIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scraperId)
        scraperId = scraperIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ScraperStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AmpClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AmpClientTypes {
    /// The ScraperSummary structure contains a summary of the details about one scraper in your account.
    public struct ScraperSummary: Swift.Equatable {
        /// (Optional) A name associated with the scraper.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the scraper.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the scraper was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        /// This member is required.
        public var destination: AmpClientTypes.Destination?
        /// The date and time that the scraper was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to discover and collect metrics on your behalf.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ID of the scraper.
        /// This member is required.
        public var scraperId: Swift.String?
        /// The Amazon EKS cluster from which the scraper collects metrics.
        /// This member is required.
        public var source: AmpClientTypes.Source?
        /// A structure that contains the current status of the scraper.
        /// This member is required.
        public var status: AmpClientTypes.ScraperStatus?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public var tags: [Swift.String:Swift.String]?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destination: AmpClientTypes.Destination? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            scraperId: Swift.String? = nil,
            source: AmpClientTypes.Source? = nil,
            status: AmpClientTypes.ScraperStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Completing the request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quotas code of the originating quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service quotas code for the originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension AmpClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksconfiguration = "eksConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eksconfiguration(eksconfiguration):
                try container.encode(eksconfiguration, forKey: .eksconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eksconfigurationDecoded = try values.decodeIfPresent(AmpClientTypes.EksConfiguration.self, forKey: .eksconfiguration)
        if let eksconfiguration = eksconfigurationDecoded {
            self = .eksconfiguration(eksconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmpClientTypes {
    /// The source of collected metrics for a scraper.
    public enum Source: Swift.Equatable {
        /// The Amazon EKS cluster from which a scraper collects metrics.
        case eksconfiguration(AmpClientTypes.EksConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the workspace or rule groups namespace to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values to associate with the resource. Keys may not begin with aws:.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quotas code for the originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Service quotas code for the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the workspace or rule groups namespace.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }
}

extension UpdateLoggingConfigurationInput {

    static func urlPathProvider(_ value: UpdateLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

/// Represents the input of an UpdateLoggingConfiguration operation.
public struct UpdateLoggingConfigurationInput: Swift.Equatable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ARN of the CloudWatch log group to which the vended log data will be published.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the workspace to update the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.logGroupArn = logGroupArn
        self.workspaceId = workspaceId
    }
}

struct UpdateLoggingConfigurationInputBody: Swift.Equatable {
    let logGroupArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case logGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of an UpdateLoggingConfiguration operation.
public struct UpdateLoggingConfigurationOutput: Swift.Equatable {
    /// A structure that contains the current status of the logging configuration.
    /// This member is required.
    public var status: AmpClientTypes.LoggingConfigurationStatus?

    public init(
        status: AmpClientTypes.LoggingConfigurationStatus? = nil
    )
    {
        self.status = status
    }
}

struct UpdateLoggingConfigurationOutputBody: Swift.Equatable {
    let status: AmpClientTypes.LoggingConfigurationStatus?
}

extension UpdateLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.LoggingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateWorkspaceAliasInput {

    static func urlPathProvider(_ value: UpdateWorkspaceAliasInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alias"
    }
}

/// Represents the input of an UpdateWorkspaceAlias operation.
public struct UpdateWorkspaceAliasInput: Swift.Equatable {
    /// The new alias for the workspace. It does not need to be unique. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    public var alias: Swift.String?
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceAliasInputBody: Swift.Equatable {
    let alias: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateWorkspaceAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateWorkspaceAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkspaceAliasOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkspaceAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [AmpClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: AmpClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AmpClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AmpClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AmpClientTypes.ValidationExceptionReason?
    let fieldList: [AmpClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AmpClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AmpClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AmpClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AmpClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmpClientTypes {
    /// Information about a field passed into a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message describing why the field caused an exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused an exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AmpClientTypes {
    /// Possible reasons a request failed validation.
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.WorkspaceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case kmsKeyArn
        case prometheusEndpoint
        case status
        case tags
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let prometheusEndpoint = self.prometheusEndpoint {
            try encodeContainer.encode(prometheusEndpoint, forKey: .prometheusEndpoint)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let prometheusEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prometheusEndpoint)
        prometheusEndpoint = prometheusEndpointDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension AmpClientTypes {
    /// The full details about one Amazon Managed Service for Prometheus workspace in your account.
    public struct WorkspaceDescription: Swift.Equatable {
        /// The alias that is assigned to this workspace to help identify it. It may not be unique.
        public var alias: Swift.String?
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the workspace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
        public var kmsKeyArn: Swift.String?
        /// The Prometheus endpoint available for this workspace.
        public var prometheusEndpoint: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The list of tag keys and values that are associated with the workspace.
        public var tags: [Swift.String:Swift.String]?
        /// The unique ID for the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            kmsKeyArn: Swift.String? = nil,
            prometheusEndpoint: Swift.String? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }

}

extension AmpClientTypes.WorkspaceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension AmpClientTypes {
    /// The status of the workspace.
    public struct WorkspaceStatus: Swift.Equatable {
        /// The current status of the workspace.
        /// This member is required.
        public var statusCode: AmpClientTypes.WorkspaceStatusCode?

        public init(
            statusCode: AmpClientTypes.WorkspaceStatusCode? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension AmpClientTypes {
    /// State of a workspace.
    public enum WorkspaceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Workspace has been created and is usable.
        case active
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceStatusCode(rawValue: rawValue) ?? WorkspaceStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case kmsKeyArn
        case status
        case tags
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension AmpClientTypes {
    /// The information about one Amazon Managed Service for Prometheus workspace in your account.
    public struct WorkspaceSummary: Swift.Equatable {
        /// The alias that is assigned to this workspace to help identify it. It may not be unique.
        public var alias: Swift.String?
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the workspace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
        public var kmsKeyArn: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The list of tag keys and values that are associated with the workspace.
        public var tags: [Swift.String:Swift.String]?
        /// The unique ID for the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            kmsKeyArn: Swift.String? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }

}
