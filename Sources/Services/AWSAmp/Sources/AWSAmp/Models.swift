//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAlertManagerDefinitionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLoggingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRuleGroupsNamespaceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkspaceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWorkspaceAliasOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request would cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred during the processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request references a resources that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Completing the request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quotas code of the originating quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service quotas code for the originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quotas code for the originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Service quotas code for the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension AmpClientTypes {

    /// Information about a field passed into a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why the field caused an exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused an exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension AmpClientTypes {

    /// Possible reasons a request failed validation.
    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [AmpClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: AmpClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AmpClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AmpClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// Represents the input of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The alert manager definition to add. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
    /// This member is required.
    public var data: Foundation.Data?
    /// The ID of the workspace to add the alert manager definition to.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Foundation.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// State of an AlertManagerDefinition.
    public enum AlertManagerDefinitionStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Definition creation failed.
        case creationFailed
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Definition update failed.
        case updateFailed
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertManagerDefinitionStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmpClientTypes {

    /// The status of the alert manager.
    public struct AlertManagerDefinitionStatus: Swift.Sendable {
        /// The current status of the alert manager.
        /// This member is required.
        public var statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }
}

/// Represents the output of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionOutput: Swift.Sendable {
    /// A structure that displays the current status of the alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init(
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

/// Represents the input of a DeleteAlertManagerDefinition operation.
public struct DeleteAlertManagerDefinitionInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to delete the alert manager definition from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

/// Represents the input of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionInput: Swift.Sendable {
    /// The ID of the workspace to retrieve the alert manager definition from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// The details of an alert manager definition. It is the configuration for the alert manager, including information about receivers for routing alerts.
    public struct AlertManagerDefinitionDescription: Swift.Sendable {
        /// The date and time that the alert manager definition was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The actual alert manager definition. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
        /// This member is required.
        public var data: Foundation.Data?
        /// The date and time that the alert manager definition was most recently changed.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// A structure that displays the current status of the alert manager definition..
        /// This member is required.
        public var status: AmpClientTypes.AlertManagerDefinitionStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            data: Foundation.Data? = nil,
            modifiedAt: Foundation.Date? = nil,
            status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }
    }
}

/// Represents the output of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionOutput: Swift.Sendable {
    /// The alert manager definition.
    /// This member is required.
    public var alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription?

    public init(
        alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription? = nil
    )
    {
        self.alertManagerDefinition = alertManagerDefinition
    }
}

/// Represents the input of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The alert manager definition to use. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see [AlertManagedDefinitionData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-AlertManagerDefinitionData.html).
    /// This member is required.
    public var data: Foundation.Data?
    /// The ID of the workspace to update the alert manager definition in.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Foundation.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

/// Represents the output of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionOutput: Swift.Sendable {
    /// A structure that returns the current status of the alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init(
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

/// Represents the input of a GetDefaultScraperConfiguration operation.
public struct GetDefaultScraperConfigurationInput: Swift.Sendable {

    public init() { }
}

/// Represents the output of a GetDefaultScraperConfiguration operation.
public struct GetDefaultScraperConfigurationOutput: Swift.Sendable {
    /// The configuration file. Base 64 encoded. For more information, see [Scraper configuration](https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-collector-how-to.html#AMP-collector-configuration)in the Amazon Managed Service for Prometheus User Guide.
    /// This member is required.
    public var configuration: Foundation.Data?

    public init(
        configuration: Foundation.Data? = nil
    )
    {
        self.configuration = configuration
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource to list tages for. Must be a workspace, scraper, or rule groups namespace resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tag keys and values associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension AmpClientTypes {

    /// The AmpConfiguration structure defines the Amazon Managed Service for Prometheus instance a scraper should send metrics to.
    public struct AmpConfiguration: Swift.Sendable {
        /// ARN of the Amazon Managed Service for Prometheus workspace.
        /// This member is required.
        public var workspaceArn: Swift.String?

        public init(
            workspaceArn: Swift.String? = nil
        )
        {
            self.workspaceArn = workspaceArn
        }
    }
}

extension AmpClientTypes {

    /// Where to send the metrics from a scraper.
    public enum Destination: Swift.Sendable {
        /// The Amazon Managed Service for Prometheus workspace to send metrics to.
        case ampconfiguration(AmpClientTypes.AmpConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension AmpClientTypes {

    /// A scrape configuration for a scraper, base 64 encoded. For more information, see [Scraper configuration](https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-collector-how-to.html#AMP-collector-configuration) in the Amazon Managed Service for Prometheus User Guide.
    public enum ScrapeConfiguration: Swift.Sendable {
        /// The base 64 encoded scrape configuration file.
        case configurationblob(Foundation.Data)
        case sdkUnknown(Swift.String)
    }
}

extension AmpClientTypes {

    /// The EksConfiguration structure describes the connection to the Amazon EKS cluster from which a scraper collects metrics.
    public struct EksConfiguration: Swift.Sendable {
        /// ARN of the Amazon EKS cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// A list of the security group IDs for the Amazon EKS cluster VPC configuration.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs for the Amazon EKS cluster VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            clusterArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.clusterArn = clusterArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

extension AmpClientTypes {

    /// The source of collected metrics for a scraper.
    public enum Source: Swift.Sendable {
        /// The Amazon EKS cluster from which a scraper collects metrics.
        case eksconfiguration(AmpClientTypes.EksConfiguration)
        case sdkUnknown(Swift.String)
    }
}

/// Represents the input of a CreateScraper operation.
public struct CreateScraperInput: Swift.Sendable {
    /// (optional) An alias to associate with the scraper. This is for your use, and does not need to be unique.
    public var alias: Swift.String?
    /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Managed Service for Prometheus workspace to send metrics to.
    /// This member is required.
    public var destination: AmpClientTypes.Destination?
    /// The configuration file to use in the new scraper. For more information, see [Scraper configuration](https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-collector-how-to.html#AMP-collector-configuration) in the Amazon Managed Service for Prometheus User Guide.
    /// This member is required.
    public var scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
    /// The Amazon EKS cluster from which the scraper will collect metrics.
    /// This member is required.
    public var source: AmpClientTypes.Source?
    /// (Optional) The list of tag keys and values to associate with the scraper.
    public var tags: [Swift.String: Swift.String]?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destination: AmpClientTypes.Destination? = nil,
        scrapeConfiguration: AmpClientTypes.ScrapeConfiguration? = nil,
        source: AmpClientTypes.Source? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.destination = destination
        self.scrapeConfiguration = scrapeConfiguration
        self.source = source
        self.tags = tags
    }
}

extension AmpClientTypes {

    /// State of a scraper.
    public enum ScraperStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Scraper has been created and is usable.
        case active
        /// Scraper is being created. Deletion is disallowed until status is ACTIVE.
        case creating
        /// Scraper creation failed.
        case creationFailed
        /// Scraper is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting
        /// Scraper deletion failed.
        case deletionFailed
        /// Scraper update failed.
        case updateFailed
        /// Scraper is being updated. Deletion is disallowed until status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ScraperStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .deletionFailed,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmpClientTypes {

    /// The ScraperStatus structure contains status information about the scraper.
    public struct ScraperStatus: Swift.Sendable {
        /// The current status of the scraper.
        /// This member is required.
        public var statusCode: AmpClientTypes.ScraperStatusCode?

        public init(
            statusCode: AmpClientTypes.ScraperStatusCode? = nil
        )
        {
            self.statusCode = statusCode
        }
    }
}

/// Represents the output of a CreateScraper operation.
public struct CreateScraperOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new scraper.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the new scraper.
    /// This member is required.
    public var scraperId: Swift.String?
    /// A structure that displays the current status of the scraper.
    /// This member is required.
    public var status: AmpClientTypes.ScraperStatus?
    /// The list of tag keys and values that are associated with the scraper.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        scraperId: Swift.String? = nil,
        status: AmpClientTypes.ScraperStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.scraperId = scraperId
        self.status = status
        self.tags = tags
    }
}

/// Represents the input of a DeleteScraper operation.
public struct DeleteScraperInput: Swift.Sendable {
    /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the scraper to delete.
    /// This member is required.
    public var scraperId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        scraperId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.scraperId = scraperId
    }
}

/// Represents the output of a DeleteScraper operation.
public struct DeleteScraperOutput: Swift.Sendable {
    /// The ID of the scraper to delete.
    /// This member is required.
    public var scraperId: Swift.String?
    /// The current status of the scraper.
    /// This member is required.
    public var status: AmpClientTypes.ScraperStatus?

    public init(
        scraperId: Swift.String? = nil,
        status: AmpClientTypes.ScraperStatus? = nil
    )
    {
        self.scraperId = scraperId
        self.status = status
    }
}

/// Represents the input of a DescribeScraper operation.
public struct DescribeScraperInput: Swift.Sendable {
    /// The ID of the scraper to describe.
    /// This member is required.
    public var scraperId: Swift.String?

    public init(
        scraperId: Swift.String? = nil
    )
    {
        self.scraperId = scraperId
    }
}

extension AmpClientTypes {

    /// The ScraperDescription structure contains the full details about one scraper in your account.
    public struct ScraperDescription: Swift.Sendable {
        /// (Optional) A name associated with the scraper.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the scraper. For example, arn:aws:aps:<region>:123456798012:scraper/s-example1-1234-abcd-5678-ef9012abcd34.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the scraper was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        /// This member is required.
        public var destination: AmpClientTypes.Destination?
        /// The date and time that the scraper was last modified.
        /// This member is required.
        public var lastModifiedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to discover and collect metrics on your behalf. For example, arn:aws:iam::123456789012:role/service-role/AmazonGrafanaServiceRole-12example.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The configuration in use by the scraper.
        /// This member is required.
        public var scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
        /// The ID of the scraper. For example, s-example1-1234-abcd-5678-ef9012abcd34.
        /// This member is required.
        public var scraperId: Swift.String?
        /// The Amazon EKS cluster from which the scraper collects metrics.
        /// This member is required.
        public var source: AmpClientTypes.Source?
        /// A structure that contains the current status of the scraper.
        /// This member is required.
        public var status: AmpClientTypes.ScraperStatus?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public var tags: [Swift.String: Swift.String]?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            destination: AmpClientTypes.Destination? = nil,
            lastModifiedAt: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            scrapeConfiguration: AmpClientTypes.ScrapeConfiguration? = nil,
            scraperId: Swift.String? = nil,
            source: AmpClientTypes.Source? = nil,
            status: AmpClientTypes.ScraperStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scrapeConfiguration = scrapeConfiguration
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }
    }
}

/// Represents the output of a DescribeScraper operation.
public struct DescribeScraperOutput: Swift.Sendable {
    /// Contains details about the scraper.
    /// This member is required.
    public var scraper: AmpClientTypes.ScraperDescription?

    public init(
        scraper: AmpClientTypes.ScraperDescription? = nil
    )
    {
        self.scraper = scraper
    }
}

/// Represents the input of a ListScrapers operation.
public struct ListScrapersInput: Swift.Sendable {
    /// (Optional) A list of key-value pairs to filter the list of scrapers returned. Keys include status, sourceArn, destinationArn, and alias. Filters on the same key are OR'd together, and filters on different keys are AND'd together. For example, status=ACTIVE&status=CREATING&alias=Test, will return all scrapers that have the alias Test, and are either in status ACTIVE or CREATING. To find all active scrapers that are sending metrics to a specific Amazon Managed Service for Prometheus workspace, you would use the ARN of the workspace in a query: status=ACTIVE&destinationArn=arn:aws:aps:us-east-1:123456789012:workspace/ws-example1-1234-abcd-56ef-123456789012 If this is included, it filters the results to only the scrapers that match the filter.
    public var filters: [Swift.String: [Swift.String]]?
    /// Optional) The maximum number of scrapers to return in one ListScrapers operation. The range is 1-1000. If you omit this parameter, the default of 100 is used.
    public var maxResults: Swift.Int?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AmpClientTypes {

    /// The ScraperSummary structure contains a summary of the details about one scraper in your account.
    public struct ScraperSummary: Swift.Sendable {
        /// (Optional) A name associated with the scraper.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the scraper.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the scraper was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        /// This member is required.
        public var destination: AmpClientTypes.Destination?
        /// The date and time that the scraper was last modified.
        /// This member is required.
        public var lastModifiedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to discover and collect metrics on your behalf.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ID of the scraper.
        /// This member is required.
        public var scraperId: Swift.String?
        /// The Amazon EKS cluster from which the scraper collects metrics.
        /// This member is required.
        public var source: AmpClientTypes.Source?
        /// A structure that contains the current status of the scraper.
        /// This member is required.
        public var status: AmpClientTypes.ScraperStatus?
        /// If there is a failure, the reason for the failure.
        public var statusReason: Swift.String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public var tags: [Swift.String: Swift.String]?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            destination: AmpClientTypes.Destination? = nil,
            lastModifiedAt: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            scraperId: Swift.String? = nil,
            source: AmpClientTypes.Source? = nil,
            status: AmpClientTypes.ScraperStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }
    }
}

/// Represents the output of a ListScrapers operation.
public struct ListScrapersOutput: Swift.Sendable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListScrapers operation to retrieve those results.
    public var nextToken: Swift.String?
    /// A list of ScraperSummary structures giving information about scrapers in the account that match the filters provided.
    /// This member is required.
    public var scrapers: [AmpClientTypes.ScraperSummary]?

    public init(
        nextToken: Swift.String? = nil,
        scrapers: [AmpClientTypes.ScraperSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.scrapers = scrapers
    }
}

public struct UpdateScraperInput: Swift.Sendable {
    /// The new alias of the scraper.
    public var alias: Swift.String?
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The new Amazon Managed Service for Prometheus workspace to send metrics to.
    public var destination: AmpClientTypes.Destination?
    /// Contains the base-64 encoded YAML configuration for the scraper. For more information about configuring a scraper, see [Using an Amazon Web Services managed collector](https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-collector-how-to.html) in the Amazon Managed Service for Prometheus User Guide.
    public var scrapeConfiguration: AmpClientTypes.ScrapeConfiguration?
    /// The ID of the scraper to update.
    /// This member is required.
    public var scraperId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destination: AmpClientTypes.Destination? = nil,
        scrapeConfiguration: AmpClientTypes.ScrapeConfiguration? = nil,
        scraperId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.destination = destination
        self.scrapeConfiguration = scrapeConfiguration
        self.scraperId = scraperId
    }
}

public struct UpdateScraperOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated scraper.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the updated scraper.
    /// This member is required.
    public var scraperId: Swift.String?
    /// A structure that displays the current status of the scraper.
    /// This member is required.
    public var status: AmpClientTypes.ScraperStatus?
    /// The list of tag keys and values that are associated with the scraper.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        scraperId: Swift.String? = nil,
        status: AmpClientTypes.ScraperStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.scraperId = scraperId
        self.status = status
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values to associate with the resource. Keys must not begin with aws:.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource from which to remove a tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Represents the input of a CreateWorkspace operation.
public struct CreateWorkspaceInput: Swift.Sendable {
    /// An alias that you assign to this workspace to help you identify it. It does not need to be unique. Blank spaces at the beginning or end of the alias that you specify will be trimmed from the value used.
    public var alias: Swift.String?
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// (optional) The ARN for a customer managed KMS key to use for encrypting data within your workspace. For more information about using your own key in your workspace, see [Encryption at rest](https://docs.aws.amazon.com/prometheus/latest/userguide/encryption-at-rest-Amazon-Service-Prometheus.html) in the Amazon Managed Service for Prometheus User Guide.
    public var kmsKeyArn: Swift.String?
    /// The list of tag keys and values to associate with the workspace.
    public var tags: [Swift.String: Swift.String]?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

extension AmpClientTypes {

    /// State of a workspace.
    public enum WorkspaceStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Workspace has been created and is usable.
        case active
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmpClientTypes {

    /// The status of the workspace.
    public struct WorkspaceStatus: Swift.Sendable {
        /// The current status of the workspace.
        /// This member is required.
        public var statusCode: AmpClientTypes.WorkspaceStatusCode?

        public init(
            statusCode: AmpClientTypes.WorkspaceStatusCode? = nil
        )
        {
            self.statusCode = statusCode
        }
    }
}

/// Represents the output of a CreateWorkspace operation.
public struct CreateWorkspaceOutput: Swift.Sendable {
    /// The ARN for the new workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
    public var kmsKeyArn: Swift.String?
    /// The current status of the new workspace. Immediately after you create the workspace, the status is usually CREATING.
    /// This member is required.
    public var status: AmpClientTypes.WorkspaceStatus?
    /// The list of tag keys and values that are associated with the workspace.
    public var tags: [Swift.String: Swift.String]?
    /// The unique ID for the new workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        status: AmpClientTypes.WorkspaceStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.kmsKeyArn = kmsKeyArn
        self.status = status
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

/// Represents the input of a DeleteWorkspace operation.
public struct DeleteWorkspaceInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

/// Represents the input of a DescribeWorkspace operation.
public struct DescribeWorkspaceInput: Swift.Sendable {
    /// The ID of the workspace to describe.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// The full details about one Amazon Managed Service for Prometheus workspace in your account.
    public struct WorkspaceDescription: Swift.Sendable {
        /// The alias that is assigned to this workspace to help identify it. It does not need to be unique.
        public var alias: Swift.String?
        /// The ARN of the workspace. For example, arn:aws:aps:<region>:123456789012:workspace/ws-example1-1234-abcd-5678-ef90abcd1234.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the workspace was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
        public var kmsKeyArn: Swift.String?
        /// The Prometheus endpoint available for this workspace. For example, https://aps-workspaces.<region>.amazonaws.com/workspaces/ws-example1-1234-abcd-5678-ef90abcd1234/api/v1/.
        public var prometheusEndpoint: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The list of tag keys and values that are associated with the workspace.
        public var tags: [Swift.String: Swift.String]?
        /// The unique ID for the workspace. For example, ws-example1-1234-abcd-5678-ef90abcd1234.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            kmsKeyArn: Swift.String? = nil,
            prometheusEndpoint: Swift.String? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }
}

/// Represents the output of a DescribeWorkspace operation.
public struct DescribeWorkspaceOutput: Swift.Sendable {
    /// A structure that contains details about the workspace.
    /// This member is required.
    public var workspace: AmpClientTypes.WorkspaceDescription?

    public init(
        workspace: AmpClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

/// Represents the input of a ListWorkspaces operation.
public struct ListWorkspacesInput: Swift.Sendable {
    /// If this is included, it filters the results to only the workspaces with names that start with the value that you specify here. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    public var alias: Swift.String?
    /// The maximum number of workspaces to return per request. The default is 100.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 workspaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 workspaces.
    public var nextToken: Swift.String?

    public init(
        alias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alias = alias
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AmpClientTypes {

    /// The information about one Amazon Managed Service for Prometheus workspace in your account.
    public struct WorkspaceSummary: Swift.Sendable {
        /// The alias that is assigned to this workspace to help identify it. It does not need to be unique.
        public var alias: Swift.String?
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the workspace was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// (optional) If the workspace was created with a customer managed KMS key, the ARN for the key used.
        public var kmsKeyArn: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The list of tag keys and values that are associated with the workspace.
        public var tags: [Swift.String: Swift.String]?
        /// The unique ID for the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            kmsKeyArn: Swift.String? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }
}

/// Represents the output of a ListWorkspaces operation.
public struct ListWorkspacesOutput: Swift.Sendable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListWorkspaces request to retrieve those results.
    public var nextToken: Swift.String?
    /// An array of WorkspaceSummary structures containing information about the workspaces requested.
    /// This member is required.
    public var workspaces: [AmpClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [AmpClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

/// Represents the input of a CreateLoggingConfiguration operation.
public struct CreateLoggingConfigurationInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist prior to calling this operation.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the workspace to create the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.logGroupArn = logGroupArn
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// State of a logging configuration.
    public enum LoggingConfigurationStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Logging configuration has been created/updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case active
        /// Logging configuration is being created. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Logging configuration creation failed.
        case creationFailed
        /// Logging configuration is being deleting. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Logging configuration update failed.
        case updateFailed
        /// Logging configuration is being updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingConfigurationStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmpClientTypes {

    /// The status of the logging configuration.
    public struct LoggingConfigurationStatus: Swift.Sendable {
        /// The current status of the logging configuration.
        /// This member is required.
        public var statusCode: AmpClientTypes.LoggingConfigurationStatusCode?
        /// If failed, the reason for the failure.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.LoggingConfigurationStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }
}

/// Represents the output of a CreateLoggingConfiguration operation.
public struct CreateLoggingConfigurationOutput: Swift.Sendable {
    /// A structure that displays the current status of the logging configuration.
    /// This member is required.
    public var status: AmpClientTypes.LoggingConfigurationStatus?

    public init(
        status: AmpClientTypes.LoggingConfigurationStatus? = nil
    )
    {
        self.status = status
    }
}

/// Represents the input of a DeleteLoggingConfiguration operation.
public struct DeleteLoggingConfigurationInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace containing the logging configuration to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

/// Represents the input of a DescribeLoggingConfiguration operation.
public struct DescribeLoggingConfigurationInput: Swift.Sendable {
    /// The ID of the workspace to describe the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// Contains information about the logging configuration for the workspace.
    public struct LoggingConfigurationMetadata: Swift.Sendable {
        /// The date and time that the logging configuration was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ARN of the CloudWatch log group to which the vended log data will be published.
        /// This member is required.
        public var logGroupArn: Swift.String?
        /// The date and time that the logging configuration was most recently changed.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// The current status of the logging configuration.
        /// This member is required.
        public var status: AmpClientTypes.LoggingConfigurationStatus?
        /// The ID of the workspace the logging configuration is for.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            logGroupArn: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            status: AmpClientTypes.LoggingConfigurationStatus? = nil,
            workspace: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.logGroupArn = logGroupArn
            self.modifiedAt = modifiedAt
            self.status = status
            self.workspace = workspace
        }
    }
}

/// Represents the output of a DescribeLoggingConfiguration operation.
public struct DescribeLoggingConfigurationOutput: Swift.Sendable {
    /// A structure that displays the information about the logging configuration.
    /// This member is required.
    public var loggingConfiguration: AmpClientTypes.LoggingConfigurationMetadata?

    public init(
        loggingConfiguration: AmpClientTypes.LoggingConfigurationMetadata? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

/// Represents the input of an UpdateLoggingConfiguration operation.
public struct UpdateLoggingConfigurationInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ARN of the CloudWatch log group to which the vended log data will be published.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the workspace to update the logging configuration for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        logGroupArn: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.logGroupArn = logGroupArn
        self.workspaceId = workspaceId
    }
}

/// Represents the output of an UpdateLoggingConfiguration operation.
public struct UpdateLoggingConfigurationOutput: Swift.Sendable {
    /// A structure that contains the current status of the logging configuration.
    /// This member is required.
    public var status: AmpClientTypes.LoggingConfigurationStatus?

    public init(
        status: AmpClientTypes.LoggingConfigurationStatus? = nil
    )
    {
        self.status = status
    }
}

/// Represents the input of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The rules file to use in the new namespace. Contains the base64-encoded version of the YAML rules file. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
    /// This member is required.
    public var data: Foundation.Data?
    /// The name for the new rule groups namespace.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tag keys and values to associate with the rule groups namespace.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the workspace to add the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Foundation.Data? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// State of a namespace.
    public enum RuleGroupsNamespaceStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Namespace creation failed.
        case creationFailed
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Namespace update failed.
        case updateFailed
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleGroupsNamespaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmpClientTypes {

    /// The status information about a rule groups namespace.
    public struct RuleGroupsNamespaceStatus: Swift.Sendable {
        /// The current status of the namespace.
        /// This member is required.
        public var statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode?
        /// The reason for the failure, if any.
        public var statusReason: Swift.String?

        public init(
            statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }
}

/// Represents the output of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the new rule groups namespace.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that returns the current status of the rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The list of tag keys and values that are associated with the namespace.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

/// Represents the input of a DeleteRuleGroupsNamespace operation.
public struct DeleteRuleGroupsNamespaceInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The name of the rule groups namespace to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace containing the rule groups namespace and definition to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.workspaceId = workspaceId
    }
}

/// Represents the input of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceInput: Swift.Sendable {
    /// The name of the rule groups namespace that you want information for.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace containing the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.name = name
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// The details about one rule groups namespace.
    public struct RuleGroupsNamespaceDescription: Swift.Sendable {
        /// The ARN of the rule groups namespace. For example, arn:aws:aps:<region>:123456789012:rulegroupsnamespace/ws-example1-1234-abcd-5678-ef90abcd1234/rulesfile1.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the rule groups namespace was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The rule groups file used in the namespace. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
        /// This member is required.
        public var data: Foundation.Data?
        /// The date and time that the rule groups namespace was most recently changed.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// The name of the rule groups namespace.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            data: Foundation.Data? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }
}

/// Represents the output of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceOutput: Swift.Sendable {
    /// The information about the rule groups namespace.
    /// This member is required.
    public var ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription?

    public init(
        ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription? = nil
    )
    {
        self.ruleGroupsNamespace = ruleGroupsNamespace
    }
}

/// Represents the input of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesInput: Swift.Sendable {
    /// The maximum number of results to return. The default is 100.
    public var maxResults: Swift.Int?
    /// Use this parameter to filter the rule groups namespaces that are returned. Only the namespaces with names that begin with the value that you specify are returned.
    public var name: Swift.String?
    /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 rule groups namespaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 namespaces.
    public var nextToken: Swift.String?
    /// The ID of the workspace containing the rule groups namespaces.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension AmpClientTypes {

    /// The high-level information about a rule groups namespace. To retrieve more information, use DescribeRuleGroupsNamespace.
    public struct RuleGroupsNamespaceSummary: Swift.Sendable {
        /// The ARN of the rule groups namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the rule groups namespace was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date and time that the rule groups namespace was most recently changed.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// The name of the rule groups namespace.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that displays the current status of the rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }
}

/// Represents the output of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesOutput: Swift.Sendable {
    /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListRuleGroupsNamespaces request to retrieve those results.
    public var nextToken: Swift.String?
    /// The returned list of rule groups namespaces.
    /// This member is required.
    public var ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleGroupsNamespaces = ruleGroupsNamespaces
    }
}

/// Represents the input of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceInput: Swift.Sendable {
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The new rules file to use in the namespace. A base64-encoded version of the YAML rule groups file. For details about the rule groups namespace structure, see [RuleGroupsNamespaceData](https://docs.aws.amazon.com/prometheus/latest/APIReference/yaml-RuleGroupsNamespaceData.html).
    /// This member is required.
    public var data: Foundation.Data?
    /// The name of the rule groups namespace that you are updating.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace where you are updating the rule groups namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Foundation.Data? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.workspaceId = workspaceId
    }
}

/// Represents the output of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceOutput: Swift.Sendable {
    /// The ARN of the rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the rule groups namespace that was updated.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that includes the current status of the rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The list of tag keys and values that are associated with the namespace.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

/// Represents the input of an UpdateWorkspaceAlias operation.
public struct UpdateWorkspaceAliasInput: Swift.Sendable {
    /// The new alias for the workspace. It does not need to be unique. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    public var alias: Swift.String?
    /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    public var clientToken: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

extension CreateAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: CreateAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

extension CreateLoggingConfigurationInput {

    static func urlPathProvider(_ value: CreateLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

extension CreateRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: CreateRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
    }
}

extension CreateScraperInput {

    static func urlPathProvider(_ value: CreateScraperInput) -> Swift.String? {
        return "/scrapers"
    }
}

extension CreateWorkspaceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInput) -> Swift.String? {
        return "/workspaces"
    }
}

extension DeleteAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: DeleteAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

extension DeleteAlertManagerDefinitionInput {

    static func queryItemProvider(_ value: DeleteAlertManagerDefinitionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

extension DeleteLoggingConfigurationInput {

    static func queryItemProvider(_ value: DeleteLoggingConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: DeleteRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

extension DeleteRuleGroupsNamespaceInput {

    static func queryItemProvider(_ value: DeleteRuleGroupsNamespaceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteScraperInput {

    static func urlPathProvider(_ value: DeleteScraperInput) -> Swift.String? {
        guard let scraperId = value.scraperId else {
            return nil
        }
        return "/scrapers/\(scraperId.urlPercentEncoding())"
    }
}

extension DeleteScraperInput {

    static func queryItemProvider(_ value: DeleteScraperInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteWorkspaceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension DeleteWorkspaceInput {

    static func queryItemProvider(_ value: DeleteWorkspaceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DescribeAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: DescribeAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

extension DescribeLoggingConfigurationInput {

    static func urlPathProvider(_ value: DescribeLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

extension DescribeRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: DescribeRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

extension DescribeScraperInput {

    static func urlPathProvider(_ value: DescribeScraperInput) -> Swift.String? {
        guard let scraperId = value.scraperId else {
            return nil
        }
        return "/scrapers/\(scraperId.urlPercentEncoding())"
    }
}

extension DescribeWorkspaceInput {

    static func urlPathProvider(_ value: DescribeWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension GetDefaultScraperConfigurationInput {

    static func urlPathProvider(_ value: GetDefaultScraperConfigurationInput) -> Swift.String? {
        return "/scraperconfiguration"
    }
}

extension ListRuleGroupsNamespacesInput {

    static func urlPathProvider(_ value: ListRuleGroupsNamespacesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
    }
}

extension ListRuleGroupsNamespacesInput {

    static func queryItemProvider(_ value: ListRuleGroupsNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListScrapersInput {

    static func urlPathProvider(_ value: ListScrapersInput) -> Swift.String? {
        return "/scrapers"
    }
}

extension ListScrapersInput {

    static func queryItemProvider(_ value: ListScrapersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filters = value.filters {
            let currentQueryItemNames = items.map({$0.name})
            filters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    value0.forEach { value1 in
                        let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value1.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorkspacesInput {

    static func urlPathProvider(_ value: ListWorkspacesInput) -> Swift.String? {
        return "/workspaces"
    }
}

extension ListWorkspacesInput {

    static func queryItemProvider(_ value: ListWorkspacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let alias = value.alias {
            let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        return items
    }
}

extension PutAlertManagerDefinitionInput {

    static func urlPathProvider(_ value: PutAlertManagerDefinitionInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
    }
}

extension PutRuleGroupsNamespaceInput {

    static func urlPathProvider(_ value: PutRuleGroupsNamespaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLoggingConfigurationInput {

    static func urlPathProvider(_ value: UpdateLoggingConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/logging"
    }
}

extension UpdateScraperInput {

    static func urlPathProvider(_ value: UpdateScraperInput) -> Swift.String? {
        guard let scraperId = value.scraperId else {
            return nil
        }
        return "/scrapers/\(scraperId.urlPercentEncoding())"
    }
}

extension UpdateWorkspaceAliasInput {

    static func urlPathProvider(_ value: UpdateWorkspaceAliasInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/alias"
    }
}

extension CreateAlertManagerDefinitionInput {

    static func write(value: CreateAlertManagerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
    }
}

extension CreateLoggingConfigurationInput {

    static func write(value: CreateLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["logGroupArn"].write(value.logGroupArn)
    }
}

extension CreateRuleGroupsNamespaceInput {

    static func write(value: CreateRuleGroupsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateScraperInput {

    static func write(value: CreateScraperInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alias"].write(value.alias)
        try writer["clientToken"].write(value.clientToken)
        try writer["destination"].write(value.destination, with: AmpClientTypes.Destination.write(value:to:))
        try writer["scrapeConfiguration"].write(value.scrapeConfiguration, with: AmpClientTypes.ScrapeConfiguration.write(value:to:))
        try writer["source"].write(value.source, with: AmpClientTypes.Source.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorkspaceInput {

    static func write(value: CreateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alias"].write(value.alias)
        try writer["clientToken"].write(value.clientToken)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutAlertManagerDefinitionInput {

    static func write(value: PutAlertManagerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
    }
}

extension PutRuleGroupsNamespaceInput {

    static func write(value: PutRuleGroupsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLoggingConfigurationInput {

    static func write(value: UpdateLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["logGroupArn"].write(value.logGroupArn)
    }
}

extension UpdateScraperInput {

    static func write(value: UpdateScraperInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alias"].write(value.alias)
        try writer["clientToken"].write(value.clientToken)
        try writer["destination"].write(value.destination, with: AmpClientTypes.Destination.write(value:to:))
        try writer["scrapeConfiguration"].write(value.scrapeConfiguration, with: AmpClientTypes.ScrapeConfiguration.write(value:to:))
    }
}

extension UpdateWorkspaceAliasInput {

    static func write(value: UpdateWorkspaceAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alias"].write(value.alias)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateAlertManagerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAlertManagerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAlertManagerDefinitionOutput()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.AlertManagerDefinitionStatus.read(from:))
        return value
    }
}

extension CreateLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggingConfigurationOutput()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.LoggingConfigurationStatus.read(from:))
        return value
    }
}

extension CreateRuleGroupsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleGroupsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleGroupsNamespaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.RuleGroupsNamespaceStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateScraperOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScraperOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScraperOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.scraperId = try reader["scraperId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.ScraperStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.WorkspaceStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAlertManagerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAlertManagerDefinitionOutput {
        return DeleteAlertManagerDefinitionOutput()
    }
}

extension DeleteLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoggingConfigurationOutput {
        return DeleteLoggingConfigurationOutput()
    }
}

extension DeleteRuleGroupsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleGroupsNamespaceOutput {
        return DeleteRuleGroupsNamespaceOutput()
    }
}

extension DeleteScraperOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteScraperOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteScraperOutput()
        value.scraperId = try reader["scraperId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.ScraperStatus.read(from:))
        return value
    }
}

extension DeleteWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceOutput {
        return DeleteWorkspaceOutput()
    }
}

extension DescribeAlertManagerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAlertManagerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAlertManagerDefinitionOutput()
        value.alertManagerDefinition = try reader["alertManagerDefinition"].readIfPresent(with: AmpClientTypes.AlertManagerDefinitionDescription.read(from:))
        return value
    }
}

extension DescribeLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLoggingConfigurationOutput()
        value.loggingConfiguration = try reader["loggingConfiguration"].readIfPresent(with: AmpClientTypes.LoggingConfigurationMetadata.read(from:))
        return value
    }
}

extension DescribeRuleGroupsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRuleGroupsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRuleGroupsNamespaceOutput()
        value.ruleGroupsNamespace = try reader["ruleGroupsNamespace"].readIfPresent(with: AmpClientTypes.RuleGroupsNamespaceDescription.read(from:))
        return value
    }
}

extension DescribeScraperOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeScraperOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeScraperOutput()
        value.scraper = try reader["scraper"].readIfPresent(with: AmpClientTypes.ScraperDescription.read(from:))
        return value
    }
}

extension DescribeWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: AmpClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension GetDefaultScraperConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultScraperConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultScraperConfigurationOutput()
        value.configuration = try reader["configuration"].readIfPresent() ?? Foundation.Data("".utf8)
        return value
    }
}

extension ListRuleGroupsNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRuleGroupsNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRuleGroupsNamespacesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.ruleGroupsNamespaces = try reader["ruleGroupsNamespaces"].readListIfPresent(memberReadingClosure: AmpClientTypes.RuleGroupsNamespaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListScrapersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScrapersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScrapersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scrapers = try reader["scrapers"].readListIfPresent(memberReadingClosure: AmpClientTypes.ScraperSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspacesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workspaces = try reader["workspaces"].readListIfPresent(memberReadingClosure: AmpClientTypes.WorkspaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutAlertManagerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAlertManagerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAlertManagerDefinitionOutput()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.AlertManagerDefinitionStatus.read(from:))
        return value
    }
}

extension PutRuleGroupsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRuleGroupsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRuleGroupsNamespaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.RuleGroupsNamespaceStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLoggingConfigurationOutput()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.LoggingConfigurationStatus.read(from:))
        return value
    }
}

extension UpdateScraperOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScraperOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateScraperOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.scraperId = try reader["scraperId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.ScraperStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateWorkspaceAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceAliasOutput {
        return UpdateWorkspaceAliasOutput()
    }
}

enum CreateAlertManagerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleGroupsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScraperOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAlertManagerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleGroupsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteScraperOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAlertManagerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRuleGroupsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeScraperOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultScraperConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRuleGroupsNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScrapersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAlertManagerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRuleGroupsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScraperOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: AmpClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AmpClientTypes.AlertManagerDefinitionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.AlertManagerDefinitionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.AlertManagerDefinitionStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AmpClientTypes.LoggingConfigurationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.LoggingConfigurationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.LoggingConfigurationStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AmpClientTypes.RuleGroupsNamespaceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.RuleGroupsNamespaceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.RuleGroupsNamespaceStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension AmpClientTypes.ScraperStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.ScraperStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.ScraperStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AmpClientTypes.WorkspaceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.WorkspaceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.WorkspaceStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AmpClientTypes.AlertManagerDefinitionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.AlertManagerDefinitionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.AlertManagerDefinitionDescription()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.AlertManagerDefinitionStatus.read(from:))
        value.data = try reader["data"].readIfPresent() ?? Foundation.Data("".utf8)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AmpClientTypes.LoggingConfigurationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.LoggingConfigurationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.LoggingConfigurationMetadata()
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.LoggingConfigurationStatus.read(from:))
        value.workspace = try reader["workspace"].readIfPresent() ?? ""
        value.logGroupArn = try reader["logGroupArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AmpClientTypes.RuleGroupsNamespaceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.RuleGroupsNamespaceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.RuleGroupsNamespaceDescription()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.RuleGroupsNamespaceStatus.read(from:))
        value.data = try reader["data"].readIfPresent() ?? Foundation.Data("".utf8)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AmpClientTypes.ScraperDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.ScraperDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.ScraperDescription()
        value.alias = try reader["alias"].readIfPresent()
        value.scraperId = try reader["scraperId"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.ScraperStatus.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedAt = try reader["lastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.scrapeConfiguration = try reader["scrapeConfiguration"].readIfPresent(with: AmpClientTypes.ScrapeConfiguration.read(from:))
        value.source = try reader["source"].readIfPresent(with: AmpClientTypes.Source.read(from:))
        value.destination = try reader["destination"].readIfPresent(with: AmpClientTypes.Destination.read(from:))
        return value
    }
}

extension AmpClientTypes.Destination {

    static func write(value: AmpClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ampconfiguration(ampconfiguration):
                try writer["ampConfiguration"].write(ampconfiguration, with: AmpClientTypes.AmpConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ampConfiguration":
                return .ampconfiguration(try reader["ampConfiguration"].read(with: AmpClientTypes.AmpConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AmpClientTypes.AmpConfiguration {

    static func write(value: AmpClientTypes.AmpConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workspaceArn"].write(value.workspaceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.AmpConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.AmpConfiguration()
        value.workspaceArn = try reader["workspaceArn"].readIfPresent() ?? ""
        return value
    }
}

extension AmpClientTypes.Source {

    static func write(value: AmpClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .eksconfiguration(eksconfiguration):
                try writer["eksConfiguration"].write(eksconfiguration, with: AmpClientTypes.EksConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "eksConfiguration":
                return .eksconfiguration(try reader["eksConfiguration"].read(with: AmpClientTypes.EksConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AmpClientTypes.EksConfiguration {

    static func write(value: AmpClientTypes.EksConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusterArn"].write(value.clusterArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.EksConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.EksConfiguration()
        value.clusterArn = try reader["clusterArn"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AmpClientTypes.ScrapeConfiguration {

    static func write(value: AmpClientTypes.ScrapeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .configurationblob(configurationblob):
                try writer["configurationBlob"].write(configurationblob)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.ScrapeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "configurationBlob":
                return .configurationblob(try reader["configurationBlob"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AmpClientTypes.WorkspaceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.WorkspaceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.WorkspaceDescription()
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        value.alias = try reader["alias"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.WorkspaceStatus.read(from:))
        value.prometheusEndpoint = try reader["prometheusEndpoint"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension AmpClientTypes.RuleGroupsNamespaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.RuleGroupsNamespaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.RuleGroupsNamespaceSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.RuleGroupsNamespaceStatus.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AmpClientTypes.ScraperSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.ScraperSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.ScraperSummary()
        value.alias = try reader["alias"].readIfPresent()
        value.scraperId = try reader["scraperId"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.ScraperStatus.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedAt = try reader["lastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: AmpClientTypes.Source.read(from:))
        value.destination = try reader["destination"].readIfPresent(with: AmpClientTypes.Destination.read(from:))
        return value
    }
}

extension AmpClientTypes.WorkspaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.WorkspaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.WorkspaceSummary()
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        value.alias = try reader["alias"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: AmpClientTypes.WorkspaceStatus.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension AmpClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AmpClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmpClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum AmpClientTypes {}
