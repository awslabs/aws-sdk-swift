//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension SsmSapClientTypes {

    public enum AllocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case elasticIp
        case overlay
        case unknown
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [AllocationType] {
            return [
                .elasticIp,
                .overlay,
                .unknown,
                .vpcSubnet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .elasticIp: return "ELASTIC_IP"
            case .overlay: return "OVERLAY"
            case .unknown: return "UNKNOWN"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum ApplicationDiscoveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case refreshFailed
        case registering
        case registrationFailed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationDiscoveryStatus] {
            return [
                .deleting,
                .refreshFailed,
                .registering,
                .registrationFailed,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .refreshFailed: return "REFRESH_FAILED"
            case .registering: return "REGISTERING"
            case .registrationFailed: return "REGISTRATION_FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum ApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deleting
        case failed
        case registering
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .activated,
                .deleting,
                .failed,
                .registering,
                .starting,
                .stopped,
                .stopping,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registering: return "REGISTERING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum ApplicationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hana
        case sapAbap
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationType] {
            return [
                .hana,
                .sapAbap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hana: return "HANA"
            case .sapAbap: return "SAP_ABAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// An SAP application registered with AWS Systems Manager for SAP.
    public struct Application: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Application Registry.
        public var appRegistryArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The Amazon Resource Names of the associated AWS Systems Manager for SAP applications.
        public var associatedApplicationArns: [Swift.String]?
        /// The components of the application.
        public var components: [Swift.String]?
        /// The latest discovery result for the application.
        public var discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus?
        /// The ID of the application.
        public var id: Swift.String?
        /// The time at which the application was last updated.
        public var lastUpdated: Foundation.Date?
        /// The status of the application.
        public var status: SsmSapClientTypes.ApplicationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The type of the application.
        public var type: SsmSapClientTypes.ApplicationType?

        public init(
            appRegistryArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            associatedApplicationArns: [Swift.String]? = nil,
            components: [Swift.String]? = nil,
            discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            status: SsmSapClientTypes.ApplicationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.appRegistryArn = appRegistryArn
            self.arn = arn
            self.associatedApplicationArns = associatedApplicationArns
            self.components = components
            self.discoveryStatus = discoveryStatus
            self.id = id
            self.lastUpdated = lastUpdated
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }
}

extension SsmSapClientTypes {

    public enum CredentialType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialType] {
            return [
                .admin
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// The credentials of your SAP application.
    public struct ApplicationCredential: Swift.Sendable {
        /// The type of the application credentials.
        /// This member is required.
        public var credentialType: SsmSapClientTypes.CredentialType?
        /// The name of the SAP HANA database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The secret ID created in AWS Secrets Manager to store the credentials of the SAP application.
        /// This member is required.
        public var secretId: Swift.String?

        public init(
            credentialType: SsmSapClientTypes.CredentialType? = nil,
            databaseName: Swift.String? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.credentialType = credentialType
            self.databaseName = databaseName
            self.secretId = secretId
        }
    }
}

extension SsmSapClientTypes.ApplicationCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationCredential(credentialType: \(Swift.String(describing: credentialType)), databaseName: \(Swift.String(describing: databaseName)), secretId: \"CONTENT_REDACTED\")"}
}

extension SsmSapClientTypes {

    /// The summary of the SAP application registered with AWS Systems Manager for SAP.
    public struct ApplicationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The status of the latest discovery.
        public var discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus?
        /// The ID of the application.
        public var id: Swift.String?
        /// The tags on the application.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the application.
        public var type: SsmSapClientTypes.ApplicationType?

        public init(
            arn: Swift.String? = nil,
            discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.arn = arn
            self.discoveryStatus = discoveryStatus
            self.id = id
            self.tags = tags
            self.type = type
        }
    }
}

extension SsmSapClientTypes {

    /// Provides information of the IP address.
    public struct IpAddressMember: Swift.Sendable {
        /// The type of allocation for the IP address.
        public var allocationType: SsmSapClientTypes.AllocationType?
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The primary IP address.
        public var primary: Swift.Bool?

        public init(
            allocationType: SsmSapClientTypes.AllocationType? = nil,
            ipAddress: Swift.String? = nil,
            primary: Swift.Bool? = nil
        )
        {
            self.allocationType = allocationType
            self.ipAddress = ipAddress
            self.primary = primary
        }
    }
}

extension SsmSapClientTypes {

    /// Describes the properties of the associated host.
    public struct AssociatedHost: Swift.Sendable {
        /// The ID of the Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// The name of the host.
        public var hostname: Swift.String?
        /// The IP addresses of the associated host.
        public var ipAddresses: [SsmSapClientTypes.IpAddressMember]?
        /// The version of the operating system.
        public var osVersion: Swift.String?

        public init(
            ec2InstanceId: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipAddresses: [SsmSapClientTypes.IpAddressMember]? = nil,
            osVersion: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.hostname = hostname
            self.ipAddresses = ipAddresses
            self.osVersion = osVersion
        }
    }
}

extension SsmSapClientTypes {

    public enum BackintMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsbackup
        case sdkUnknown(Swift.String)

        public static var allCases: [BackintMode] {
            return [
                .awsbackup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsbackup: return "AWSBackup"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// Configuration parameters for AWS Backint Agent for SAP HANA. You can backup your SAP HANA database with AWS Backup or Amazon S3.
    public struct BackintConfig: Swift.Sendable {
        /// AWS service for your database backup.
        /// This member is required.
        public var backintMode: SsmSapClientTypes.BackintMode?
        ///
        /// This member is required.
        public var ensureNoBackupInProcess: Swift.Bool?

        public init(
            backintMode: SsmSapClientTypes.BackintMode? = nil,
            ensureNoBackupInProcess: Swift.Bool? = nil
        )
        {
            self.backintMode = backintMode
            self.ensureNoBackupInProcess = ensureNoBackupInProcess
        }
    }
}

extension SsmSapClientTypes {

    public enum ClusterStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case maintenance
        case `none`
        case offline
        case online
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterStatus] {
            return [
                .maintenance,
                .none,
                .offline,
                .online,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .maintenance: return "MAINTENANCE"
            case .none: return "NONE"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum ComponentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abap
        case ascs
        case dialog
        case ers
        case hana
        case hanaNode
        case wd
        case webdisp
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .abap,
                .ascs,
                .dialog,
                .ers,
                .hana,
                .hanaNode,
                .wd,
                .webdisp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abap: return "ABAP"
            case .ascs: return "ASCS"
            case .dialog: return "DIALOG"
            case .ers: return "ERS"
            case .hana: return "HANA"
            case .hanaNode: return "HANA_NODE"
            case .wd: return "WD"
            case .webdisp: return "WEBDISP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum DatabaseConnectionMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case direct
        case overlay
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseConnectionMethod] {
            return [
                .direct,
                .overlay
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .direct: return "DIRECT"
            case .overlay: return "OVERLAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// The connection specifications for the database.
    public struct DatabaseConnection: Swift.Sendable {
        /// The IP address for connection.
        public var connectionIp: Swift.String?
        /// The Amazon Resource Name of the connected SAP HANA database.
        public var databaseArn: Swift.String?
        /// The method of connection.
        public var databaseConnectionMethod: SsmSapClientTypes.DatabaseConnectionMethod?

        public init(
            connectionIp: Swift.String? = nil,
            databaseArn: Swift.String? = nil,
            databaseConnectionMethod: SsmSapClientTypes.DatabaseConnectionMethod? = nil
        )
        {
            self.connectionIp = connectionIp
            self.databaseArn = databaseArn
            self.databaseConnectionMethod = databaseConnectionMethod
        }
    }
}

extension SsmSapClientTypes {

    public enum HostRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case leader
        case standby
        case unknown
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [HostRole] {
            return [
                .leader,
                .standby,
                .unknown,
                .worker
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .leader: return "LEADER"
            case .standby: return "STANDBY"
            case .unknown: return "UNKNOWN"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// Describes the properties of the Dedicated Host.
    public struct Host: Swift.Sendable {
        /// The ID of Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// The IP address of the Dedicated Host.
        public var hostIp: Swift.String?
        /// The name of the Dedicated Host.
        public var hostName: Swift.String?
        /// The role of the Dedicated Host.
        public var hostRole: SsmSapClientTypes.HostRole?
        /// The instance ID of the instance on the Dedicated Host.
        public var instanceId: Swift.String?
        /// The version of the operating system.
        public var osVersion: Swift.String?

        public init(
            ec2InstanceId: Swift.String? = nil,
            hostIp: Swift.String? = nil,
            hostName: Swift.String? = nil,
            hostRole: SsmSapClientTypes.HostRole? = nil,
            instanceId: Swift.String? = nil,
            osVersion: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.hostIp = hostIp
            self.hostName = hostName
            self.hostRole = hostRole
            self.instanceId = instanceId
            self.osVersion = osVersion
        }
    }
}

extension SsmSapClientTypes {

    public enum OperationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deltaDatashipping
        case logreplay
        case logreplayReadaccess
        case `none`
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationMode] {
            return [
                .deltaDatashipping,
                .logreplay,
                .logreplayReadaccess,
                .none,
                .primary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deltaDatashipping: return "DELTA_DATASHIPPING"
            case .logreplay: return "LOGREPLAY"
            case .logreplayReadaccess: return "LOGREPLAY_READACCESS"
            case .none: return "NONE"
            case .primary: return "PRIMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum ReplicationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case async
        case `none`
        case primary
        case sync
        case syncmem
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationMode] {
            return [
                .async,
                .none,
                .primary,
                .sync,
                .syncmem
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case .none: return "NONE"
            case .primary: return "PRIMARY"
            case .sync: return "SYNC"
            case .syncmem: return "SYNCMEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// Details of the SAP HANA system replication for the instance.
    public struct Resilience: Swift.Sendable {
        /// The cluster status of the component.
        public var clusterStatus: SsmSapClientTypes.ClusterStatus?
        /// Indicates if or not enqueue replication is enabled for the ASCS component.
        public var enqueueReplication: Swift.Bool?
        /// The operation mode of the component.
        public var hsrOperationMode: SsmSapClientTypes.OperationMode?
        /// The replication mode of the component.
        public var hsrReplicationMode: SsmSapClientTypes.ReplicationMode?
        /// The tier of the component.
        public var hsrTier: Swift.String?

        public init(
            clusterStatus: SsmSapClientTypes.ClusterStatus? = nil,
            enqueueReplication: Swift.Bool? = nil,
            hsrOperationMode: SsmSapClientTypes.OperationMode? = nil,
            hsrReplicationMode: SsmSapClientTypes.ReplicationMode? = nil,
            hsrTier: Swift.String? = nil
        )
        {
            self.clusterStatus = clusterStatus
            self.enqueueReplication = enqueueReplication
            self.hsrOperationMode = hsrOperationMode
            self.hsrReplicationMode = hsrReplicationMode
            self.hsrTier = hsrTier
        }
    }
}

extension SsmSapClientTypes {

    public enum ComponentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case running
        case runningWithError
        case starting
        case stopped
        case stopping
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .activated,
                .running,
                .runningWithError,
                .starting,
                .stopped,
                .stopping,
                .undefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .running: return "RUNNING"
            case .runningWithError: return "RUNNING_WITH_ERROR"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .undefined: return "UNDEFINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// The SAP component of your application.
    public struct Component: Swift.Sendable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The associated host of the component.
        public var associatedHost: SsmSapClientTypes.AssociatedHost?
        /// The child components of a highly available environment. For example, in a highly available SAP on AWS workload, the child component consists of the primary and secondar instances.
        public var childComponents: [Swift.String]?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The type of the component.
        public var componentType: SsmSapClientTypes.ComponentType?
        /// The connection specifications for the database of the component.
        public var databaseConnection: SsmSapClientTypes.DatabaseConnection?
        /// The SAP HANA databases of the component.
        public var databases: [Swift.String]?
        /// The SAP HANA version of the component.
        public var hdbVersion: Swift.String?
        /// The hosts of the component.
        @available(*, deprecated, message: "This shape is no longer used. Please use AssociatedHost.")
        public var hosts: [SsmSapClientTypes.Host]?
        /// The time at which the component was last updated.
        public var lastUpdated: Foundation.Date?
        /// The parent component of a highly available environment. For example, in a highly available SAP on AWS workload, the parent component consists of the entire setup, including the child components.
        public var parentComponent: Swift.String?
        /// The primary host of the component.
        @available(*, deprecated, message: "This shape is no longer used. Please use AssociatedHost.")
        public var primaryHost: Swift.String?
        /// Details of the SAP HANA system replication for the component.
        public var resilience: SsmSapClientTypes.Resilience?
        /// The SAP feature of the component.
        public var sapFeature: Swift.String?
        /// The hostname of the component.
        public var sapHostname: Swift.String?
        /// The kernel version of the component.
        public var sapKernelVersion: Swift.String?
        /// The SAP System Identifier of the application component.
        public var sid: Swift.String?
        /// The status of the component.
        ///
        /// * ACTIVATED - this status has been deprecated.
        ///
        /// * STARTING - the component is in the process of being started.
        ///
        /// * STOPPED - the component is not running.
        ///
        /// * STOPPING - the component is in the process of being stopped.
        ///
        /// * RUNNING - the component is running.
        ///
        /// * RUNNING_WITH_ERROR - one or more child component(s) of the parent component is not running. Call [GetComponent](https://docs.aws.amazon.com/ssmsap/latest/APIReference/API_GetComponent.html) to review the status of each child component.
        ///
        /// * UNDEFINED - AWS Systems Manager for SAP cannot provide the component status based on the discovered information. Verify your SAP application.
        public var status: SsmSapClientTypes.ComponentStatus?
        /// The SAP system number of the application component.
        public var systemNumber: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            associatedHost: SsmSapClientTypes.AssociatedHost? = nil,
            childComponents: [Swift.String]? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            databaseConnection: SsmSapClientTypes.DatabaseConnection? = nil,
            databases: [Swift.String]? = nil,
            hdbVersion: Swift.String? = nil,
            hosts: [SsmSapClientTypes.Host]? = nil,
            lastUpdated: Foundation.Date? = nil,
            parentComponent: Swift.String? = nil,
            primaryHost: Swift.String? = nil,
            resilience: SsmSapClientTypes.Resilience? = nil,
            sapFeature: Swift.String? = nil,
            sapHostname: Swift.String? = nil,
            sapKernelVersion: Swift.String? = nil,
            sid: Swift.String? = nil,
            status: SsmSapClientTypes.ComponentStatus? = nil,
            systemNumber: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.associatedHost = associatedHost
            self.childComponents = childComponents
            self.componentId = componentId
            self.componentType = componentType
            self.databaseConnection = databaseConnection
            self.databases = databases
            self.hdbVersion = hdbVersion
            self.hosts = hosts
            self.lastUpdated = lastUpdated
            self.parentComponent = parentComponent
            self.primaryHost = primaryHost
            self.resilience = resilience
            self.sapFeature = sapFeature
            self.sapHostname = sapHostname
            self.sapKernelVersion = sapKernelVersion
            self.sid = sid
            self.status = status
            self.systemNumber = systemNumber
        }
    }
}

extension SsmSapClientTypes {

    /// The summary of the component.
    public struct ComponentSummary: Swift.Sendable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the component summary.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The type of the component.
        public var componentType: SsmSapClientTypes.ComponentType?
        /// The tags of the component.
        public var tags: [Swift.String: Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.componentType = componentType
            self.tags = tags
        }
    }
}

/// A conflict has occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SsmSapClientTypes {

    public enum ConnectedEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dbms
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectedEntityType] {
            return [
                .dbms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dbms: return "DBMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum DatabaseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case system
        case tenant
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseType] {
            return [
                .system,
                .tenant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .tenant: return "TENANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    public enum DatabaseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case running
        case starting
        case stopped
        case unknown
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseStatus] {
            return [
                .error,
                .running,
                .starting,
                .stopped,
                .unknown,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// The SAP HANA database of the application registered with AWS Systems Manager for SAP.
    public struct Database: Swift.Sendable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the database.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The Amazon Resource Names of the connected AWS Systems Manager for SAP components.
        public var connectedComponentArns: [Swift.String]?
        /// The credentials of the database.
        public var credentials: [SsmSapClientTypes.ApplicationCredential]?
        /// The ID of the SAP HANA database.
        public var databaseId: Swift.String?
        /// The name of the database.
        public var databaseName: Swift.String?
        /// The type of the database.
        public var databaseType: SsmSapClientTypes.DatabaseType?
        /// The time at which the database was last updated.
        public var lastUpdated: Foundation.Date?
        /// The primary host of the database.
        public var primaryHost: Swift.String?
        /// The SQL port of the database.
        public var sqlPort: Swift.Int?
        /// The status of the database.
        public var status: SsmSapClientTypes.DatabaseStatus?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            connectedComponentArns: [Swift.String]? = nil,
            credentials: [SsmSapClientTypes.ApplicationCredential]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            lastUpdated: Foundation.Date? = nil,
            primaryHost: Swift.String? = nil,
            sqlPort: Swift.Int? = nil,
            status: SsmSapClientTypes.DatabaseStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.connectedComponentArns = connectedComponentArns
            self.credentials = credentials
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.databaseType = databaseType
            self.lastUpdated = lastUpdated
            self.primaryHost = primaryHost
            self.sqlPort = sqlPort
            self.status = status
        }
    }
}

extension SsmSapClientTypes {

    /// The summary of the database.
    public struct DatabaseSummary: Swift.Sendable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the database.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The ID of the database.
        public var databaseId: Swift.String?
        /// The type of the database.
        public var databaseType: SsmSapClientTypes.DatabaseType?
        /// The tags of the database.
        public var tags: [Swift.String: Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.databaseId = databaseId
            self.databaseType = databaseType
            self.tags = tags
        }
    }
}

/// An internal error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource is not available.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SsmSapClientTypes {

    public enum PermissionActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case restore
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionActionType] {
            return [
                .restore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .restore: return "RESTORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteResourcePermissionInput: Swift.Sendable {
    /// Delete or restore the permissions on the target database.
    public var actionType: SsmSapClientTypes.PermissionActionType?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the source resource.
    public var sourceResourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

public struct DeleteResourcePermissionOutput: Swift.Sendable {
    /// The policy that removes permissions on the target database.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

/// The request is not authorized.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterApplicationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeregisterApplicationOutput: Swift.Sendable {

    public init() { }
}

extension SsmSapClientTypes {

    public enum FilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case greaterThanOrEquals
        case lessThanOrEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals,
                .greaterThanOrEquals,
                .lessThanOrEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "Equals"
            case .greaterThanOrEquals: return "GreaterThanOrEquals"
            case .lessThanOrEquals: return "LessThanOrEquals"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// A specific result obtained by specifying the name, value, and operator.
    public struct Filter: Swift.Sendable {
        /// The name of the filter. Filter names are case-sensitive.
        /// This member is required.
        public var name: Swift.String?
        /// The operator for the filter.
        /// This member is required.
        public var `operator`: SsmSapClientTypes.FilterOperator?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: SsmSapClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

public struct GetApplicationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application registry.
    public var appRegistryArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationArn: Swift.String?
    /// The ID of the application.
    public var applicationId: Swift.String?

    public init(
        appRegistryArn: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.appRegistryArn = appRegistryArn
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

public struct GetApplicationOutput: Swift.Sendable {
    /// Returns all of the metadata of an application registered with AWS Systems Manager for SAP.
    public var application: SsmSapClientTypes.Application?
    /// The tags of a registered application.
    public var tags: [Swift.String: Swift.String]?

    public init(
        application: SsmSapClientTypes.Application? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.application = application
        self.tags = tags
    }
}

public struct GetComponentInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the component.
    /// This member is required.
    public var componentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
    }
}

public struct GetComponentOutput: Swift.Sendable {
    /// The component of an application registered with AWS Systems Manager for SAP.
    public var component: SsmSapClientTypes.Component?
    /// The tags of a component.
    public var tags: [Swift.String: Swift.String]?

    public init(
        component: SsmSapClientTypes.Component? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.component = component
        self.tags = tags
    }
}

public struct GetDatabaseInput: Swift.Sendable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The ID of the component.
    public var componentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the database.
    public var databaseArn: Swift.String?
    /// The ID of the database.
    public var databaseId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        databaseArn: Swift.String? = nil,
        databaseId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.databaseArn = databaseArn
        self.databaseId = databaseId
    }
}

public struct GetDatabaseOutput: Swift.Sendable {
    /// The SAP HANA database of an application registered with AWS Systems Manager for SAP.
    public var database: SsmSapClientTypes.Database?
    /// The tags of a database.
    public var tags: [Swift.String: Swift.String]?

    public init(
        database: SsmSapClientTypes.Database? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.database = database
        self.tags = tags
    }
}

public struct GetOperationInput: Swift.Sendable {
    /// The ID of the operation.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension SsmSapClientTypes {

    public enum OperationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case inprogress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .error,
                .inprogress,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .inprogress: return "INPROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// The operations performed by AWS Systems Manager for SAP.
    public struct Operation: Swift.Sendable {
        /// The end time of the operation.
        public var endTime: Foundation.Date?
        /// The ID of the operation.
        public var id: Swift.String?
        /// The time at which the operation was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The properties of the operation.
        public var properties: [Swift.String: Swift.String?]?
        /// The Amazon Resource Name (ARN) of the operation.
        public var resourceArn: Swift.String?
        /// The resource ID of the operation.
        public var resourceId: Swift.String?
        /// The resource type of the operation.
        public var resourceType: Swift.String?
        /// The start time of the operation.
        public var startTime: Foundation.Date?
        /// The status of the operation.
        public var status: SsmSapClientTypes.OperationStatus?
        /// The status message of the operation.
        public var statusMessage: Swift.String?
        /// The type of the operation.
        public var type: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            properties: [Swift.String: Swift.String?]? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: SsmSapClientTypes.OperationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.properties = properties
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }
}

public struct GetOperationOutput: Swift.Sendable {
    /// Returns the details of an operation.
    public var operation: SsmSapClientTypes.Operation?

    public init(
        operation: SsmSapClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

public struct GetResourcePermissionInput: Swift.Sendable {
    ///
    public var actionType: SsmSapClientTypes.PermissionActionType?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePermissionOutput: Swift.Sendable {
    ///
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct ListApplicationsInput: Swift.Sendable {
    /// The filter of name, value, and operator.
    public var filters: [SsmSapClientTypes.Filter]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SsmSapClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 50,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput: Swift.Sendable {
    /// The applications registered with AWS Systems Manager for SAP.
    public var applications: [SsmSapClientTypes.ApplicationSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        applications: [SsmSapClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct ListComponentsInput: Swift.Sendable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = 50,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListComponentsOutput: Swift.Sendable {
    /// List of components registered with AWS System Manager for SAP.
    public var components: [SsmSapClientTypes.ComponentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        components: [SsmSapClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

public struct ListDatabasesInput: Swift.Sendable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The ID of the component.
    public var componentId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        maxResults: Swift.Int? = 50,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDatabasesOutput: Swift.Sendable {
    /// The SAP HANA databases of an application.
    public var databases: [SsmSapClientTypes.DatabaseSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        databases: [SsmSapClientTypes.DatabaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

public struct ListOperationEventsInput: Swift.Sendable {
    /// Optionally specify filters to narrow the returned operation event items. Valid filter names include status, resourceID, and resourceType. The valid operator for all three filters is Equals.
    public var filters: [SsmSapClientTypes.Filter]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The ID of the operation.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        filters: [SsmSapClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 50,
        nextToken: Swift.String? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operationId = operationId
    }
}

extension SsmSapClientTypes {

    /// The resource contains a ResourceArn and the ResourceType.
    public struct Resource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the source resource. Example of ResourceArn: "arn:aws:ec2:us-east-1:111111111111:instance/i-abcdefgh987654321"
        public var resourceArn: Swift.String?
        /// The resource type. Example of ResourceType: "AWS::SystemsManagerSAP::Component" or "AWS::EC2::Instance".
        public var resourceType: Swift.String?

        public init(
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }
}

extension SsmSapClientTypes {

    public enum OperationEventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationEventStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SsmSapClientTypes {

    /// An operation event returns details for an operation, including key milestones which can be used to monitor and track operations in progress. Operation events contain:
    ///
    /// * Description string
    ///
    /// * Resource, including its ARN and type
    ///
    /// * Status
    ///
    /// * StatusMessage string
    ///
    /// * TimeStamp
    ///
    ///
    /// Operation event examples include StartApplication or StopApplication.
    public struct OperationEvent: Swift.Sendable {
        /// A description of the operation event. For example, "Stop the EC2 instance i-abcdefgh987654321".
        public var description: Swift.String?
        /// The resource involved in the operations event. Contains ResourceArn ARN and ResourceType.
        public var resource: SsmSapClientTypes.Resource?
        /// The status of the operation event. The possible statuses are: IN_PROGRESS, COMPLETED, and FAILED.
        public var status: SsmSapClientTypes.OperationEventStatus?
        /// The status message relating to a specific operation event.
        public var statusMessage: Swift.String?
        /// The timestamp of the specified operation event.
        public var timestamp: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            resource: SsmSapClientTypes.Resource? = nil,
            status: SsmSapClientTypes.OperationEventStatus? = nil,
            statusMessage: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.description = description
            self.resource = resource
            self.status = status
            self.statusMessage = statusMessage
            self.timestamp = timestamp
        }
    }
}

public struct ListOperationEventsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A returned list of operation events that meet the filter criteria.
    public var operationEvents: [SsmSapClientTypes.OperationEvent]?

    public init(
        nextToken: Swift.String? = nil,
        operationEvents: [SsmSapClientTypes.OperationEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationEvents = operationEvents
    }
}

public struct ListOperationsInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The filters of an operation.
    public var filters: [SsmSapClientTypes.Filter]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        filters: [SsmSapClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 50,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOperationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// List of operations performed by AWS Systems Manager for SAP.
    public var operations: [SsmSapClientTypes.Operation]?

    public init(
        nextToken: Swift.String? = nil,
        operations: [SsmSapClientTypes.Operation]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    ///
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutResourcePermissionInput: Swift.Sendable {
    ///
    /// This member is required.
    public var actionType: SsmSapClientTypes.PermissionActionType?
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var sourceResourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

public struct PutResourcePermissionOutput: Swift.Sendable {
    ///
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct RegisterApplicationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The type of the application.
    /// This member is required.
    public var applicationType: SsmSapClientTypes.ApplicationType?
    /// The credentials of the SAP application.
    public var credentials: [SsmSapClientTypes.ApplicationCredential]?
    /// The Amazon Resource Name of the SAP HANA database.
    public var databaseArn: Swift.String?
    /// The Amazon EC2 instances on which your SAP application is running.
    /// This member is required.
    public var instances: [Swift.String]?
    /// The SAP instance number of the application.
    public var sapInstanceNumber: Swift.String?
    /// The System ID of the application.
    public var sid: Swift.String?
    /// The tags to be attached to the SAP application.
    public var tags: [Swift.String: Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        applicationType: SsmSapClientTypes.ApplicationType? = nil,
        credentials: [SsmSapClientTypes.ApplicationCredential]? = [],
        databaseArn: Swift.String? = nil,
        instances: [Swift.String]? = nil,
        sapInstanceNumber: Swift.String? = nil,
        sid: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationType = applicationType
        self.credentials = credentials
        self.databaseArn = databaseArn
        self.instances = instances
        self.sapInstanceNumber = sapInstanceNumber
        self.sid = sid
        self.tags = tags
    }
}

public struct RegisterApplicationOutput: Swift.Sendable {
    /// The application registered with AWS Systems Manager for SAP.
    public var application: SsmSapClientTypes.Application?
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        application: SsmSapClientTypes.Application? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.application = application
        self.operationId = operationId
    }
}

public struct StartApplicationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct StartApplicationOutput: Swift.Sendable {
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct StartApplicationRefreshInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct StartApplicationRefreshOutput: Swift.Sendable {
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct StopApplicationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Boolean. If included and if set to True, the StopApplication operation will shut down the associated Amazon EC2 instance in addition to the application.
    public var includeEc2InstanceShutdown: Swift.Bool?
    /// Specify the ConnectedEntityType. Accepted type is DBMS. If this parameter is included, the connected DBMS (Database Management System) will be stopped.
    public var stopConnectedEntity: SsmSapClientTypes.ConnectedEntityType?

    public init(
        applicationId: Swift.String? = nil,
        includeEc2InstanceShutdown: Swift.Bool? = nil,
        stopConnectedEntity: SsmSapClientTypes.ConnectedEntityType? = nil
    )
    {
        self.applicationId = applicationId
        self.includeEc2InstanceShutdown = includeEc2InstanceShutdown
        self.stopConnectedEntity = stopConnectedEntity
    }
}

public struct StopApplicationOutput: Swift.Sendable {
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags on a resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds/updates or removes credentials for applications registered with AWS Systems Manager for SAP.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateApplicationSettingsInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Installation of AWS Backint Agent for SAP HANA.
    public var backint: SsmSapClientTypes.BackintConfig?
    /// The credentials to be added or updated.
    public var credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]?
    /// The credentials to be removed.
    public var credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]?
    /// The Amazon Resource Name of the SAP HANA database that replaces the current SAP HANA connection with the SAP_ABAP application.
    public var databaseArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        backint: SsmSapClientTypes.BackintConfig? = nil,
        credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]? = nil,
        credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]? = nil,
        databaseArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.backint = backint
        self.credentialsToAddOrUpdate = credentialsToAddOrUpdate
        self.credentialsToRemove = credentialsToRemove
        self.databaseArn = databaseArn
    }
}

public struct UpdateApplicationSettingsOutput: Swift.Sendable {
    /// The update message.
    public var message: Swift.String?
    /// The IDs of the operations.
    public var operationIds: [Swift.String]?

    public init(
        message: Swift.String? = nil,
        operationIds: [Swift.String]? = nil
    )
    {
        self.message = message
        self.operationIds = operationIds
    }
}

extension DeleteResourcePermissionInput {

    static func urlPathProvider(_ value: DeleteResourcePermissionInput) -> Swift.String? {
        return "/delete-resource-permission"
    }
}

extension DeregisterApplicationInput {

    static func urlPathProvider(_ value: DeregisterApplicationInput) -> Swift.String? {
        return "/deregister-application"
    }
}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        return "/get-application"
    }
}

extension GetComponentInput {

    static func urlPathProvider(_ value: GetComponentInput) -> Swift.String? {
        return "/get-component"
    }
}

extension GetDatabaseInput {

    static func urlPathProvider(_ value: GetDatabaseInput) -> Swift.String? {
        return "/get-database"
    }
}

extension GetOperationInput {

    static func urlPathProvider(_ value: GetOperationInput) -> Swift.String? {
        return "/get-operation"
    }
}

extension GetResourcePermissionInput {

    static func urlPathProvider(_ value: GetResourcePermissionInput) -> Swift.String? {
        return "/get-resource-permission"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/list-applications"
    }
}

extension ListComponentsInput {

    static func urlPathProvider(_ value: ListComponentsInput) -> Swift.String? {
        return "/list-components"
    }
}

extension ListDatabasesInput {

    static func urlPathProvider(_ value: ListDatabasesInput) -> Swift.String? {
        return "/list-databases"
    }
}

extension ListOperationEventsInput {

    static func urlPathProvider(_ value: ListOperationEventsInput) -> Swift.String? {
        return "/list-operation-events"
    }
}

extension ListOperationsInput {

    static func urlPathProvider(_ value: ListOperationsInput) -> Swift.String? {
        return "/list-operations"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutResourcePermissionInput {

    static func urlPathProvider(_ value: PutResourcePermissionInput) -> Swift.String? {
        return "/put-resource-permission"
    }
}

extension RegisterApplicationInput {

    static func urlPathProvider(_ value: RegisterApplicationInput) -> Swift.String? {
        return "/register-application"
    }
}

extension StartApplicationInput {

    static func urlPathProvider(_ value: StartApplicationInput) -> Swift.String? {
        return "/start-application"
    }
}

extension StartApplicationRefreshInput {

    static func urlPathProvider(_ value: StartApplicationRefreshInput) -> Swift.String? {
        return "/start-application-refresh"
    }
}

extension StopApplicationInput {

    static func urlPathProvider(_ value: StopApplicationInput) -> Swift.String? {
        return "/stop-application"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApplicationSettingsInput {

    static func urlPathProvider(_ value: UpdateApplicationSettingsInput) -> Swift.String? {
        return "/update-application-settings"
    }
}

extension DeleteResourcePermissionInput {

    static func write(value: DeleteResourcePermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionType"].write(value.actionType)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["SourceResourceArn"].write(value.sourceResourceArn)
    }
}

extension DeregisterApplicationInput {

    static func write(value: DeregisterApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
    }
}

extension GetApplicationInput {

    static func write(value: GetApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppRegistryArn"].write(value.appRegistryArn)
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["ApplicationId"].write(value.applicationId)
    }
}

extension GetComponentInput {

    static func write(value: GetComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["ComponentId"].write(value.componentId)
    }
}

extension GetDatabaseInput {

    static func write(value: GetDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["ComponentId"].write(value.componentId)
        try writer["DatabaseArn"].write(value.databaseArn)
        try writer["DatabaseId"].write(value.databaseId)
    }
}

extension GetOperationInput {

    static func write(value: GetOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperationId"].write(value.operationId)
    }
}

extension GetResourcePermissionInput {

    static func write(value: GetResourcePermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionType"].write(value.actionType)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SsmSapClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListComponentsInput {

    static func write(value: ListComponentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDatabasesInput {

    static func write(value: ListDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["ComponentId"].write(value.componentId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListOperationEventsInput {

    static func write(value: ListOperationEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SsmSapClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OperationId"].write(value.operationId)
    }
}

extension ListOperationsInput {

    static func write(value: ListOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SsmSapClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutResourcePermissionInput {

    static func write(value: PutResourcePermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionType"].write(value.actionType)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["SourceResourceArn"].write(value.sourceResourceArn)
    }
}

extension RegisterApplicationInput {

    static func write(value: RegisterApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["ApplicationType"].write(value.applicationType)
        try writer["Credentials"].writeList(value.credentials, memberWritingClosure: SsmSapClientTypes.ApplicationCredential.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseArn"].write(value.databaseArn)
        try writer["Instances"].writeList(value.instances, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SapInstanceNumber"].write(value.sapInstanceNumber)
        try writer["Sid"].write(value.sid)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartApplicationInput {

    static func write(value: StartApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
    }
}

extension StartApplicationRefreshInput {

    static func write(value: StartApplicationRefreshInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
    }
}

extension StopApplicationInput {

    static func write(value: StopApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["IncludeEc2InstanceShutdown"].write(value.includeEc2InstanceShutdown)
        try writer["StopConnectedEntity"].write(value.stopConnectedEntity)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApplicationSettingsInput {

    static func write(value: UpdateApplicationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["Backint"].write(value.backint, with: SsmSapClientTypes.BackintConfig.write(value:to:))
        try writer["CredentialsToAddOrUpdate"].writeList(value.credentialsToAddOrUpdate, memberWritingClosure: SsmSapClientTypes.ApplicationCredential.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CredentialsToRemove"].writeList(value.credentialsToRemove, memberWritingClosure: SsmSapClientTypes.ApplicationCredential.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseArn"].write(value.databaseArn)
    }
}

extension DeleteResourcePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResourcePermissionOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension DeregisterApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterApplicationOutput {
        return DeregisterApplicationOutput()
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.application = try reader["Application"].readIfPresent(with: SsmSapClientTypes.Application.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentOutput()
        value.component = try reader["Component"].readIfPresent(with: SsmSapClientTypes.Component.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: SsmSapClientTypes.Database.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOperationOutput()
        value.operation = try reader["Operation"].readIfPresent(with: SsmSapClientTypes.Operation.read(from:))
        return value
    }
}

extension GetResourcePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePermissionOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentsOutput()
        value.components = try reader["Components"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.ComponentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatabasesOutput()
        value.databases = try reader["Databases"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.DatabaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOperationEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOperationEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOperationEventsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.operationEvents = try reader["OperationEvents"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.OperationEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOperationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.operations = try reader["Operations"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.Operation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutResourcePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePermissionOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension RegisterApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterApplicationOutput()
        value.application = try reader["Application"].readIfPresent(with: SsmSapClientTypes.Application.read(from:))
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension StartApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartApplicationOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension StartApplicationRefreshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartApplicationRefreshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartApplicationRefreshOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension StopApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopApplicationOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationSettingsOutput()
        value.message = try reader["Message"].readIfPresent()
        value.operationIds = try reader["OperationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum DeleteResourcePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOperationEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartApplicationRefreshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SsmSapClientTypes.Application {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Application()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.appRegistryArn = try reader["AppRegistryArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.discoveryStatus = try reader["DiscoveryStatus"].readIfPresent()
        value.components = try reader["Components"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.associatedApplicationArns = try reader["AssociatedApplicationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SsmSapClientTypes.Component {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Component {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Component()
        value.componentId = try reader["ComponentId"].readIfPresent()
        value.sid = try reader["Sid"].readIfPresent()
        value.systemNumber = try reader["SystemNumber"].readIfPresent()
        value.parentComponent = try reader["ParentComponent"].readIfPresent()
        value.childComponents = try reader["ChildComponents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.componentType = try reader["ComponentType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.sapHostname = try reader["SapHostname"].readIfPresent()
        value.sapFeature = try reader["SapFeature"].readIfPresent()
        value.sapKernelVersion = try reader["SapKernelVersion"].readIfPresent()
        value.hdbVersion = try reader["HdbVersion"].readIfPresent()
        value.resilience = try reader["Resilience"].readIfPresent(with: SsmSapClientTypes.Resilience.read(from:))
        value.associatedHost = try reader["AssociatedHost"].readIfPresent(with: SsmSapClientTypes.AssociatedHost.read(from:))
        value.databases = try reader["Databases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.hosts = try reader["Hosts"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.Host.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.primaryHost = try reader["PrimaryHost"].readIfPresent()
        value.databaseConnection = try reader["DatabaseConnection"].readIfPresent(with: SsmSapClientTypes.DatabaseConnection.read(from:))
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.DatabaseConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.DatabaseConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.DatabaseConnection()
        value.databaseConnectionMethod = try reader["DatabaseConnectionMethod"].readIfPresent()
        value.databaseArn = try reader["DatabaseArn"].readIfPresent()
        value.connectionIp = try reader["ConnectionIp"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.Host {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Host {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Host()
        value.hostName = try reader["HostName"].readIfPresent()
        value.hostIp = try reader["HostIp"].readIfPresent()
        value.ec2InstanceId = try reader["EC2InstanceId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.hostRole = try reader["HostRole"].readIfPresent()
        value.osVersion = try reader["OsVersion"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.AssociatedHost {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.AssociatedHost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.AssociatedHost()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.ec2InstanceId = try reader["Ec2InstanceId"].readIfPresent()
        value.ipAddresses = try reader["IpAddresses"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.IpAddressMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.osVersion = try reader["OsVersion"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.IpAddressMember {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.IpAddressMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.IpAddressMember()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.primary = try reader["Primary"].readIfPresent()
        value.allocationType = try reader["AllocationType"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.Resilience {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Resilience {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Resilience()
        value.hsrTier = try reader["HsrTier"].readIfPresent()
        value.hsrReplicationMode = try reader["HsrReplicationMode"].readIfPresent()
        value.hsrOperationMode = try reader["HsrOperationMode"].readIfPresent()
        value.clusterStatus = try reader["ClusterStatus"].readIfPresent()
        value.enqueueReplication = try reader["EnqueueReplication"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.Database {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Database {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Database()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.componentId = try reader["ComponentId"].readIfPresent()
        value.credentials = try reader["Credentials"].readListIfPresent(memberReadingClosure: SsmSapClientTypes.ApplicationCredential.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.databaseType = try reader["DatabaseType"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.primaryHost = try reader["PrimaryHost"].readIfPresent()
        value.sqlPort = try reader["SQLPort"].readIfPresent()
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.connectedComponentArns = try reader["ConnectedComponentArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SsmSapClientTypes.ApplicationCredential {

    static func write(value: SsmSapClientTypes.ApplicationCredential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CredentialType"].write(value.credentialType)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["SecretId"].write(value.secretId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.ApplicationCredential {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.ApplicationCredential()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.credentialType = try reader["CredentialType"].readIfPresent() ?? .sdkUnknown("")
        value.secretId = try reader["SecretId"].readIfPresent() ?? ""
        return value
    }
}

extension SsmSapClientTypes.Operation {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Operation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Operation()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.properties = try reader["Properties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SsmSapClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.ApplicationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.discoveryStatus = try reader["DiscoveryStatus"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SsmSapClientTypes.ComponentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.ComponentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.ComponentSummary()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.componentId = try reader["ComponentId"].readIfPresent()
        value.componentType = try reader["ComponentType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.DatabaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.DatabaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.DatabaseSummary()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.componentId = try reader["ComponentId"].readIfPresent()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.databaseType = try reader["DatabaseType"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SsmSapClientTypes.OperationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.OperationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.OperationEvent()
        value.description = try reader["Description"].readIfPresent()
        value.resource = try reader["Resource"].readIfPresent(with: SsmSapClientTypes.Resource.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SsmSapClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> SsmSapClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SsmSapClientTypes.Resource()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension SsmSapClientTypes.Filter {

    static func write(value: SsmSapClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension SsmSapClientTypes.BackintConfig {

    static func write(value: SsmSapClientTypes.BackintConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackintMode"].write(value.backintMode)
        try writer["EnsureNoBackupInProcess"].write(value.ensureNoBackupInProcess)
    }
}

public enum SsmSapClientTypes {}
