// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmSapClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryArn = "AppRegistryArn"
        case arn = "Arn"
        case components = "Components"
        case discoveryStatus = "DiscoveryStatus"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryArn = self.appRegistryArn {
            try encodeContainer.encode(appRegistryArn, forKey: .appRegistryArn)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentid0 in components {
                try componentsContainer.encode(componentid0)
            }
        }
        if let discoveryStatus = self.discoveryStatus {
            try encodeContainer.encode(discoveryStatus.rawValue, forKey: .discoveryStatus)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appRegistryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryArn)
        appRegistryArn = appRegistryArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let discoveryStatusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationDiscoveryStatus.self, forKey: .discoveryStatus)
        discoveryStatus = discoveryStatusDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .components)
        var componentsDecoded0:[Swift.String]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String]()
            for string0 in componentsContainer {
                if let string0 = string0 {
                    componentsDecoded0?.append(string0)
                }
            }
        }
        components = componentsDecoded0
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension SsmSapClientTypes {
    /// An SAP application registered with AWS Systems Manager for SAP.
    public struct Application: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Application Registry.
        public var appRegistryArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The components of the application.
        public var components: [Swift.String]?
        /// The latest discovery result for the application.
        public var discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus?
        /// The ID of the application.
        public var id: Swift.String?
        /// The time at which the application was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The status of the application.
        public var status: SsmSapClientTypes.ApplicationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The type of the application.
        public var type: SsmSapClientTypes.ApplicationType?

        public init(
            appRegistryArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            components: [Swift.String]? = nil,
            discoveryStatus: SsmSapClientTypes.ApplicationDiscoveryStatus? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            status: SsmSapClientTypes.ApplicationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.appRegistryArn = appRegistryArn
            self.arn = arn
            self.components = components
            self.discoveryStatus = discoveryStatus
            self.id = id
            self.lastUpdated = lastUpdated
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension SsmSapClientTypes.ApplicationCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialType = "CredentialType"
        case databaseName = "DatabaseName"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialType = self.credentialType {
            try encodeContainer.encode(credentialType.rawValue, forKey: .credentialType)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let secretId = self.secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let credentialTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.CredentialType.self, forKey: .credentialType)
        credentialType = credentialTypeDecoded
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension SsmSapClientTypes.ApplicationCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationCredential(credentialType: \(Swift.String(describing: credentialType)), databaseName: \(Swift.String(describing: databaseName)), secretId: \"CONTENT_REDACTED\")"}
}

extension SsmSapClientTypes {
    /// The credentials of your SAP application.
    public struct ApplicationCredential: Swift.Equatable {
        /// The type of the application credentials.
        /// This member is required.
        public var credentialType: SsmSapClientTypes.CredentialType?
        /// The name of the SAP HANA database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The secret ID created in AWS Secrets Manager to store the credentials of the SAP application.
        /// This member is required.
        public var secretId: Swift.String?

        public init(
            credentialType: SsmSapClientTypes.CredentialType? = nil,
            databaseName: Swift.String? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.credentialType = credentialType
            self.databaseName = databaseName
            self.secretId = secretId
        }
    }

}

extension SsmSapClientTypes {
    public enum ApplicationDiscoveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case refreshFailed
        case registering
        case registrationFailed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationDiscoveryStatus] {
            return [
                .deleting,
                .refreshFailed,
                .registering,
                .registrationFailed,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .refreshFailed: return "REFRESH_FAILED"
            case .registering: return "REGISTERING"
            case .registrationFailed: return "REGISTRATION_FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationDiscoveryStatus(rawValue: rawValue) ?? ApplicationDiscoveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case deleting
        case failed
        case registering
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .activated,
                .deleting,
                .failed,
                .registering,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registering: return "REGISTERING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes {
    /// The summary of the SAP application registered with AWS Systems Manager for SAP.
    public struct ApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The ID of the application.
        public var id: Swift.String?
        /// The tags on the application.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the application.
        public var type: SsmSapClientTypes.ApplicationType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.tags = tags
            self.type = type
        }
    }

}

extension SsmSapClientTypes {
    public enum ApplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hana
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationType] {
            return [
                .hana,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hana: return "HANA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationType(rawValue: rawValue) ?? ApplicationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.AssociatedHost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "Ec2InstanceId"
        case hostname = "Hostname"
        case osVersion = "OsVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = self.ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
    }
}

extension SsmSapClientTypes {
    /// Describes the properties of the associated host.
    public struct AssociatedHost: Swift.Equatable {
        /// The ID of the Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// The name of the host.
        public var hostname: Swift.String?
        /// The version of the operating system.
        public var osVersion: Swift.String?

        public init(
            ec2InstanceId: Swift.String? = nil,
            hostname: Swift.String? = nil,
            osVersion: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.hostname = hostname
            self.osVersion = osVersion
        }
    }

}

extension SsmSapClientTypes.BackintConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backintMode = "BackintMode"
        case ensureNoBackupInProcess = "EnsureNoBackupInProcess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backintMode = self.backintMode {
            try encodeContainer.encode(backintMode.rawValue, forKey: .backintMode)
        }
        if let ensureNoBackupInProcess = self.ensureNoBackupInProcess {
            try encodeContainer.encode(ensureNoBackupInProcess, forKey: .ensureNoBackupInProcess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backintModeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.BackintMode.self, forKey: .backintMode)
        backintMode = backintModeDecoded
        let ensureNoBackupInProcessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ensureNoBackupInProcess)
        ensureNoBackupInProcess = ensureNoBackupInProcessDecoded
    }
}

extension SsmSapClientTypes {
    /// Configuration parameters for AWS Backint Agent for SAP HANA. You can backup your SAP HANA database with AWS Backup or Amazon S3.
    public struct BackintConfig: Swift.Equatable {
        /// AWS service for your database backup.
        /// This member is required.
        public var backintMode: SsmSapClientTypes.BackintMode?
        ///
        /// This member is required.
        public var ensureNoBackupInProcess: Swift.Bool?

        public init(
            backintMode: SsmSapClientTypes.BackintMode? = nil,
            ensureNoBackupInProcess: Swift.Bool? = nil
        )
        {
            self.backintMode = backintMode
            self.ensureNoBackupInProcess = ensureNoBackupInProcess
        }
    }

}

extension SsmSapClientTypes {
    public enum BackintMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsbackup
        case sdkUnknown(Swift.String)

        public static var allCases: [BackintMode] {
            return [
                .awsbackup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsbackup: return "AWSBackup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackintMode(rawValue: rawValue) ?? BackintMode.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes {
    public enum ClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case maintenance
        case `none`
        case offline
        case online
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterStatus] {
            return [
                .maintenance,
                .none,
                .offline,
                .online,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maintenance: return "MAINTENANCE"
            case .none: return "NONE"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterStatus(rawValue: rawValue) ?? ClusterStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case associatedHost = "AssociatedHost"
        case childComponents = "ChildComponents"
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case databases = "Databases"
        case hdbVersion = "HdbVersion"
        case hosts = "Hosts"
        case lastUpdated = "LastUpdated"
        case parentComponent = "ParentComponent"
        case primaryHost = "PrimaryHost"
        case resilience = "Resilience"
        case sapHostname = "SapHostname"
        case sapKernelVersion = "SapKernelVersion"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associatedHost = self.associatedHost {
            try encodeContainer.encode(associatedHost, forKey: .associatedHost)
        }
        if let childComponents = childComponents {
            var childComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .childComponents)
            for componentid0 in childComponents {
                try childComponentsContainer.encode(componentid0)
            }
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType.rawValue, forKey: .componentType)
        }
        if let databases = databases {
            var databasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databases)
            for databaseid0 in databases {
                try databasesContainer.encode(databaseid0)
            }
        }
        if let hdbVersion = self.hdbVersion {
            try encodeContainer.encode(hdbVersion, forKey: .hdbVersion)
        }
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for host0 in hosts {
                try hostsContainer.encode(host0)
            }
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let parentComponent = self.parentComponent {
            try encodeContainer.encode(parentComponent, forKey: .parentComponent)
        }
        if let primaryHost = self.primaryHost {
            try encodeContainer.encode(primaryHost, forKey: .primaryHost)
        }
        if let resilience = self.resilience {
            try encodeContainer.encode(resilience, forKey: .resilience)
        }
        if let sapHostname = self.sapHostname {
            try encodeContainer.encode(sapHostname, forKey: .sapHostname)
        }
        if let sapKernelVersion = self.sapKernelVersion {
            try encodeContainer.encode(sapKernelVersion, forKey: .sapKernelVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let parentComponentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentComponent)
        parentComponent = parentComponentDecoded
        let childComponentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .childComponents)
        var childComponentsDecoded0:[Swift.String]? = nil
        if let childComponentsContainer = childComponentsContainer {
            childComponentsDecoded0 = [Swift.String]()
            for string0 in childComponentsContainer {
                if let string0 = string0 {
                    childComponentsDecoded0?.append(string0)
                }
            }
        }
        childComponents = childComponentsDecoded0
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentType.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentStatus.self, forKey: .status)
        status = statusDecoded
        let sapHostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sapHostname)
        sapHostname = sapHostnameDecoded
        let sapKernelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sapKernelVersion)
        sapKernelVersion = sapKernelVersionDecoded
        let hdbVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hdbVersion)
        hdbVersion = hdbVersionDecoded
        let resilienceDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Resilience.self, forKey: .resilience)
        resilience = resilienceDecoded
        let associatedHostDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.AssociatedHost.self, forKey: .associatedHost)
        associatedHost = associatedHostDecoded
        let databasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databases)
        var databasesDecoded0:[Swift.String]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [Swift.String]()
            for string0 in databasesContainer {
                if let string0 = string0 {
                    databasesDecoded0?.append(string0)
                }
            }
        }
        databases = databasesDecoded0
        let hostsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.Host?].self, forKey: .hosts)
        var hostsDecoded0:[SsmSapClientTypes.Host]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [SsmSapClientTypes.Host]()
            for structure0 in hostsContainer {
                if let structure0 = structure0 {
                    hostsDecoded0?.append(structure0)
                }
            }
        }
        hosts = hostsDecoded0
        let primaryHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryHost)
        primaryHost = primaryHostDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmSapClientTypes {
    /// The SAP component of your application.
    public struct Component: Swift.Equatable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The associated host of the component.
        public var associatedHost: SsmSapClientTypes.AssociatedHost?
        /// The child components of a highly available environment. For example, in a highly available SAP on AWS workload, the child component consists of the primary and secondar instances.
        public var childComponents: [Swift.String]?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The type of the component.
        public var componentType: SsmSapClientTypes.ComponentType?
        /// The SAP HANA databases of the component.
        public var databases: [Swift.String]?
        /// The SAP HANA version of the component.
        public var hdbVersion: Swift.String?
        /// The hosts of the component.
        @available(*, deprecated, message: "This shape is no longer used. Please use AssociatedHost.")
        public var hosts: [SsmSapClientTypes.Host]?
        /// The time at which the component was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The parent component of a highly available environment. For example, in a highly available SAP on AWS workload, the parent component consists of the entire setup, including the child components.
        public var parentComponent: Swift.String?
        /// The primary host of the component.
        @available(*, deprecated, message: "This shape is no longer used. Please use AssociatedHost.")
        public var primaryHost: Swift.String?
        /// Details of the SAP HANA system replication for the component.
        public var resilience: SsmSapClientTypes.Resilience?
        /// The hostname of the component.
        public var sapHostname: Swift.String?
        /// The kernel version of the component.
        public var sapKernelVersion: Swift.String?
        /// The status of the component.
        public var status: SsmSapClientTypes.ComponentStatus?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            associatedHost: SsmSapClientTypes.AssociatedHost? = nil,
            childComponents: [Swift.String]? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            databases: [Swift.String]? = nil,
            hdbVersion: Swift.String? = nil,
            hosts: [SsmSapClientTypes.Host]? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            parentComponent: Swift.String? = nil,
            primaryHost: Swift.String? = nil,
            resilience: SsmSapClientTypes.Resilience? = nil,
            sapHostname: Swift.String? = nil,
            sapKernelVersion: Swift.String? = nil,
            status: SsmSapClientTypes.ComponentStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.associatedHost = associatedHost
            self.childComponents = childComponents
            self.componentId = componentId
            self.componentType = componentType
            self.databases = databases
            self.hdbVersion = hdbVersion
            self.hosts = hosts
            self.lastUpdated = lastUpdated
            self.parentComponent = parentComponent
            self.primaryHost = primaryHost
            self.resilience = resilience
            self.sapHostname = sapHostname
            self.sapKernelVersion = sapKernelVersion
            self.status = status
        }
    }

}

extension SsmSapClientTypes {
    public enum ComponentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case running
        case runningWithError
        case starting
        case stopped
        case stopping
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .activated,
                .running,
                .runningWithError,
                .starting,
                .stopped,
                .stopping,
                .undefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .running: return "RUNNING"
            case .runningWithError: return "RUNNING_WITH_ERROR"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .undefined: return "UNDEFINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentStatus(rawValue: rawValue) ?? ComponentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType.rawValue, forKey: .componentType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentType.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmSapClientTypes {
    /// The summary of the component.
    public struct ComponentSummary: Swift.Equatable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the component summary.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The type of the component.
        public var componentType: SsmSapClientTypes.ComponentType?
        /// The tags of the component.
        public var tags: [Swift.String:Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.componentType = componentType
            self.tags = tags
        }
    }

}

extension SsmSapClientTypes {
    public enum ComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hana
        case hanaNode
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .hana,
                .hanaNode,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hana: return "HANA"
            case .hanaNode: return "HANA_NODE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflict has occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmSapClientTypes {
    public enum CredentialType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialType] {
            return [
                .admin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CredentialType(rawValue: rawValue) ?? CredentialType.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case componentId = "ComponentId"
        case credentials = "Credentials"
        case databaseId = "DatabaseId"
        case databaseName = "DatabaseName"
        case databaseType = "DatabaseType"
        case lastUpdated = "LastUpdated"
        case primaryHost = "PrimaryHost"
        case sqlPort = "SQLPort"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for applicationcredential0 in credentials {
                try credentialsContainer.encode(applicationcredential0)
            }
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databaseType = self.databaseType {
            try encodeContainer.encode(databaseType.rawValue, forKey: .databaseType)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let primaryHost = self.primaryHost {
            try encodeContainer.encode(primaryHost, forKey: .primaryHost)
        }
        if let sqlPort = self.sqlPort {
            try encodeContainer.encode(sqlPort, forKey: .sqlPort)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let credentialsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentials)
        var credentialsDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseType.self, forKey: .databaseType)
        databaseType = databaseTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseStatus.self, forKey: .status)
        status = statusDecoded
        let primaryHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryHost)
        primaryHost = primaryHostDecoded
        let sqlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sqlPort)
        sqlPort = sqlPortDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension SsmSapClientTypes {
    /// The SAP HANA database of the application registered with AWS Systems Manager for SAP.
    public struct Database: Swift.Equatable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the database.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The credentials of the database.
        public var credentials: [SsmSapClientTypes.ApplicationCredential]?
        /// The ID of the SAP HANA database.
        public var databaseId: Swift.String?
        /// The name of the database.
        public var databaseName: Swift.String?
        /// The type of the database.
        public var databaseType: SsmSapClientTypes.DatabaseType?
        /// The time at which the database was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The primary host of the database.
        public var primaryHost: Swift.String?
        /// The SQL port of the database.
        public var sqlPort: Swift.Int?
        /// The status of the database.
        public var status: SsmSapClientTypes.DatabaseStatus?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            credentials: [SsmSapClientTypes.ApplicationCredential]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            primaryHost: Swift.String? = nil,
            sqlPort: Swift.Int? = nil,
            status: SsmSapClientTypes.DatabaseStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.credentials = credentials
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.databaseType = databaseType
            self.lastUpdated = lastUpdated
            self.primaryHost = primaryHost
            self.sqlPort = sqlPort
            self.status = status
        }
    }

}

extension SsmSapClientTypes {
    public enum DatabaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case running
        case starting
        case stopped
        case unknown
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseStatus] {
            return [
                .error,
                .running,
                .starting,
                .stopped,
                .unknown,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseStatus(rawValue: rawValue) ?? DatabaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.DatabaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case componentId = "ComponentId"
        case databaseId = "DatabaseId"
        case databaseType = "DatabaseType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseType = self.databaseType {
            try encodeContainer.encode(databaseType.rawValue, forKey: .databaseType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseType.self, forKey: .databaseType)
        databaseType = databaseTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes {
    /// The summary of the database.
    public struct DatabaseSummary: Swift.Equatable {
        /// The ID of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the database.
        public var arn: Swift.String?
        /// The ID of the component.
        public var componentId: Swift.String?
        /// The ID of the database.
        public var databaseId: Swift.String?
        /// The type of the database.
        public var databaseType: SsmSapClientTypes.DatabaseType?
        /// The tags of the database.
        public var tags: [Swift.String:Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.databaseId = databaseId
            self.databaseType = databaseType
            self.tags = tags
        }
    }

}

extension SsmSapClientTypes {
    public enum DatabaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case tenant
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseType] {
            return [
                .system,
                .tenant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .tenant: return "TENANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseType(rawValue: rawValue) ?? DatabaseType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceResourceArn = self.sourceResourceArn {
            try encodeContainer.encode(sourceResourceArn, forKey: .sourceResourceArn)
        }
    }
}

extension DeleteResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-resource-permission"
    }
}

public struct DeleteResourcePermissionInput: Swift.Equatable {
    /// Delete or restore the permissions on the target database.
    public var actionType: SsmSapClientTypes.PermissionActionType?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the source resource.
    public var sourceResourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

struct DeleteResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let sourceResourceArn: Swift.String?
    let resourceArn: Swift.String?
}

extension DeleteResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let sourceResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceArn)
        sourceResourceArn = sourceResourceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResourcePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteResourcePermissionOutput: Swift.Equatable {
    /// The policy that removes permissions on the target database.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteResourcePermissionOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension DeleteResourcePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DeleteResourcePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension DeregisterApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deregister-application"
    }
}

public struct DeregisterApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeregisterApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
}

extension DeregisterApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DeregisterApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SsmSapClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmSapClientTypes {
    /// A specific result obtained by specifying the name, value, and operator.
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        /// This member is required.
        public var name: Swift.String?
        /// The operator for the filter.
        /// This member is required.
        public var `operator`: SsmSapClientTypes.FilterOperator?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: SsmSapClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension SsmSapClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case greaterThanOrEquals
        case lessThanOrEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals,
                .greaterThanOrEquals,
                .lessThanOrEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "Equals"
            case .greaterThanOrEquals: return "GreaterThanOrEquals"
            case .lessThanOrEquals: return "LessThanOrEquals"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension GetApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryArn = "AppRegistryArn"
        case applicationArn = "ApplicationArn"
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryArn = self.appRegistryArn {
            try encodeContainer.encode(appRegistryArn, forKey: .appRegistryArn)
        }
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-application"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application registry.
    public var appRegistryArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationArn: Swift.String?
    /// The ID of the application.
    public var applicationId: Swift.String?

    public init(
        appRegistryArn: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.appRegistryArn = appRegistryArn
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let applicationArn: Swift.String?
    let appRegistryArn: Swift.String?
}

extension GetApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryArn = "AppRegistryArn"
        case applicationArn = "ApplicationArn"
        case applicationId = "ApplicationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let appRegistryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryArn)
        appRegistryArn = appRegistryArnDecoded
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
            self.tags = output.tags
        } else {
            self.application = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// Returns all of the metadata of an application registered with AWS Systems Manager for SAP.
    public var application: SsmSapClientTypes.Application?
    /// The tags of a registered application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        application: SsmSapClientTypes.Application? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.application = application
        self.tags = tags
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let application: SsmSapClientTypes.Application?
    let tags: [Swift.String:Swift.String]?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-component"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the component.
    /// This member is required.
    public var componentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
    }
}

struct GetComponentInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
}

extension GetComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
    }
}

extension GetComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
            self.tags = output.tags
        } else {
            self.component = nil
            self.tags = nil
        }
    }
}

public struct GetComponentOutput: Swift.Equatable {
    /// The component of an application registered with AWS Systems Manager for SAP.
    public var component: SsmSapClientTypes.Component?
    /// The tags of a component.
    public var tags: [Swift.String:Swift.String]?

    public init(
        component: SsmSapClientTypes.Component? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.component = component
        self.tags = tags
    }
}

struct GetComponentOutputBody: Swift.Equatable {
    let component: SsmSapClientTypes.Component?
    let tags: [Swift.String:Swift.String]?
}

extension GetComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Component.self, forKey: .component)
        component = componentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case databaseArn = "DatabaseArn"
        case databaseId = "DatabaseId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let databaseArn = self.databaseArn {
            try encodeContainer.encode(databaseArn, forKey: .databaseArn)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
    }
}

extension GetDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-database"
    }
}

public struct GetDatabaseInput: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The ID of the component.
    public var componentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the database.
    public var databaseArn: Swift.String?
    /// The ID of the database.
    public var databaseId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        databaseArn: Swift.String? = nil,
        databaseId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.databaseArn = databaseArn
        self.databaseId = databaseId
    }
}

struct GetDatabaseInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
    let databaseId: Swift.String?
    let databaseArn: Swift.String?
}

extension GetDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case databaseArn = "DatabaseArn"
        case databaseId = "DatabaseId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseArn)
        databaseArn = databaseArnDecoded
    }
}

extension GetDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDatabaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
            self.tags = output.tags
        } else {
            self.database = nil
            self.tags = nil
        }
    }
}

public struct GetDatabaseOutput: Swift.Equatable {
    /// The SAP HANA database of an application registered with AWS Systems Manager for SAP.
    public var database: SsmSapClientTypes.Database?
    /// The tags of a database.
    public var tags: [Swift.String:Swift.String]?

    public init(
        database: SsmSapClientTypes.Database? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.database = database
        self.tags = tags
    }
}

struct GetDatabaseOutputBody: Swift.Equatable {
    let database: SsmSapClientTypes.Database?
    let tags: [Swift.String:Swift.String]?
}

extension GetDatabaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = self.operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

extension GetOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-operation"
    }
}

public struct GetOperationInput: Swift.Equatable {
    /// The ID of the operation.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension GetOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutput: Swift.Equatable {
    /// Returns the details of an operation.
    public var operation: SsmSapClientTypes.Operation?

    public init(
        operation: SsmSapClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputBody: Swift.Equatable {
    let operation: SsmSapClientTypes.Operation?
}

extension GetOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

enum GetOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-resource-permission"
    }
}

public struct GetResourcePermissionInput: Swift.Equatable {
    ///
    public var actionType: SsmSapClientTypes.PermissionActionType?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
    }
}

struct GetResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let resourceArn: Swift.String?
}

extension GetResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePermissionOutput: Swift.Equatable {
    ///
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePermissionOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetResourcePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SsmSapClientTypes.Host: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "EC2InstanceId"
        case hostIp = "HostIp"
        case hostName = "HostName"
        case hostRole = "HostRole"
        case instanceId = "InstanceId"
        case osVersion = "OsVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = self.ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let hostIp = self.hostIp {
            try encodeContainer.encode(hostIp, forKey: .hostIp)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hostRole = self.hostRole {
            try encodeContainer.encode(hostRole.rawValue, forKey: .hostRole)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hostIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostIp)
        hostIp = hostIpDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let hostRoleDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.HostRole.self, forKey: .hostRole)
        hostRole = hostRoleDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
    }
}

extension SsmSapClientTypes {
    /// Describes the properties of the Dedicated Host.
    public struct Host: Swift.Equatable {
        /// The ID of Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// The IP address of the Dedicated Host.
        public var hostIp: Swift.String?
        /// The name of the Dedicated Host.
        public var hostName: Swift.String?
        /// The role of the Dedicated Host.
        public var hostRole: SsmSapClientTypes.HostRole?
        /// The instance ID of the instance on the Dedicated Host.
        public var instanceId: Swift.String?
        /// The version of the operating system.
        public var osVersion: Swift.String?

        public init(
            ec2InstanceId: Swift.String? = nil,
            hostIp: Swift.String? = nil,
            hostName: Swift.String? = nil,
            hostRole: SsmSapClientTypes.HostRole? = nil,
            instanceId: Swift.String? = nil,
            osVersion: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.hostIp = hostIp
            self.hostName = hostName
            self.hostRole = hostRole
            self.instanceId = instanceId
            self.osVersion = osVersion
        }
    }

}

extension SsmSapClientTypes {
    public enum HostRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leader
        case standby
        case unknown
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [HostRole] {
            return [
                .leader,
                .standby,
                .unknown,
                .worker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leader: return "LEADER"
            case .standby: return "STANDBY"
            case .unknown: return "UNKNOWN"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HostRole(rawValue: rawValue) ?? HostRole.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The applications registered with AWS Systems Manager for SAP.
    public var applications: [SsmSapClientTypes.ApplicationSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        applications: [SsmSapClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [SsmSapClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[SsmSapClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [SsmSapClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// List of components registered with AWS System Manager for SAP.
    public var components: [SsmSapClientTypes.ComponentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        components: [SsmSapClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let components: [SsmSapClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components = "Components"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ComponentSummary?].self, forKey: .components)
        var componentsDecoded0:[SsmSapClientTypes.ComponentSummary]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [SsmSapClientTypes.ComponentSummary]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-databases"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The ID of the component.
    public var componentId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutput: Swift.Equatable {
    /// The SAP HANA databases of an application.
    public var databases: [SsmSapClientTypes.DatabaseSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        databases: [SsmSapClientTypes.DatabaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputBody: Swift.Equatable {
    let databases: [SsmSapClientTypes.DatabaseSummary]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.DatabaseSummary?].self, forKey: .databases)
        var databasesDecoded0:[SsmSapClientTypes.DatabaseSummary]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [SsmSapClientTypes.DatabaseSummary]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-operations"
    }
}

public struct ListOperationsInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The filters of an operation.
    public var filters: [SsmSapClientTypes.Filter]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If you do not specify a value for MaxResults, the request returns 50 items per page by default.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        filters: [SsmSapClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [SsmSapClientTypes.Filter]?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[SsmSapClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmSapClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operations = output.operations
        } else {
            self.nextToken = nil
            self.operations = nil
        }
    }
}

public struct ListOperationsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// List of operations performed by AWS Systems Manager for SAP.
    public var operations: [SsmSapClientTypes.Operation]?

    public init(
        nextToken: Swift.String? = nil,
        operations: [SsmSapClientTypes.Operation]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

struct ListOperationsOutputBody: Swift.Equatable {
    let operations: [SsmSapClientTypes.Operation]?
    let nextToken: Swift.String?
}

extension ListOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operations = "Operations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.Operation?].self, forKey: .operations)
        var operationsDecoded0:[SsmSapClientTypes.Operation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [SsmSapClientTypes.Operation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    ///
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SsmSapClientTypes.Operation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case id = "Id"
        case lastUpdatedTime = "LastUpdatedTime"
        case properties = "Properties"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, operationProperties0) in properties {
                guard let operationProperties0 = operationProperties0 else {
                    try propertiesContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try propertiesContainer.encode(operationProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String?]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in propertiesContainer {
                propertiesDecoded0?[key0] = string0
            }
        }
        properties = propertiesDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension SsmSapClientTypes {
    /// The operations performed by AWS Systems Manager for SAP.
    public struct Operation: Swift.Equatable {
        /// The end time of the operation.
        public var endTime: ClientRuntime.Date?
        /// The ID of the operation.
        public var id: Swift.String?
        /// The time at which the operation was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The properties of the operation.
        public var properties: [Swift.String:Swift.String?]?
        /// The Amazon Resource Name (ARN) of the operation.
        public var resourceArn: Swift.String?
        /// The resource ID of the operation.
        public var resourceId: Swift.String?
        /// The resource type of the operation.
        public var resourceType: Swift.String?
        /// The start time of the operation.
        public var startTime: ClientRuntime.Date?
        /// The status of the operation.
        public var status: SsmSapClientTypes.OperationStatus?
        /// The status message of the operation.
        public var statusMessage: Swift.String?
        /// The type of the operation.
        public var type: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            properties: [Swift.String:Swift.String?]? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmSapClientTypes.OperationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.properties = properties
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension SsmSapClientTypes {
    public enum OperationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deltaDatashipping
        case logreplay
        case logreplayReadaccess
        case `none`
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationMode] {
            return [
                .deltaDatashipping,
                .logreplay,
                .logreplayReadaccess,
                .none,
                .primary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deltaDatashipping: return "DELTA_DATASHIPPING"
            case .logreplay: return "LOGREPLAY"
            case .logreplayReadaccess: return "LOGREPLAY_READACCESS"
            case .none: return "NONE"
            case .primary: return "PRIMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationMode(rawValue: rawValue) ?? OperationMode.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case inprogress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .error,
                .inprogress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .inprogress: return "INPROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes {
    public enum PermissionActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restore
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionActionType] {
            return [
                .restore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restore: return "RESTORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionActionType(rawValue: rawValue) ?? PermissionActionType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceResourceArn = self.sourceResourceArn {
            try encodeContainer.encode(sourceResourceArn, forKey: .sourceResourceArn)
        }
    }
}

extension PutResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-resource-permission"
    }
}

public struct PutResourcePermissionInput: Swift.Equatable {
    ///
    /// This member is required.
    public var actionType: SsmSapClientTypes.PermissionActionType?
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var sourceResourceArn: Swift.String?

    public init(
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

struct PutResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let sourceResourceArn: Swift.String?
    let resourceArn: Swift.String?
}

extension PutResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let sourceResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceArn)
        sourceResourceArn = sourceResourceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension PutResourcePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutResourcePermissionOutput: Swift.Equatable {
    ///
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct PutResourcePermissionOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutResourcePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutResourcePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationType = "ApplicationType"
        case credentials = "Credentials"
        case instances = "Instances"
        case sapInstanceNumber = "SapInstanceNumber"
        case sid = "Sid"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationType = self.applicationType {
            try encodeContainer.encode(applicationType.rawValue, forKey: .applicationType)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for applicationcredential0 in credentials {
                try credentialsContainer.encode(applicationcredential0)
            }
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceid0 in instances {
                try instancesContainer.encode(instanceid0)
            }
        }
        if let sapInstanceNumber = self.sapInstanceNumber {
            try encodeContainer.encode(sapInstanceNumber, forKey: .sapInstanceNumber)
        }
        if let sid = self.sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension RegisterApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/register-application"
    }
}

public struct RegisterApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The type of the application.
    /// This member is required.
    public var applicationType: SsmSapClientTypes.ApplicationType?
    /// The credentials of the SAP application.
    /// This member is required.
    public var credentials: [SsmSapClientTypes.ApplicationCredential]?
    /// The Amazon EC2 instances on which your SAP application is running.
    /// This member is required.
    public var instances: [Swift.String]?
    /// The SAP instance number of the application.
    public var sapInstanceNumber: Swift.String?
    /// The System ID of the application.
    public var sid: Swift.String?
    /// The tags to be attached to the SAP application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        applicationType: SsmSapClientTypes.ApplicationType? = nil,
        credentials: [SsmSapClientTypes.ApplicationCredential]? = nil,
        instances: [Swift.String]? = nil,
        sapInstanceNumber: Swift.String? = nil,
        sid: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationType = applicationType
        self.credentials = credentials
        self.instances = instances
        self.sapInstanceNumber = sapInstanceNumber
        self.sid = sid
        self.tags = tags
    }
}

struct RegisterApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let applicationType: SsmSapClientTypes.ApplicationType?
    let instances: [Swift.String]?
    let sapInstanceNumber: Swift.String?
    let sid: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let credentials: [SsmSapClientTypes.ApplicationCredential]?
}

extension RegisterApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationType = "ApplicationType"
        case credentials = "Credentials"
        case instances = "Instances"
        case sapInstanceNumber = "SapInstanceNumber"
        case sid = "Sid"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .applicationType)
        applicationType = applicationTypeDecoded
        let instancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instances)
        var instancesDecoded0:[Swift.String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Swift.String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let sapInstanceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sapInstanceNumber)
        sapInstanceNumber = sapInstanceNumberDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let credentialsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentials)
        var credentialsDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension RegisterApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
            self.operationId = output.operationId
        } else {
            self.application = nil
            self.operationId = nil
        }
    }
}

public struct RegisterApplicationOutput: Swift.Equatable {
    /// The application registered with AWS Systems Manager for SAP.
    public var application: SsmSapClientTypes.Application?
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        application: SsmSapClientTypes.Application? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.application = application
        self.operationId = operationId
    }
}

struct RegisterApplicationOutputBody: Swift.Equatable {
    let application: SsmSapClientTypes.Application?
    let operationId: Swift.String?
}

extension RegisterApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
        case operationId = "OperationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

enum RegisterApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SsmSapClientTypes {
    public enum ReplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case `none`
        case primary
        case sync
        case syncmem
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationMode] {
            return [
                .async,
                .none,
                .primary,
                .sync,
                .syncmem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case .none: return "NONE"
            case .primary: return "PRIMARY"
            case .sync: return "SYNC"
            case .syncmem: return "SYNCMEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationMode(rawValue: rawValue) ?? ReplicationMode.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.Resilience: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterStatus = "ClusterStatus"
        case hsrOperationMode = "HsrOperationMode"
        case hsrReplicationMode = "HsrReplicationMode"
        case hsrTier = "HsrTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterStatus = self.clusterStatus {
            try encodeContainer.encode(clusterStatus.rawValue, forKey: .clusterStatus)
        }
        if let hsrOperationMode = self.hsrOperationMode {
            try encodeContainer.encode(hsrOperationMode.rawValue, forKey: .hsrOperationMode)
        }
        if let hsrReplicationMode = self.hsrReplicationMode {
            try encodeContainer.encode(hsrReplicationMode.rawValue, forKey: .hsrReplicationMode)
        }
        if let hsrTier = self.hsrTier {
            try encodeContainer.encode(hsrTier, forKey: .hsrTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsrTierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsrTier)
        hsrTier = hsrTierDecoded
        let hsrReplicationModeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ReplicationMode.self, forKey: .hsrReplicationMode)
        hsrReplicationMode = hsrReplicationModeDecoded
        let hsrOperationModeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.OperationMode.self, forKey: .hsrOperationMode)
        hsrOperationMode = hsrOperationModeDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ClusterStatus.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
    }
}

extension SsmSapClientTypes {
    /// Details of the SAP HANA system replication for the instance.
    public struct Resilience: Swift.Equatable {
        /// The cluster status of the component.
        public var clusterStatus: SsmSapClientTypes.ClusterStatus?
        /// The operation mode of the component.
        public var hsrOperationMode: SsmSapClientTypes.OperationMode?
        /// The replication mode of the component.
        public var hsrReplicationMode: SsmSapClientTypes.ReplicationMode?
        /// The tier of the component.
        public var hsrTier: Swift.String?

        public init(
            clusterStatus: SsmSapClientTypes.ClusterStatus? = nil,
            hsrOperationMode: SsmSapClientTypes.OperationMode? = nil,
            hsrReplicationMode: SsmSapClientTypes.ReplicationMode? = nil,
            hsrTier: Swift.String? = nil
        )
        {
            self.clusterStatus = clusterStatus
            self.hsrOperationMode = hsrOperationMode
            self.hsrReplicationMode = hsrReplicationMode
            self.hsrTier = hsrTier
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is not available.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartApplicationRefreshInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension StartApplicationRefreshInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-application-refresh"
    }
}

public struct StartApplicationRefreshInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StartApplicationRefreshInputBody: Swift.Equatable {
    let applicationId: Swift.String?
}

extension StartApplicationRefreshInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension StartApplicationRefreshOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartApplicationRefreshOutputBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct StartApplicationRefreshOutput: Swift.Equatable {
    /// The ID of the operation.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct StartApplicationRefreshOutputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension StartApplicationRefreshOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

enum StartApplicationRefreshOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags on a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds/updates or removes credentials for applications registered with AWS Systems Manager for SAP.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case backint = "Backint"
        case credentialsToAddOrUpdate = "CredentialsToAddOrUpdate"
        case credentialsToRemove = "CredentialsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let backint = self.backint {
            try encodeContainer.encode(backint, forKey: .backint)
        }
        if let credentialsToAddOrUpdate = credentialsToAddOrUpdate {
            var credentialsToAddOrUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentialsToAddOrUpdate)
            for applicationcredential0 in credentialsToAddOrUpdate {
                try credentialsToAddOrUpdateContainer.encode(applicationcredential0)
            }
        }
        if let credentialsToRemove = credentialsToRemove {
            var credentialsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentialsToRemove)
            for applicationcredential0 in credentialsToRemove {
                try credentialsToRemoveContainer.encode(applicationcredential0)
            }
        }
    }
}

extension UpdateApplicationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-application-settings"
    }
}

public struct UpdateApplicationSettingsInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Installation of AWS Backint Agent for SAP HANA.
    public var backint: SsmSapClientTypes.BackintConfig?
    /// The credentials to be added or updated.
    public var credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]?
    /// The credentials to be removed.
    public var credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]?

    public init(
        applicationId: Swift.String? = nil,
        backint: SsmSapClientTypes.BackintConfig? = nil,
        credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]? = nil,
        credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]? = nil
    )
    {
        self.applicationId = applicationId
        self.backint = backint
        self.credentialsToAddOrUpdate = credentialsToAddOrUpdate
        self.credentialsToRemove = credentialsToRemove
    }
}

struct UpdateApplicationSettingsInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]?
    let credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]?
    let backint: SsmSapClientTypes.BackintConfig?
}

extension UpdateApplicationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case backint = "Backint"
        case credentialsToAddOrUpdate = "CredentialsToAddOrUpdate"
        case credentialsToRemove = "CredentialsToRemove"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let credentialsToAddOrUpdateContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentialsToAddOrUpdate)
        var credentialsToAddOrUpdateDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsToAddOrUpdateContainer = credentialsToAddOrUpdateContainer {
            credentialsToAddOrUpdateDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsToAddOrUpdateContainer {
                if let structure0 = structure0 {
                    credentialsToAddOrUpdateDecoded0?.append(structure0)
                }
            }
        }
        credentialsToAddOrUpdate = credentialsToAddOrUpdateDecoded0
        let credentialsToRemoveContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentialsToRemove)
        var credentialsToRemoveDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsToRemoveContainer = credentialsToRemoveContainer {
            credentialsToRemoveDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsToRemoveContainer {
                if let structure0 = structure0 {
                    credentialsToRemoveDecoded0?.append(structure0)
                }
            }
        }
        credentialsToRemove = credentialsToRemoveDecoded0
        let backintDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.BackintConfig.self, forKey: .backint)
        backint = backintDecoded
    }
}

extension UpdateApplicationSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.operationIds = output.operationIds
        } else {
            self.message = nil
            self.operationIds = nil
        }
    }
}

public struct UpdateApplicationSettingsOutput: Swift.Equatable {
    /// The update message.
    public var message: Swift.String?
    /// The IDs of the operations.
    public var operationIds: [Swift.String]?

    public init(
        message: Swift.String? = nil,
        operationIds: [Swift.String]? = nil
    )
    {
        self.message = message
        self.operationIds = operationIds
    }
}

struct UpdateApplicationSettingsOutputBody: Swift.Equatable {
    let message: Swift.String?
    let operationIds: [Swift.String]?
}

extension UpdateApplicationSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case operationIds = "OperationIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let operationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operationIds)
        var operationIdsDecoded0:[Swift.String]? = nil
        if let operationIdsContainer = operationIdsContainer {
            operationIdsDecoded0 = [Swift.String]()
            for string0 in operationIdsContainer {
                if let string0 = string0 {
                    operationIdsDecoded0?.append(string0)
                }
            }
        }
        operationIds = operationIdsDecoded0
    }
}

enum UpdateApplicationSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
