// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.ConfigParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey
        case parameterValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.
    public struct ConfigParameter: Swift.Equatable {
        /// The key of the parameter. The options are auto_mv, datestyle, enable_case_sensitivity_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var parameterKey: Swift.String?
        /// The value of the parameter to set.
        public var parameterValue: Swift.String?

        public init(
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The submitted action has conflicts.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConvertRecoveryPointToSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
        case retentionPeriod
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ConvertRecoveryPointToSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConvertRecoveryPointToSnapshotInput: Swift.Equatable {
    /// The unique identifier of the recovery point.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// How long to retain the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the created snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        recoveryPointId: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct ConvertRecoveryPointToSnapshotInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension ConvertRecoveryPointToSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
        case retentionPeriod
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConvertRecoveryPointToSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConvertRecoveryPointToSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct ConvertRecoveryPointToSnapshotOutput: Swift.Equatable {
    /// The snapshot converted from the recovery point.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct ConvertRecoveryPointToSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension ConvertRecoveryPointToSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum ConvertRecoveryPointToSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case subnetIds
        case vpcSecurityGroupIds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupid0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension CreateEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint. An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can't contain two consecutive hyphens or end with a hyphen.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The unique identifers of subnets from which Amazon Redshift Serverless chooses one to deploy a VPC endpoint.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The unique identifiers of the security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// The name of the workgroup to associate with the VPC endpoint.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        endpointName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
        self.subnetIds = subnetIds
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.workgroupName = workgroupName
    }
}

struct CreateEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
    let subnetIds: [Swift.String]?
    let workgroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension CreateEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case subnetIds
        case vpcSecurityGroupIds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension CreateEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct CreateEndpointAccessOutput: Swift.Equatable {
    /// The created VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension CreateEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum CreateEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNamespaceInput(dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), namespaceName: \(Swift.String(describing: namespaceName)), tags: \(Swift.String(describing: tags)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

extension CreateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case adminUsername
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNamespaceInput: Swift.Equatable {
    /// The password of the administrator for the first database created in the namespace.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace.
    public var adminUsername: Swift.String?
    /// The name of the first database created in the namespace.
    public var dbName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. Available export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// The name of the namespace.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// A list of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        dbName: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        namespaceName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.dbName = dbName
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.namespaceName = namespaceName
        self.tags = tags
    }
}

struct CreateNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let adminUsername: Swift.String?
    let adminUserPassword: Swift.String?
    let dbName: Swift.String?
    let kmsKeyId: Swift.String?
    let defaultIamRoleArn: Swift.String?
    let iamRoles: [Swift.String]?
    let logExports: [RedshiftServerlessClientTypes.LogExport]?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension CreateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case adminUsername
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct CreateNamespaceOutput: Swift.Equatable {
    /// The created namespace object.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct CreateNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension CreateNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum CreateNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case retentionPeriod
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The namespace to create a snapshot for.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// How long to retain the created snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        namespaceName: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.namespaceName = namespaceName
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case retentionPeriod
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateSnapshotOutput: Swift.Equatable {
    /// The created snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension CreateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }
}

extension CreateUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUsageLimitInput: Swift.Equatable {
    /// The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    /// This member is required.
    public var amount: Swift.Int?
    /// The action that Amazon Redshift Serverless takes when the limit is reached. The default is log.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
    public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
    /// The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of Amazon Redshift Serverless usage to create a usage limit for.
    /// This member is required.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.period = period
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

struct CreateUsageLimitInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?
    let amount: Swift.Int?
    let period: RedshiftServerlessClientTypes.UsageLimitPeriod?
    let breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
}

extension CreateUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension CreateUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct CreateUsageLimitOutput: Swift.Equatable {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct CreateUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension CreateUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum CreateUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case namespaceName
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case tags
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension CreateWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkgroupInput: Swift.Equatable {
    /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitivity_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
    public var enhancedVpcRouting: Swift.Bool?
    /// The name of the namespace to associate with the workgroup.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessed from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// A array of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?
    /// The name of the created workgroup.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.namespaceName = namespaceName
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.workgroupName = workgroupName
    }
}

struct CreateWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let namespaceName: Swift.String?
    let baseCapacity: Swift.Int?
    let enhancedVpcRouting: Swift.Bool?
    let configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let tags: [RedshiftServerlessClientTypes.Tag]?
    let port: Swift.Int?
}

extension CreateWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case namespaceName
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case tags
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension CreateWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct CreateWorkgroupOutput: Swift.Equatable {
    /// The created workgroup object.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct CreateWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension CreateWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum CreateWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientCapacityException": return try await InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

extension DeleteEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to delete.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct DeleteEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
}

extension DeleteEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension DeleteEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DeleteEndpointAccessOutput: Swift.Equatable {
    /// The deleted VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension DeleteEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum DeleteEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalSnapshotName
        case finalSnapshotRetentionPeriod
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalSnapshotName = self.finalSnapshotName {
            try encodeContainer.encode(finalSnapshotName, forKey: .finalSnapshotName)
        }
        if let finalSnapshotRetentionPeriod = self.finalSnapshotRetentionPeriod {
            try encodeContainer.encode(finalSnapshotRetentionPeriod, forKey: .finalSnapshotRetentionPeriod)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The name of the snapshot to be created before the namespace is deleted.
    public var finalSnapshotName: Swift.String?
    /// How long to retain the final snapshot.
    public var finalSnapshotRetentionPeriod: Swift.Int?
    /// The name of the namespace to delete.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        finalSnapshotName: Swift.String? = nil,
        finalSnapshotRetentionPeriod: Swift.Int? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.finalSnapshotName = finalSnapshotName
        self.finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriod
        self.namespaceName = namespaceName
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let finalSnapshotName: Swift.String?
    let finalSnapshotRetentionPeriod: Swift.Int?
}

extension DeleteNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalSnapshotName
        case finalSnapshotRetentionPeriod
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let finalSnapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalSnapshotName)
        finalSnapshotName = finalSnapshotNameDecoded
        let finalSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalSnapshotRetentionPeriod)
        finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriodDecoded
    }
}

extension DeleteNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct DeleteNamespaceOutput: Swift.Equatable {
    /// The deleted namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct DeleteNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension DeleteNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum DeleteNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension DeleteSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSnapshotInput: Swift.Equatable {
    /// The name of the snapshot to be deleted.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        snapshotName: Swift.String? = nil
    )
    {
        self.snapshotName = snapshotName
    }
}

struct DeleteSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
}

extension DeleteSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension DeleteSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteSnapshotOutput: Swift.Equatable {
    /// The deleted snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension DeleteSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum DeleteSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension DeleteUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUsageLimitInput: Swift.Equatable {
    /// The unique identifier of the usage limit to delete.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

struct DeleteUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
}

extension DeleteUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
    }
}

extension DeleteUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct DeleteUsageLimitOutput: Swift.Equatable {
    /// The deleted usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct DeleteUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension DeleteUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum DeleteUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension DeleteWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkgroupInput: Swift.Equatable {
    /// The name of the workgroup to be deleted.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

struct DeleteWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
}

extension DeleteWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension DeleteWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct DeleteWorkgroupOutput: Swift.Equatable {
    /// The deleted workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct DeleteWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension DeleteWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum DeleteWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case port
        case vpcEndpoints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let vpcEndpoints = vpcEndpoints {
            var vpcEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpoints)
            for vpcendpoint0 in vpcEndpoints {
                try vpcEndpointsContainer.encode(vpcendpoint0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcEndpointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.VpcEndpoint?].self, forKey: .vpcEndpoints)
        var vpcEndpointsDecoded0:[RedshiftServerlessClientTypes.VpcEndpoint]? = nil
        if let vpcEndpointsContainer = vpcEndpointsContainer {
            vpcEndpointsDecoded0 = [RedshiftServerlessClientTypes.VpcEndpoint]()
            for structure0 in vpcEndpointsContainer {
                if let structure0 = structure0 {
                    vpcEndpointsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpoints = vpcEndpointsDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The VPC endpoint object.
    public struct Endpoint: Swift.Equatable {
        /// The DNS address of the VPC endpoint.
        public var address: Swift.String?
        /// The port that Amazon Redshift Serverless listens on.
        public var port: Swift.Int?
        /// An array of VpcEndpoint objects.
        public var vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]?

        public init(
            address: Swift.String? = nil,
            port: Swift.Int? = nil,
            vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]? = nil
        )
        {
            self.address = address
            self.port = port
            self.vpcEndpoints = vpcEndpoints
        }
    }

}

extension RedshiftServerlessClientTypes.EndpointAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case endpointArn
        case endpointCreateTime
        case endpointName
        case endpointStatus
        case port
        case subnetIds
        case vpcEndpoint
        case vpcSecurityGroups
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointCreateTime = self.endpointCreateTime {
            try encodeContainer.encodeTimestamp(endpointCreateTime, format: .dateTime, forKey: .endpointCreateTime)
        }
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let endpointStatus = self.endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpoint = self.vpcEndpoint {
            try encodeContainer.encode(vpcEndpoint, forKey: .vpcEndpoint)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembership0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endpointCreateTime)
        endpointCreateTime = endpointCreateTimeDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[RedshiftServerlessClientTypes.VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Information about an Amazon Redshift Serverless VPC endpoint.
    public struct EndpointAccess: Swift.Equatable {
        /// The DNS address of the endpoint.
        public var address: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint.
        public var endpointArn: Swift.String?
        /// The time that the endpoint was created.
        public var endpointCreateTime: ClientRuntime.Date?
        /// The name of the VPC endpoint.
        public var endpointName: Swift.String?
        /// The status of the VPC endpoint.
        public var endpointStatus: Swift.String?
        /// The port number on which Amazon Redshift Serverless accepts incoming connections.
        public var port: Swift.Int?
        /// The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.
        public var subnetIds: [Swift.String]?
        /// The connection endpoint for connecting to Amazon Redshift Serverless.
        public var vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint?
        /// The security groups associated with the endpoint.
        public var vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]?
        /// The name of the workgroup associated with the endpoint.
        public var workgroupName: Swift.String?

        public init(
            address: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            endpointCreateTime: ClientRuntime.Date? = nil,
            endpointName: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            port: Swift.Int? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint? = nil,
            vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.address = address
            self.endpointArn = endpointArn
            self.endpointCreateTime = endpointCreateTime
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.port = port
            self.subnetIds = subnetIds
            self.vpcEndpoint = vpcEndpoint
            self.vpcSecurityGroups = vpcSecurityGroups
            self.workgroupName = workgroupName
        }
    }

}

extension GetCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbName
        case durationSeconds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension GetCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCredentialsInput: Swift.Equatable {
    /// The name of the database to get temporary authorization to log on to. Constraints:
    ///
    /// * Must be 1 to 64 alphanumeric characters or hyphens.
    ///
    /// * Must contain only uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.
    ///
    /// * The first character must be a letter.
    ///
    /// * Must not contain a colon ( : ) or slash ( / ).
    ///
    /// * Cannot be a reserved word. A list of reserved words can be found in [Reserved Words ](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide
    public var dbName: Swift.String?
    /// The number of seconds until the returned temporary password expires. The minimum is 900 seconds, and the maximum is 3600 seconds.
    public var durationSeconds: Swift.Int?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        dbName: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.dbName = dbName
        self.durationSeconds = durationSeconds
        self.workgroupName = workgroupName
    }
}

struct GetCredentialsInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let dbName: Swift.String?
    let durationSeconds: Swift.Int?
}

extension GetCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbName
        case durationSeconds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension GetCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialsOutput(expiration: \(Swift.String(describing: expiration)), nextRefreshTime: \(Swift.String(describing: nextRefreshTime)), dbPassword: \"CONTENT_REDACTED\", dbUser: \"CONTENT_REDACTED\")"}
}

extension GetCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dbPassword = output.dbPassword
            self.dbUser = output.dbUser
            self.expiration = output.expiration
            self.nextRefreshTime = output.nextRefreshTime
        } else {
            self.dbPassword = nil
            self.dbUser = nil
            self.expiration = nil
            self.nextRefreshTime = nil
        }
    }
}

public struct GetCredentialsOutput: Swift.Equatable {
    /// A temporary password that authorizes the user name returned by DbUser to log on to the database DbName.
    public var dbPassword: Swift.String?
    /// A database user name that is authorized to log on to the database DbName using the password DbPassword. If the specified DbUser exists in the database, the new user name has the same database privileges as the the user named in DbUser. By default, the user is added to PUBLIC.
    public var dbUser: Swift.String?
    /// The date and time the password in DbPassword expires.
    public var expiration: ClientRuntime.Date?
    /// The date and time of when the DbUser and DbPassword authorization refreshes.
    public var nextRefreshTime: ClientRuntime.Date?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        nextRefreshTime: ClientRuntime.Date? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.expiration = expiration
        self.nextRefreshTime = nextRefreshTime
    }
}

struct GetCredentialsOutputBody: Swift.Equatable {
    let dbUser: Swift.String?
    let dbPassword: Swift.String?
    let expiration: ClientRuntime.Date?
    let nextRefreshTime: ClientRuntime.Date?
}

extension GetCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword
        case dbUser
        case expiration
        case nextRefreshTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
        let nextRefreshTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextRefreshTime)
        nextRefreshTime = nextRefreshTimeDecoded
    }
}

enum GetCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

extension GetEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to return information for.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct GetEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
}

extension GetEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension GetEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetEndpointAccessOutput: Swift.Equatable {
    /// The returned VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension GetEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum GetEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension GetNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamespaceInput: Swift.Equatable {
    /// The name of the namespace to retrieve information for.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

struct GetNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension GetNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension GetNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutput: Swift.Equatable {
    /// The returned namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension GetNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum GetNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
    }
}

extension GetRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRecoveryPointInput: Swift.Equatable {
    /// The unique identifier of the recovery point to return information for.
    /// This member is required.
    public var recoveryPointId: Swift.String?

    public init(
        recoveryPointId: Swift.String? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
    }
}

struct GetRecoveryPointInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
}

extension GetRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
    }
}

extension GetRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.recoveryPoint = output.recoveryPoint
        } else {
            self.recoveryPoint = nil
        }
    }
}

public struct GetRecoveryPointOutput: Swift.Equatable {
    /// The returned recovery point object.
    public var recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint?

    public init(
        recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint? = nil
    )
    {
        self.recoveryPoint = recoveryPoint
    }
}

struct GetRecoveryPointOutputBody: Swift.Equatable {
    let recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint?
}

extension GetRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.RecoveryPoint.self, forKey: .recoveryPoint)
        recoveryPoint = recoveryPointDecoded
    }
}

enum GetRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// The returned resource policy.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ResourcePolicy.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case snapshotArn
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension GetSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSnapshotInput: Swift.Equatable {
    /// The owner Amazon Web Services account of a snapshot shared with another user.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to return.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to return.
    public var snapshotName: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
    }
}

struct GetSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let ownerAccount: Swift.String?
    let snapshotArn: Swift.String?
}

extension GetSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case snapshotArn
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
    }
}

extension GetSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct GetSnapshotOutput: Swift.Equatable {
    /// The returned snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct GetSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension GetSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum GetSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableRestoreStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableRestoreRequestId = self.tableRestoreRequestId {
            try encodeContainer.encode(tableRestoreRequestId, forKey: .tableRestoreRequestId)
        }
    }
}

extension GetTableRestoreStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableRestoreStatusInput: Swift.Equatable {
    /// The ID of the RestoreTableFromSnapshot request to return status for.
    /// This member is required.
    public var tableRestoreRequestId: Swift.String?

    public init(
        tableRestoreRequestId: Swift.String? = nil
    )
    {
        self.tableRestoreRequestId = tableRestoreRequestId
    }
}

struct GetTableRestoreStatusInputBody: Swift.Equatable {
    let tableRestoreRequestId: Swift.String?
}

extension GetTableRestoreStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
    }
}

extension GetTableRestoreStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableRestoreStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct GetTableRestoreStatusOutput: Swift.Equatable {
    /// The returned TableRestoreStatus object that contains information about the status of your RestoreTableFromSnapshot request.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct GetTableRestoreStatusOutputBody: Swift.Equatable {
    let tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?
}

extension GetTableRestoreStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

enum GetTableRestoreStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension GetUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUsageLimitInput: Swift.Equatable {
    /// The unique identifier of the usage limit to return information for.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

struct GetUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
}

extension GetUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
    }
}

extension GetUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct GetUsageLimitOutput: Swift.Equatable {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct GetUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension GetUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum GetUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension GetWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetWorkgroupInput: Swift.Equatable {
    /// The name of the workgroup to return information for.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

struct GetWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
}

extension GetWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension GetWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct GetWorkgroupOutput: Swift.Equatable {
    /// The returned workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct GetWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension GetWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum GetWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InsufficientCapacityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is an insufficient capacity to perform the action.
public struct InsufficientCapacityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientCapacityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientCapacityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientCapacityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided pagination token is invalid.
public struct InvalidPaginationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEndpointAccessInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListEndpointAccess operation returns a nextToken, you can include the returned nextToken in following ListEndpointAccess operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The unique identifier of the virtual private cloud with access to Amazon Redshift Serverless.
    public var vpcId: Swift.String?
    /// The name of the workgroup associated with the VPC endpoint to return.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vpcId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcId = vpcId
        self.workgroupName = workgroupName
    }
}

struct ListEndpointAccessInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let vpcId: Swift.String?
}

extension ListEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension ListEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointAccessOutput: Swift.Equatable {
    /// The returned VPC endpoints.
    /// This member is required.
    public var endpoints: [RedshiftServerlessClientTypes.EndpointAccess]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        endpoints: [RedshiftServerlessClientTypes.EndpointAccess]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointAccessOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let endpoints: [RedshiftServerlessClientTypes.EndpointAccess]?
}

extension ListEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.EndpointAccess?].self, forKey: .endpoints)
        var endpointsDecoded0:[RedshiftServerlessClientTypes.EndpointAccess]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [RedshiftServerlessClientTypes.EndpointAccess]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

enum ListEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNamespacesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListNamespacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamespacesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListNamespaces operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
}

extension ListNamespacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNamespacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNamespacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutput: Swift.Equatable {
    /// The list of returned namespaces.
    /// This member is required.
    public var namespaces: [RedshiftServerlessClientTypes.Namespace]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        namespaces: [RedshiftServerlessClientTypes.Namespace]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let namespaces: [RedshiftServerlessClientTypes.Namespace]?
}

extension ListNamespacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let namespacesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Namespace?].self, forKey: .namespaces)
        var namespacesDecoded0:[RedshiftServerlessClientTypes.Namespace]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [RedshiftServerlessClientTypes.Namespace]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
    }
}

enum ListNamespacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryPointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListRecoveryPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecoveryPointsInput: Swift.Equatable {
    /// The time when creation of the recovery point finished.
    public var endTime: ClientRuntime.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list recovery points.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to list recovery points for.
    public var namespaceName: Swift.String?
    /// If your initial ListRecoveryPoints operation returns a nextToken, you can include the returned nextToken in following ListRecoveryPoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The time when the recovery point's creation was initiated.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListRecoveryPointsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let namespaceName: Swift.String?
    let namespaceArn: Swift.String?
}

extension ListRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
    }
}

extension ListRecoveryPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The returned recovery point objects.
    public var recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsOutputBody: Swift.Equatable {
    let recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]?
    let nextToken: Swift.String?
}

extension ListRecoveryPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recoveryPoints
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.RecoveryPoint?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[RedshiftServerlessClientTypes.RecoveryPoint]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [RedshiftServerlessClientTypes.RecoveryPoint]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecoveryPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case ownerAccount
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSnapshotsInput: Swift.Equatable {
    /// The timestamp showing when the snapshot creation finished.
    public var endTime: ClientRuntime.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list all snapshots.
    public var namespaceArn: Swift.String?
    /// The namespace from which to list all snapshots.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account of the snapshot.
    public var ownerAccount: Swift.String?
    /// The time when the creation of the snapshot was initiated.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.startTime = startTime
    }
}

struct ListSnapshotsInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let namespaceArn: Swift.String?
    let ownerAccount: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension ListSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case ownerAccount
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ListSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct ListSnapshotsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned snapshot objects.
    public var snapshots: [RedshiftServerlessClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [RedshiftServerlessClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct ListSnapshotsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let snapshots: [RedshiftServerlessClientTypes.Snapshot]?
}

extension ListSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case snapshots
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let snapshotsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Snapshot?].self, forKey: .snapshots)
        var snapshotsDecoded0:[RedshiftServerlessClientTypes.Snapshot]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [RedshiftServerlessClientTypes.Snapshot]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
    }
}

enum ListSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableRestoreStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListTableRestoreStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTableRestoreStatusInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The namespace from which to list all of the statuses of RestoreTableFromSnapshot operations .
    public var namespaceName: Swift.String?
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will return results on the next page.
    public var nextToken: Swift.String?
    /// The workgroup from which to list all of the statuses of RestoreTableFromSnapshot operations.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.workgroupName = workgroupName
    }
}

struct ListTableRestoreStatusInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
}

extension ListTableRestoreStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension ListTableRestoreStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableRestoreStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableRestoreStatuses = output.tableRestoreStatuses
        } else {
            self.nextToken = nil
            self.tableRestoreStatuses = nil
        }
    }
}

public struct ListTableRestoreStatusOutput: Swift.Equatable {
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will returns results on the next page.
    public var nextToken: Swift.String?
    /// The array of returned TableRestoreStatus objects.
    public var tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]?

    public init(
        nextToken: Swift.String? = nil,
        tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableRestoreStatuses = tableRestoreStatuses
    }
}

struct ListTableRestoreStatusOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]?
}

extension ListTableRestoreStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tableRestoreStatuses
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tableRestoreStatusesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.TableRestoreStatus?].self, forKey: .tableRestoreStatuses)
        var tableRestoreStatusesDecoded0:[RedshiftServerlessClientTypes.TableRestoreStatus]? = nil
        if let tableRestoreStatusesContainer = tableRestoreStatusesContainer {
            tableRestoreStatusesDecoded0 = [RedshiftServerlessClientTypes.TableRestoreStatus]()
            for structure0 in tableRestoreStatusesContainer {
                if let structure0 = structure0 {
                    tableRestoreStatusesDecoded0?.append(structure0)
                }
            }
        }
        tableRestoreStatuses = tableRestoreStatusesDecoded0
    }
}

enum ListTableRestoreStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of the key-value pairs assigned to the resource.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsageLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }
}

extension ListUsageLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsageLimitsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 100.
    public var maxResults: Swift.Int?
    /// If your initial ListUsageLimits operation returns a nextToken, you can include the returned nextToken in following ListUsageLimits operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the resource whose usage limits you want to list.
    public var resourceArn: Swift.String?
    /// The Amazon Redshift Serverless feature whose limits you want to see.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

struct ListUsageLimitsInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?
}

extension ListUsageLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case usageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
    }
}

extension ListUsageLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsageLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageLimits = output.usageLimits
        } else {
            self.nextToken = nil
            self.usageLimits = nil
        }
    }
}

public struct ListUsageLimitsOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// An array of returned usage limit objects.
    public var usageLimits: [RedshiftServerlessClientTypes.UsageLimit]?

    public init(
        nextToken: Swift.String? = nil,
        usageLimits: [RedshiftServerlessClientTypes.UsageLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageLimits = usageLimits
    }
}

struct ListUsageLimitsOutputBody: Swift.Equatable {
    let usageLimits: [RedshiftServerlessClientTypes.UsageLimit]?
    let nextToken: Swift.String?
}

extension ListUsageLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case usageLimits
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.UsageLimit?].self, forKey: .usageLimits)
        var usageLimitsDecoded0:[RedshiftServerlessClientTypes.UsageLimit]? = nil
        if let usageLimitsContainer = usageLimitsContainer {
            usageLimitsDecoded0 = [RedshiftServerlessClientTypes.UsageLimit]()
            for structure0 in usageLimitsContainer {
                if let structure0 = structure0 {
                    usageLimitsDecoded0?.append(structure0)
                }
            }
        }
        usageLimits = usageLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsageLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkgroupsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListWorkgroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkgroupsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListWorkgroups operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkgroupsInputBody: Swift.Equatable {
}

extension ListWorkgroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkgroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkgroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workgroups = output.workgroups
        } else {
            self.nextToken = nil
            self.workgroups = nil
        }
    }
}

public struct ListWorkgroupsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token.
    public var nextToken: Swift.String?
    /// The returned array of workgroups.
    /// This member is required.
    public var workgroups: [RedshiftServerlessClientTypes.Workgroup]?

    public init(
        nextToken: Swift.String? = nil,
        workgroups: [RedshiftServerlessClientTypes.Workgroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.workgroups = workgroups
    }
}

struct ListWorkgroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workgroups: [RedshiftServerlessClientTypes.Workgroup]?
}

extension ListWorkgroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workgroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workgroupsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Workgroup?].self, forKey: .workgroups)
        var workgroupsDecoded0:[RedshiftServerlessClientTypes.Workgroup]? = nil
        if let workgroupsContainer = workgroupsContainer {
            workgroupsDecoded0 = [RedshiftServerlessClientTypes.Workgroup]()
            for structure0 in workgroupsContainer {
                if let structure0 = structure0 {
                    workgroupsDecoded0?.append(structure0)
                }
            }
        }
        workgroups = workgroupsDecoded0
    }
}

enum ListWorkgroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum LogExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionLog
        case userActivityLog
        case userLog
        case sdkUnknown(Swift.String)

        public static var allCases: [LogExport] {
            return [
                .connectionLog,
                .userActivityLog,
                .userLog,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionLog: return "connectionlog"
            case .userActivityLog: return "useractivitylog"
            case .userLog: return "userlog"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogExport(rawValue: rawValue) ?? LogExport.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.Namespace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUsername
        case creationDate
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceArn
        case namespaceId
        case namespaceName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .dateTime, forKey: .creationDate)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceId = self.namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.NamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension RedshiftServerlessClientTypes.Namespace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Namespace(creationDate: \(Swift.String(describing: creationDate)), dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), namespaceArn: \(Swift.String(describing: namespaceArn)), namespaceId: \(Swift.String(describing: namespaceId)), namespaceName: \(Swift.String(describing: namespaceName)), status: \(Swift.String(describing: status)), adminUsername: \"CONTENT_REDACTED\")"}
}

extension RedshiftServerlessClientTypes {
    /// A collection of database objects and users.
    public struct Namespace: Swift.Equatable {
        /// The username of the administrator for the first database created in the namespace.
        public var adminUsername: Swift.String?
        /// The date of when the namespace was created.
        public var creationDate: ClientRuntime.Date?
        /// The name of the first database created in the namespace.
        public var dbName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
        public var defaultIamRoleArn: Swift.String?
        /// A list of IAM roles to associate with the namespace.
        public var iamRoles: [Swift.String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.
        public var logExports: [RedshiftServerlessClientTypes.LogExport]?
        /// The Amazon Resource Name (ARN) associated with a namespace.
        public var namespaceArn: Swift.String?
        /// The unique identifier of a namespace.
        public var namespaceId: Swift.String?
        /// The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in [Reserved Words](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide.
        public var namespaceName: Swift.String?
        /// The status of the namespace.
        public var status: RedshiftServerlessClientTypes.NamespaceStatus?

        public init(
            adminUsername: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            dbName: Swift.String? = nil,
            defaultIamRoleArn: Swift.String? = nil,
            iamRoles: [Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            status: RedshiftServerlessClientTypes.NamespaceStatus? = nil
        )
        {
            self.adminUsername = adminUsername
            self.creationDate = creationDate
            self.dbName = dbName
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.namespaceArn = namespaceArn
            self.namespaceId = namespaceId
            self.namespaceName = namespaceName
            self.status = status
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum NamespaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .available,
                .deleting,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceStatus(rawValue: rawValue) ?? NamespaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case networkInterfaceId
        case privateIpAddress
        case subnetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a network interface in an Amazon Redshift Serverless managed VPC endpoint.
    public struct NetworkInterface: Swift.Equatable {
        /// The availability Zone.
        public var availabilityZone: Swift.String?
        /// The unique identifier of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The unique identifier of the subnet.
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
        }
    }

}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot. "{\"Version\": \"2012-10-17\", \"Statement\" : [{ \"Sid\": \"AllowUserRestoreFromSnapshot\", \"Principal\":{\"AWS\": [\"739247239426\"]}, \"Action\": [\"redshift-serverless:RestoreFromSnapshot\"] , \"Effect\": \"Allow\" }]}"
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the account to create or update a resource policy for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourcePolicy = nil
        }
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {
    /// The policy that was created or updated.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

struct PutResourcePolicyOutputBody: Swift.Equatable {
    let resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?
}

extension PutResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ResourcePolicy.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.RecoveryPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
        case recoveryPointCreateTime
        case recoveryPointId
        case totalSizeInMegaBytes
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let recoveryPointCreateTime = self.recoveryPointCreateTime {
            try encodeContainer.encodeTimestamp(recoveryPointCreateTime, format: .dateTime, forKey: .recoveryPointCreateTime)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let totalSizeInMegaBytes = self.totalSizeInMegaBytes {
            try encodeContainer.encode(totalSizeInMegaBytes, forKey: .totalSizeInMegaBytes)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let recoveryPointCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .recoveryPointCreateTime)
        recoveryPointCreateTime = recoveryPointCreateTimeDecoded
        let totalSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalSizeInMegaBytes)
        totalSizeInMegaBytes = totalSizeInMegaBytesDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The automatically created recovery point of a namespace. Recovery points are created every 30 minutes and kept for 24 hours.
    public struct RecoveryPoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.
        public var namespaceArn: Swift.String?
        /// The name of the namespace the recovery point is associated with.
        public var namespaceName: Swift.String?
        /// The time the recovery point is created.
        public var recoveryPointCreateTime: ClientRuntime.Date?
        /// The unique identifier of the recovery point.
        public var recoveryPointId: Swift.String?
        /// The total size of the data in the recovery point in megabytes.
        public var totalSizeInMegaBytes: Swift.Double?
        /// The name of the workgroup the recovery point is associated with.
        public var workgroupName: Swift.String?

        public init(
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            recoveryPointCreateTime: ClientRuntime.Date? = nil,
            recoveryPointId: Swift.String? = nil,
            totalSizeInMegaBytes: Swift.Double? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.recoveryPointCreateTime = recoveryPointCreateTime
            self.recoveryPointId = recoveryPointId
            self.totalSizeInMegaBytes = totalSizeInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension RedshiftServerlessClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.
    public struct ResourcePolicy: Swift.Equatable {
        /// The resource policy.
        public var policy: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        public var resourceArn: Swift.String?

        public init(
            policy: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.policy = policy
            self.resourceArn = resourceArn
        }
    }

}

extension RestoreFromRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case recoveryPointId
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreFromRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreFromRecoveryPointInput: Swift.Equatable {
    /// The name of the namespace to restore data into.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The unique identifier of the recovery point to restore from.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// The name of the workgroup used to restore data.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil,
        recoveryPointId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
        self.recoveryPointId = recoveryPointId
        self.workgroupName = workgroupName
    }
}

struct RestoreFromRecoveryPointInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
}

extension RestoreFromRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case recoveryPointId
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension RestoreFromRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreFromRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.recoveryPointId = output.recoveryPointId
        } else {
            self.namespace = nil
            self.recoveryPointId = nil
        }
    }
}

public struct RestoreFromRecoveryPointOutput: Swift.Equatable {
    /// The namespace that data was restored into.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The unique identifier of the recovery point used for the restore.
    public var recoveryPointId: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        recoveryPointId: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.recoveryPointId = recoveryPointId
    }
}

struct RestoreFromRecoveryPointOutputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension RestoreFromRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
        case recoveryPointId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum RestoreFromRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreFromSnapshotInput: Swift.Equatable {
    /// The name of the namespace to restore the snapshot to.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The Amazon Web Services account that owns the snapshot.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to restore from. Required if restoring from Amazon Redshift Serverless to a provisioned cluster. Must not be specified at the same time as snapshotName. The format of the ARN is arn:aws:redshift:<region>:<account_id>:snapshot:<cluster_identifier>/<snapshot_identifier>.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to restore from. Must not be specified at the same time as snapshotArn.
    public var snapshotName: Swift.String?
    /// The name of the workgroup used to restore the snapshot.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
        self.workgroupName = workgroupName
    }
}

struct RestoreFromSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
    let snapshotName: Swift.String?
    let snapshotArn: Swift.String?
    let ownerAccount: Swift.String?
}

extension RestoreFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
    }
}

extension RestoreFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.ownerAccount = output.ownerAccount
            self.snapshotName = output.snapshotName
        } else {
            self.namespace = nil
            self.ownerAccount = nil
            self.snapshotName = nil
        }
    }
}

public struct RestoreFromSnapshotOutput: Swift.Equatable {
    /// A collection of database objects and users.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The owner Amazon Web Services; account of the snapshot that was restored.
    public var ownerAccount: Swift.String?
    /// The name of the snapshot used to restore the namespace.
    public var snapshotName: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.ownerAccount = ownerAccount
        self.snapshotName = snapshotName
    }
}

struct RestoreFromSnapshotOutputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let ownerAccount: Swift.String?
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension RestoreFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
        case ownerAccount
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum RestoreFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreTableFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activateCaseSensitiveIdentifier = self.activateCaseSensitiveIdentifier {
            try encodeContainer.encode(activateCaseSensitiveIdentifier, forKey: .activateCaseSensitiveIdentifier)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let newTableName = self.newTableName {
            try encodeContainer.encode(newTableName, forKey: .newTableName)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let sourceDatabaseName = self.sourceDatabaseName {
            try encodeContainer.encode(sourceDatabaseName, forKey: .sourceDatabaseName)
        }
        if let sourceSchemaName = self.sourceSchemaName {
            try encodeContainer.encode(sourceSchemaName, forKey: .sourceSchemaName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetSchemaName = self.targetSchemaName {
            try encodeContainer.encode(targetSchemaName, forKey: .targetSchemaName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreTableFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreTableFromSnapshotInput: Swift.Equatable {
    /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
    public var activateCaseSensitiveIdentifier: Swift.Bool?
    /// The namespace of the snapshot to restore from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the table to create from the restore operation.
    /// This member is required.
    public var newTableName: Swift.String?
    /// The name of the snapshot to restore the table from.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// The name of the source database that contains the table being restored.
    /// This member is required.
    public var sourceDatabaseName: Swift.String?
    /// The name of the source schema that contains the table being restored.
    public var sourceSchemaName: Swift.String?
    /// The name of the source table being restored.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// The name of the database to restore the table to.
    public var targetDatabaseName: Swift.String?
    /// The name of the schema to restore the table to.
    public var targetSchemaName: Swift.String?
    /// The workgroup to restore the table to.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        activateCaseSensitiveIdentifier: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        newTableName: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
        self.namespaceName = namespaceName
        self.newTableName = newTableName
        self.snapshotName = snapshotName
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.workgroupName = workgroupName
    }
}

struct RestoreTableFromSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
    let snapshotName: Swift.String?
    let sourceDatabaseName: Swift.String?
    let sourceSchemaName: Swift.String?
    let sourceTableName: Swift.String?
    let targetDatabaseName: Swift.String?
    let targetSchemaName: Swift.String?
    let newTableName: Swift.String?
    let activateCaseSensitiveIdentifier: Swift.Bool?
}

extension RestoreTableFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
        let activateCaseSensitiveIdentifierDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activateCaseSensitiveIdentifier)
        activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifierDecoded
    }
}

extension RestoreTableFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreTableFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct RestoreTableFromSnapshotOutput: Swift.Equatable {
    /// The TableRestoreStatus object that contains the status of the restore operation.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct RestoreTableFromSnapshotOutputBody: Swift.Equatable {
    let tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?
}

extension RestoreTableFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

enum RestoreTableFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service limit was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsWithProvisionedRestoreAccess
        case accountsWithRestoreAccess
        case actualIncrementalBackupSizeInMegaBytes
        case adminUsername
        case backupProgressInMegaBytes
        case currentBackupRateInMegaBytesPerSecond
        case elapsedTimeInSeconds
        case estimatedSecondsToCompletion
        case kmsKeyId
        case namespaceArn
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotCreateTime
        case snapshotName
        case snapshotRemainingDays
        case snapshotRetentionPeriod
        case snapshotRetentionStartTime
        case status
        case totalBackupSizeInMegaBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess {
            var accountsWithProvisionedRestoreAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountsWithProvisionedRestoreAccess)
            for string0 in accountsWithProvisionedRestoreAccess {
                try accountsWithProvisionedRestoreAccessContainer.encode(string0)
            }
        }
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountsWithRestoreAccess)
            for string0 in accountsWithRestoreAccess {
                try accountsWithRestoreAccessContainer.encode(string0)
            }
        }
        if let actualIncrementalBackupSizeInMegaBytes = self.actualIncrementalBackupSizeInMegaBytes {
            try encodeContainer.encode(actualIncrementalBackupSizeInMegaBytes, forKey: .actualIncrementalBackupSizeInMegaBytes)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let backupProgressInMegaBytes = self.backupProgressInMegaBytes {
            try encodeContainer.encode(backupProgressInMegaBytes, forKey: .backupProgressInMegaBytes)
        }
        if let currentBackupRateInMegaBytesPerSecond = self.currentBackupRateInMegaBytesPerSecond {
            try encodeContainer.encode(currentBackupRateInMegaBytesPerSecond, forKey: .currentBackupRateInMegaBytesPerSecond)
        }
        if let elapsedTimeInSeconds = self.elapsedTimeInSeconds {
            try encodeContainer.encode(elapsedTimeInSeconds, forKey: .elapsedTimeInSeconds)
        }
        if let estimatedSecondsToCompletion = self.estimatedSecondsToCompletion {
            try encodeContainer.encode(estimatedSecondsToCompletion, forKey: .estimatedSecondsToCompletion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encodeTimestamp(snapshotCreateTime, format: .dateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let snapshotRemainingDays = self.snapshotRemainingDays {
            try encodeContainer.encode(snapshotRemainingDays, forKey: .snapshotRemainingDays)
        }
        if let snapshotRetentionPeriod = self.snapshotRetentionPeriod {
            try encodeContainer.encode(snapshotRetentionPeriod, forKey: .snapshotRetentionPeriod)
        }
        if let snapshotRetentionStartTime = self.snapshotRetentionStartTime {
            try encodeContainer.encodeTimestamp(snapshotRetentionStartTime, format: .dateTime, forKey: .snapshotRetentionStartTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalBackupSizeInMegaBytes = self.totalBackupSizeInMegaBytes {
            try encodeContainer.encode(totalBackupSizeInMegaBytes, forKey: .totalBackupSizeInMegaBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let snapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionPeriod)
        snapshotRetentionPeriod = snapshotRetentionPeriodDecoded
        let snapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRemainingDays)
        snapshotRemainingDays = snapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .snapshotRetentionStartTime)
        snapshotRetentionStartTime = snapshotRetentionStartTimeDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let accountsWithRestoreAccessContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountsWithRestoreAccess)
        var accountsWithRestoreAccessDecoded0:[Swift.String]? = nil
        if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
            accountsWithRestoreAccessDecoded0 = [Swift.String]()
            for string0 in accountsWithRestoreAccessContainer {
                if let string0 = string0 {
                    accountsWithRestoreAccessDecoded0?.append(string0)
                }
            }
        }
        accountsWithRestoreAccess = accountsWithRestoreAccessDecoded0
        let accountsWithProvisionedRestoreAccessContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountsWithProvisionedRestoreAccess)
        var accountsWithProvisionedRestoreAccessDecoded0:[Swift.String]? = nil
        if let accountsWithProvisionedRestoreAccessContainer = accountsWithProvisionedRestoreAccessContainer {
            accountsWithProvisionedRestoreAccessDecoded0 = [Swift.String]()
            for string0 in accountsWithProvisionedRestoreAccessContainer {
                if let string0 = string0 {
                    accountsWithProvisionedRestoreAccessDecoded0?.append(string0)
                }
            }
        }
        accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccessDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// A snapshot object that contains databases.
    public struct Snapshot: Swift.Equatable {
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.
        public var accountsWithProvisionedRestoreAccess: [Swift.String]?
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.
        public var accountsWithRestoreAccess: [Swift.String]?
        /// The size of the incremental backup in megabytes.
        public var actualIncrementalBackupSizeInMegaBytes: Swift.Double?
        /// The username of the database within a snapshot.
        public var adminUsername: Swift.String?
        /// The size in megabytes of the data that has been backed up to a snapshot.
        public var backupProgressInMegaBytes: Swift.Double?
        /// The rate at which data is backed up into a snapshot in megabytes per second.
        public var currentBackupRateInMegaBytesPerSecond: Swift.Double?
        /// The amount of time it took to back up data into a snapshot.
        public var elapsedTimeInSeconds: Swift.Int?
        /// The estimated amount of seconds until the snapshot completes backup.
        public var estimatedSecondsToCompletion: Swift.Int?
        /// The unique identifier of the KMS key used to encrypt the snapshot.
        public var kmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the namespace the snapshot was created from.
        public var namespaceArn: Swift.String?
        /// The name of the namepsace.
        public var namespaceName: Swift.String?
        /// The owner Amazon Web Services; account of the snapshot.
        public var ownerAccount: Swift.String?
        /// The Amazon Resource Name (ARN) of the snapshot.
        public var snapshotArn: Swift.String?
        /// The timestamp of when the snapshot was created.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// The name of the snapshot.
        public var snapshotName: Swift.String?
        /// The amount of days until the snapshot is deleted.
        public var snapshotRemainingDays: Swift.Int?
        /// The period of time, in days, of how long the snapshot is retained.
        public var snapshotRetentionPeriod: Swift.Int?
        /// The timestamp of when data within the snapshot started getting retained.
        public var snapshotRetentionStartTime: ClientRuntime.Date?
        /// The status of the snapshot.
        public var status: RedshiftServerlessClientTypes.SnapshotStatus?
        /// The total size, in megabytes, of how big the snapshot is.
        public var totalBackupSizeInMegaBytes: Swift.Double?

        public init(
            accountsWithProvisionedRestoreAccess: [Swift.String]? = nil,
            accountsWithRestoreAccess: [Swift.String]? = nil,
            actualIncrementalBackupSizeInMegaBytes: Swift.Double? = nil,
            adminUsername: Swift.String? = nil,
            backupProgressInMegaBytes: Swift.Double? = nil,
            currentBackupRateInMegaBytesPerSecond: Swift.Double? = nil,
            elapsedTimeInSeconds: Swift.Int? = nil,
            estimatedSecondsToCompletion: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotName: Swift.String? = nil,
            snapshotRemainingDays: Swift.Int? = nil,
            snapshotRetentionPeriod: Swift.Int? = nil,
            snapshotRetentionStartTime: ClientRuntime.Date? = nil,
            status: RedshiftServerlessClientTypes.SnapshotStatus? = nil,
            totalBackupSizeInMegaBytes: Swift.Double? = nil
        )
        {
            self.accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess
            self.accountsWithRestoreAccess = accountsWithRestoreAccess
            self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
            self.adminUsername = adminUsername
            self.backupProgressInMegaBytes = backupProgressInMegaBytes
            self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
            self.kmsKeyId = kmsKeyId
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotName = snapshotName
            self.snapshotRemainingDays = snapshotRemainingDays
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
            self.snapshotRetentionStartTime = snapshotRetentionStartTime
            self.status = status
            self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case cancelled
        case copying
        case creating
        case deleted
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .cancelled,
                .copying,
                .creating,
                .deleted,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .cancelled: return "CANCELLED"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.TableRestoreStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case namespaceName
        case newTableName
        case progressInMegaBytes
        case requestTime
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case status
        case tableRestoreRequestId
        case targetDatabaseName
        case targetSchemaName
        case totalDataInMegaBytes
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let newTableName = self.newTableName {
            try encodeContainer.encode(newTableName, forKey: .newTableName)
        }
        if let progressInMegaBytes = self.progressInMegaBytes {
            try encodeContainer.encode(progressInMegaBytes, forKey: .progressInMegaBytes)
        }
        if let requestTime = self.requestTime {
            try encodeContainer.encodeTimestamp(requestTime, format: .epochSeconds, forKey: .requestTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let sourceDatabaseName = self.sourceDatabaseName {
            try encodeContainer.encode(sourceDatabaseName, forKey: .sourceDatabaseName)
        }
        if let sourceSchemaName = self.sourceSchemaName {
            try encodeContainer.encode(sourceSchemaName, forKey: .sourceSchemaName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tableRestoreRequestId = self.tableRestoreRequestId {
            try encodeContainer.encode(tableRestoreRequestId, forKey: .tableRestoreRequestId)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetSchemaName = self.targetSchemaName {
            try encodeContainer.encode(targetSchemaName, forKey: .targetSchemaName)
        }
        if let totalDataInMegaBytes = self.totalDataInMegaBytes {
            try encodeContainer.encode(totalDataInMegaBytes, forKey: .totalDataInMegaBytes)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestTime)
        requestTime = requestTimeDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a table restore request.
    public struct TableRestoreStatus: Swift.Equatable {
        /// A description of the status of the table restore request. Status values include SUCCEEDED, FAILED, CANCELED, PENDING, IN_PROGRESS.
        public var message: Swift.String?
        /// The namespace of the table being restored from.
        public var namespaceName: Swift.String?
        /// The name of the table to create from the restore operation.
        public var newTableName: Swift.String?
        /// The amount of data restored to the new table so far, in megabytes (MB).
        public var progressInMegaBytes: Swift.Int?
        /// The time that the table restore request was made, in Universal Coordinated Time (UTC).
        public var requestTime: ClientRuntime.Date?
        /// The name of the snapshot being restored from.
        public var snapshotName: Swift.String?
        /// The name of the source database being restored from.
        public var sourceDatabaseName: Swift.String?
        /// The name of the source schema being restored from.
        public var sourceSchemaName: Swift.String?
        /// The name of the source table being restored from.
        public var sourceTableName: Swift.String?
        /// A value that describes the current state of the table restore request. Possible values include SUCCEEDED, FAILED, CANCELED, PENDING, IN_PROGRESS.
        public var status: Swift.String?
        /// The ID of the RestoreTableFromSnapshot request.
        public var tableRestoreRequestId: Swift.String?
        /// The name of the database to restore to.
        public var targetDatabaseName: Swift.String?
        /// The name of the schema to restore to.
        public var targetSchemaName: Swift.String?
        /// The total amount of data to restore to the new table, in megabytes (MB).
        public var totalDataInMegaBytes: Swift.Int?
        /// The name of the workgroup being restored from.
        public var workgroupName: Swift.String?

        public init(
            message: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            newTableName: Swift.String? = nil,
            progressInMegaBytes: Swift.Int? = nil,
            requestTime: ClientRuntime.Date? = nil,
            snapshotName: Swift.String? = nil,
            sourceDatabaseName: Swift.String? = nil,
            sourceSchemaName: Swift.String? = nil,
            sourceTableName: Swift.String? = nil,
            status: Swift.String? = nil,
            tableRestoreRequestId: Swift.String? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetSchemaName: Swift.String? = nil,
            totalDataInMegaBytes: Swift.Int? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.message = message
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.progressInMegaBytes = progressInMegaBytes
            self.requestTime = requestTime
            self.snapshotName = snapshotName
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.status = status
            self.tableRestoreRequestId = tableRestoreRequestId
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.totalDataInMegaBytes = totalDataInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

extension RedshiftServerlessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// A map of key-value pairs.
    public struct Tag: Swift.Equatable {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The map of the key-value pairs used to tag the resource.
    /// This member is required.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeded the number of tags allowed for a resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that exceeded the number of tags allowed for a resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupid0)
            }
        }
    }
}

extension UpdateEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to update.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The list of VPC security groups associated with the endpoint after the endpoint is modified.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        endpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.endpointName = endpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct UpdateEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension UpdateEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension UpdateEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct UpdateEndpointAccessOutput: Swift.Equatable {
    /// The updated VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct UpdateEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension UpdateEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum UpdateEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNamespaceInput(defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), namespaceName: \(Swift.String(describing: namespaceName)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

extension UpdateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case adminUsername
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension UpdateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNamespaceInput: Swift.Equatable {
    /// The password of the administrator for the first database created in the namespace. This parameter must be updated together with adminUsername.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace. This parameter must be updated together with adminUserPassword.
    public var adminUsername: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace. This parameter must be updated together with iamRoles.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace. This parameter must be updated together with defaultIamRoleArn.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. The export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// The name of the namespace to update. You can't update the name of a namespace once it is created.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.namespaceName = namespaceName
    }
}

struct UpdateNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let adminUserPassword: Swift.String?
    let adminUsername: Swift.String?
    let kmsKeyId: Swift.String?
    let defaultIamRoleArn: Swift.String?
    let iamRoles: [Swift.String]?
    let logExports: [RedshiftServerlessClientTypes.LogExport]?
}

extension UpdateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case adminUsername
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
    }
}

extension UpdateNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct UpdateNamespaceOutput: Swift.Equatable {
    /// A list of tag instances.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct UpdateNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension UpdateNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum UpdateNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriod
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension UpdateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSnapshotInput: Swift.Equatable {
    /// The new retention period of the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
    }
}

struct UpdateSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
}

extension UpdateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriod
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension UpdateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct UpdateSnapshotOutput: Swift.Equatable {
    /// The updated snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct UpdateSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension UpdateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum UpdateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension UpdateUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUsageLimitInput: Swift.Equatable {
    /// The new limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    public var amount: Swift.Int?
    /// The new action that Amazon Redshift Serverless takes when the limit is reached.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The identifier of the usage limit to update.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.usageLimitId = usageLimitId
    }
}

struct UpdateUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
    let amount: Swift.Int?
    let breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
}

extension UpdateUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension UpdateUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct UpdateUsageLimitOutput: Swift.Equatable {
    /// The updated usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct UpdateUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension UpdateUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum UpdateUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension UpdateWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkgroupInput: Swift.Equatable {
    /// The new base data warehouse capacity in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitivity_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
    public var enhancedVpcRouting: Swift.Bool?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessible from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// The name of the workgroup to update. You can't update the name of a workgroup once it is created.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.workgroupName = workgroupName
    }
}

struct UpdateWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let baseCapacity: Swift.Int?
    let enhancedVpcRouting: Swift.Bool?
    let configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    let publiclyAccessible: Swift.Bool?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let port: Swift.Int?
}

extension UpdateWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension UpdateWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct UpdateWorkgroupOutput: Swift.Equatable {
    /// The updated workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct UpdateWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension UpdateWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum UpdateWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientCapacityException": return try await InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.UsageLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageLimitArn
        case usageLimitId
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageLimitArn = self.usageLimitArn {
            try encodeContainer.encode(usageLimitArn, forKey: .usageLimitArn)
        }
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let usageLimitArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitArn)
        usageLimitArn = usageLimitArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The usage limit object.
    public struct UsageLimit: Swift.Equatable {
        /// The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.
        public var amount: Swift.Int?
        /// The action that Amazon Redshift Serverless takes when the limit is reached.
        public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
        /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
        public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
        /// The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.
        public var resourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource associated with the usage limit.
        public var usageLimitArn: Swift.String?
        /// The identifier of the usage limit.
        public var usageLimitId: Swift.String?
        /// The Amazon Redshift Serverless feature to limit.
        public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

        public init(
            amount: Swift.Int? = nil,
            breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
            period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
            resourceArn: Swift.String? = nil,
            usageLimitArn: Swift.String? = nil,
            usageLimitId: Swift.String? = nil,
            usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
        )
        {
            self.amount = amount
            self.breachAction = breachAction
            self.period = period
            self.resourceArn = resourceArn
            self.usageLimitArn = usageLimitArn
            self.usageLimitId = usageLimitId
            self.usageType = usageType
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitBreachAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deactivate
        case emitMetric
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitBreachAction] {
            return [
                .deactivate,
                .emitMetric,
                .log,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "deactivate"
            case .emitMetric: return "emit-metric"
            case .log: return "log"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitBreachAction(rawValue: rawValue) ?? UsageLimitBreachAction.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitPeriod] {
            return [
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "daily"
            case .monthly: return "monthly"
            case .weekly: return "weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitPeriod(rawValue: rawValue) ?? UsageLimitPeriod.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossRegionDatasharing
        case serverlessCompute
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitUsageType] {
            return [
                .crossRegionDatasharing,
                .serverlessCompute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossRegionDatasharing: return "cross-region-datasharing"
            case .serverlessCompute: return "serverless-compute"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitUsageType(rawValue: rawValue) ?? UsageLimitUsageType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input failed to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.VpcEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaces
        case vpcEndpointId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[RedshiftServerlessClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [RedshiftServerlessClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.
    public struct VpcEndpoint: Swift.Equatable {
        /// One or more network interfaces of the endpoint. Also known as an interface endpoint.
        public var networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]?
        /// The connection endpoint ID for connecting to Amazon Redshift Serverless.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier that the endpoint is associated with.
        public var vpcId: Swift.String?

        public init(
            networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkInterfaces = networkInterfaces
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension RedshiftServerlessClientTypes.VpcSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case vpcSecurityGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Describes the members of a VPC security group.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The unique identifier of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension RedshiftServerlessClientTypes.Workgroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case creationDate
        case endpoint
        case enhancedVpcRouting
        case namespaceName
        case port
        case publiclyAccessible
        case securityGroupIds
        case status
        case subnetIds
        case workgroupArn
        case workgroupId
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .dateTime, forKey: .creationDate)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let workgroupArn = self.workgroupArn {
            try encodeContainer.encode(workgroupArn, forKey: .workgroupArn)
        }
        if let workgroupId = self.workgroupId {
            try encodeContainer.encode(workgroupId, forKey: .workgroupId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupId)
        workgroupId = workgroupIdDecoded
        let workgroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupArn)
        workgroupArn = workgroupArnDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.WorkgroupStatus.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The collection of computing resources from which an endpoint is created.
    public struct Workgroup: Swift.Equatable {
        /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
        public var baseCapacity: Swift.Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitivity_identifier, enable_user_activity_logging, query_group, , search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
        /// The creation date of the workgroup.
        public var creationDate: ClientRuntime.Date?
        /// The endpoint that is created from the workgroup.
        public var endpoint: RedshiftServerlessClientTypes.Endpoint?
        /// The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
        public var enhancedVpcRouting: Swift.Bool?
        /// The namespace the workgroup is associated with.
        public var namespaceName: Swift.String?
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public var port: Swift.Int?
        /// A value that specifies whether the workgroup can be accessible from a public network
        public var publiclyAccessible: Swift.Bool?
        /// An array of security group IDs to associate with the workgroup.
        public var securityGroupIds: [Swift.String]?
        /// The status of the workgroup.
        public var status: RedshiftServerlessClientTypes.WorkgroupStatus?
        /// An array of subnet IDs the workgroup is associated with.
        public var subnetIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) that links to the workgroup.
        public var workgroupArn: Swift.String?
        /// The unique identifier of the workgroup.
        public var workgroupId: Swift.String?
        /// The name of the workgroup.
        public var workgroupName: Swift.String?

        public init(
            baseCapacity: Swift.Int? = nil,
            configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
            creationDate: ClientRuntime.Date? = nil,
            endpoint: RedshiftServerlessClientTypes.Endpoint? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            namespaceName: Swift.String? = nil,
            port: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: RedshiftServerlessClientTypes.WorkgroupStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            workgroupArn: Swift.String? = nil,
            workgroupId: Swift.String? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.creationDate = creationDate
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.namespaceName = namespaceName
            self.port = port
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.workgroupArn = workgroupArn
            self.workgroupId = workgroupId
            self.workgroupName = workgroupName
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum WorkgroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkgroupStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkgroupStatus(rawValue: rawValue) ?? WorkgroupStatus.sdkUnknown(rawValue)
        }
    }
}
