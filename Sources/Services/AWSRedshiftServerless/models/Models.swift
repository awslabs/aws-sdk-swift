// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.Association: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainCertificateExpiryTime
        case customDomainName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainCertificateArn = self.customDomainCertificateArn {
            try encodeContainer.encode(customDomainCertificateArn, forKey: .customDomainCertificateArn)
        }
        if let customDomainCertificateExpiryTime = self.customDomainCertificateExpiryTime {
            try encodeContainer.encodeTimestamp(customDomainCertificateExpiryTime, format: .dateTime, forKey: .customDomainCertificateExpiryTime)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
        let customDomainCertificateExpiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .customDomainCertificateExpiryTime)
        customDomainCertificateExpiryTime = customDomainCertificateExpiryTimeDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// An object that represents the custom domain name association.
    public struct Association: Swift.Equatable {
        /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
        public var customDomainCertificateArn: Swift.String?
        /// The expiration time for the certificate.
        public var customDomainCertificateExpiryTime: ClientRuntime.Date?
        /// The custom domain name associated with the workgroup.
        public var customDomainName: Swift.String?
        /// The name of the workgroup associated with the database.
        public var workgroupName: Swift.String?

        public init(
            customDomainCertificateArn: Swift.String? = nil,
            customDomainCertificateExpiryTime: ClientRuntime.Date? = nil,
            customDomainName: Swift.String? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }
    }

}

extension RedshiftServerlessClientTypes.ConfigParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey
        case parameterValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.
    public struct ConfigParameter: Swift.Equatable {
        /// The key of the parameter. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var parameterKey: Swift.String?
        /// The value of the parameter to set.
        public var parameterValue: Swift.String?

        public init(
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The submitted action has conflicts.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConvertRecoveryPointToSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
        case retentionPeriod
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ConvertRecoveryPointToSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ConvertRecoveryPointToSnapshotInput: Swift.Equatable {
    /// The unique identifier of the recovery point.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// How long to retain the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the created snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        recoveryPointId: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct ConvertRecoveryPointToSnapshotInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension ConvertRecoveryPointToSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
        case retentionPeriod
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConvertRecoveryPointToSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConvertRecoveryPointToSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct ConvertRecoveryPointToSnapshotOutput: Swift.Equatable {
    /// The snapshot converted from the recovery point.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct ConvertRecoveryPointToSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension ConvertRecoveryPointToSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum ConvertRecoveryPointToSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainCertificateArn = self.customDomainCertificateArn {
            try encodeContainer.encode(customDomainCertificateArn, forKey: .customDomainCertificateArn)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension CreateCustomDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomDomainAssociationInput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
    /// This member is required.
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name to associate with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct CreateCustomDomainAssociationInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let customDomainName: Swift.String?
    let customDomainCertificateArn: Swift.String?
}

extension CreateCustomDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
    }
}

extension CreateCustomDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.customDomainCertificateArn = output.customDomainCertificateArn
            self.customDomainCertificateExpiryTime = output.customDomainCertificateExpiryTime
            self.customDomainName = output.customDomainName
            self.workgroupName = output.workgroupName
        } else {
            self.customDomainCertificateArn = nil
            self.customDomainCertificateExpiryTime = nil
            self.customDomainName = nil
            self.workgroupName = nil
        }
    }
}

public struct CreateCustomDomainAssociationOutput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: ClientRuntime.Date?
    /// The custom domain name to associate with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct CreateCustomDomainAssociationOutputBody: Swift.Equatable {
    let customDomainName: Swift.String?
    let workgroupName: Swift.String?
    let customDomainCertificateArn: Swift.String?
    let customDomainCertificateExpiryTime: ClientRuntime.Date?
}

extension CreateCustomDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainCertificateExpiryTime
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
        let customDomainCertificateExpiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .customDomainCertificateExpiryTime)
        customDomainCertificateExpiryTime = customDomainCertificateExpiryTimeDecoded
    }
}

enum CreateCustomDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case ownerAccount
        case subnetIds
        case vpcSecurityGroupIds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupid0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension CreateEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint. An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can't contain two consecutive hyphens or end with a hyphen.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?
    /// The unique identifers of subnets from which Amazon Redshift Serverless chooses one to deploy a VPC endpoint.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The unique identifiers of the security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// The name of the workgroup to associate with the VPC endpoint.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        endpointName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
        self.ownerAccount = ownerAccount
        self.subnetIds = subnetIds
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.workgroupName = workgroupName
    }
}

struct CreateEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
    let subnetIds: [Swift.String]?
    let workgroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let ownerAccount: Swift.String?
}

extension CreateEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case ownerAccount
        case subnetIds
        case vpcSecurityGroupIds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
    }
}

extension CreateEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct CreateEndpointAccessOutput: Swift.Equatable {
    /// The created VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension CreateEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum CreateEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNamespaceInput(adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), manageAdminPassword: \(Swift.String(describing: manageAdminPassword)), namespaceName: \(Swift.String(describing: namespaceName)), redshiftIdcApplicationArn: \(Swift.String(describing: redshiftIdcApplicationArn)), tags: \(Swift.String(describing: tags)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

extension CreateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case adminUserPassword
        case adminUsername
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case manageAdminPassword
        case namespaceName
        case redshiftIdcApplicationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPasswordSecretKmsKeyId = self.adminPasswordSecretKmsKeyId {
            try encodeContainer.encode(adminPasswordSecretKmsKeyId, forKey: .adminPasswordSecretKmsKeyId)
        }
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let manageAdminPassword = self.manageAdminPassword {
            try encodeContainer.encode(manageAdminPassword, forKey: .manageAdminPassword)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let redshiftIdcApplicationArn = self.redshiftIdcApplicationArn {
            try encodeContainer.encode(redshiftIdcApplicationArn, forKey: .redshiftIdcApplicationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNamespaceInput: Swift.Equatable {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret. You can only use this parameter if manageAdminPassword is true.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// The password of the administrator for the first database created in the namespace. You can't use adminUserPassword if manageAdminPassword is true.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace.
    public var adminUsername: Swift.String?
    /// The name of the first database created in the namespace.
    public var dbName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. Available export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials. You can't use adminUserPassword if manageAdminPassword is true. If manageAdminPassword is false or not set, Amazon Redshift uses adminUserPassword for the admin user account's password.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The ARN for the Redshift application that integrates with IAM Identity Center.
    public var redshiftIdcApplicationArn: Swift.String?
    /// A list of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        dbName: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        redshiftIdcApplicationArn: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.dbName = dbName
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
        self.redshiftIdcApplicationArn = redshiftIdcApplicationArn
        self.tags = tags
    }
}

struct CreateNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let adminUsername: Swift.String?
    let adminUserPassword: Swift.String?
    let dbName: Swift.String?
    let kmsKeyId: Swift.String?
    let defaultIamRoleArn: Swift.String?
    let iamRoles: [Swift.String]?
    let logExports: [RedshiftServerlessClientTypes.LogExport]?
    let tags: [RedshiftServerlessClientTypes.Tag]?
    let manageAdminPassword: Swift.Bool?
    let adminPasswordSecretKmsKeyId: Swift.String?
    let redshiftIdcApplicationArn: Swift.String?
}

extension CreateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case adminUserPassword
        case adminUsername
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case manageAdminPassword
        case namespaceName
        case redshiftIdcApplicationArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let manageAdminPasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageAdminPassword)
        manageAdminPassword = manageAdminPasswordDecoded
        let adminPasswordSecretKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretKmsKeyId)
        adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyIdDecoded
        let redshiftIdcApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redshiftIdcApplicationArn)
        redshiftIdcApplicationArn = redshiftIdcApplicationArnDecoded
    }
}

extension CreateNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct CreateNamespaceOutput: Swift.Equatable {
    /// The created namespace object.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct CreateNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension CreateNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum CreateNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateScheduledActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case endTime
        case namespaceName
        case roleArn
        case schedule
        case scheduledActionDescription
        case scheduledActionName
        case startTime
        case targetAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let scheduledActionDescription = self.scheduledActionDescription {
            try encodeContainer.encode(scheduledActionDescription, forKey: .scheduledActionDescription)
        }
        if let scheduledActionName = self.scheduledActionName {
            try encodeContainer.encode(scheduledActionName, forKey: .scheduledActionName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let targetAction = self.targetAction {
            try encodeContainer.encode(targetAction, forKey: .targetAction)
        }
    }
}

extension CreateScheduledActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateScheduledActionInput: Swift.Equatable {
    /// Indicates whether the schedule is enabled. If false, the scheduled action does not trigger. For more information about state of the scheduled action, see [ScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_ScheduledAction.html).
    public var enabled: Swift.Bool?
    /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
    public var endTime: ClientRuntime.Date?
    /// The name of the namespace for which to create a scheduled action.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
    /// This member is required.
    public var roleArn: Swift.String?
    /// The schedule for a one-time (at format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Format of at expressions is "at(yyyy-mm-ddThh:mm:ss)". For example, "at(2016-03-04T17:27:00)". Format of cron expressions is "cron(Minutes Hours Day-of-month Month Day-of-week Year)". For example, "cron(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
    /// This member is required.
    public var schedule: RedshiftServerlessClientTypes.Schedule?
    /// The description of the scheduled action.
    public var scheduledActionDescription: Swift.String?
    /// The name of the scheduled action.
    /// This member is required.
    public var scheduledActionName: Swift.String?
    /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
    public var startTime: ClientRuntime.Date?
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    /// This member is required.
    public var targetAction: RedshiftServerlessClientTypes.TargetAction?

    public init(
        enabled: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        namespaceName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schedule: RedshiftServerlessClientTypes.Schedule? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
    )
    {
        self.enabled = enabled
        self.endTime = endTime
        self.namespaceName = namespaceName
        self.roleArn = roleArn
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

struct CreateScheduledActionInputBody: Swift.Equatable {
    let scheduledActionName: Swift.String?
    let targetAction: RedshiftServerlessClientTypes.TargetAction?
    let schedule: RedshiftServerlessClientTypes.Schedule?
    let roleArn: Swift.String?
    let namespaceName: Swift.String?
    let enabled: Swift.Bool?
    let scheduledActionDescription: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension CreateScheduledActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case endTime
        case namespaceName
        case roleArn
        case schedule
        case scheduledActionDescription
        case scheduledActionName
        case startTime
        case targetAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TargetAction.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CreateScheduledActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateScheduledActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAction = output.scheduledAction
        } else {
            self.scheduledAction = nil
        }
    }
}

public struct CreateScheduledActionOutput: Swift.Equatable {
    /// The returned ScheduledAction object that describes the properties of a scheduled action.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

struct CreateScheduledActionOutputBody: Swift.Equatable {
    let scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?
}

extension CreateScheduledActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ScheduledActionResponse.self, forKey: .scheduledAction)
        scheduledAction = scheduledActionDecoded
    }
}

enum CreateScheduledActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotCopyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationKmsKeyId
        case destinationRegion
        case namespaceName
        case snapshotRetentionPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationKmsKeyId = self.destinationKmsKeyId {
            try encodeContainer.encode(destinationKmsKeyId, forKey: .destinationKmsKeyId)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let snapshotRetentionPeriod = self.snapshotRetentionPeriod {
            try encodeContainer.encode(snapshotRetentionPeriod, forKey: .snapshotRetentionPeriod)
        }
    }
}

extension CreateSnapshotCopyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSnapshotCopyConfigurationInput: Swift.Equatable {
    /// The KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
    public var destinationKmsKeyId: Swift.String?
    /// The destination Amazon Web Services Region that you want to copy snapshots to.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the namespace to copy snapshots from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The retention period of the snapshots that you copy to the destination Amazon Web Services Region.
    public var snapshotRetentionPeriod: Swift.Int?

    public init(
        destinationKmsKeyId: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        snapshotRetentionPeriod: Swift.Int? = nil
    )
    {
        self.destinationKmsKeyId = destinationKmsKeyId
        self.destinationRegion = destinationRegion
        self.namespaceName = namespaceName
        self.snapshotRetentionPeriod = snapshotRetentionPeriod
    }
}

struct CreateSnapshotCopyConfigurationInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let destinationRegion: Swift.String?
    let snapshotRetentionPeriod: Swift.Int?
    let destinationKmsKeyId: Swift.String?
}

extension CreateSnapshotCopyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationKmsKeyId
        case destinationRegion
        case namespaceName
        case snapshotRetentionPeriod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let snapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionPeriod)
        snapshotRetentionPeriod = snapshotRetentionPeriodDecoded
        let destinationKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationKmsKeyId)
        destinationKmsKeyId = destinationKmsKeyIdDecoded
    }
}

extension CreateSnapshotCopyConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotCopyConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotCopyConfiguration = output.snapshotCopyConfiguration
        } else {
            self.snapshotCopyConfiguration = nil
        }
    }
}

public struct CreateSnapshotCopyConfigurationOutput: Swift.Equatable {
    /// The snapshot copy configuration object that is returned.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

struct CreateSnapshotCopyConfigurationOutputBody: Swift.Equatable {
    let snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?
}

extension CreateSnapshotCopyConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.SnapshotCopyConfiguration.self, forKey: .snapshotCopyConfiguration)
        snapshotCopyConfiguration = snapshotCopyConfigurationDecoded
    }
}

enum CreateSnapshotCopyConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case retentionPeriod
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The namespace to create a snapshot for.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// How long to retain the created snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        namespaceName: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.namespaceName = namespaceName
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case retentionPeriod
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateSnapshotOutput: Swift.Equatable {
    /// The created snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension CreateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case retentionPeriod
        case snapshotNamePrefix
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotNamePrefix = self.snapshotNamePrefix {
            try encodeContainer.encode(snapshotNamePrefix, forKey: .snapshotNamePrefix)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let snapshotNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotNamePrefix)
        snapshotNamePrefix = snapshotNamePrefixDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The parameters that you can use to configure a [scheduled action](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html) to create a snapshot. For more information about creating a scheduled action, see [CreateScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html).
    public struct CreateSnapshotScheduleActionParameters: Swift.Equatable {
        /// The name of the namespace for which you want to configure a scheduled action to create a snapshot.
        /// This member is required.
        public var namespaceName: Swift.String?
        /// The retention period of the snapshot created by the scheduled action.
        public var retentionPeriod: Swift.Int?
        /// A string prefix that is attached to the name of the snapshot created by the scheduled action. The final name of the snapshot is the string prefix appended by the date and time of when the snapshot was created.
        /// This member is required.
        public var snapshotNamePrefix: Swift.String?
        /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the snapshot.
        public var tags: [RedshiftServerlessClientTypes.Tag]?

        public init(
            namespaceName: Swift.String? = nil,
            retentionPeriod: Swift.Int? = nil,
            snapshotNamePrefix: Swift.String? = nil,
            tags: [RedshiftServerlessClientTypes.Tag]? = nil
        )
        {
            self.namespaceName = namespaceName
            self.retentionPeriod = retentionPeriod
            self.snapshotNamePrefix = snapshotNamePrefix
            self.tags = tags
        }
    }

}

extension CreateUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }
}

extension CreateUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUsageLimitInput: Swift.Equatable {
    /// The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    /// This member is required.
    public var amount: Swift.Int?
    /// The action that Amazon Redshift Serverless takes when the limit is reached. The default is log.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
    public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
    /// The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of Amazon Redshift Serverless usage to create a usage limit for.
    /// This member is required.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.period = period
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

struct CreateUsageLimitInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?
    let amount: Swift.Int?
    let period: RedshiftServerlessClientTypes.UsageLimitPeriod?
    let breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
}

extension CreateUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension CreateUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct CreateUsageLimitOutput: Swift.Equatable {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct CreateUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension CreateUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum CreateUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case maxCapacity
        case namespaceName
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case tags
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension CreateWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkgroupInput: Swift.Equatable {
    /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
    public var enhancedVpcRouting: Swift.Bool?
    /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
    public var maxCapacity: Swift.Int?
    /// The name of the namespace to associate with the workgroup.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessed from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// A array of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?
    /// The name of the created workgroup.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        maxCapacity: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maxCapacity = maxCapacity
        self.namespaceName = namespaceName
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.workgroupName = workgroupName
    }
}

struct CreateWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let namespaceName: Swift.String?
    let baseCapacity: Swift.Int?
    let enhancedVpcRouting: Swift.Bool?
    let configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let tags: [RedshiftServerlessClientTypes.Tag]?
    let port: Swift.Int?
    let maxCapacity: Swift.Int?
}

extension CreateWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case maxCapacity
        case namespaceName
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case tags
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
    }
}

extension CreateWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct CreateWorkgroupOutput: Swift.Equatable {
    /// The created workgroup object.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct CreateWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension CreateWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum CreateWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientCapacityException": return try await InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension DeleteCustomDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomDomainAssociationInput: Swift.Equatable {
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct DeleteCustomDomainAssociationInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let customDomainName: Swift.String?
}

extension DeleteCustomDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
    }
}

extension DeleteCustomDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomDomainAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

extension DeleteEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to delete.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct DeleteEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
}

extension DeleteEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension DeleteEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DeleteEndpointAccessOutput: Swift.Equatable {
    /// The deleted VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension DeleteEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum DeleteEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalSnapshotName
        case finalSnapshotRetentionPeriod
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalSnapshotName = self.finalSnapshotName {
            try encodeContainer.encode(finalSnapshotName, forKey: .finalSnapshotName)
        }
        if let finalSnapshotRetentionPeriod = self.finalSnapshotRetentionPeriod {
            try encodeContainer.encode(finalSnapshotRetentionPeriod, forKey: .finalSnapshotRetentionPeriod)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The name of the snapshot to be created before the namespace is deleted.
    public var finalSnapshotName: Swift.String?
    /// How long to retain the final snapshot.
    public var finalSnapshotRetentionPeriod: Swift.Int?
    /// The name of the namespace to delete.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        finalSnapshotName: Swift.String? = nil,
        finalSnapshotRetentionPeriod: Swift.Int? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.finalSnapshotName = finalSnapshotName
        self.finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriod
        self.namespaceName = namespaceName
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let finalSnapshotName: Swift.String?
    let finalSnapshotRetentionPeriod: Swift.Int?
}

extension DeleteNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalSnapshotName
        case finalSnapshotRetentionPeriod
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let finalSnapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalSnapshotName)
        finalSnapshotName = finalSnapshotNameDecoded
        let finalSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalSnapshotRetentionPeriod)
        finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriodDecoded
    }
}

extension DeleteNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct DeleteNamespaceOutput: Swift.Equatable {
    /// The deleted namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct DeleteNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension DeleteNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum DeleteNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteScheduledActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledActionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledActionName = self.scheduledActionName {
            try encodeContainer.encode(scheduledActionName, forKey: .scheduledActionName)
        }
    }
}

extension DeleteScheduledActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteScheduledActionInput: Swift.Equatable {
    /// The name of the scheduled action to delete.
    /// This member is required.
    public var scheduledActionName: Swift.String?

    public init(
        scheduledActionName: Swift.String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

struct DeleteScheduledActionInputBody: Swift.Equatable {
    let scheduledActionName: Swift.String?
}

extension DeleteScheduledActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledActionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
    }
}

extension DeleteScheduledActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteScheduledActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAction = output.scheduledAction
        } else {
            self.scheduledAction = nil
        }
    }
}

public struct DeleteScheduledActionOutput: Swift.Equatable {
    /// The deleted scheduled action object.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

struct DeleteScheduledActionOutputBody: Swift.Equatable {
    let scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?
}

extension DeleteScheduledActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ScheduledActionResponse.self, forKey: .scheduledAction)
        scheduledAction = scheduledActionDecoded
    }
}

enum DeleteScheduledActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSnapshotCopyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfigurationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotCopyConfigurationId = self.snapshotCopyConfigurationId {
            try encodeContainer.encode(snapshotCopyConfigurationId, forKey: .snapshotCopyConfigurationId)
        }
    }
}

extension DeleteSnapshotCopyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSnapshotCopyConfigurationInput: Swift.Equatable {
    /// The ID of the snapshot copy configuration to delete.
    /// This member is required.
    public var snapshotCopyConfigurationId: Swift.String?

    public init(
        snapshotCopyConfigurationId: Swift.String? = nil
    )
    {
        self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
    }
}

struct DeleteSnapshotCopyConfigurationInputBody: Swift.Equatable {
    let snapshotCopyConfigurationId: Swift.String?
}

extension DeleteSnapshotCopyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfigurationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyConfigurationId)
        snapshotCopyConfigurationId = snapshotCopyConfigurationIdDecoded
    }
}

extension DeleteSnapshotCopyConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSnapshotCopyConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotCopyConfiguration = output.snapshotCopyConfiguration
        } else {
            self.snapshotCopyConfiguration = nil
        }
    }
}

public struct DeleteSnapshotCopyConfigurationOutput: Swift.Equatable {
    /// The deleted snapshot copy configuration object.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

struct DeleteSnapshotCopyConfigurationOutputBody: Swift.Equatable {
    let snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?
}

extension DeleteSnapshotCopyConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.SnapshotCopyConfiguration.self, forKey: .snapshotCopyConfiguration)
        snapshotCopyConfiguration = snapshotCopyConfigurationDecoded
    }
}

enum DeleteSnapshotCopyConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension DeleteSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSnapshotInput: Swift.Equatable {
    /// The name of the snapshot to be deleted.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        snapshotName: Swift.String? = nil
    )
    {
        self.snapshotName = snapshotName
    }
}

struct DeleteSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
}

extension DeleteSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension DeleteSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteSnapshotOutput: Swift.Equatable {
    /// The deleted snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension DeleteSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum DeleteSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension DeleteUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUsageLimitInput: Swift.Equatable {
    /// The unique identifier of the usage limit to delete.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

struct DeleteUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
}

extension DeleteUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
    }
}

extension DeleteUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct DeleteUsageLimitOutput: Swift.Equatable {
    /// The deleted usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct DeleteUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension DeleteUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum DeleteUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension DeleteWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkgroupInput: Swift.Equatable {
    /// The name of the workgroup to be deleted.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

struct DeleteWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
}

extension DeleteWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension DeleteWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct DeleteWorkgroupOutput: Swift.Equatable {
    /// The deleted workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct DeleteWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension DeleteWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum DeleteWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case port
        case vpcEndpoints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let vpcEndpoints = vpcEndpoints {
            var vpcEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpoints)
            for vpcendpoint0 in vpcEndpoints {
                try vpcEndpointsContainer.encode(vpcendpoint0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcEndpointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.VpcEndpoint?].self, forKey: .vpcEndpoints)
        var vpcEndpointsDecoded0:[RedshiftServerlessClientTypes.VpcEndpoint]? = nil
        if let vpcEndpointsContainer = vpcEndpointsContainer {
            vpcEndpointsDecoded0 = [RedshiftServerlessClientTypes.VpcEndpoint]()
            for structure0 in vpcEndpointsContainer {
                if let structure0 = structure0 {
                    vpcEndpointsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpoints = vpcEndpointsDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The VPC endpoint object.
    public struct Endpoint: Swift.Equatable {
        /// The DNS address of the VPC endpoint.
        public var address: Swift.String?
        /// The port that Amazon Redshift Serverless listens on.
        public var port: Swift.Int?
        /// An array of VpcEndpoint objects.
        public var vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]?

        public init(
            address: Swift.String? = nil,
            port: Swift.Int? = nil,
            vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]? = nil
        )
        {
            self.address = address
            self.port = port
            self.vpcEndpoints = vpcEndpoints
        }
    }

}

extension RedshiftServerlessClientTypes.EndpointAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case endpointArn
        case endpointCreateTime
        case endpointName
        case endpointStatus
        case port
        case subnetIds
        case vpcEndpoint
        case vpcSecurityGroups
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointCreateTime = self.endpointCreateTime {
            try encodeContainer.encodeTimestamp(endpointCreateTime, format: .dateTime, forKey: .endpointCreateTime)
        }
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let endpointStatus = self.endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpoint = self.vpcEndpoint {
            try encodeContainer.encode(vpcEndpoint, forKey: .vpcEndpoint)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembership0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let endpointCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endpointCreateTime)
        endpointCreateTime = endpointCreateTimeDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[RedshiftServerlessClientTypes.VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.VpcEndpoint.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Information about an Amazon Redshift Serverless VPC endpoint.
    public struct EndpointAccess: Swift.Equatable {
        /// The DNS address of the endpoint.
        public var address: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint.
        public var endpointArn: Swift.String?
        /// The time that the endpoint was created.
        public var endpointCreateTime: ClientRuntime.Date?
        /// The name of the VPC endpoint.
        public var endpointName: Swift.String?
        /// The status of the VPC endpoint.
        public var endpointStatus: Swift.String?
        /// The port number on which Amazon Redshift Serverless accepts incoming connections.
        public var port: Swift.Int?
        /// The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.
        public var subnetIds: [Swift.String]?
        /// The connection endpoint for connecting to Amazon Redshift Serverless.
        public var vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint?
        /// The security groups associated with the endpoint.
        public var vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]?
        /// The name of the workgroup associated with the endpoint.
        public var workgroupName: Swift.String?

        public init(
            address: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            endpointCreateTime: ClientRuntime.Date? = nil,
            endpointName: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            port: Swift.Int? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint? = nil,
            vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.address = address
            self.endpointArn = endpointArn
            self.endpointCreateTime = endpointCreateTime
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.port = port
            self.subnetIds = subnetIds
            self.vpcEndpoint = vpcEndpoint
            self.vpcSecurityGroups = vpcSecurityGroups
            self.workgroupName = workgroupName
        }
    }

}

extension GetCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case dbName
        case durationSeconds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension GetCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCredentialsInput: Swift.Equatable {
    /// The custom domain name associated with the workgroup. The custom domain name or the workgroup name must be included in the request.
    public var customDomainName: Swift.String?
    /// The name of the database to get temporary authorization to log on to. Constraints:
    ///
    /// * Must be 1 to 64 alphanumeric characters or hyphens.
    ///
    /// * Must contain only uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.
    ///
    /// * The first character must be a letter.
    ///
    /// * Must not contain a colon ( : ) or slash ( / ).
    ///
    /// * Cannot be a reserved word. A list of reserved words can be found in [Reserved Words ](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide
    public var dbName: Swift.String?
    /// The number of seconds until the returned temporary password expires. The minimum is 900 seconds, and the maximum is 3600 seconds.
    public var durationSeconds: Swift.Int?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        dbName: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.dbName = dbName
        self.durationSeconds = durationSeconds
        self.workgroupName = workgroupName
    }
}

struct GetCredentialsInputBody: Swift.Equatable {
    let dbName: Swift.String?
    let durationSeconds: Swift.Int?
    let workgroupName: Swift.String?
    let customDomainName: Swift.String?
}

extension GetCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case dbName
        case durationSeconds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
    }
}

extension GetCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialsOutput(expiration: \(Swift.String(describing: expiration)), nextRefreshTime: \(Swift.String(describing: nextRefreshTime)), dbPassword: \"CONTENT_REDACTED\", dbUser: \"CONTENT_REDACTED\")"}
}

extension GetCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dbPassword = output.dbPassword
            self.dbUser = output.dbUser
            self.expiration = output.expiration
            self.nextRefreshTime = output.nextRefreshTime
        } else {
            self.dbPassword = nil
            self.dbUser = nil
            self.expiration = nil
            self.nextRefreshTime = nil
        }
    }
}

public struct GetCredentialsOutput: Swift.Equatable {
    /// A temporary password that authorizes the user name returned by DbUser to log on to the database DbName.
    public var dbPassword: Swift.String?
    /// A database user name that is authorized to log on to the database DbName using the password DbPassword. If the specified DbUser exists in the database, the new user name has the same database privileges as the the user named in DbUser. By default, the user is added to PUBLIC.
    public var dbUser: Swift.String?
    /// The date and time the password in DbPassword expires.
    public var expiration: ClientRuntime.Date?
    /// The date and time of when the DbUser and DbPassword authorization refreshes.
    public var nextRefreshTime: ClientRuntime.Date?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        nextRefreshTime: ClientRuntime.Date? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.expiration = expiration
        self.nextRefreshTime = nextRefreshTime
    }
}

struct GetCredentialsOutputBody: Swift.Equatable {
    let dbUser: Swift.String?
    let dbPassword: Swift.String?
    let expiration: ClientRuntime.Date?
    let nextRefreshTime: ClientRuntime.Date?
}

extension GetCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword
        case dbUser
        case expiration
        case nextRefreshTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
        let nextRefreshTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextRefreshTime)
        nextRefreshTime = nextRefreshTimeDecoded
    }
}

enum GetCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCustomDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension GetCustomDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCustomDomainAssociationInput: Swift.Equatable {
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct GetCustomDomainAssociationInputBody: Swift.Equatable {
    let customDomainName: Swift.String?
    let workgroupName: Swift.String?
}

extension GetCustomDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension GetCustomDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCustomDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.customDomainCertificateArn = output.customDomainCertificateArn
            self.customDomainCertificateExpiryTime = output.customDomainCertificateExpiryTime
            self.customDomainName = output.customDomainName
            self.workgroupName = output.workgroupName
        } else {
            self.customDomainCertificateArn = nil
            self.customDomainCertificateExpiryTime = nil
            self.customDomainName = nil
            self.workgroupName = nil
        }
    }
}

public struct GetCustomDomainAssociationOutput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: ClientRuntime.Date?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct GetCustomDomainAssociationOutputBody: Swift.Equatable {
    let customDomainName: Swift.String?
    let workgroupName: Swift.String?
    let customDomainCertificateArn: Swift.String?
    let customDomainCertificateExpiryTime: ClientRuntime.Date?
}

extension GetCustomDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainCertificateExpiryTime
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
        let customDomainCertificateExpiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .customDomainCertificateExpiryTime)
        customDomainCertificateExpiryTime = customDomainCertificateExpiryTimeDecoded
    }
}

enum GetCustomDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
    }
}

extension GetEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to return information for.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

struct GetEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
}

extension GetEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
    }
}

extension GetEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetEndpointAccessOutput: Swift.Equatable {
    /// The returned VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension GetEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum GetEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension GetNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamespaceInput: Swift.Equatable {
    /// The name of the namespace to retrieve information for.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

struct GetNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension GetNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension GetNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutput: Swift.Equatable {
    /// The returned namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension GetNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum GetNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
    }
}

extension GetRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRecoveryPointInput: Swift.Equatable {
    /// The unique identifier of the recovery point to return information for.
    /// This member is required.
    public var recoveryPointId: Swift.String?

    public init(
        recoveryPointId: Swift.String? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
    }
}

struct GetRecoveryPointInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
}

extension GetRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPointId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
    }
}

extension GetRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.recoveryPoint = output.recoveryPoint
        } else {
            self.recoveryPoint = nil
        }
    }
}

public struct GetRecoveryPointOutput: Swift.Equatable {
    /// The returned recovery point object.
    public var recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint?

    public init(
        recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint? = nil
    )
    {
        self.recoveryPoint = recoveryPoint
    }
}

struct GetRecoveryPointOutputBody: Swift.Equatable {
    let recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint?
}

extension GetRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryPoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.RecoveryPoint.self, forKey: .recoveryPoint)
        recoveryPoint = recoveryPointDecoded
    }
}

enum GetRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// The returned resource policy.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ResourcePolicy.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetScheduledActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledActionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledActionName = self.scheduledActionName {
            try encodeContainer.encode(scheduledActionName, forKey: .scheduledActionName)
        }
    }
}

extension GetScheduledActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetScheduledActionInput: Swift.Equatable {
    /// The name of the scheduled action.
    /// This member is required.
    public var scheduledActionName: Swift.String?

    public init(
        scheduledActionName: Swift.String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

struct GetScheduledActionInputBody: Swift.Equatable {
    let scheduledActionName: Swift.String?
}

extension GetScheduledActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledActionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
    }
}

extension GetScheduledActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetScheduledActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAction = output.scheduledAction
        } else {
            self.scheduledAction = nil
        }
    }
}

public struct GetScheduledActionOutput: Swift.Equatable {
    /// The returned scheduled action object.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

struct GetScheduledActionOutputBody: Swift.Equatable {
    let scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?
}

extension GetScheduledActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ScheduledActionResponse.self, forKey: .scheduledAction)
        scheduledAction = scheduledActionDecoded
    }
}

enum GetScheduledActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case snapshotArn
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension GetSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSnapshotInput: Swift.Equatable {
    /// The owner Amazon Web Services account of a snapshot shared with another user.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to return.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to return.
    public var snapshotName: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
    }
}

struct GetSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let ownerAccount: Swift.String?
    let snapshotArn: Swift.String?
}

extension GetSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case snapshotArn
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
    }
}

extension GetSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct GetSnapshotOutput: Swift.Equatable {
    /// The returned snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct GetSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension GetSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum GetSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableRestoreStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableRestoreRequestId = self.tableRestoreRequestId {
            try encodeContainer.encode(tableRestoreRequestId, forKey: .tableRestoreRequestId)
        }
    }
}

extension GetTableRestoreStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableRestoreStatusInput: Swift.Equatable {
    /// The ID of the RestoreTableFromSnapshot request to return status for.
    /// This member is required.
    public var tableRestoreRequestId: Swift.String?

    public init(
        tableRestoreRequestId: Swift.String? = nil
    )
    {
        self.tableRestoreRequestId = tableRestoreRequestId
    }
}

struct GetTableRestoreStatusInputBody: Swift.Equatable {
    let tableRestoreRequestId: Swift.String?
}

extension GetTableRestoreStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
    }
}

extension GetTableRestoreStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableRestoreStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct GetTableRestoreStatusOutput: Swift.Equatable {
    /// The returned TableRestoreStatus object that contains information about the status of your RestoreTableFromSnapshot request.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct GetTableRestoreStatusOutputBody: Swift.Equatable {
    let tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?
}

extension GetTableRestoreStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

enum GetTableRestoreStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension GetUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUsageLimitInput: Swift.Equatable {
    /// The unique identifier of the usage limit to return information for.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

struct GetUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
}

extension GetUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
    }
}

extension GetUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct GetUsageLimitOutput: Swift.Equatable {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct GetUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension GetUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum GetUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension GetWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetWorkgroupInput: Swift.Equatable {
    /// The name of the workgroup to return information for.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

struct GetWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
}

extension GetWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension GetWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct GetWorkgroupOutput: Swift.Equatable {
    /// The returned workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct GetWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension GetWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum GetWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InsufficientCapacityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is an insufficient capacity to perform the action.
public struct InsufficientCapacityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientCapacityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientCapacityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientCapacityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided pagination token is invalid.
public struct InvalidPaginationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCustomDomainAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainCertificateArn = self.customDomainCertificateArn {
            try encodeContainer.encode(customDomainCertificateArn, forKey: .customDomainCertificateArn)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
    }
}

extension ListCustomDomainAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomDomainAssociationsInput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomDomainAssociationsInputBody: Swift.Equatable {
    let customDomainName: Swift.String?
    let customDomainCertificateArn: Swift.String?
}

extension ListCustomDomainAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
    }
}

extension ListCustomDomainAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomDomainAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomDomainAssociationsOutput: Swift.Equatable {
    /// A list of Association objects.
    public var associations: [RedshiftServerlessClientTypes.Association]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        associations: [RedshiftServerlessClientTypes.Association]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct ListCustomDomainAssociationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let associations: [RedshiftServerlessClientTypes.Association]?
}

extension ListCustomDomainAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let associationsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Association?].self, forKey: .associations)
        var associationsDecoded0:[RedshiftServerlessClientTypes.Association]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [RedshiftServerlessClientTypes.Association]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

enum ListCustomDomainAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case vpcId
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEndpointAccessInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListEndpointAccess operation returns a nextToken, you can include the returned nextToken in following ListEndpointAccess operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?
    /// The unique identifier of the virtual private cloud with access to Amazon Redshift Serverless.
    public var vpcId: Swift.String?
    /// The name of the workgroup associated with the VPC endpoint to return.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        vpcId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.vpcId = vpcId
        self.workgroupName = workgroupName
    }
}

struct ListEndpointAccessInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let vpcId: Swift.String?
    let ownerAccount: Swift.String?
}

extension ListEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
        case vpcId
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
    }
}

extension ListEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointAccessOutput: Swift.Equatable {
    /// The returned VPC endpoints.
    /// This member is required.
    public var endpoints: [RedshiftServerlessClientTypes.EndpointAccess]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        endpoints: [RedshiftServerlessClientTypes.EndpointAccess]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointAccessOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let endpoints: [RedshiftServerlessClientTypes.EndpointAccess]?
}

extension ListEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.EndpointAccess?].self, forKey: .endpoints)
        var endpointsDecoded0:[RedshiftServerlessClientTypes.EndpointAccess]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [RedshiftServerlessClientTypes.EndpointAccess]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

enum ListEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNamespacesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListNamespacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamespacesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListNamespaces operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
}

extension ListNamespacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNamespacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNamespacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutput: Swift.Equatable {
    /// The list of returned namespaces.
    /// This member is required.
    public var namespaces: [RedshiftServerlessClientTypes.Namespace]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        namespaces: [RedshiftServerlessClientTypes.Namespace]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let namespaces: [RedshiftServerlessClientTypes.Namespace]?
}

extension ListNamespacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let namespacesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Namespace?].self, forKey: .namespaces)
        var namespacesDecoded0:[RedshiftServerlessClientTypes.Namespace]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [RedshiftServerlessClientTypes.Namespace]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
    }
}

enum ListNamespacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryPointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListRecoveryPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecoveryPointsInput: Swift.Equatable {
    /// The time when creation of the recovery point finished.
    public var endTime: ClientRuntime.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list recovery points.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to list recovery points for.
    public var namespaceName: Swift.String?
    /// If your initial ListRecoveryPoints operation returns a nextToken, you can include the returned nextToken in following ListRecoveryPoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The time when the recovery point's creation was initiated.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListRecoveryPointsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let namespaceName: Swift.String?
    let namespaceArn: Swift.String?
}

extension ListRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
    }
}

extension ListRecoveryPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The returned recovery point objects.
    public var recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsOutputBody: Swift.Equatable {
    let recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]?
    let nextToken: Swift.String?
}

extension ListRecoveryPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recoveryPoints
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.RecoveryPoint?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[RedshiftServerlessClientTypes.RecoveryPoint]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [RedshiftServerlessClientTypes.RecoveryPoint]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecoveryPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScheduledActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension ListScheduledActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListScheduledActionsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. Use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The name of namespace associated with the scheduled action to retrieve.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
    }
}

struct ListScheduledActionsInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension ListScheduledActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension ListScheduledActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScheduledActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduledActions = output.scheduledActions
        } else {
            self.nextToken = nil
            self.scheduledActions = nil
        }
    }
}

public struct ListScheduledActionsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned scheduled action objects.
    public var scheduledActions: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledActions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledActions = scheduledActions
    }
}

struct ListScheduledActionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let scheduledActions: [Swift.String]?
}

extension ListScheduledActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case scheduledActions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scheduledActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scheduledActions)
        var scheduledActionsDecoded0:[Swift.String]? = nil
        if let scheduledActionsContainer = scheduledActionsContainer {
            scheduledActionsDecoded0 = [Swift.String]()
            for string0 in scheduledActionsContainer {
                if let string0 = string0 {
                    scheduledActionsDecoded0?.append(string0)
                }
            }
        }
        scheduledActions = scheduledActionsDecoded0
    }
}

enum ListScheduledActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSnapshotCopyConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension ListSnapshotCopyConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSnapshotCopyConfigurationsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The namespace from which to list all snapshot copy configurations.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
    }
}

struct ListSnapshotCopyConfigurationsInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension ListSnapshotCopyConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension ListSnapshotCopyConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSnapshotCopyConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshotCopyConfigurations = output.snapshotCopyConfigurations
        } else {
            self.nextToken = nil
            self.snapshotCopyConfigurations = nil
        }
    }
}

public struct ListSnapshotCopyConfigurationsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned snapshot copy configurations.
    /// This member is required.
    public var snapshotCopyConfigurations: [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        snapshotCopyConfigurations: [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshotCopyConfigurations = snapshotCopyConfigurations
    }
}

struct ListSnapshotCopyConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let snapshotCopyConfigurations: [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]?
}

extension ListSnapshotCopyConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case snapshotCopyConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let snapshotCopyConfigurationsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.SnapshotCopyConfiguration?].self, forKey: .snapshotCopyConfigurations)
        var snapshotCopyConfigurationsDecoded0:[RedshiftServerlessClientTypes.SnapshotCopyConfiguration]? = nil
        if let snapshotCopyConfigurationsContainer = snapshotCopyConfigurationsContainer {
            snapshotCopyConfigurationsDecoded0 = [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]()
            for structure0 in snapshotCopyConfigurationsContainer {
                if let structure0 = structure0 {
                    snapshotCopyConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        snapshotCopyConfigurations = snapshotCopyConfigurationsDecoded0
    }
}

enum ListSnapshotCopyConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case ownerAccount
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSnapshotsInput: Swift.Equatable {
    /// The timestamp showing when the snapshot creation finished.
    public var endTime: ClientRuntime.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list all snapshots.
    public var namespaceArn: Swift.String?
    /// The namespace from which to list all snapshots.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account of the snapshot.
    public var ownerAccount: Swift.String?
    /// The time when the creation of the snapshot was initiated.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.startTime = startTime
    }
}

struct ListSnapshotsInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let namespaceArn: Swift.String?
    let ownerAccount: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension ListSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceArn
        case namespaceName
        case ownerAccount
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ListSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct ListSnapshotsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned snapshot objects.
    public var snapshots: [RedshiftServerlessClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [RedshiftServerlessClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct ListSnapshotsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let snapshots: [RedshiftServerlessClientTypes.Snapshot]?
}

extension ListSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case snapshots
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let snapshotsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Snapshot?].self, forKey: .snapshots)
        var snapshotsDecoded0:[RedshiftServerlessClientTypes.Snapshot]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [RedshiftServerlessClientTypes.Snapshot]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
    }
}

enum ListSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableRestoreStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListTableRestoreStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTableRestoreStatusInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The namespace from which to list all of the statuses of RestoreTableFromSnapshot operations .
    public var namespaceName: Swift.String?
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will return results on the next page.
    public var nextToken: Swift.String?
    /// The workgroup from which to list all of the statuses of RestoreTableFromSnapshot operations.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.workgroupName = workgroupName
    }
}

struct ListTableRestoreStatusInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
}

extension ListTableRestoreStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension ListTableRestoreStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableRestoreStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableRestoreStatuses = output.tableRestoreStatuses
        } else {
            self.nextToken = nil
            self.tableRestoreStatuses = nil
        }
    }
}

public struct ListTableRestoreStatusOutput: Swift.Equatable {
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will returns results on the next page.
    public var nextToken: Swift.String?
    /// The array of returned TableRestoreStatus objects.
    public var tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]?

    public init(
        nextToken: Swift.String? = nil,
        tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableRestoreStatuses = tableRestoreStatuses
    }
}

struct ListTableRestoreStatusOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]?
}

extension ListTableRestoreStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tableRestoreStatuses
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tableRestoreStatusesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.TableRestoreStatus?].self, forKey: .tableRestoreStatuses)
        var tableRestoreStatusesDecoded0:[RedshiftServerlessClientTypes.TableRestoreStatus]? = nil
        if let tableRestoreStatusesContainer = tableRestoreStatusesContainer {
            tableRestoreStatusesDecoded0 = [RedshiftServerlessClientTypes.TableRestoreStatus]()
            for structure0 in tableRestoreStatusesContainer {
                if let structure0 = structure0 {
                    tableRestoreStatusesDecoded0?.append(structure0)
                }
            }
        }
        tableRestoreStatuses = tableRestoreStatusesDecoded0
    }
}

enum ListTableRestoreStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of the key-value pairs assigned to the resource.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsageLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }
}

extension ListUsageLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsageLimitsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 100.
    public var maxResults: Swift.Int?
    /// If your initial ListUsageLimits operation returns a nextToken, you can include the returned nextToken in following ListUsageLimits operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the resource whose usage limits you want to list.
    public var resourceArn: Swift.String?
    /// The Amazon Redshift Serverless feature whose limits you want to see.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

struct ListUsageLimitsInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?
}

extension ListUsageLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case usageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
    }
}

extension ListUsageLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsageLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageLimits = output.usageLimits
        } else {
            self.nextToken = nil
            self.usageLimits = nil
        }
    }
}

public struct ListUsageLimitsOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// An array of returned usage limit objects.
    public var usageLimits: [RedshiftServerlessClientTypes.UsageLimit]?

    public init(
        nextToken: Swift.String? = nil,
        usageLimits: [RedshiftServerlessClientTypes.UsageLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageLimits = usageLimits
    }
}

struct ListUsageLimitsOutputBody: Swift.Equatable {
    let usageLimits: [RedshiftServerlessClientTypes.UsageLimit]?
    let nextToken: Swift.String?
}

extension ListUsageLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case usageLimits
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.UsageLimit?].self, forKey: .usageLimits)
        var usageLimitsDecoded0:[RedshiftServerlessClientTypes.UsageLimit]? = nil
        if let usageLimitsContainer = usageLimitsContainer {
            usageLimitsDecoded0 = [RedshiftServerlessClientTypes.UsageLimit]()
            for structure0 in usageLimitsContainer {
                if let structure0 = structure0 {
                    usageLimitsDecoded0?.append(structure0)
                }
            }
        }
        usageLimits = usageLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsageLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationException": return try await InvalidPaginationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkgroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension ListWorkgroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkgroupsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListWorkgroups operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
    }
}

struct ListWorkgroupsInputBody: Swift.Equatable {
    let ownerAccount: Swift.String?
}

extension ListWorkgroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerAccount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
    }
}

extension ListWorkgroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkgroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workgroups = output.workgroups
        } else {
            self.nextToken = nil
            self.workgroups = nil
        }
    }
}

public struct ListWorkgroupsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token.
    public var nextToken: Swift.String?
    /// The returned array of workgroups.
    /// This member is required.
    public var workgroups: [RedshiftServerlessClientTypes.Workgroup]?

    public init(
        nextToken: Swift.String? = nil,
        workgroups: [RedshiftServerlessClientTypes.Workgroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.workgroups = workgroups
    }
}

struct ListWorkgroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workgroups: [RedshiftServerlessClientTypes.Workgroup]?
}

extension ListWorkgroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workgroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workgroupsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Workgroup?].self, forKey: .workgroups)
        var workgroupsDecoded0:[RedshiftServerlessClientTypes.Workgroup]? = nil
        if let workgroupsContainer = workgroupsContainer {
            workgroupsDecoded0 = [RedshiftServerlessClientTypes.Workgroup]()
            for structure0 in workgroupsContainer {
                if let structure0 = structure0 {
                    workgroupsDecoded0?.append(structure0)
                }
            }
        }
        workgroups = workgroupsDecoded0
    }
}

enum ListWorkgroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum LogExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionLog
        case userActivityLog
        case userLog
        case sdkUnknown(Swift.String)

        public static var allCases: [LogExport] {
            return [
                .connectionLog,
                .userActivityLog,
                .userLog,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionLog: return "connectionlog"
            case .userActivityLog: return "useractivitylog"
            case .userLog: return "userlog"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogExport(rawValue: rawValue) ?? LogExport.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.Namespace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretArn
        case adminPasswordSecretKmsKeyId
        case adminUsername
        case creationDate
        case dbName
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case namespaceArn
        case namespaceId
        case namespaceName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPasswordSecretArn = self.adminPasswordSecretArn {
            try encodeContainer.encode(adminPasswordSecretArn, forKey: .adminPasswordSecretArn)
        }
        if let adminPasswordSecretKmsKeyId = self.adminPasswordSecretKmsKeyId {
            try encodeContainer.encode(adminPasswordSecretKmsKeyId, forKey: .adminPasswordSecretKmsKeyId)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .dateTime, forKey: .creationDate)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceId = self.namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.NamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let adminPasswordSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretArn)
        adminPasswordSecretArn = adminPasswordSecretArnDecoded
        let adminPasswordSecretKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretKmsKeyId)
        adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyIdDecoded
    }
}

extension RedshiftServerlessClientTypes.Namespace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Namespace(adminPasswordSecretArn: \(Swift.String(describing: adminPasswordSecretArn)), adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), creationDate: \(Swift.String(describing: creationDate)), dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), namespaceArn: \(Swift.String(describing: namespaceArn)), namespaceId: \(Swift.String(describing: namespaceId)), namespaceName: \(Swift.String(describing: namespaceName)), status: \(Swift.String(describing: status)), adminUsername: \"CONTENT_REDACTED\")"}
}

extension RedshiftServerlessClientTypes {
    /// A collection of database objects and users.
    public struct Namespace: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public var adminPasswordSecretArn: Swift.String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public var adminPasswordSecretKmsKeyId: Swift.String?
        /// The username of the administrator for the first database created in the namespace.
        public var adminUsername: Swift.String?
        /// The date of when the namespace was created.
        public var creationDate: ClientRuntime.Date?
        /// The name of the first database created in the namespace.
        public var dbName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
        public var defaultIamRoleArn: Swift.String?
        /// A list of IAM roles to associate with the namespace.
        public var iamRoles: [Swift.String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.
        public var logExports: [RedshiftServerlessClientTypes.LogExport]?
        /// The Amazon Resource Name (ARN) associated with a namespace.
        public var namespaceArn: Swift.String?
        /// The unique identifier of a namespace.
        public var namespaceId: Swift.String?
        /// The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in [Reserved Words](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide.
        public var namespaceName: Swift.String?
        /// The status of the namespace.
        public var status: RedshiftServerlessClientTypes.NamespaceStatus?

        public init(
            adminPasswordSecretArn: Swift.String? = nil,
            adminPasswordSecretKmsKeyId: Swift.String? = nil,
            adminUsername: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            dbName: Swift.String? = nil,
            defaultIamRoleArn: Swift.String? = nil,
            iamRoles: [Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            status: RedshiftServerlessClientTypes.NamespaceStatus? = nil
        )
        {
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.creationDate = creationDate
            self.dbName = dbName
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.namespaceArn = namespaceArn
            self.namespaceId = namespaceId
            self.namespaceName = namespaceName
            self.status = status
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum NamespaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .available,
                .deleting,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceStatus(rawValue: rawValue) ?? NamespaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case networkInterfaceId
        case privateIpAddress
        case subnetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a network interface in an Amazon Redshift Serverless managed VPC endpoint.
    public struct NetworkInterface: Swift.Equatable {
        /// The availability Zone.
        public var availabilityZone: Swift.String?
        /// The unique identifier of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The unique identifier of the subnet.
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
        }
    }

}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot. "{\"Version\": \"2012-10-17\", \"Statement\" : [{ \"Sid\": \"AllowUserRestoreFromSnapshot\", \"Principal\":{\"AWS\": [\"739247239426\"]}, \"Action\": [\"redshift-serverless:RestoreFromSnapshot\"] , \"Effect\": \"Allow\" }]}"
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the account to create or update a resource policy for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourcePolicy = nil
        }
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {
    /// The policy that was created or updated.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

struct PutResourcePolicyOutputBody: Swift.Equatable {
    let resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?
}

extension PutResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ResourcePolicy.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.RecoveryPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
        case recoveryPointCreateTime
        case recoveryPointId
        case totalSizeInMegaBytes
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let recoveryPointCreateTime = self.recoveryPointCreateTime {
            try encodeContainer.encodeTimestamp(recoveryPointCreateTime, format: .dateTime, forKey: .recoveryPointCreateTime)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let totalSizeInMegaBytes = self.totalSizeInMegaBytes {
            try encodeContainer.encode(totalSizeInMegaBytes, forKey: .totalSizeInMegaBytes)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let recoveryPointCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .recoveryPointCreateTime)
        recoveryPointCreateTime = recoveryPointCreateTimeDecoded
        let totalSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalSizeInMegaBytes)
        totalSizeInMegaBytes = totalSizeInMegaBytesDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The automatically created recovery point of a namespace. Recovery points are created every 30 minutes and kept for 24 hours.
    public struct RecoveryPoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.
        public var namespaceArn: Swift.String?
        /// The name of the namespace the recovery point is associated with.
        public var namespaceName: Swift.String?
        /// The time the recovery point is created.
        public var recoveryPointCreateTime: ClientRuntime.Date?
        /// The unique identifier of the recovery point.
        public var recoveryPointId: Swift.String?
        /// The total size of the data in the recovery point in megabytes.
        public var totalSizeInMegaBytes: Swift.Double?
        /// The name of the workgroup the recovery point is associated with.
        public var workgroupName: Swift.String?

        public init(
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            recoveryPointCreateTime: ClientRuntime.Date? = nil,
            recoveryPointId: Swift.String? = nil,
            totalSizeInMegaBytes: Swift.Double? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.recoveryPointCreateTime = recoveryPointCreateTime
            self.recoveryPointId = recoveryPointId
            self.totalSizeInMegaBytes = totalSizeInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension RedshiftServerlessClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.
    public struct ResourcePolicy: Swift.Equatable {
        /// The resource policy.
        public var policy: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        public var resourceArn: Swift.String?

        public init(
            policy: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.policy = policy
            self.resourceArn = resourceArn
        }
    }

}

extension RestoreFromRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case recoveryPointId
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreFromRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreFromRecoveryPointInput: Swift.Equatable {
    /// The name of the namespace to restore data into.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The unique identifier of the recovery point to restore from.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// The name of the workgroup used to restore data.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil,
        recoveryPointId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
        self.recoveryPointId = recoveryPointId
        self.workgroupName = workgroupName
    }
}

struct RestoreFromRecoveryPointInputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
}

extension RestoreFromRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
        case recoveryPointId
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension RestoreFromRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreFromRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.recoveryPointId = output.recoveryPointId
        } else {
            self.namespace = nil
            self.recoveryPointId = nil
        }
    }
}

public struct RestoreFromRecoveryPointOutput: Swift.Equatable {
    /// The namespace that data was restored into.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The unique identifier of the recovery point used for the restore.
    public var recoveryPointId: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        recoveryPointId: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.recoveryPointId = recoveryPointId
    }
}

struct RestoreFromRecoveryPointOutputBody: Swift.Equatable {
    let recoveryPointId: Swift.String?
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension RestoreFromRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
        case recoveryPointId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum RestoreFromRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case manageAdminPassword
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPasswordSecretKmsKeyId = self.adminPasswordSecretKmsKeyId {
            try encodeContainer.encode(adminPasswordSecretKmsKeyId, forKey: .adminPasswordSecretKmsKeyId)
        }
        if let manageAdminPassword = self.manageAdminPassword {
            try encodeContainer.encode(manageAdminPassword, forKey: .manageAdminPassword)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreFromSnapshotInput: Swift.Equatable {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// If true, Amazon Redshift uses Secrets Manager to manage the restored snapshot's admin credentials. If MmanageAdminPassword is false or not set, Amazon Redshift uses the admin credentials that the namespace or cluster had at the time the snapshot was taken.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace to restore the snapshot to.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The Amazon Web Services account that owns the snapshot.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to restore from. Required if restoring from Amazon Redshift Serverless to a provisioned cluster. Must not be specified at the same time as snapshotName. The format of the ARN is arn:aws:redshift:<region>:<account_id>:snapshot:<cluster_identifier>/<snapshot_identifier>.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to restore from. Must not be specified at the same time as snapshotArn.
    public var snapshotName: Swift.String?
    /// The name of the workgroup used to restore the snapshot.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
        self.workgroupName = workgroupName
    }
}

struct RestoreFromSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
    let snapshotName: Swift.String?
    let snapshotArn: Swift.String?
    let ownerAccount: Swift.String?
    let manageAdminPassword: Swift.Bool?
    let adminPasswordSecretKmsKeyId: Swift.String?
}

extension RestoreFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case manageAdminPassword
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let manageAdminPasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageAdminPassword)
        manageAdminPassword = manageAdminPasswordDecoded
        let adminPasswordSecretKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretKmsKeyId)
        adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyIdDecoded
    }
}

extension RestoreFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.ownerAccount = output.ownerAccount
            self.snapshotName = output.snapshotName
        } else {
            self.namespace = nil
            self.ownerAccount = nil
            self.snapshotName = nil
        }
    }
}

public struct RestoreFromSnapshotOutput: Swift.Equatable {
    /// A collection of database objects and users.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The owner Amazon Web Services; account of the snapshot that was restored.
    public var ownerAccount: Swift.String?
    /// The name of the snapshot used to restore the namespace.
    public var snapshotName: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.ownerAccount = ownerAccount
        self.snapshotName = snapshotName
    }
}

struct RestoreFromSnapshotOutputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let ownerAccount: Swift.String?
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension RestoreFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
        case ownerAccount
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum RestoreFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreTableFromRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case recoveryPointId
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activateCaseSensitiveIdentifier = self.activateCaseSensitiveIdentifier {
            try encodeContainer.encode(activateCaseSensitiveIdentifier, forKey: .activateCaseSensitiveIdentifier)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let newTableName = self.newTableName {
            try encodeContainer.encode(newTableName, forKey: .newTableName)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let sourceDatabaseName = self.sourceDatabaseName {
            try encodeContainer.encode(sourceDatabaseName, forKey: .sourceDatabaseName)
        }
        if let sourceSchemaName = self.sourceSchemaName {
            try encodeContainer.encode(sourceSchemaName, forKey: .sourceSchemaName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetSchemaName = self.targetSchemaName {
            try encodeContainer.encode(targetSchemaName, forKey: .targetSchemaName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreTableFromRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreTableFromRecoveryPointInput: Swift.Equatable {
    /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
    public var activateCaseSensitiveIdentifier: Swift.Bool?
    /// Namespace of the recovery point to restore from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the table to create from the restore operation.
    /// This member is required.
    public var newTableName: Swift.String?
    /// The ID of the recovery point to restore the table from.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// The name of the source database that contains the table being restored.
    /// This member is required.
    public var sourceDatabaseName: Swift.String?
    /// The name of the source schema that contains the table being restored.
    public var sourceSchemaName: Swift.String?
    /// The name of the source table being restored.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// The name of the database to restore the table to.
    public var targetDatabaseName: Swift.String?
    /// The name of the schema to restore the table to.
    public var targetSchemaName: Swift.String?
    /// The workgroup to restore the table to.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        activateCaseSensitiveIdentifier: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        newTableName: Swift.String? = nil,
        recoveryPointId: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
        self.namespaceName = namespaceName
        self.newTableName = newTableName
        self.recoveryPointId = recoveryPointId
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.workgroupName = workgroupName
    }
}

struct RestoreTableFromRecoveryPointInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
    let recoveryPointId: Swift.String?
    let sourceDatabaseName: Swift.String?
    let sourceSchemaName: Swift.String?
    let sourceTableName: Swift.String?
    let targetDatabaseName: Swift.String?
    let targetSchemaName: Swift.String?
    let newTableName: Swift.String?
    let activateCaseSensitiveIdentifier: Swift.Bool?
}

extension RestoreTableFromRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case recoveryPointId
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
        let activateCaseSensitiveIdentifierDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activateCaseSensitiveIdentifier)
        activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifierDecoded
    }
}

extension RestoreTableFromRecoveryPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreTableFromRecoveryPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct RestoreTableFromRecoveryPointOutput: Swift.Equatable {
    /// Contains information about a table restore request.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct RestoreTableFromRecoveryPointOutputBody: Swift.Equatable {
    let tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?
}

extension RestoreTableFromRecoveryPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

enum RestoreTableFromRecoveryPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreTableFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activateCaseSensitiveIdentifier = self.activateCaseSensitiveIdentifier {
            try encodeContainer.encode(activateCaseSensitiveIdentifier, forKey: .activateCaseSensitiveIdentifier)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let newTableName = self.newTableName {
            try encodeContainer.encode(newTableName, forKey: .newTableName)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let sourceDatabaseName = self.sourceDatabaseName {
            try encodeContainer.encode(sourceDatabaseName, forKey: .sourceDatabaseName)
        }
        if let sourceSchemaName = self.sourceSchemaName {
            try encodeContainer.encode(sourceSchemaName, forKey: .sourceSchemaName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetSchemaName = self.targetSchemaName {
            try encodeContainer.encode(targetSchemaName, forKey: .targetSchemaName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension RestoreTableFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreTableFromSnapshotInput: Swift.Equatable {
    /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
    public var activateCaseSensitiveIdentifier: Swift.Bool?
    /// The namespace of the snapshot to restore from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the table to create from the restore operation.
    /// This member is required.
    public var newTableName: Swift.String?
    /// The name of the snapshot to restore the table from.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// The name of the source database that contains the table being restored.
    /// This member is required.
    public var sourceDatabaseName: Swift.String?
    /// The name of the source schema that contains the table being restored.
    public var sourceSchemaName: Swift.String?
    /// The name of the source table being restored.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// The name of the database to restore the table to.
    public var targetDatabaseName: Swift.String?
    /// The name of the schema to restore the table to.
    public var targetSchemaName: Swift.String?
    /// The workgroup to restore the table to.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        activateCaseSensitiveIdentifier: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        newTableName: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
        self.namespaceName = namespaceName
        self.newTableName = newTableName
        self.snapshotName = snapshotName
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.workgroupName = workgroupName
    }
}

struct RestoreTableFromSnapshotInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let workgroupName: Swift.String?
    let snapshotName: Swift.String?
    let sourceDatabaseName: Swift.String?
    let sourceSchemaName: Swift.String?
    let sourceTableName: Swift.String?
    let targetDatabaseName: Swift.String?
    let targetSchemaName: Swift.String?
    let newTableName: Swift.String?
    let activateCaseSensitiveIdentifier: Swift.Bool?
}

extension RestoreTableFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateCaseSensitiveIdentifier
        case namespaceName
        case newTableName
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case targetDatabaseName
        case targetSchemaName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
        let activateCaseSensitiveIdentifierDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activateCaseSensitiveIdentifier)
        activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifierDecoded
    }
}

extension RestoreTableFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreTableFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableRestoreStatus = output.tableRestoreStatus
        } else {
            self.tableRestoreStatus = nil
        }
    }
}

public struct RestoreTableFromSnapshotOutput: Swift.Equatable {
    /// The TableRestoreStatus object that contains the status of the restore operation.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

struct RestoreTableFromSnapshotOutputBody: Swift.Equatable {
    let tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?
}

extension RestoreTableFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableRestoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TableRestoreStatus.self, forKey: .tableRestoreStatus)
        tableRestoreStatus = tableRestoreStatusDecoded
    }
}

enum RestoreTableFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.Schedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case at
        case cron
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .at(at):
                try container.encodeTimestamp(at, format: .epochSeconds, forKey: .at)
            case let .cron(cron):
                try container.encode(cron, forKey: .cron)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let atDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .at)
        if let at = atDecoded {
            self = .at(at)
            return
        }
        let cronDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .cron)
        if let cron = cronDecoded {
            self = .cron(cron)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RedshiftServerlessClientTypes {
    /// The schedule of when Amazon Redshift Serverless should run the scheduled action.
    public enum Schedule: Swift.Equatable {
        /// The timestamp of when Amazon Redshift Serverless should run the scheduled action. Format of at expressions is "at(yyyy-mm-ddThh:mm:ss)". For example, "at(2016-03-04T17:27:00)".
        case at(ClientRuntime.Date)
        /// The cron expression to use to schedule a recurring scheduled action. Schedule invocations must be separated by at least one hour. Format of cron expressions is "cron(Minutes Hours Day-of-month Month Day-of-week Year)". For example, "cron(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
        case cron(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RedshiftServerlessClientTypes.ScheduledActionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case namespaceName
        case nextInvocations
        case roleArn
        case schedule
        case scheduledActionDescription
        case scheduledActionName
        case scheduledActionUuid
        case startTime
        case state
        case targetAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let nextInvocations = nextInvocations {
            var nextInvocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nextInvocations)
            for timestamp0 in nextInvocations {
                try nextInvocationsContainer.encodeTimestamp(timestamp0, format: .epochSeconds)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let scheduledActionDescription = self.scheduledActionDescription {
            try encodeContainer.encode(scheduledActionDescription, forKey: .scheduledActionDescription)
        }
        if let scheduledActionName = self.scheduledActionName {
            try encodeContainer.encode(scheduledActionName, forKey: .scheduledActionName)
        }
        if let scheduledActionUuid = self.scheduledActionUuid {
            try encodeContainer.encode(scheduledActionUuid, forKey: .scheduledActionUuid)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targetAction = self.targetAction {
            try encodeContainer.encode(targetAction, forKey: .targetAction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let nextInvocationsContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .nextInvocations)
        var nextInvocationsDecoded0:[ClientRuntime.Date]? = nil
        if let nextInvocationsContainer = nextInvocationsContainer {
            nextInvocationsDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in nextInvocationsContainer {
                if let timestamp0 = timestamp0 {
                    nextInvocationsDecoded0?.append(timestamp0)
                }
            }
        }
        nextInvocations = nextInvocationsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TargetAction.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let scheduledActionUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionUuid)
        scheduledActionUuid = scheduledActionUuidDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The returned scheduled action object.
    public struct ScheduledActionResponse: Swift.Equatable {
        /// The end time of
        public var endTime: ClientRuntime.Date?
        /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
        public var namespaceName: Swift.String?
        /// An array of timestamps of when the next scheduled actions will trigger.
        public var nextInvocations: [ClientRuntime.Date]?
        /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
        public var roleArn: Swift.String?
        /// The schedule for a one-time (at format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Format of at expressions is "at(yyyy-mm-ddThh:mm:ss)". For example, "at(2016-03-04T17:27:00)". Format of cron expressions is "cron(Minutes Hours Day-of-month Month Day-of-week Year)". For example, "cron(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
        public var schedule: RedshiftServerlessClientTypes.Schedule?
        /// The description of the scheduled action.
        public var scheduledActionDescription: Swift.String?
        /// The name of the scheduled action.
        public var scheduledActionName: Swift.String?
        /// The uuid of the scheduled action.
        public var scheduledActionUuid: Swift.String?
        /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
        public var startTime: ClientRuntime.Date?
        /// The state of the scheduled action.
        public var state: RedshiftServerlessClientTypes.State?
        /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
        public var targetAction: RedshiftServerlessClientTypes.TargetAction?

        public init(
            endTime: ClientRuntime.Date? = nil,
            namespaceName: Swift.String? = nil,
            nextInvocations: [ClientRuntime.Date]? = nil,
            roleArn: Swift.String? = nil,
            schedule: RedshiftServerlessClientTypes.Schedule? = nil,
            scheduledActionDescription: Swift.String? = nil,
            scheduledActionName: Swift.String? = nil,
            scheduledActionUuid: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: RedshiftServerlessClientTypes.State? = nil,
            targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
        )
        {
            self.endTime = endTime
            self.namespaceName = namespaceName
            self.nextInvocations = nextInvocations
            self.roleArn = roleArn
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.scheduledActionUuid = scheduledActionUuid
            self.startTime = startTime
            self.state = state
            self.targetAction = targetAction
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service limit was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsWithProvisionedRestoreAccess
        case accountsWithRestoreAccess
        case actualIncrementalBackupSizeInMegaBytes
        case adminPasswordSecretArn
        case adminPasswordSecretKmsKeyId
        case adminUsername
        case backupProgressInMegaBytes
        case currentBackupRateInMegaBytesPerSecond
        case elapsedTimeInSeconds
        case estimatedSecondsToCompletion
        case kmsKeyId
        case namespaceArn
        case namespaceName
        case ownerAccount
        case snapshotArn
        case snapshotCreateTime
        case snapshotName
        case snapshotRemainingDays
        case snapshotRetentionPeriod
        case snapshotRetentionStartTime
        case status
        case totalBackupSizeInMegaBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess {
            var accountsWithProvisionedRestoreAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountsWithProvisionedRestoreAccess)
            for string0 in accountsWithProvisionedRestoreAccess {
                try accountsWithProvisionedRestoreAccessContainer.encode(string0)
            }
        }
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountsWithRestoreAccess)
            for string0 in accountsWithRestoreAccess {
                try accountsWithRestoreAccessContainer.encode(string0)
            }
        }
        if let actualIncrementalBackupSizeInMegaBytes = self.actualIncrementalBackupSizeInMegaBytes {
            try encodeContainer.encode(actualIncrementalBackupSizeInMegaBytes, forKey: .actualIncrementalBackupSizeInMegaBytes)
        }
        if let adminPasswordSecretArn = self.adminPasswordSecretArn {
            try encodeContainer.encode(adminPasswordSecretArn, forKey: .adminPasswordSecretArn)
        }
        if let adminPasswordSecretKmsKeyId = self.adminPasswordSecretKmsKeyId {
            try encodeContainer.encode(adminPasswordSecretKmsKeyId, forKey: .adminPasswordSecretKmsKeyId)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let backupProgressInMegaBytes = self.backupProgressInMegaBytes {
            try encodeContainer.encode(backupProgressInMegaBytes, forKey: .backupProgressInMegaBytes)
        }
        if let currentBackupRateInMegaBytesPerSecond = self.currentBackupRateInMegaBytesPerSecond {
            try encodeContainer.encode(currentBackupRateInMegaBytesPerSecond, forKey: .currentBackupRateInMegaBytesPerSecond)
        }
        if let elapsedTimeInSeconds = self.elapsedTimeInSeconds {
            try encodeContainer.encode(elapsedTimeInSeconds, forKey: .elapsedTimeInSeconds)
        }
        if let estimatedSecondsToCompletion = self.estimatedSecondsToCompletion {
            try encodeContainer.encode(estimatedSecondsToCompletion, forKey: .estimatedSecondsToCompletion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let namespaceArn = self.namespaceArn {
            try encodeContainer.encode(namespaceArn, forKey: .namespaceArn)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encodeTimestamp(snapshotCreateTime, format: .dateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let snapshotRemainingDays = self.snapshotRemainingDays {
            try encodeContainer.encode(snapshotRemainingDays, forKey: .snapshotRemainingDays)
        }
        if let snapshotRetentionPeriod = self.snapshotRetentionPeriod {
            try encodeContainer.encode(snapshotRetentionPeriod, forKey: .snapshotRetentionPeriod)
        }
        if let snapshotRetentionStartTime = self.snapshotRetentionStartTime {
            try encodeContainer.encodeTimestamp(snapshotRetentionStartTime, format: .dateTime, forKey: .snapshotRetentionStartTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalBackupSizeInMegaBytes = self.totalBackupSizeInMegaBytes {
            try encodeContainer.encode(totalBackupSizeInMegaBytes, forKey: .totalBackupSizeInMegaBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let snapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionPeriod)
        snapshotRetentionPeriod = snapshotRetentionPeriodDecoded
        let snapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRemainingDays)
        snapshotRemainingDays = snapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .snapshotRetentionStartTime)
        snapshotRetentionStartTime = snapshotRetentionStartTimeDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let accountsWithRestoreAccessContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountsWithRestoreAccess)
        var accountsWithRestoreAccessDecoded0:[Swift.String]? = nil
        if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
            accountsWithRestoreAccessDecoded0 = [Swift.String]()
            for string0 in accountsWithRestoreAccessContainer {
                if let string0 = string0 {
                    accountsWithRestoreAccessDecoded0?.append(string0)
                }
            }
        }
        accountsWithRestoreAccess = accountsWithRestoreAccessDecoded0
        let accountsWithProvisionedRestoreAccessContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountsWithProvisionedRestoreAccess)
        var accountsWithProvisionedRestoreAccessDecoded0:[Swift.String]? = nil
        if let accountsWithProvisionedRestoreAccessContainer = accountsWithProvisionedRestoreAccessContainer {
            accountsWithProvisionedRestoreAccessDecoded0 = [Swift.String]()
            for string0 in accountsWithProvisionedRestoreAccessContainer {
                if let string0 = string0 {
                    accountsWithProvisionedRestoreAccessDecoded0?.append(string0)
                }
            }
        }
        accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccessDecoded0
        let adminPasswordSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretArn)
        adminPasswordSecretArn = adminPasswordSecretArnDecoded
        let adminPasswordSecretKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretKmsKeyId)
        adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyIdDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// A snapshot object that contains databases.
    public struct Snapshot: Swift.Equatable {
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.
        public var accountsWithProvisionedRestoreAccess: [Swift.String]?
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.
        public var accountsWithRestoreAccess: [Swift.String]?
        /// The size of the incremental backup in megabytes.
        public var actualIncrementalBackupSizeInMegaBytes: Swift.Double?
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public var adminPasswordSecretArn: Swift.String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public var adminPasswordSecretKmsKeyId: Swift.String?
        /// The username of the database within a snapshot.
        public var adminUsername: Swift.String?
        /// The size in megabytes of the data that has been backed up to a snapshot.
        public var backupProgressInMegaBytes: Swift.Double?
        /// The rate at which data is backed up into a snapshot in megabytes per second.
        public var currentBackupRateInMegaBytesPerSecond: Swift.Double?
        /// The amount of time it took to back up data into a snapshot.
        public var elapsedTimeInSeconds: Swift.Int?
        /// The estimated amount of seconds until the snapshot completes backup.
        public var estimatedSecondsToCompletion: Swift.Int?
        /// The unique identifier of the KMS key used to encrypt the snapshot.
        public var kmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the namespace the snapshot was created from.
        public var namespaceArn: Swift.String?
        /// The name of the namepsace.
        public var namespaceName: Swift.String?
        /// The owner Amazon Web Services; account of the snapshot.
        public var ownerAccount: Swift.String?
        /// The Amazon Resource Name (ARN) of the snapshot.
        public var snapshotArn: Swift.String?
        /// The timestamp of when the snapshot was created.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// The name of the snapshot.
        public var snapshotName: Swift.String?
        /// The amount of days until the snapshot is deleted.
        public var snapshotRemainingDays: Swift.Int?
        /// The period of time, in days, of how long the snapshot is retained.
        public var snapshotRetentionPeriod: Swift.Int?
        /// The timestamp of when data within the snapshot started getting retained.
        public var snapshotRetentionStartTime: ClientRuntime.Date?
        /// The status of the snapshot.
        public var status: RedshiftServerlessClientTypes.SnapshotStatus?
        /// The total size, in megabytes, of how big the snapshot is.
        public var totalBackupSizeInMegaBytes: Swift.Double?

        public init(
            accountsWithProvisionedRestoreAccess: [Swift.String]? = nil,
            accountsWithRestoreAccess: [Swift.String]? = nil,
            actualIncrementalBackupSizeInMegaBytes: Swift.Double? = nil,
            adminPasswordSecretArn: Swift.String? = nil,
            adminPasswordSecretKmsKeyId: Swift.String? = nil,
            adminUsername: Swift.String? = nil,
            backupProgressInMegaBytes: Swift.Double? = nil,
            currentBackupRateInMegaBytesPerSecond: Swift.Double? = nil,
            elapsedTimeInSeconds: Swift.Int? = nil,
            estimatedSecondsToCompletion: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotName: Swift.String? = nil,
            snapshotRemainingDays: Swift.Int? = nil,
            snapshotRetentionPeriod: Swift.Int? = nil,
            snapshotRetentionStartTime: ClientRuntime.Date? = nil,
            status: RedshiftServerlessClientTypes.SnapshotStatus? = nil,
            totalBackupSizeInMegaBytes: Swift.Double? = nil
        )
        {
            self.accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess
            self.accountsWithRestoreAccess = accountsWithRestoreAccess
            self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.backupProgressInMegaBytes = backupProgressInMegaBytes
            self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
            self.kmsKeyId = kmsKeyId
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotName = snapshotName
            self.snapshotRemainingDays = snapshotRemainingDays
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
            self.snapshotRetentionStartTime = snapshotRetentionStartTime
            self.status = status
            self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        }
    }

}

extension RedshiftServerlessClientTypes.SnapshotCopyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationKmsKeyId
        case destinationRegion
        case namespaceName
        case snapshotCopyConfigurationArn
        case snapshotCopyConfigurationId
        case snapshotRetentionPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationKmsKeyId = self.destinationKmsKeyId {
            try encodeContainer.encode(destinationKmsKeyId, forKey: .destinationKmsKeyId)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let snapshotCopyConfigurationArn = self.snapshotCopyConfigurationArn {
            try encodeContainer.encode(snapshotCopyConfigurationArn, forKey: .snapshotCopyConfigurationArn)
        }
        if let snapshotCopyConfigurationId = self.snapshotCopyConfigurationId {
            try encodeContainer.encode(snapshotCopyConfigurationId, forKey: .snapshotCopyConfigurationId)
        }
        if let snapshotRetentionPeriod = self.snapshotRetentionPeriod {
            try encodeContainer.encode(snapshotRetentionPeriod, forKey: .snapshotRetentionPeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyConfigurationId)
        snapshotCopyConfigurationId = snapshotCopyConfigurationIdDecoded
        let snapshotCopyConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyConfigurationArn)
        snapshotCopyConfigurationArn = snapshotCopyConfigurationArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let snapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionPeriod)
        snapshotRetentionPeriod = snapshotRetentionPeriodDecoded
        let destinationKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationKmsKeyId)
        destinationKmsKeyId = destinationKmsKeyIdDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The object that you configure to copy snapshots from one namespace to a namespace in another Amazon Web Services Region.
    public struct SnapshotCopyConfiguration: Swift.Equatable {
        /// The ID of the KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
        public var destinationKmsKeyId: Swift.String?
        /// The destination Amazon Web Services Region to copy snapshots to.
        public var destinationRegion: Swift.String?
        /// The name of the namespace to copy snapshots from in the source Amazon Web Services Region.
        public var namespaceName: Swift.String?
        /// The ARN of the snapshot copy configuration object.
        public var snapshotCopyConfigurationArn: Swift.String?
        /// The ID of the snapshot copy configuration object.
        public var snapshotCopyConfigurationId: Swift.String?
        /// The retention period of snapshots that are copied to the destination Amazon Web Services Region.
        public var snapshotRetentionPeriod: Swift.Int?

        public init(
            destinationKmsKeyId: Swift.String? = nil,
            destinationRegion: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            snapshotCopyConfigurationArn: Swift.String? = nil,
            snapshotCopyConfigurationId: Swift.String? = nil,
            snapshotRetentionPeriod: Swift.Int? = nil
        )
        {
            self.destinationKmsKeyId = destinationKmsKeyId
            self.destinationRegion = destinationRegion
            self.namespaceName = namespaceName
            self.snapshotCopyConfigurationArn = snapshotCopyConfigurationArn
            self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case cancelled
        case copying
        case creating
        case deleted
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .cancelled,
                .copying,
                .creating,
                .deleted,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .cancelled: return "CANCELLED"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes.TableRestoreStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case namespaceName
        case newTableName
        case progressInMegaBytes
        case recoveryPointId
        case requestTime
        case snapshotName
        case sourceDatabaseName
        case sourceSchemaName
        case sourceTableName
        case status
        case tableRestoreRequestId
        case targetDatabaseName
        case targetSchemaName
        case totalDataInMegaBytes
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let newTableName = self.newTableName {
            try encodeContainer.encode(newTableName, forKey: .newTableName)
        }
        if let progressInMegaBytes = self.progressInMegaBytes {
            try encodeContainer.encode(progressInMegaBytes, forKey: .progressInMegaBytes)
        }
        if let recoveryPointId = self.recoveryPointId {
            try encodeContainer.encode(recoveryPointId, forKey: .recoveryPointId)
        }
        if let requestTime = self.requestTime {
            try encodeContainer.encodeTimestamp(requestTime, format: .epochSeconds, forKey: .requestTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let sourceDatabaseName = self.sourceDatabaseName {
            try encodeContainer.encode(sourceDatabaseName, forKey: .sourceDatabaseName)
        }
        if let sourceSchemaName = self.sourceSchemaName {
            try encodeContainer.encode(sourceSchemaName, forKey: .sourceSchemaName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tableRestoreRequestId = self.tableRestoreRequestId {
            try encodeContainer.encode(tableRestoreRequestId, forKey: .tableRestoreRequestId)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetSchemaName = self.targetSchemaName {
            try encodeContainer.encode(targetSchemaName, forKey: .targetSchemaName)
        }
        if let totalDataInMegaBytes = self.totalDataInMegaBytes {
            try encodeContainer.encode(totalDataInMegaBytes, forKey: .totalDataInMegaBytes)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableRestoreRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableRestoreRequestId)
        tableRestoreRequestId = tableRestoreRequestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestTime)
        requestTime = requestTimeDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let totalDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDataInMegaBytes)
        totalDataInMegaBytes = totalDataInMegaBytesDecoded
        let sourceDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDatabaseName)
        sourceDatabaseName = sourceDatabaseNameDecoded
        let sourceSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSchemaName)
        sourceSchemaName = sourceSchemaNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetSchemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSchemaName)
        targetSchemaName = targetSchemaNameDecoded
        let newTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newTableName)
        newTableName = newTableNameDecoded
        let recoveryPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointId)
        recoveryPointId = recoveryPointIdDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a table restore request.
    public struct TableRestoreStatus: Swift.Equatable {
        /// A message that explains the returned status. For example, if the status of the operation is FAILED, the message explains why the operation failed.
        public var message: Swift.String?
        /// The namespace of the table being restored from.
        public var namespaceName: Swift.String?
        /// The name of the table to create from the restore operation.
        public var newTableName: Swift.String?
        /// The amount of data restored to the new table so far, in megabytes (MB).
        public var progressInMegaBytes: Swift.Int?
        /// The ID of the recovery point being restored from.
        public var recoveryPointId: Swift.String?
        /// The time that the table restore request was made, in Universal Coordinated Time (UTC).
        public var requestTime: ClientRuntime.Date?
        /// The name of the snapshot being restored from.
        public var snapshotName: Swift.String?
        /// The name of the source database being restored from.
        public var sourceDatabaseName: Swift.String?
        /// The name of the source schema being restored from.
        public var sourceSchemaName: Swift.String?
        /// The name of the source table being restored from.
        public var sourceTableName: Swift.String?
        /// A value that describes the current state of the table restore request. Possible values are SUCCEEDED, FAILED, CANCELED, PENDING, and IN_PROGRESS.
        public var status: Swift.String?
        /// The ID of the RestoreTableFromSnapshot request.
        public var tableRestoreRequestId: Swift.String?
        /// The name of the database to restore to.
        public var targetDatabaseName: Swift.String?
        /// The name of the schema to restore to.
        public var targetSchemaName: Swift.String?
        /// The total amount of data to restore to the new table, in megabytes (MB).
        public var totalDataInMegaBytes: Swift.Int?
        /// The name of the workgroup being restored from.
        public var workgroupName: Swift.String?

        public init(
            message: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            newTableName: Swift.String? = nil,
            progressInMegaBytes: Swift.Int? = nil,
            recoveryPointId: Swift.String? = nil,
            requestTime: ClientRuntime.Date? = nil,
            snapshotName: Swift.String? = nil,
            sourceDatabaseName: Swift.String? = nil,
            sourceSchemaName: Swift.String? = nil,
            sourceTableName: Swift.String? = nil,
            status: Swift.String? = nil,
            tableRestoreRequestId: Swift.String? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetSchemaName: Swift.String? = nil,
            totalDataInMegaBytes: Swift.Int? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.message = message
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.progressInMegaBytes = progressInMegaBytes
            self.recoveryPointId = recoveryPointId
            self.requestTime = requestTime
            self.snapshotName = snapshotName
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.status = status
            self.tableRestoreRequestId = tableRestoreRequestId
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.totalDataInMegaBytes = totalDataInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

extension RedshiftServerlessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// A map of key-value pairs.
    public struct Tag: Swift.Equatable {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The map of the key-value pairs used to tag the resource.
    /// This member is required.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [RedshiftServerlessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RedshiftServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RedshiftServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.TargetAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createsnapshot = "createSnapshot"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .createsnapshot(createsnapshot):
                try container.encode(createsnapshot, forKey: .createsnapshot)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let createsnapshotDecoded = try values.decodeIfPresent(RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters.self, forKey: .createsnapshot)
        if let createsnapshot = createsnapshotDecoded {
            self = .createsnapshot(createsnapshot)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RedshiftServerlessClientTypes {
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    public enum TargetAction: Swift.Equatable {
        /// The parameters that you can use to configure a [scheduled action](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html) to create a snapshot. For more information about creating a scheduled action, see [CreateScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html).
        case createsnapshot(RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters)
        case sdkUnknown(Swift.String)
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeded the number of tags allowed for a resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that exceeded the number of tags allowed for a resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCustomDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainCertificateArn = self.customDomainCertificateArn {
            try encodeContainer.encode(customDomainCertificateArn, forKey: .customDomainCertificateArn)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension UpdateCustomDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomDomainAssociationInput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN). This is optional.
    /// This member is required.
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct UpdateCustomDomainAssociationInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let customDomainName: Swift.String?
    let customDomainCertificateArn: Swift.String?
}

extension UpdateCustomDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
    }
}

extension UpdateCustomDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.customDomainCertificateArn = output.customDomainCertificateArn
            self.customDomainCertificateExpiryTime = output.customDomainCertificateExpiryTime
            self.customDomainName = output.customDomainName
            self.workgroupName = output.workgroupName
        } else {
            self.customDomainCertificateArn = nil
            self.customDomainCertificateExpiryTime = nil
            self.customDomainName = nil
            self.workgroupName = nil
        }
    }
}

public struct UpdateCustomDomainAssociationOutput: Swift.Equatable {
    /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: ClientRuntime.Date?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

struct UpdateCustomDomainAssociationOutputBody: Swift.Equatable {
    let customDomainName: Swift.String?
    let workgroupName: Swift.String?
    let customDomainCertificateArn: Swift.String?
    let customDomainCertificateExpiryTime: ClientRuntime.Date?
}

extension UpdateCustomDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomainCertificateArn
        case customDomainCertificateExpiryTime
        case customDomainName
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
        let customDomainCertificateExpiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .customDomainCertificateExpiryTime)
        customDomainCertificateExpiryTime = customDomainCertificateExpiryTimeDecoded
    }
}

enum UpdateCustomDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEndpointAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointName = self.endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupid0)
            }
        }
    }
}

extension UpdateEndpointAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEndpointAccessInput: Swift.Equatable {
    /// The name of the VPC endpoint to update.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The list of VPC security groups associated with the endpoint after the endpoint is modified.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        endpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.endpointName = endpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct UpdateEndpointAccessInputBody: Swift.Equatable {
    let endpointName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension UpdateEndpointAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointName
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension UpdateEndpointAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEndpointAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct UpdateEndpointAccessOutput: Swift.Equatable {
    /// The updated VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct UpdateEndpointAccessOutputBody: Swift.Equatable {
    let endpoint: RedshiftServerlessClientTypes.EndpointAccess?
}

extension UpdateEndpointAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.EndpointAccess.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum UpdateEndpointAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNamespaceInput(adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), manageAdminPassword: \(Swift.String(describing: manageAdminPassword)), namespaceName: \(Swift.String(describing: namespaceName)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

extension UpdateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case adminUserPassword
        case adminUsername
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case manageAdminPassword
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPasswordSecretKmsKeyId = self.adminPasswordSecretKmsKeyId {
            try encodeContainer.encode(adminPasswordSecretKmsKeyId, forKey: .adminPasswordSecretKmsKeyId)
        }
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let adminUsername = self.adminUsername {
            try encodeContainer.encode(adminUsername, forKey: .adminUsername)
        }
        if let defaultIamRoleArn = self.defaultIamRoleArn {
            try encodeContainer.encode(defaultIamRoleArn, forKey: .defaultIamRoleArn)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for iamrolearn0 in iamRoles {
                try iamRolesContainer.encode(iamrolearn0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logExports = logExports {
            var logExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logExports)
            for logexport0 in logExports {
                try logExportsContainer.encode(logexport0.rawValue)
            }
        }
        if let manageAdminPassword = self.manageAdminPassword {
            try encodeContainer.encode(manageAdminPassword, forKey: .manageAdminPassword)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension UpdateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNamespaceInput: Swift.Equatable {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret. You can only use this parameter if manageAdminPassword is true.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// The password of the administrator for the first database created in the namespace. This parameter must be updated together with adminUsername. You can't use adminUserPassword if manageAdminPassword is true.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace. This parameter must be updated together with adminUserPassword.
    public var adminUsername: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace. This parameter must be updated together with iamRoles.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace. This parameter must be updated together with defaultIamRoleArn.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. The export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials. You can't use adminUserPassword if manageAdminPassword is true. If manageAdminPassword is false or not set, Amazon Redshift uses adminUserPassword for the admin user account's password.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace to update. You can't update the name of a namespace once it is created.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
    }
}

struct UpdateNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
    let adminUserPassword: Swift.String?
    let adminUsername: Swift.String?
    let kmsKeyId: Swift.String?
    let defaultIamRoleArn: Swift.String?
    let iamRoles: [Swift.String]?
    let logExports: [RedshiftServerlessClientTypes.LogExport]?
    let manageAdminPassword: Swift.Bool?
    let adminPasswordSecretKmsKeyId: Swift.String?
}

extension UpdateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPasswordSecretKmsKeyId
        case adminUserPassword
        case adminUsername
        case defaultIamRoleArn
        case iamRoles
        case kmsKeyId
        case logExports
        case manageAdminPassword
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let adminUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUsername)
        adminUsername = adminUsernameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[Swift.String]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [Swift.String]()
            for string0 in iamRolesContainer {
                if let string0 = string0 {
                    iamRolesDecoded0?.append(string0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let logExportsContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.LogExport?].self, forKey: .logExports)
        var logExportsDecoded0:[RedshiftServerlessClientTypes.LogExport]? = nil
        if let logExportsContainer = logExportsContainer {
            logExportsDecoded0 = [RedshiftServerlessClientTypes.LogExport]()
            for string0 in logExportsContainer {
                if let string0 = string0 {
                    logExportsDecoded0?.append(string0)
                }
            }
        }
        logExports = logExportsDecoded0
        let manageAdminPasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageAdminPassword)
        manageAdminPassword = manageAdminPasswordDecoded
        let adminPasswordSecretKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminPasswordSecretKmsKeyId)
        adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyIdDecoded
    }
}

extension UpdateNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct UpdateNamespaceOutput: Swift.Equatable {
    /// A list of tag instances.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct UpdateNamespaceOutputBody: Swift.Equatable {
    let namespace: RedshiftServerlessClientTypes.Namespace?
}

extension UpdateNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

enum UpdateNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateScheduledActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case endTime
        case roleArn
        case schedule
        case scheduledActionDescription
        case scheduledActionName
        case startTime
        case targetAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let scheduledActionDescription = self.scheduledActionDescription {
            try encodeContainer.encode(scheduledActionDescription, forKey: .scheduledActionDescription)
        }
        if let scheduledActionName = self.scheduledActionName {
            try encodeContainer.encode(scheduledActionName, forKey: .scheduledActionName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let targetAction = self.targetAction {
            try encodeContainer.encode(targetAction, forKey: .targetAction)
        }
    }
}

extension UpdateScheduledActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateScheduledActionInput: Swift.Equatable {
    /// Specifies whether to enable the scheduled action.
    public var enabled: Swift.Bool?
    /// The end time in UTC of the scheduled action to update.
    public var endTime: ClientRuntime.Date?
    /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
    public var roleArn: Swift.String?
    /// The schedule for a one-time (at format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Format of at expressions is "at(yyyy-mm-ddThh:mm:ss)". For example, "at(2016-03-04T17:27:00)". Format of cron expressions is "cron(Minutes Hours Day-of-month Month Day-of-week Year)". For example, "cron(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
    public var schedule: RedshiftServerlessClientTypes.Schedule?
    /// The descripion of the scheduled action to update to.
    public var scheduledActionDescription: Swift.String?
    /// The name of the scheduled action to update to.
    /// This member is required.
    public var scheduledActionName: Swift.String?
    /// The start time in UTC of the scheduled action to update to.
    public var startTime: ClientRuntime.Date?
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    public var targetAction: RedshiftServerlessClientTypes.TargetAction?

    public init(
        enabled: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        schedule: RedshiftServerlessClientTypes.Schedule? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
    )
    {
        self.enabled = enabled
        self.endTime = endTime
        self.roleArn = roleArn
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

struct UpdateScheduledActionInputBody: Swift.Equatable {
    let scheduledActionName: Swift.String?
    let targetAction: RedshiftServerlessClientTypes.TargetAction?
    let schedule: RedshiftServerlessClientTypes.Schedule?
    let roleArn: Swift.String?
    let enabled: Swift.Bool?
    let scheduledActionDescription: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension UpdateScheduledActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case endTime
        case roleArn
        case schedule
        case scheduledActionDescription
        case scheduledActionName
        case startTime
        case targetAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionName)
        scheduledActionName = scheduledActionNameDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.TargetAction.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let scheduledActionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledActionDescription)
        scheduledActionDescription = scheduledActionDescriptionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension UpdateScheduledActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateScheduledActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAction = output.scheduledAction
        } else {
            self.scheduledAction = nil
        }
    }
}

public struct UpdateScheduledActionOutput: Swift.Equatable {
    /// The ScheduledAction object that was updated.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

struct UpdateScheduledActionOutputBody: Swift.Equatable {
    let scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?
}

extension UpdateScheduledActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.ScheduledActionResponse.self, forKey: .scheduledAction)
        scheduledAction = scheduledActionDecoded
    }
}

enum UpdateScheduledActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSnapshotCopyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfigurationId
        case snapshotRetentionPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotCopyConfigurationId = self.snapshotCopyConfigurationId {
            try encodeContainer.encode(snapshotCopyConfigurationId, forKey: .snapshotCopyConfigurationId)
        }
        if let snapshotRetentionPeriod = self.snapshotRetentionPeriod {
            try encodeContainer.encode(snapshotRetentionPeriod, forKey: .snapshotRetentionPeriod)
        }
    }
}

extension UpdateSnapshotCopyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSnapshotCopyConfigurationInput: Swift.Equatable {
    /// The ID of the snapshot copy configuration to update.
    /// This member is required.
    public var snapshotCopyConfigurationId: Swift.String?
    /// The new retention period of how long to keep a snapshot in the destination Amazon Web Services Region.
    public var snapshotRetentionPeriod: Swift.Int?

    public init(
        snapshotCopyConfigurationId: Swift.String? = nil,
        snapshotRetentionPeriod: Swift.Int? = nil
    )
    {
        self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
        self.snapshotRetentionPeriod = snapshotRetentionPeriod
    }
}

struct UpdateSnapshotCopyConfigurationInputBody: Swift.Equatable {
    let snapshotCopyConfigurationId: Swift.String?
    let snapshotRetentionPeriod: Swift.Int?
}

extension UpdateSnapshotCopyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfigurationId
        case snapshotRetentionPeriod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyConfigurationId)
        snapshotCopyConfigurationId = snapshotCopyConfigurationIdDecoded
        let snapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionPeriod)
        snapshotRetentionPeriod = snapshotRetentionPeriodDecoded
    }
}

extension UpdateSnapshotCopyConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSnapshotCopyConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotCopyConfiguration = output.snapshotCopyConfiguration
        } else {
            self.snapshotCopyConfiguration = nil
        }
    }
}

public struct UpdateSnapshotCopyConfigurationOutput: Swift.Equatable {
    /// The updated snapshot copy configuration object.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

struct UpdateSnapshotCopyConfigurationOutputBody: Swift.Equatable {
    let snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?
}

extension UpdateSnapshotCopyConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotCopyConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotCopyConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.SnapshotCopyConfiguration.self, forKey: .snapshotCopyConfiguration)
        snapshotCopyConfiguration = snapshotCopyConfigurationDecoded
    }
}

enum UpdateSnapshotCopyConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriod
        case snapshotName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension UpdateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSnapshotInput: Swift.Equatable {
    /// The new retention period of the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
    }
}

struct UpdateSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
    let retentionPeriod: Swift.Int?
}

extension UpdateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriod
        case snapshotName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension UpdateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct UpdateSnapshotOutput: Swift.Equatable {
    /// The updated snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct UpdateSnapshotOutputBody: Swift.Equatable {
    let snapshot: RedshiftServerlessClientTypes.Snapshot?
}

extension UpdateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum UpdateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUsageLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case usageLimitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
    }
}

extension UpdateUsageLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUsageLimitInput: Swift.Equatable {
    /// The new limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    public var amount: Swift.Int?
    /// The new action that Amazon Redshift Serverless takes when the limit is reached.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The identifier of the usage limit to update.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.usageLimitId = usageLimitId
    }
}

struct UpdateUsageLimitInputBody: Swift.Equatable {
    let usageLimitId: Swift.String?
    let amount: Swift.Int?
    let breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
}

extension UpdateUsageLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case usageLimitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension UpdateUsageLimitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUsageLimitOutputBody = try responseDecoder.decode(responseBody: data)
            self.usageLimit = output.usageLimit
        } else {
            self.usageLimit = nil
        }
    }
}

public struct UpdateUsageLimitOutput: Swift.Equatable {
    /// The updated usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

struct UpdateUsageLimitOutputBody: Swift.Equatable {
    let usageLimit: RedshiftServerlessClientTypes.UsageLimit?
}

extension UpdateUsageLimitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageLimit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimit.self, forKey: .usageLimit)
        usageLimit = usageLimitDecoded
    }
}

enum UpdateUsageLimitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkgroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case maxCapacity
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension UpdateWorkgroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkgroupInput: Swift.Equatable {
    /// The new base data warehouse capacity in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
    public var enhancedVpcRouting: Swift.Bool?
    /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
    public var maxCapacity: Swift.Int?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessible from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// The name of the workgroup to update. You can't update the name of a workgroup once it is created.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        maxCapacity: Swift.Int? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maxCapacity = maxCapacity
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.workgroupName = workgroupName
    }
}

struct UpdateWorkgroupInputBody: Swift.Equatable {
    let workgroupName: Swift.String?
    let baseCapacity: Swift.Int?
    let enhancedVpcRouting: Swift.Bool?
    let configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    let publiclyAccessible: Swift.Bool?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let port: Swift.Int?
    let maxCapacity: Swift.Int?
}

extension UpdateWorkgroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case enhancedVpcRouting
        case maxCapacity
        case port
        case publiclyAccessible
        case securityGroupIds
        case subnetIds
        case workgroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
    }
}

extension UpdateWorkgroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkgroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workgroup = output.workgroup
        } else {
            self.workgroup = nil
        }
    }
}

public struct UpdateWorkgroupOutput: Swift.Equatable {
    /// The updated workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

struct UpdateWorkgroupOutputBody: Swift.Equatable {
    let workgroup: RedshiftServerlessClientTypes.Workgroup?
}

extension UpdateWorkgroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Workgroup.self, forKey: .workgroup)
        workgroup = workgroupDecoded
    }
}

enum UpdateWorkgroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientCapacityException": return try await InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftServerlessClientTypes.UsageLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case breachAction
        case period
        case resourceArn
        case usageLimitArn
        case usageLimitId
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let breachAction = self.breachAction {
            try encodeContainer.encode(breachAction.rawValue, forKey: .breachAction)
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let usageLimitArn = self.usageLimitArn {
            try encodeContainer.encode(usageLimitArn, forKey: .usageLimitArn)
        }
        if let usageLimitId = self.usageLimitId {
            try encodeContainer.encode(usageLimitId, forKey: .usageLimitId)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageLimitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitId)
        usageLimitId = usageLimitIdDecoded
        let usageLimitArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageLimitArn)
        usageLimitArn = usageLimitArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitUsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let periodDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitPeriod.self, forKey: .period)
        period = periodDecoded
        let breachActionDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.UsageLimitBreachAction.self, forKey: .breachAction)
        breachAction = breachActionDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// The usage limit object.
    public struct UsageLimit: Swift.Equatable {
        /// The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.
        public var amount: Swift.Int?
        /// The action that Amazon Redshift Serverless takes when the limit is reached.
        public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
        /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
        public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
        /// The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.
        public var resourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource associated with the usage limit.
        public var usageLimitArn: Swift.String?
        /// The identifier of the usage limit.
        public var usageLimitId: Swift.String?
        /// The Amazon Redshift Serverless feature to limit.
        public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

        public init(
            amount: Swift.Int? = nil,
            breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
            period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
            resourceArn: Swift.String? = nil,
            usageLimitArn: Swift.String? = nil,
            usageLimitId: Swift.String? = nil,
            usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
        )
        {
            self.amount = amount
            self.breachAction = breachAction
            self.period = period
            self.resourceArn = resourceArn
            self.usageLimitArn = usageLimitArn
            self.usageLimitId = usageLimitId
            self.usageType = usageType
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitBreachAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deactivate
        case emitMetric
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitBreachAction] {
            return [
                .deactivate,
                .emitMetric,
                .log,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "deactivate"
            case .emitMetric: return "emit-metric"
            case .log: return "log"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitBreachAction(rawValue: rawValue) ?? UsageLimitBreachAction.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitPeriod] {
            return [
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "daily"
            case .monthly: return "monthly"
            case .weekly: return "weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitPeriod(rawValue: rawValue) ?? UsageLimitPeriod.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftServerlessClientTypes {
    public enum UsageLimitUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossRegionDatasharing
        case serverlessCompute
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitUsageType] {
            return [
                .crossRegionDatasharing,
                .serverlessCompute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossRegionDatasharing: return "cross-region-datasharing"
            case .serverlessCompute: return "serverless-compute"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageLimitUsageType(rawValue: rawValue) ?? UsageLimitUsageType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input failed to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RedshiftServerlessClientTypes.VpcEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaces
        case vpcEndpointId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[RedshiftServerlessClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [RedshiftServerlessClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.
    public struct VpcEndpoint: Swift.Equatable {
        /// One or more network interfaces of the endpoint. Also known as an interface endpoint.
        public var networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]?
        /// The connection endpoint ID for connecting to Amazon Redshift Serverless.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier that the endpoint is associated with.
        public var vpcId: Swift.String?

        public init(
            networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkInterfaces = networkInterfaces
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension RedshiftServerlessClientTypes.VpcSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case vpcSecurityGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RedshiftServerlessClientTypes {
    /// Describes the members of a VPC security group.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The unique identifier of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension RedshiftServerlessClientTypes.Workgroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCapacity
        case configParameters
        case creationDate
        case crossAccountVpcs
        case customDomainCertificateArn
        case customDomainCertificateExpiryTime
        case customDomainName
        case endpoint
        case enhancedVpcRouting
        case maxCapacity
        case namespaceName
        case patchVersion
        case port
        case publiclyAccessible
        case securityGroupIds
        case status
        case subnetIds
        case workgroupArn
        case workgroupId
        case workgroupName
        case workgroupVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseCapacity = self.baseCapacity {
            try encodeContainer.encode(baseCapacity, forKey: .baseCapacity)
        }
        if let configParameters = configParameters {
            var configParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configParameters)
            for configparameter0 in configParameters {
                try configParametersContainer.encode(configparameter0)
            }
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .dateTime, forKey: .creationDate)
        }
        if let crossAccountVpcs = crossAccountVpcs {
            var crossAccountVpcsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossAccountVpcs)
            for string0 in crossAccountVpcs {
                try crossAccountVpcsContainer.encode(string0)
            }
        }
        if let customDomainCertificateArn = self.customDomainCertificateArn {
            try encodeContainer.encode(customDomainCertificateArn, forKey: .customDomainCertificateArn)
        }
        if let customDomainCertificateExpiryTime = self.customDomainCertificateExpiryTime {
            try encodeContainer.encodeTimestamp(customDomainCertificateExpiryTime, format: .dateTime, forKey: .customDomainCertificateExpiryTime)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let enhancedVpcRouting = self.enhancedVpcRouting {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let workgroupArn = self.workgroupArn {
            try encodeContainer.encode(workgroupArn, forKey: .workgroupArn)
        }
        if let workgroupId = self.workgroupId {
            try encodeContainer.encode(workgroupId, forKey: .workgroupId)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
        if let workgroupVersion = self.workgroupVersion {
            try encodeContainer.encode(workgroupVersion, forKey: .workgroupVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupId)
        workgroupId = workgroupIdDecoded
        let workgroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupArn)
        workgroupArn = workgroupArnDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let baseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseCapacity)
        baseCapacity = baseCapacityDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let configParametersContainer = try containerValues.decodeIfPresent([RedshiftServerlessClientTypes.ConfigParameter?].self, forKey: .configParameters)
        var configParametersDecoded0:[RedshiftServerlessClientTypes.ConfigParameter]? = nil
        if let configParametersContainer = configParametersContainer {
            configParametersDecoded0 = [RedshiftServerlessClientTypes.ConfigParameter]()
            for structure0 in configParametersContainer {
                if let structure0 = structure0 {
                    configParametersDecoded0?.append(structure0)
                }
            }
        }
        configParameters = configParametersDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.WorkgroupStatus.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftServerlessClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let customDomainCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainCertificateArn)
        customDomainCertificateArn = customDomainCertificateArnDecoded
        let customDomainCertificateExpiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .customDomainCertificateExpiryTime)
        customDomainCertificateExpiryTime = customDomainCertificateExpiryTimeDecoded
        let workgroupVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupVersion)
        workgroupVersion = workgroupVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let crossAccountVpcsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .crossAccountVpcs)
        var crossAccountVpcsDecoded0:[Swift.String]? = nil
        if let crossAccountVpcsContainer = crossAccountVpcsContainer {
            crossAccountVpcsDecoded0 = [Swift.String]()
            for string0 in crossAccountVpcsContainer {
                if let string0 = string0 {
                    crossAccountVpcsDecoded0?.append(string0)
                }
            }
        }
        crossAccountVpcs = crossAccountVpcsDecoded0
    }
}

extension RedshiftServerlessClientTypes {
    /// The collection of computing resources from which an endpoint is created.
    public struct Workgroup: Swift.Equatable {
        /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
        public var baseCapacity: Swift.Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
        /// The creation date of the workgroup.
        public var creationDate: ClientRuntime.Date?
        /// A list of VPCs. Each entry is the unique identifier of a virtual private cloud with access to Amazon Redshift Serverless. If all of the VPCs for the grantee are allowed, it shows an asterisk.
        public var crossAccountVpcs: [Swift.String]?
        /// The custom domain nameâ€™s certificate Amazon resource name (ARN).
        public var customDomainCertificateArn: Swift.String?
        /// The expiration time for the certificate.
        public var customDomainCertificateExpiryTime: ClientRuntime.Date?
        /// The custom domain name associated with the workgroup.
        public var customDomainName: Swift.String?
        /// The endpoint that is created from the workgroup.
        public var endpoint: RedshiftServerlessClientTypes.Endpoint?
        /// The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
        public var enhancedVpcRouting: Swift.Bool?
        /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
        public var maxCapacity: Swift.Int?
        /// The namespace the workgroup is associated with.
        public var namespaceName: Swift.String?
        /// The patch version of your Amazon Redshift Serverless workgroup. For more information about patch versions, see [Cluster versions for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/cluster-versions.html).
        public var patchVersion: Swift.String?
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public var port: Swift.Int?
        /// A value that specifies whether the workgroup can be accessible from a public network
        public var publiclyAccessible: Swift.Bool?
        /// An array of security group IDs to associate with the workgroup.
        public var securityGroupIds: [Swift.String]?
        /// The status of the workgroup.
        public var status: RedshiftServerlessClientTypes.WorkgroupStatus?
        /// An array of subnet IDs the workgroup is associated with.
        public var subnetIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) that links to the workgroup.
        public var workgroupArn: Swift.String?
        /// The unique identifier of the workgroup.
        public var workgroupId: Swift.String?
        /// The name of the workgroup.
        public var workgroupName: Swift.String?
        /// The Amazon Redshift Serverless version of your workgroup. For more information about Amazon Redshift Serverless versions, see[Cluster versions for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/cluster-versions.html).
        public var workgroupVersion: Swift.String?

        public init(
            baseCapacity: Swift.Int? = nil,
            configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
            creationDate: ClientRuntime.Date? = nil,
            crossAccountVpcs: [Swift.String]? = nil,
            customDomainCertificateArn: Swift.String? = nil,
            customDomainCertificateExpiryTime: ClientRuntime.Date? = nil,
            customDomainName: Swift.String? = nil,
            endpoint: RedshiftServerlessClientTypes.Endpoint? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            namespaceName: Swift.String? = nil,
            patchVersion: Swift.String? = nil,
            port: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: RedshiftServerlessClientTypes.WorkgroupStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            workgroupArn: Swift.String? = nil,
            workgroupId: Swift.String? = nil,
            workgroupName: Swift.String? = nil,
            workgroupVersion: Swift.String? = nil
        )
        {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.creationDate = creationDate
            self.crossAccountVpcs = crossAccountVpcs
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maxCapacity = maxCapacity
            self.namespaceName = namespaceName
            self.patchVersion = patchVersion
            self.port = port
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.workgroupArn = workgroupArn
            self.workgroupId = workgroupId
            self.workgroupName = workgroupName
            self.workgroupVersion = workgroupVersion
        }
    }

}

extension RedshiftServerlessClientTypes {
    public enum WorkgroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkgroupStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkgroupStatus(rawValue: rawValue) ?? WorkgroupStatus.sdkUnknown(rawValue)
        }
    }
}
