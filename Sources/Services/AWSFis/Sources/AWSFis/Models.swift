//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension FisClientTypes {

    public enum AccountTargeting: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiAccount
        case singleAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountTargeting] {
            return [
                .multiAccount,
                .singleAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiAccount: return "multi-account"
            case .singleAccount: return "single-account"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Describes a parameter for an action.
    public struct ActionParameter: Swift.Sendable {
        /// The parameter description.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = false
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }
}

extension FisClientTypes {

    /// Describes a target for an action.
    public struct ActionTarget: Swift.Sendable {
        /// The resource type of the target.
        public var resourceType: Swift.String?

        public init(
            resourceType: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
        }
    }
}

extension FisClientTypes {

    /// Describes an action. For more information, see [FIS actions](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html) in the Fault Injection Service User Guide.
    public struct Action: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the action.
        public var arn: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The action parameters, if applicable.
        public var parameters: [Swift.String: FisClientTypes.ActionParameter]?
        /// The tags for the action.
        public var tags: [Swift.String: Swift.String]?
        /// The supported targets for the action.
        public var targets: [Swift.String: FisClientTypes.ActionTarget]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String: FisClientTypes.ActionParameter]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targets: [Swift.String: FisClientTypes.ActionTarget]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    public enum ActionsMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case runAll
        case skipAll
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionsMode] {
            return [
                .runAll,
                .skipAll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .runAll: return "run-all"
            case .skipAll: return "skip-all"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Provides a summary of an action.
    public struct ActionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the action.
        public var arn: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The tags for the action.
        public var tags: [Swift.String: Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String: FisClientTypes.ActionTarget]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targets: [Swift.String: FisClientTypes.ActionTarget]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }
    }
}

/// The request could not be processed because of a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified input is not valid, or fails to satisfy the constraints for the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FisClientTypes {

    /// Specifies an action for an experiment template. For more information, see [Actions](https://docs.aws.amazon.com/fis/latest/userguide/actions.html) in the Fault Injection Service User Guide.
    public struct CreateExperimentTemplateActionInput: Swift.Sendable {
        /// The ID of the action. The format of the action ID is: aws:service-name:action-type.
        /// This member is required.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String: Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String: Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String: Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    public enum EmptyTargetResolutionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [EmptyTargetResolutionMode] {
            return [
                .fail,
                .skip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "fail"
            case .skip: return "skip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Specifies experiment options for an experiment template.
    public struct CreateExperimentTemplateExperimentOptionsInput: Swift.Sendable {
        /// Specifies the account targeting setting for experiment options.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// Specifies the empty target resolution mode for experiment options.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }
}

extension FisClientTypes {

    /// Specifies the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfigurationInput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }
}

extension FisClientTypes {

    /// Specifies the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfigurationInput: Swift.Sendable {
        /// The name of the destination bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }
}

extension FisClientTypes {

    /// Specifies the configuration for experiment logging.
    public struct CreateExperimentTemplateLogConfigurationInput: Swift.Sendable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        /// This member is required.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }
}

extension FisClientTypes {

    /// Specifies a stop condition for an experiment template.
    public struct CreateExperimentTemplateStopConditionInput: Swift.Sendable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is a CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }
}

extension FisClientTypes {

    /// Specifies a filter used for the target resource input in an experiment template. For more information, see [Resource filters](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters) in the Fault Injection Service User Guide.
    public struct ExperimentTemplateTargetInputFilter: Swift.Sendable {
        /// The attribute path for the filter.
        /// This member is required.
        public var path: Swift.String?
        /// The attribute values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }
}

extension FisClientTypes {

    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both ARNs and tags. For more information, see [Targets](https://docs.aws.amazon.com/fis/latest/userguide/targets.html) in the Fault Injection Service User Guide.
    public struct CreateExperimentTemplateTargetInput: Swift.Sendable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.
        ///
        /// * ALL - Run the action on all identified targets. This is the default.
        ///
        /// * COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random. For example, COUNT(1) selects one of the targets.
        ///
        /// * PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets at random. For example, PERCENT(25) selects 25% of the targets.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }
}

public struct CreateExperimentTemplateInput: Swift.Sendable {
    /// The actions for the experiment.
    /// This member is required.
    public var actions: [Swift.String: FisClientTypes.CreateExperimentTemplateActionInput]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A description for the experiment template.
    /// This member is required.
    public var description: Swift.String?
    /// The experiment options for the experiment template.
    public var experimentOptions: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stop conditions.
    /// This member is required.
    public var stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    /// The tags to apply to the experiment template.
    public var tags: [Swift.String: Swift.String]?
    /// The targets for the experiment.
    public var targets: [Swift.String: FisClientTypes.CreateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String: FisClientTypes.CreateExperimentTemplateActionInput]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentOptions: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput? = nil,
        logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: [Swift.String: FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.experimentOptions = experimentOptions
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

extension FisClientTypes {

    /// Describes an action for an experiment template.
    public struct ExperimentTemplateAction: Swift.Sendable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String: Swift.String]?
        /// The name of the action that must be completed before the current action starts.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String: Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String: Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    /// Describes the experiment options for an experiment template.
    public struct ExperimentTemplateExperimentOptions: Swift.Sendable {
        /// The account targeting setting for an experiment template.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// The empty target resolution mode for an experiment template.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfiguration: Swift.Sendable {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging.
    public struct ExperimentTemplateLogConfiguration: Swift.Sendable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }
}

extension FisClientTypes {

    /// Describes a stop condition for an experiment template.
    public struct ExperimentTemplateStopCondition: Swift.Sendable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }
}

extension FisClientTypes {

    /// Describes a filter used for the target resources in an experiment template.
    public struct ExperimentTemplateTargetFilter: Swift.Sendable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }
}

extension FisClientTypes {

    /// Describes a target for an experiment template.
    public struct ExperimentTemplateTarget: Swift.Sendable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetFilter]? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }
}

extension FisClientTypes {

    /// Describes an experiment template.
    public struct ExperimentTemplate: Swift.Sendable {
        /// The actions for the experiment.
        public var actions: [Swift.String: FisClientTypes.ExperimentTemplateAction]?
        /// The Amazon Resource Name (ARN) of the experiment template.
        public var arn: Swift.String?
        /// The time the experiment template was created.
        public var creationTime: Foundation.Date?
        /// The description for the experiment template.
        public var description: Swift.String?
        /// The experiment options for an experiment template.
        public var experimentOptions: FisClientTypes.ExperimentTemplateExperimentOptions?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time the experiment template was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public var roleArn: Swift.String?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public var tags: [Swift.String: Swift.String]?
        /// The count of target account configurations for the experiment template.
        public var targetAccountConfigurationsCount: Swift.Int?
        /// The targets for the experiment.
        public var targets: [Swift.String: FisClientTypes.ExperimentTemplateTarget]?

        public init(
            actions: [Swift.String: FisClientTypes.ExperimentTemplateAction]? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            experimentOptions: FisClientTypes.ExperimentTemplateExperimentOptions? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targetAccountConfigurationsCount: Swift.Int? = nil,
            targets: [Swift.String: FisClientTypes.ExperimentTemplateTarget]? = nil
        )
        {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.experimentOptions = experimentOptions
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }
    }
}

public struct CreateExperimentTemplateOutput: Swift.Sendable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

public struct CreateTargetAccountConfigurationInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the target account.
    public var description: Swift.String?
    /// The experiment template ID.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role for the target account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.description = description
        self.experimentTemplateId = experimentTemplateId
        self.roleArn = roleArn
    }
}

extension FisClientTypes {

    /// Describes a target account configuration.
    public struct TargetAccountConfiguration: Swift.Sendable {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }
}

public struct CreateTargetAccountConfigurationOutput: Swift.Sendable {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

public struct DeleteExperimentTemplateInput: Swift.Sendable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteExperimentTemplateOutput: Swift.Sendable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

public struct DeleteTargetAccountConfigurationInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentTemplateId = experimentTemplateId
    }
}

public struct DeleteTargetAccountConfigurationOutput: Swift.Sendable {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

extension FisClientTypes {

    public enum ExperimentActionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case skipped
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentActionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .skipped,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .skipped: return "skipped"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Describes the state of an action.
    public struct ExperimentActionState: Swift.Sendable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the action.
        public var status: FisClientTypes.ExperimentActionStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentActionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension FisClientTypes {

    /// Describes the action for an experiment.
    public struct ExperimentAction: Swift.Sendable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The time that the action ended.
        public var endTime: Foundation.Date?
        /// The parameters for the action.
        public var parameters: [Swift.String: Swift.String]?
        /// The name of the action that must be completed before this action starts.
        public var startAfter: [Swift.String]?
        /// The time that the action started.
        public var startTime: Foundation.Date?
        /// The state of the action.
        public var state: FisClientTypes.ExperimentActionState?
        /// The targets for the action.
        public var targets: [Swift.String: Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            state: FisClientTypes.ExperimentActionState? = nil,
            targets: [Swift.String: Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.endTime = endTime
            self.parameters = parameters
            self.startAfter = startAfter
            self.startTime = startTime
            self.state = state
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    /// Describes the options for an experiment.
    public struct ExperimentOptions: Swift.Sendable {
        /// The account targeting setting for an experiment.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// The actions mode of the experiment that is set from the StartExperiment API command.
        public var actionsMode: FisClientTypes.ActionsMode?
        /// The empty target resolution mode for an experiment.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            actionsMode: FisClientTypes.ActionsMode? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.actionsMode = actionsMode
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentCloudWatchLogsLogConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentS3LogConfiguration: Swift.Sendable {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }
}

extension FisClientTypes {

    /// Describes the configuration for experiment logging.
    public struct ExperimentLogConfiguration: Swift.Sendable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }
}

extension FisClientTypes {

    /// Describes the error when an experiment has failed.
    public struct ExperimentError: Swift.Sendable {
        /// The Amazon Web Services Account ID where the experiment failure occurred.
        public var accountId: Swift.String?
        /// The error code for the failed experiment.
        public var code: Swift.String?
        /// Context for the section of the experiment template that failed.
        public var location: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            code: Swift.String? = nil,
            location: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.code = code
            self.location = location
        }
    }
}

extension FisClientTypes {

    public enum ExperimentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Describes the state of an experiment.
    public struct ExperimentState: Swift.Sendable {
        /// The error information of the experiment when the action has failed.
        public var error: FisClientTypes.ExperimentError?
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the experiment.
        public var status: FisClientTypes.ExperimentStatus?

        public init(
            error: FisClientTypes.ExperimentError? = nil,
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentStatus? = nil
        )
        {
            self.error = error
            self.reason = reason
            self.status = status
        }
    }
}

extension FisClientTypes {

    /// Describes the stop condition for an experiment.
    public struct ExperimentStopCondition: Swift.Sendable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }
}

extension FisClientTypes {

    /// Describes a filter used for the target resources in an experiment.
    public struct ExperimentTargetFilter: Swift.Sendable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }
}

extension FisClientTypes {

    /// Describes a target for an experiment.
    public struct ExperimentTarget: Swift.Sendable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTargetFilter]? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }
}

extension FisClientTypes {

    /// Describes an experiment.
    public struct Experiment: Swift.Sendable {
        /// The actions for the experiment.
        public var actions: [Swift.String: FisClientTypes.ExperimentAction]?
        /// The Amazon Resource Name (ARN) of the experiment.
        public var arn: Swift.String?
        /// The time that the experiment was created.
        public var creationTime: Foundation.Date?
        /// The time that the experiment ended.
        public var endTime: Foundation.Date?
        /// The experiment options for the experiment.
        public var experimentOptions: FisClientTypes.ExperimentOptions?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public var roleArn: Swift.String?
        /// The time that the experiment started.
        public var startTime: Foundation.Date?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentStopCondition]?
        /// The tags for the experiment.
        public var tags: [Swift.String: Swift.String]?
        /// The count of target account configurations for the experiment.
        public var targetAccountConfigurationsCount: Swift.Int?
        /// The targets for the experiment.
        public var targets: [Swift.String: FisClientTypes.ExperimentTarget]?

        public init(
            actions: [Swift.String: FisClientTypes.ExperimentAction]? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            experimentOptions: FisClientTypes.ExperimentOptions? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            logConfiguration: FisClientTypes.ExperimentLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            stopConditions: [FisClientTypes.ExperimentStopCondition]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targetAccountConfigurationsCount: Swift.Int? = nil,
            targets: [Swift.String: FisClientTypes.ExperimentTarget]? = nil
        )
        {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    /// Provides a summary of an experiment.
    public struct ExperimentSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the experiment.
        public var arn: Swift.String?
        /// The time that the experiment was created.
        public var creationTime: Foundation.Date?
        /// The experiment options for the experiment.
        public var experimentOptions: FisClientTypes.ExperimentOptions?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The tags for the experiment.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            experimentOptions: FisClientTypes.ExperimentOptions? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }
    }
}

extension FisClientTypes {

    /// Describes a target account configuration for an experiment.
    public struct ExperimentTargetAccountConfiguration: Swift.Sendable {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }
}

extension FisClientTypes {

    /// Provides a summary of a target account configuration.
    public struct ExperimentTargetAccountConfigurationSummary: Swift.Sendable {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }
}

extension FisClientTypes {

    /// Provides a summary of an experiment template.
    public struct ExperimentTemplateSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the experiment template.
        public var arn: Swift.String?
        /// The time that the experiment template was created.
        public var creationTime: Foundation.Date?
        /// The description of the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time that the experiment template was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The tags for the experiment template.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }
    }
}

public struct GetActionInput: Swift.Sendable {
    /// The ID of the action.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetActionOutput: Swift.Sendable {
    /// Information about the action.
    public var action: FisClientTypes.Action?

    public init(
        action: FisClientTypes.Action? = nil
    )
    {
        self.action = action
    }
}

public struct GetExperimentInput: Swift.Sendable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetExperimentOutput: Swift.Sendable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

public struct GetExperimentTargetAccountConfigurationInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentId = experimentId
    }
}

public struct GetExperimentTargetAccountConfigurationOutput: Swift.Sendable {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.ExperimentTargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.ExperimentTargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

public struct GetExperimentTemplateInput: Swift.Sendable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetExperimentTemplateOutput: Swift.Sendable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

public struct GetSafetyLeverInput: Swift.Sendable {
    /// The ID of the safety lever.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension FisClientTypes {

    public enum SafetyLeverStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disengaged
        case engaged
        case engaging
        case sdkUnknown(Swift.String)

        public static var allCases: [SafetyLeverStatus] {
            return [
                .disengaged,
                .engaged,
                .engaging
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disengaged: return "disengaged"
            case .engaged: return "engaged"
            case .engaging: return "engaging"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Describes the state of the safety lever.
    public struct SafetyLeverState: Swift.Sendable {
        /// The reason for the state of the safety lever.
        public var reason: Swift.String?
        /// The state of the safety lever.
        public var status: FisClientTypes.SafetyLeverStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.SafetyLeverStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension FisClientTypes {

    /// Describes a safety lever.
    public struct SafetyLever: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the safety lever.
        public var arn: Swift.String?
        /// The ID of the safety lever.
        public var id: Swift.String?
        /// The state of the safety lever.
        public var state: FisClientTypes.SafetyLeverState?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.SafetyLeverState? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.state = state
        }
    }
}

public struct GetSafetyLeverOutput: Swift.Sendable {
    /// Information about the safety lever.
    public var safetyLever: FisClientTypes.SafetyLever?

    public init(
        safetyLever: FisClientTypes.SafetyLever? = nil
    )
    {
        self.safetyLever = safetyLever
    }
}

public struct GetTargetAccountConfigurationInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentTemplateId = experimentTemplateId
    }
}

public struct GetTargetAccountConfigurationOutput: Swift.Sendable {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

public struct GetTargetResourceTypeInput: Swift.Sendable {
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceType: Swift.String? = nil
    )
    {
        self.resourceType = resourceType
    }
}

extension FisClientTypes {

    /// Describes the parameters for a resource type. Use parameters to determine which tasks are identified during target resolution.
    public struct TargetResourceTypeParameter: Swift.Sendable {
        /// A description of the parameter.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = false
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }
}

extension FisClientTypes {

    /// Describes a resource type.
    public struct TargetResourceType: Swift.Sendable {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The parameters for the resource type.
        public var parameters: [Swift.String: FisClientTypes.TargetResourceTypeParameter]?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            parameters: [Swift.String: FisClientTypes.TargetResourceTypeParameter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.parameters = parameters
            self.resourceType = resourceType
        }
    }
}

public struct GetTargetResourceTypeOutput: Swift.Sendable {
    /// Information about the resource type.
    public var targetResourceType: FisClientTypes.TargetResourceType?

    public init(
        targetResourceType: FisClientTypes.TargetResourceType? = nil
    )
    {
        self.targetResourceType = targetResourceType
    }
}

public struct ListActionsInput: Swift.Sendable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListActionsOutput: Swift.Sendable {
    /// The actions.
    public var actions: [FisClientTypes.ActionSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        actions: [FisClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

public struct ListExperimentResolvedTargetsInput: Swift.Sendable {
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The name of the target.
    public var targetName: Swift.String?

    public init(
        experimentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.experimentId = experimentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetName = targetName
    }
}

extension FisClientTypes {

    /// Describes a resolved target.
    public struct ResolvedTarget: Swift.Sendable {
        /// The resource type of the target.
        public var resourceType: Swift.String?
        /// Information about the target.
        public var targetInformation: [Swift.String: Swift.String]?
        /// The name of the target.
        public var targetName: Swift.String?

        public init(
            resourceType: Swift.String? = nil,
            targetInformation: [Swift.String: Swift.String]? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.targetInformation = targetInformation
            self.targetName = targetName
        }
    }
}

public struct ListExperimentResolvedTargetsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The resolved targets.
    public var resolvedTargets: [FisClientTypes.ResolvedTarget]?

    public init(
        nextToken: Swift.String? = nil,
        resolvedTargets: [FisClientTypes.ResolvedTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvedTargets = resolvedTargets
    }
}

public struct ListExperimentsInput: Swift.Sendable {
    /// The ID of the experiment template.
    public var experimentTemplateId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentTemplateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplateId = experimentTemplateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListExperimentsOutput: Swift.Sendable {
    /// The experiments.
    public var experiments: [FisClientTypes.ExperimentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experiments: [FisClientTypes.ExperimentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

public struct ListExperimentTargetAccountConfigurationsInput: Swift.Sendable {
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentId = experimentId
        self.nextToken = nextToken
    }
}

public struct ListExperimentTargetAccountConfigurationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target account configurations.
    public var targetAccountConfigurations: [FisClientTypes.ExperimentTargetAccountConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetAccountConfigurations: [FisClientTypes.ExperimentTargetAccountConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetAccountConfigurations = targetAccountConfigurations
    }
}

public struct ListExperimentTemplatesInput: Swift.Sendable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListExperimentTemplatesOutput: Swift.Sendable {
    /// The experiment templates.
    public var experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTargetAccountConfigurationsInput: Swift.Sendable {
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentTemplateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplateId = experimentTemplateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FisClientTypes {

    /// Provides a summary of a target account configuration.
    public struct TargetAccountConfigurationSummary: Swift.Sendable {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }
}

public struct ListTargetAccountConfigurationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target account configurations.
    public var targetAccountConfigurations: [FisClientTypes.TargetAccountConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetAccountConfigurations: [FisClientTypes.TargetAccountConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetAccountConfigurations = targetAccountConfigurations
    }
}

public struct ListTargetResourceTypesInput: Swift.Sendable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FisClientTypes {

    /// Describes a resource type.
    public struct TargetResourceTypeSummary: Swift.Sendable {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceType = resourceType
        }
    }
}

public struct ListTargetResourceTypesOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target resource types.
    public var targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetResourceTypes = targetResourceTypes
    }
}

extension FisClientTypes {

    /// Specifies experiment options for running an experiment.
    public struct StartExperimentExperimentOptionsInput: Swift.Sendable {
        /// Specifies the actions mode for experiment options.
        public var actionsMode: FisClientTypes.ActionsMode?

        public init(
            actionsMode: FisClientTypes.ActionsMode? = nil
        )
        {
            self.actionsMode = actionsMode
        }
    }
}

public struct StartExperimentInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The experiment options for running the experiment.
    public var experimentOptions: FisClientTypes.StartExperimentExperimentOptionsInput?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The tags to apply to the experiment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        experimentOptions: FisClientTypes.StartExperimentExperimentOptionsInput? = nil,
        experimentTemplateId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentOptions = experimentOptions
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

public struct StartExperimentOutput: Swift.Sendable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

public struct StopExperimentInput: Swift.Sendable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct StopExperimentOutput: Swift.Sendable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension FisClientTypes {

    /// Specifies an action for an experiment template.
    public struct UpdateExperimentTemplateActionInputItem: Swift.Sendable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String: Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String: Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String: Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }
}

extension FisClientTypes {

    /// Specifies an experiment option for an experiment template.
    public struct UpdateExperimentTemplateExperimentOptionsInput: Swift.Sendable {
        /// The empty target resolution mode of the experiment template.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }
}

extension FisClientTypes {

    /// Specifies the configuration for experiment logging.
    public struct UpdateExperimentTemplateLogConfigurationInput: Swift.Sendable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }
}

extension FisClientTypes {

    /// Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.
    public struct UpdateExperimentTemplateStopConditionInput: Swift.Sendable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }
}

extension FisClientTypes {

    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.
    public struct UpdateExperimentTemplateTargetInput: Swift.Sendable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }
}

public struct UpdateExperimentTemplateInput: Swift.Sendable {
    /// The actions for the experiment.
    public var actions: [Swift.String: FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    /// A description for the template.
    public var description: Swift.String?
    /// The experiment options for the experiment template.
    public var experimentOptions: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput?
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    public var roleArn: Swift.String?
    /// The stop conditions for the experiment.
    public var stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    /// The targets for the experiment.
    public var targets: [Swift.String: FisClientTypes.UpdateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String: FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil,
        description: Swift.String? = nil,
        experimentOptions: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput? = nil,
        id: Swift.String? = nil,
        logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [Swift.String: FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.experimentOptions = experimentOptions
        self.id = id
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

public struct UpdateExperimentTemplateOutput: Swift.Sendable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

extension FisClientTypes {

    public enum SafetyLeverStatusInput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disengaged
        case engaged
        case sdkUnknown(Swift.String)

        public static var allCases: [SafetyLeverStatusInput] {
            return [
                .disengaged,
                .engaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disengaged: return "disengaged"
            case .engaged: return "engaged"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes {

    /// Specifies a state for a safety lever.
    public struct UpdateSafetyLeverStateInput: Swift.Sendable {
        /// The reason for updating the state of the safety lever.
        /// This member is required.
        public var reason: Swift.String?
        /// The updated state of the safety lever.
        /// This member is required.
        public var status: FisClientTypes.SafetyLeverStatusInput?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.SafetyLeverStatusInput? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

public struct UpdateSafetyLeverStateInput: Swift.Sendable {
    /// The ID of the safety lever.
    /// This member is required.
    public var id: Swift.String?
    /// The state of the safety lever.
    /// This member is required.
    public var state: FisClientTypes.UpdateSafetyLeverStateInput?

    public init(
        id: Swift.String? = nil,
        state: FisClientTypes.UpdateSafetyLeverStateInput? = nil
    )
    {
        self.id = id
        self.state = state
    }
}

public struct UpdateSafetyLeverStateOutput: Swift.Sendable {
    /// Information about the safety lever.
    public var safetyLever: FisClientTypes.SafetyLever?

    public init(
        safetyLever: FisClientTypes.SafetyLever? = nil
    )
    {
        self.safetyLever = safetyLever
    }
}

public struct UpdateTargetAccountConfigurationInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The description of the target account.
    public var description: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role for the target account.
    public var roleArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.description = description
        self.experimentTemplateId = experimentTemplateId
        self.roleArn = roleArn
    }
}

public struct UpdateTargetAccountConfigurationOutput: Swift.Sendable {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

extension CreateExperimentTemplateInput {

    static func urlPathProvider(_ value: CreateExperimentTemplateInput) -> Swift.String? {
        return "/experimentTemplates"
    }
}

extension CreateTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: CreateTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension DeleteExperimentTemplateInput {

    static func urlPathProvider(_ value: DeleteExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

extension DeleteTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: DeleteTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension GetActionInput {

    static func urlPathProvider(_ value: GetActionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/actions/\(id.urlPercentEncoding())"
    }
}

extension GetExperimentInput {

    static func urlPathProvider(_ value: GetExperimentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

extension GetExperimentTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: GetExperimentTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension GetExperimentTemplateInput {

    static func urlPathProvider(_ value: GetExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

extension GetSafetyLeverInput {

    static func urlPathProvider(_ value: GetSafetyLeverInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/safetyLevers/\(id.urlPercentEncoding())"
    }
}

extension GetTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: GetTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension GetTargetResourceTypeInput {

    static func urlPathProvider(_ value: GetTargetResourceTypeInput) -> Swift.String? {
        guard let resourceType = value.resourceType else {
            return nil
        }
        return "/targetResourceTypes/\(resourceType.urlPercentEncoding())"
    }
}

extension ListActionsInput {

    static func urlPathProvider(_ value: ListActionsInput) -> Swift.String? {
        return "/actions"
    }
}

extension ListActionsInput {

    static func queryItemProvider(_ value: ListActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentResolvedTargetsInput {

    static func urlPathProvider(_ value: ListExperimentResolvedTargetsInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/resolvedTargets"
    }
}

extension ListExperimentResolvedTargetsInput {

    static func queryItemProvider(_ value: ListExperimentResolvedTargetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let targetName = value.targetName {
            let targetNameQueryItem = Smithy.URIQueryItem(name: "targetName".urlPercentEncoding(), value: Swift.String(targetName).urlPercentEncoding())
            items.append(targetNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentsInput {

    static func urlPathProvider(_ value: ListExperimentsInput) -> Swift.String? {
        return "/experiments"
    }
}

extension ListExperimentsInput {

    static func queryItemProvider(_ value: ListExperimentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let experimentTemplateId = value.experimentTemplateId {
            let experimentTemplateIdQueryItem = Smithy.URIQueryItem(name: "experimentTemplateId".urlPercentEncoding(), value: Swift.String(experimentTemplateId).urlPercentEncoding())
            items.append(experimentTemplateIdQueryItem)
        }
        return items
    }
}

extension ListExperimentTargetAccountConfigurationsInput {

    static func urlPathProvider(_ value: ListExperimentTargetAccountConfigurationsInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/targetAccountConfigurations"
    }
}

extension ListExperimentTargetAccountConfigurationsInput {

    static func queryItemProvider(_ value: ListExperimentTargetAccountConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentTemplatesInput {

    static func urlPathProvider(_ value: ListExperimentTemplatesInput) -> Swift.String? {
        return "/experimentTemplates"
    }
}

extension ListExperimentTemplatesInput {

    static func queryItemProvider(_ value: ListExperimentTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTargetAccountConfigurationsInput {

    static func urlPathProvider(_ value: ListTargetAccountConfigurationsInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations"
    }
}

extension ListTargetAccountConfigurationsInput {

    static func queryItemProvider(_ value: ListTargetAccountConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTargetResourceTypesInput {

    static func urlPathProvider(_ value: ListTargetResourceTypesInput) -> Swift.String? {
        return "/targetResourceTypes"
    }
}

extension ListTargetResourceTypesInput {

    static func queryItemProvider(_ value: ListTargetResourceTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension StartExperimentInput {

    static func urlPathProvider(_ value: StartExperimentInput) -> Swift.String? {
        return "/experiments"
    }
}

extension StopExperimentInput {

    static func urlPathProvider(_ value: StopExperimentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let tagKeys = value.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UpdateExperimentTemplateInput {

    static func urlPathProvider(_ value: UpdateExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

extension UpdateSafetyLeverStateInput {

    static func urlPathProvider(_ value: UpdateSafetyLeverStateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/safetyLevers/\(id.urlPercentEncoding())/state"
    }
}

extension UpdateTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: UpdateTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension CreateExperimentTemplateInput {

    static func write(value: CreateExperimentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.CreateExperimentTemplateActionInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput.write(value:to:))
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.CreateExperimentTemplateLogConfigurationInput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.CreateExperimentTemplateStopConditionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.CreateExperimentTemplateTargetInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTargetAccountConfigurationInput {

    static func write(value: CreateTargetAccountConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension StartExperimentInput {

    static func write(value: StartExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.StartExperimentExperimentOptionsInput.write(value:to:))
        try writer["experimentTemplateId"].write(value.experimentTemplateId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateExperimentTemplateInput {

    static func write(value: UpdateExperimentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.UpdateExperimentTemplateActionInputItem.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput.write(value:to:))
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.UpdateExperimentTemplateStopConditionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.UpdateExperimentTemplateTargetInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSafetyLeverStateInput {

    static func write(value: UpdateSafetyLeverStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state, with: FisClientTypes.UpdateSafetyLeverStateInput.write(value:to:))
    }
}

extension UpdateTargetAccountConfigurationInput {

    static func write(value: UpdateTargetAccountConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension CreateExperimentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

extension CreateTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

extension DeleteExperimentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

extension DeleteTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

extension GetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetActionOutput()
        value.action = try reader["action"].readIfPresent(with: FisClientTypes.Action.read(from:))
        return value
    }
}

extension GetExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

extension GetExperimentTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExperimentTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTargetAccountConfiguration.read(from:))
        return value
    }
}

extension GetExperimentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

extension GetSafetyLeverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSafetyLeverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSafetyLeverOutput()
        value.safetyLever = try reader["safetyLever"].readIfPresent(with: FisClientTypes.SafetyLever.read(from:))
        return value
    }
}

extension GetTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

extension GetTargetResourceTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTargetResourceTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetResourceTypeOutput()
        value.targetResourceType = try reader["targetResourceType"].readIfPresent(with: FisClientTypes.TargetResourceType.read(from:))
        return value
    }
}

extension ListActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActionsOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: FisClientTypes.ActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExperimentResolvedTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExperimentResolvedTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentResolvedTargetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resolvedTargets = try reader["resolvedTargets"].readListIfPresent(memberReadingClosure: FisClientTypes.ResolvedTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListExperimentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExperimentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentsOutput()
        value.experiments = try reader["experiments"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExperimentTargetAccountConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExperimentTargetAccountConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentTargetAccountConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetAccountConfigurations = try reader["targetAccountConfigurations"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTargetAccountConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListExperimentTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExperimentTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentTemplatesOutput()
        value.experimentTemplates = try reader["experimentTemplates"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTargetAccountConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetAccountConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetAccountConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetAccountConfigurations = try reader["targetAccountConfigurations"].readListIfPresent(memberReadingClosure: FisClientTypes.TargetAccountConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTargetResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetResourceTypesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetResourceTypes = try reader["targetResourceTypes"].readListIfPresent(memberReadingClosure: FisClientTypes.TargetResourceTypeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

extension StopExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateExperimentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

extension UpdateSafetyLeverStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSafetyLeverStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSafetyLeverStateOutput()
        value.safetyLever = try reader["safetyLever"].readIfPresent(with: FisClientTypes.SafetyLever.read(from:))
        return value
    }
}

extension UpdateTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

enum CreateExperimentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExperimentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExperimentTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExperimentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSafetyLeverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTargetResourceTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExperimentResolvedTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExperimentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExperimentTargetAccountConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExperimentTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetAccountConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateExperimentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSafetyLeverStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FisClientTypes.ExperimentTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplate()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTemplateTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.actions = try reader["actions"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTemplateAction.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stopConditions = try reader["stopConditions"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateStopCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logConfiguration = try reader["logConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateLogConfiguration.read(from:))
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentTemplateExperimentOptions.read(from:))
        value.targetAccountConfigurationsCount = try reader["targetAccountConfigurationsCount"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateExperimentOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateExperimentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateExperimentOptions()
        value.accountTargeting = try reader["accountTargeting"].readIfPresent()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateLogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateLogConfiguration()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentTemplateS3LogConfiguration.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateS3LogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateS3LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateS3LogConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateStopCondition {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateStopCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateStopCondition()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateAction()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ExperimentTemplateTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateTargetFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ExperimentTemplateTargetFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateTargetFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateTargetFilter()
        value.path = try reader["path"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes.TargetAccountConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetAccountConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetAccountConfiguration()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes.Action {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.Action()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ActionTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ActionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionParameter()
        value.description = try reader["description"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension FisClientTypes.Experiment {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.Experiment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.Experiment()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.experimentTemplateId = try reader["experimentTemplateId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentState.read(from:))
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.actions = try reader["actions"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentAction.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stopConditions = try reader["stopConditions"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentStopCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logConfiguration = try reader["logConfiguration"].readIfPresent(with: FisClientTypes.ExperimentLogConfiguration.read(from:))
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentOptions.read(from:))
        value.targetAccountConfigurationsCount = try reader["targetAccountConfigurationsCount"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentOptions()
        value.accountTargeting = try reader["accountTargeting"].readIfPresent()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        value.actionsMode = try reader["actionsMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentLogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentLogConfiguration()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentS3LogConfiguration.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentS3LogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentS3LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentS3LogConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentCloudWatchLogsLogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentCloudWatchLogsLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentCloudWatchLogsLogConfiguration()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentStopCondition {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentStopCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentStopCondition()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentAction()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentActionState.read(from:))
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension FisClientTypes.ExperimentActionState {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentActionState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentActionState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTargetFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ExperimentTargetFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetFilter()
        value.path = try reader["path"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ExperimentState {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: FisClientTypes.ExperimentError.read(from:))
        return value
    }
}

extension FisClientTypes.ExperimentError {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentError()
        value.accountId = try reader["accountId"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTargetAccountConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetAccountConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetAccountConfiguration()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes.SafetyLever {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.SafetyLever {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.SafetyLever()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.SafetyLeverState.read(from:))
        return value
    }
}

extension FisClientTypes.SafetyLeverState {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.SafetyLeverState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.SafetyLeverState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension FisClientTypes.TargetResourceType {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceType()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: FisClientTypes.TargetResourceTypeParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.TargetResourceTypeParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceTypeParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceTypeParameter()
        value.description = try reader["description"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ResolvedTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ResolvedTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ResolvedTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.targetName = try reader["targetName"].readIfPresent()
        value.targetInformation = try reader["targetInformation"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.ExperimentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.experimentTemplateId = try reader["experimentTemplateId"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentState.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentOptions.read(from:))
        return value
    }
}

extension FisClientTypes.ExperimentTargetAccountConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetAccountConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetAccountConfigurationSummary()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes.ExperimentTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes.TargetAccountConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetAccountConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetAccountConfigurationSummary()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes.TargetResourceTypeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceTypeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceTypeSummary()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateStopConditionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }
}

extension FisClientTypes.CreateExperimentTemplateTargetInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }
}

extension FisClientTypes.ExperimentTemplateTargetInputFilter {

    static func write(value: FisClientTypes.ExperimentTemplateTargetInputFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["path"].write(value.path)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension FisClientTypes.CreateExperimentTemplateLogConfigurationInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.write(value:to:))
    }
}

extension FisClientTypes.ExperimentTemplateS3LogConfigurationInput {

    static func write(value: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }
}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput {

    static func write(value: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupArn"].write(value.logGroupArn)
    }
}

extension FisClientTypes.CreateExperimentTemplateExperimentOptionsInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountTargeting"].write(value.accountTargeting)
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }
}

extension FisClientTypes.StartExperimentExperimentOptionsInput {

    static func write(value: FisClientTypes.StartExperimentExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionsMode"].write(value.actionsMode)
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateStopConditionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }
}

extension FisClientTypes.UpdateExperimentTemplateTargetInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }
}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem {

    static func write(value: FisClientTypes.UpdateExperimentTemplateActionInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension FisClientTypes.UpdateExperimentTemplateLogConfigurationInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.write(value:to:))
    }
}

extension FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }
}

extension FisClientTypes.UpdateSafetyLeverStateInput {

    static func write(value: FisClientTypes.UpdateSafetyLeverStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reason"].write(value.reason)
        try writer["status"].write(value.status)
    }
}

public enum FisClientTypes {}
