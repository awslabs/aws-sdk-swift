// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FisClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case parameters
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, actionParameterMap0) in parameters {
                try parametersContainer.encode(actionParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actionTargetMap0) in targets {
                try targetsContainer.encode(actionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:FisClientTypes.ActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:FisClientTypes.ActionParameter]()
            for (key0, actionparameter0) in parametersContainer {
                if let actionparameter0 = actionparameter0 {
                    parametersDecoded0?[key0] = actionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Describes an action. For more information, see [FIS actions](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html) in the Fault Injection Simulator User Guide.
    public struct Action: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The action parameters, if applicable.
        public var parameters: [Swift.String:FisClientTypes.ActionParameter]?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The supported targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.ActionParameter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension FisClientTypes {
    /// Describes a parameter for an action.
    public struct ActionParameter: Swift.Equatable {
        /// The parameter description.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension FisClientTypes.ActionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actionTargetMap0) in targets {
                try targetsContainer.encode(actionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an action.
    public struct ActionSummary: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension FisClientTypes {
    /// Describes a target for an action.
    public struct ActionTarget: Swift.Equatable {
        /// The resource type of the target.
        public var resourceType: Swift.String?

        public init(
            resourceType: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateActionParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateActionParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafter0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafter0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentTemplateActionTargetMap0) in targets {
                try targetsContainer.encode(experimentTemplateActionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template. For more information, see [Actions](https://docs.aws.amazon.com/fis/latest/userguide/actions.html) in the Fault Injection Simulator User Guide.
    public struct CreateExperimentTemplateActionInput: Swift.Equatable {
        /// The ID of the action. The format of the action ID is: aws:service-name:action-type.
        /// This member is required.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension CreateExperimentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case logConfiguration
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, createExperimentTemplateActionInputMap0) in actions {
                try actionsContainer.encode(createExperimentTemplateActionInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for createexperimenttemplatestopconditioninput0 in stopConditions {
                try stopConditionsContainer.encode(createexperimenttemplatestopconditioninput0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, createExperimentTemplateTargetInputMap0) in targets {
                try targetsContainer.encode(createExperimentTemplateTargetInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experimentTemplates"
    }
}

public struct CreateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    /// This member is required.
    public var actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A description for the experiment template.
    /// This member is required.
    public var description: Swift.String?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stop conditions.
    /// This member is required.
    public var stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    /// The tags to apply to the experiment template.
    public var tags: [Swift.String:Swift.String]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

struct CreateExperimentTemplateInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let description: Swift.String?
    let stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    let targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?
    let actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?
}

extension CreateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case logConfiguration
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.CreateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.CreateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]()
            for (key0, createexperimenttemplatetargetinput0) in targetsContainer {
                if let createexperimenttemplatetargetinput0 = createexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = createexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateActionInput?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]()
            for (key0, createexperimenttemplateactioninput0) in actionsContainer {
                if let createexperimenttemplateactioninput0 = createexperimenttemplateactioninput0 {
                    actionsDecoded0?[key0] = createexperimenttemplateactioninput0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let logConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.CreateExperimentTemplateLogConfigurationInput.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateLogConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsConfiguration
        case logSchemaVersion
        case s3Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let logSchemaVersion = self.logSchemaVersion {
            try encodeContainer.encode(logSchemaVersion, forKey: .logSchemaVersion)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateS3LogConfigurationInput.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let logSchemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .logSchemaVersion)
        logSchemaVersion = logSchemaVersionDecoded
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging.
    public struct CreateExperimentTemplateLogConfigurationInput: Swift.Equatable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        /// This member is required.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension CreateExperimentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExperimentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct CreateExperimentTemplateOutput: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct CreateExperimentTemplateOutputBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension CreateExperimentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

enum CreateExperimentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment template.
    public struct CreateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is a CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.CreateExperimentTemplateTargetInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case parameters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetinputfilter0 in filters {
                try filtersContainer.encode(experimenttemplatetargetinputfilter0)
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateTargetParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateTargetParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagMap0) in resourceTags {
                try resourceTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = self.selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetparametervalue0) in parametersContainer {
                if let experimenttemplatetargetparametervalue0 = experimenttemplatetargetparametervalue0 {
                    parametersDecoded0?[key0] = experimenttemplatetargetparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both ARNs and tags. For more information, see [Targets](https://docs.aws.amazon.com/fis/latest/userguide/targets.html) in the Fault Injection Simulator User Guide.
    public struct CreateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.
        ///
        /// * ALL - Run the action on all identified targets. This is the default.
        ///
        /// * COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random. For example, COUNT(1) selects one of the targets.
        ///
        /// * PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets at random. For example, PERCENT(25) selects 25% of the targets.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension DeleteExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct DeleteExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteExperimentTemplateInputBody: Swift.Equatable {
}

extension DeleteExperimentTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExperimentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteExperimentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct DeleteExperimentTemplateOutput: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct DeleteExperimentTemplateOutputBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension DeleteExperimentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

enum DeleteExperimentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FisClientTypes.Experiment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case endTime
        case experimentTemplateId
        case id
        case logConfiguration
        case roleArn
        case startTime
        case state
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimentActionMap0) in actions {
                try actionsContainer.encode(experimentActionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let experimentTemplateId = self.experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimentstopcondition0 in stopConditions {
                try stopConditionsContainer.encode(experimentstopcondition0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentTargetMap0) in targets {
                try targetsContainer.encode(experimentTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTarget]()
            for (key0, experimenttarget0) in targetsContainer {
                if let experimenttarget0 = experimenttarget0 {
                    targetsDecoded0?[key0] = experimenttarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentAction]()
            for (key0, experimentaction0) in actionsContainer {
                if let experimentaction0 = experimentaction0 {
                    actionsDecoded0?[key0] = experimentaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let logConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentLogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
    }
}

extension FisClientTypes {
    /// Describes an experiment.
    public struct Experiment: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentAction]?
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The time that the experiment ended.
        public var endTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public var roleArn: Swift.String?
        /// The time that the experiment started.
        public var startTime: ClientRuntime.Date?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentStopCondition]?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTarget]?

        public init(
            actions: [Swift.String:FisClientTypes.ExperimentAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            logConfiguration: FisClientTypes.ExperimentLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            stopConditions: [FisClientTypes.ExperimentStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case endTime
        case parameters
        case startAfter
        case startTime
        case state
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentActionParameterMap0) in parameters {
                try parametersContainer.encode(experimentActionParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimentactionstartafter0 in startAfter {
                try startAfterContainer.encode(experimentactionstartafter0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentActionTargetMap0) in targets {
                try targetsContainer.encode(experimentActionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimentactionparameter0) in parametersContainer {
                if let experimentactionparameter0 = experimentactionparameter0 {
                    parametersDecoded0?[key0] = experimentactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttargetname0) in targetsContainer {
                if let experimenttargetname0 = experimenttargetname0 {
                    targetsDecoded0?[key0] = experimenttargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension FisClientTypes {
    /// Describes the action for an experiment.
    public struct ExperimentAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The time that the action ended.
        public var endTime: ClientRuntime.Date?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before this action starts.
        public var startAfter: [Swift.String]?
        /// The time that the action started.
        public var startTime: ClientRuntime.Date?
        /// The state of the action.
        public var state: FisClientTypes.ExperimentActionState?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentActionState? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.endTime = endTime
            self.parameters = parameters
            self.startAfter = startAfter
            self.startTime = startTime
            self.state = state
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentActionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes {
    /// Describes the state of an action.
    public struct ExperimentActionState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the action.
        public var status: FisClientTypes.ExperimentActionStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentActionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentActionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentActionStatus(rawValue: rawValue) ?? ExperimentActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentCloudWatchLogsLogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentCloudWatchLogsLogConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentLogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsConfiguration
        case logSchemaVersion
        case s3Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let logSchemaVersion = self.logSchemaVersion {
            try encodeContainer.encode(logSchemaVersion, forKey: .logSchemaVersion)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentCloudWatchLogsLogConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentS3LogConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let logSchemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .logSchemaVersion)
        logSchemaVersion = logSchemaVersionDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging.
    public struct ExperimentLogConfiguration: Swift.Equatable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension FisClientTypes.ExperimentS3LogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentS3LogConfiguration: Swift.Equatable {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes {
    /// Describes the state of an experiment.
    public struct ExperimentState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the experiment.
        public var status: FisClientTypes.ExperimentStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentStopCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Describes the stop condition for an experiment.
    public struct ExperimentStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case experimentTemplateId
        case id
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let experimentTemplateId = self.experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment.
    public struct ExperimentSummary: Swift.Equatable {
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case parameters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttargetfilter0 in filters {
                try filtersContainer.encode(experimenttargetfilter0)
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTargetParameterMap0) in parameters {
                try parametersContainer.encode(experimentTargetParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagMap0) in resourceTags {
                try resourceTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = self.selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttargetparametervalue0) in parametersContainer {
                if let experimenttargetparametervalue0 = experimenttargetparametervalue0 {
                    parametersDecoded0?[key0] = experimenttargetparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment.
    public struct ExperimentTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTargetFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTargetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttargetfiltervalue0 in values {
                try valuesContainer.encode(experimenttargetfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment.
    public struct ExperimentTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case description
        case id
        case lastUpdateTime
        case logConfiguration
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimentTemplateActionMap0) in actions {
                try actionsContainer.encode(experimentTemplateActionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimenttemplatestopcondition0 in stopConditions {
                try stopConditionsContainer.encode(experimenttemplatestopcondition0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentTemplateTargetMap0) in targets {
                try targetsContainer.encode(experimentTemplateTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateTarget]()
            for (key0, experimenttemplatetarget0) in targetsContainer {
                if let experimenttemplatetarget0 = experimenttemplatetarget0 {
                    targetsDecoded0?[key0] = experimenttemplatetarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateAction]()
            for (key0, experimenttemplateaction0) in actionsContainer {
                if let experimenttemplateaction0 = experimenttemplateaction0 {
                    actionsDecoded0?[key0] = experimenttemplateaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentTemplateStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentTemplateStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let logConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateLogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
    }
}

extension FisClientTypes {
    /// Describes an experiment template.
    public struct ExperimentTemplate: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]?
        /// The time the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public var roleArn: Swift.String?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]?

        public init(
            actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateActionParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateActionParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafter0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafter0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentTemplateActionTargetMap0) in targets {
                try targetsContainer.encode(experimentTemplateActionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Describes an action for an experiment template.
    public struct ExperimentTemplateAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfigurationInput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentTemplateLogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsConfiguration
        case logSchemaVersion
        case s3Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let logSchemaVersion = self.logSchemaVersion {
            try encodeContainer.encode(logSchemaVersion, forKey: .logSchemaVersion)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateS3LogConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let logSchemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .logSchemaVersion)
        logSchemaVersion = logSchemaVersionDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging.
    public struct ExperimentTemplateLogConfiguration: Swift.Equatable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension FisClientTypes.ExperimentTemplateS3LogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfiguration: Swift.Equatable {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentTemplateS3LogConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfigurationInput: Swift.Equatable {
        /// The name of the destination bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentTemplateStopCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Describes a stop condition for an experiment template.
    public struct ExperimentTemplateStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case lastUpdateTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment template.
    public struct ExperimentTemplateSummary: Swift.Equatable {
        /// The time that the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time that the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTemplateTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case parameters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilter0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilter0)
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateTargetParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateTargetParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagMap0) in resourceTags {
                try resourceTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = self.selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetparametervalue0) in parametersContainer {
                if let experimenttemplatetargetparametervalue0 = experimenttemplatetargetparametervalue0 {
                    parametersDecoded0?[key0] = experimenttemplatetargetparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment template.
    public struct ExperimentTemplateTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalue0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment template.
    public struct ExperimentTemplateTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetInputFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalue0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Specifies a filter used for the target resource input in an experiment template. For more information, see [Resource filters](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters) in the Fault Injection Simulator User Guide.
    public struct ExperimentTemplateTargetInputFilter: Swift.Equatable {
        /// The attribute path for the filter.
        /// This member is required.
        public var path: Swift.String?
        /// The attribute values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension GetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/actions/\(id.urlPercentEncoding())"
    }
}

public struct GetActionInput: Swift.Equatable {
    /// The ID of the action.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetActionInputBody: Swift.Equatable {
}

extension GetActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
        } else {
            self.action = nil
        }
    }
}

public struct GetActionOutput: Swift.Equatable {
    /// Information about the action.
    public var action: FisClientTypes.Action?

    public init(
        action: FisClientTypes.Action? = nil
    )
    {
        self.action = action
    }
}

struct GetActionOutputBody: Swift.Equatable {
    let action: FisClientTypes.Action?
}

extension GetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FisClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

enum GetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentInputBody: Swift.Equatable {
}

extension GetExperimentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutput: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension GetExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum GetExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentTemplateInputBody: Swift.Equatable {
}

extension GetExperimentTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExperimentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct GetExperimentTemplateOutput: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct GetExperimentTemplateOutputBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension GetExperimentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

enum GetExperimentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTargetResourceTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceType = resourceType else {
            return nil
        }
        return "/targetResourceTypes/\(resourceType.urlPercentEncoding())"
    }
}

public struct GetTargetResourceTypeInput: Swift.Equatable {
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceType: Swift.String? = nil
    )
    {
        self.resourceType = resourceType
    }
}

struct GetTargetResourceTypeInputBody: Swift.Equatable {
}

extension GetTargetResourceTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTargetResourceTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTargetResourceTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.targetResourceType = output.targetResourceType
        } else {
            self.targetResourceType = nil
        }
    }
}

public struct GetTargetResourceTypeOutput: Swift.Equatable {
    /// Information about the resource type.
    public var targetResourceType: FisClientTypes.TargetResourceType?

    public init(
        targetResourceType: FisClientTypes.TargetResourceType? = nil
    )
    {
        self.targetResourceType = targetResourceType
    }
}

struct GetTargetResourceTypeOutputBody: Swift.Equatable {
    let targetResourceType: FisClientTypes.TargetResourceType?
}

extension GetTargetResourceTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetResourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceTypeDecoded = try containerValues.decodeIfPresent(FisClientTypes.TargetResourceType.self, forKey: .targetResourceType)
        targetResourceType = targetResourceTypeDecoded
    }
}

enum GetTargetResourceTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListActionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/actions"
    }
}

public struct ListActionsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActionsInputBody: Swift.Equatable {
}

extension ListActionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionsOutput: Swift.Equatable {
    /// The actions.
    public var actions: [FisClientTypes.ActionSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        actions: [FisClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListActionsOutputBody: Swift.Equatable {
    let actions: [FisClientTypes.ActionSummary]?
    let nextToken: Swift.String?
}

extension ListActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[FisClientTypes.ActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [FisClientTypes.ActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExperimentTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListExperimentTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experimentTemplates"
    }
}

public struct ListExperimentTemplatesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesInputBody: Swift.Equatable {
}

extension ListExperimentTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExperimentTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplates = output.experimentTemplates
            self.nextToken = output.nextToken
        } else {
            self.experimentTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentTemplatesOutput: Swift.Equatable {
    /// The experiment templates.
    public var experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesOutputBody: Swift.Equatable {
    let experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListExperimentTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplates
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplatesContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateSummary?].self, forKey: .experimentTemplates)
        var experimentTemplatesDecoded0:[FisClientTypes.ExperimentTemplateSummary]? = nil
        if let experimentTemplatesContainer = experimentTemplatesContainer {
            experimentTemplatesDecoded0 = [FisClientTypes.ExperimentTemplateSummary]()
            for structure0 in experimentTemplatesContainer {
                if let structure0 = structure0 {
                    experimentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        experimentTemplates = experimentTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExperimentTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExperimentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListExperimentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experiments"
    }
}

public struct ListExperimentsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentsInputBody: Swift.Equatable {
}

extension ListExperimentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExperimentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutput: Swift.Equatable {
    /// The experiments.
    public var experiments: [FisClientTypes.ExperimentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experiments: [FisClientTypes.ExperimentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputBody: Swift.Equatable {
    let experiments: [FisClientTypes.ExperimentSummary]?
    let nextToken: Swift.String?
}

extension ListExperimentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentSummary?].self, forKey: .experiments)
        var experimentsDecoded0:[FisClientTypes.ExperimentSummary]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [FisClientTypes.ExperimentSummary]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExperimentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTargetResourceTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTargetResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/targetResourceTypes"
    }
}

public struct ListTargetResourceTypesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTargetResourceTypesInputBody: Swift.Equatable {
}

extension ListTargetResourceTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTargetResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTargetResourceTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targetResourceTypes = output.targetResourceTypes
        } else {
            self.nextToken = nil
            self.targetResourceTypes = nil
        }
    }
}

public struct ListTargetResourceTypesOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target resource types.
    public var targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetResourceTypes = targetResourceTypes
    }
}

struct ListTargetResourceTypesOutputBody: Swift.Equatable {
    let targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]?
    let nextToken: Swift.String?
}

extension ListTargetResourceTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case targetResourceTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceTypesContainer = try containerValues.decodeIfPresent([FisClientTypes.TargetResourceTypeSummary?].self, forKey: .targetResourceTypes)
        var targetResourceTypesDecoded0:[FisClientTypes.TargetResourceTypeSummary]? = nil
        if let targetResourceTypesContainer = targetResourceTypesContainer {
            targetResourceTypesDecoded0 = [FisClientTypes.TargetResourceTypeSummary]()
            for structure0 in targetResourceTypesContainer {
                if let structure0 = structure0 {
                    targetResourceTypesDecoded0?.append(structure0)
                }
            }
        }
        targetResourceTypes = targetResourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTargetResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let experimentTemplateId = self.experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experiments"
    }
}

public struct StartExperimentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The tags to apply to the experiment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

struct StartExperimentInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let experimentTemplateId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StartExperimentOutput: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StartExperimentOutputBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension StartExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum StartExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct StopExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopExperimentInputBody: Swift.Equatable {
}

extension StopExperimentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StopExperimentOutput: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StopExperimentOutputBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension StopExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum StopExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FisClientTypes.TargetResourceType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case parameters
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, targetResourceTypeParameterMap0) in parameters {
                try parametersContainer.encode(targetResourceTypeParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.TargetResourceTypeParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:FisClientTypes.TargetResourceTypeParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:FisClientTypes.TargetResourceTypeParameter]()
            for (key0, targetresourcetypeparameter0) in parametersContainer {
                if let targetresourcetypeparameter0 = targetresourcetypeparameter0 {
                    parametersDecoded0?[key0] = targetresourcetypeparameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension FisClientTypes {
    /// Describes a resource type.
    public struct TargetResourceType: Swift.Equatable {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The parameters for the resource type.
        public var parameters: [Swift.String:FisClientTypes.TargetResourceTypeParameter]?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.TargetResourceTypeParameter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.parameters = parameters
            self.resourceType = resourceType
        }
    }

}

extension FisClientTypes.TargetResourceTypeParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension FisClientTypes {
    /// Describes the parameters for a resource type. Use parameters to determine which tasks are identified during target resolution.
    public struct TargetResourceTypeParameter: Swift.Equatable {
        /// A description of the parameter.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension FisClientTypes.TargetResourceTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension FisClientTypes {
    /// Describes a resource type.
    public struct TargetResourceTypeSummary: Swift.Equatable {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceType = resourceType
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let tagKeys = tagKeys {
                tagKeys.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateActionParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateActionParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafter0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafter0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentTemplateActionTargetMap0) in targets {
                try targetsContainer.encode(experimentTemplateActionTargetMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct UpdateExperimentTemplateActionInputItem: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension UpdateExperimentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case logConfiguration
        case roleArn
        case stopConditions
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, updateExperimentTemplateActionInputMap0) in actions {
                try actionsContainer.encode(updateExperimentTemplateActionInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for updateexperimenttemplatestopconditioninput0 in stopConditions {
                try stopConditionsContainer.encode(updateexperimenttemplatestopconditioninput0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, updateExperimentTemplateTargetInputMap0) in targets {
                try targetsContainer.encode(updateExperimentTemplateTargetInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct UpdateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    public var actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    /// A description for the template.
    public var description: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    public var roleArn: Swift.String?
    /// The stop conditions for the experiment.
    public var stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.id = id
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

struct UpdateExperimentTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
    let stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    let targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?
    let actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    let roleArn: Swift.String?
    let logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?
}

extension UpdateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case logConfiguration
        case roleArn
        case stopConditions
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.UpdateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.UpdateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]()
            for (key0, updateexperimenttemplatetargetinput0) in targetsContainer {
                if let updateexperimenttemplatetargetinput0 = updateexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = updateexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateActionInputItem?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]()
            for (key0, updateexperimenttemplateactioninputitem0) in actionsContainer {
                if let updateexperimenttemplateactioninputitem0 = updateexperimenttemplateactioninputitem0 {
                    actionsDecoded0?[key0] = updateexperimenttemplateactioninputitem0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.UpdateExperimentTemplateLogConfigurationInput.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
    }
}

extension FisClientTypes.UpdateExperimentTemplateLogConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsConfiguration
        case logSchemaVersion
        case s3Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let logSchemaVersion = self.logSchemaVersion {
            try encodeContainer.encode(logSchemaVersion, forKey: .logSchemaVersion)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplateS3LogConfigurationInput.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let logSchemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .logSchemaVersion)
        logSchemaVersion = logSchemaVersionDecoded
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging.
    public struct UpdateExperimentTemplateLogConfigurationInput: Swift.Equatable {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension UpdateExperimentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExperimentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct UpdateExperimentTemplateOutput: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct UpdateExperimentTemplateOutputBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension UpdateExperimentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

enum UpdateExperimentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.
    public struct UpdateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.UpdateExperimentTemplateTargetInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case parameters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetinputfilter0 in filters {
                try filtersContainer.encode(experimenttemplatetargetinputfilter0)
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentTemplateTargetParameterMap0) in parameters {
                try parametersContainer.encode(experimentTemplateTargetParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagMap0) in resourceTags {
                try resourceTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = self.selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetparametervalue0) in parametersContainer {
                if let experimenttemplatetargetparametervalue0 = experimenttemplatetargetparametervalue0 {
                    parametersDecoded0?[key0] = experimenttemplatetargetparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.
    public struct UpdateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified input is not valid, or fails to satisfy the constraints for the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
