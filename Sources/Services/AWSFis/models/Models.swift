// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension FisClientTypes {

    public enum AccountTargeting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiAccount
        case singleAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountTargeting] {
            return [
                .multiAccount,
                .singleAccount,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiAccount: return "multi-account"
            case .singleAccount: return "single-account"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes.Action {

    static func write(value: FisClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: FisClientTypes.ActionParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.ActionTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.Action()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes an action. For more information, see [FIS actions](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html) in the Fault Injection Service User Guide.
    public struct Action {
        /// The Amazon Resource Name (ARN) of the action.
        public var arn: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The action parameters, if applicable.
        public var parameters: [Swift.String:FisClientTypes.ActionParameter]?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The supported targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.ActionParameter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionParameter {

    static func write(value: FisClientTypes.ActionParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["required"].write(value.`required`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionParameter()
        value.description = try reader["description"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a parameter for an action.
    public struct ActionParameter {
        /// The parameter description.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension FisClientTypes.ActionSummary {

    static func write(value: FisClientTypes.ActionSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.ActionTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ActionTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Provides a summary of an action.
    public struct ActionSummary {
        /// The Amazon Resource Name (ARN) of the action.
        public var arn: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionTarget {

    static func write(value: FisClientTypes.ActionTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ActionTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ActionTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a target for an action.
    public struct ActionTarget {
        /// The resource type of the target.
        public var resourceType: Swift.String?

        public init(
            resourceType: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
        }
    }

}

extension FisClientTypes {

    public enum ActionsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case runAll
        case skipAll
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionsMode] {
            return [
                .runAll,
                .skipAll,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .runAll: return "run-all"
            case .skipAll: return "skip-all"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request could not be processed because of a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.CreateExperimentTemplateActionInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.CreateExperimentTemplateActionInput()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template. For more information, see [Actions](https://docs.aws.amazon.com/fis/latest/userguide/actions.html) in the Fault Injection Service User Guide.
    public struct CreateExperimentTemplateActionInput {
        /// The ID of the action. The format of the action ID is: aws:service-name:action-type.
        /// This member is required.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.CreateExperimentTemplateExperimentOptionsInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountTargeting"].write(value.accountTargeting)
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.CreateExperimentTemplateExperimentOptionsInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.CreateExperimentTemplateExperimentOptionsInput()
        value.accountTargeting = try reader["accountTargeting"].readIfPresent()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies experiment options for an experiment template.
    public struct CreateExperimentTemplateExperimentOptionsInput {
        /// Specifies the account targeting setting for experiment options.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// Specifies the empty target resolution mode for experiment options.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }

}

extension CreateExperimentTemplateInput {

    static func urlPathProvider(_ value: CreateExperimentTemplateInput) -> Swift.String? {
        return "/experimentTemplates"
    }
}

extension CreateExperimentTemplateInput {

    static func write(value: CreateExperimentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.CreateExperimentTemplateActionInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput.write(value:to:))
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.CreateExperimentTemplateLogConfigurationInput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.CreateExperimentTemplateStopConditionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.CreateExperimentTemplateTargetInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateExperimentTemplateInput {
    /// The actions for the experiment.
    /// This member is required.
    public var actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A description for the experiment template.
    /// This member is required.
    public var description: Swift.String?
    /// The experiment options for the experiment template.
    public var experimentOptions: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stop conditions.
    /// This member is required.
    public var stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    /// The tags to apply to the experiment template.
    public var tags: [Swift.String:Swift.String]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentOptions: FisClientTypes.CreateExperimentTemplateExperimentOptionsInput? = nil,
        logConfiguration: FisClientTypes.CreateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.experimentOptions = experimentOptions
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

extension FisClientTypes.CreateExperimentTemplateLogConfigurationInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.CreateExperimentTemplateLogConfigurationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.CreateExperimentTemplateLogConfigurationInput()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging.
    public struct CreateExperimentTemplateLogConfigurationInput {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        /// This member is required.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension CreateExperimentTemplateOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

public struct CreateExperimentTemplateOutput {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

enum CreateExperimentTemplateOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateStopConditionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.CreateExperimentTemplateStopConditionInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.CreateExperimentTemplateStopConditionInput()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment template.
    public struct CreateExperimentTemplateStopConditionInput {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is a CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.CreateExperimentTemplateTargetInput {

    static func write(value: FisClientTypes.CreateExperimentTemplateTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.CreateExperimentTemplateTargetInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.CreateExperimentTemplateTargetInput()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both ARNs and tags. For more information, see [Targets](https://docs.aws.amazon.com/fis/latest/userguide/targets.html) in the Fault Injection Service User Guide.
    public struct CreateExperimentTemplateTargetInput {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.
        ///
        /// * ALL - Run the action on all identified targets. This is the default.
        ///
        /// * COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random. For example, COUNT(1) selects one of the targets.
        ///
        /// * PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets at random. For example, PERCENT(25) selects 25% of the targets.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension CreateTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: CreateTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension CreateTargetAccountConfigurationInput {

    static func write(value: CreateTargetAccountConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }
}

public struct CreateTargetAccountConfigurationInput {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the target account.
    public var description: Swift.String?
    /// The experiment template ID.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role for the target account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.description = description
        self.experimentTemplateId = experimentTemplateId
        self.roleArn = roleArn
    }
}

extension CreateTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

public struct CreateTargetAccountConfigurationOutput {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

enum CreateTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteExperimentTemplateInput {

    static func urlPathProvider(_ value: DeleteExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct DeleteExperimentTemplateInput {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteExperimentTemplateOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

public struct DeleteExperimentTemplateOutput {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

enum DeleteExperimentTemplateOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: DeleteTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

public struct DeleteTargetAccountConfigurationInput {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentTemplateId = experimentTemplateId
    }
}

extension DeleteTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

public struct DeleteTargetAccountConfigurationOutput {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

enum DeleteTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes {

    public enum EmptyTargetResolutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [EmptyTargetResolutionMode] {
            return [
                .fail,
                .skip,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "fail"
            case .skip: return "skip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes.Experiment {

    static func write(value: FisClientTypes.Experiment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.ExperimentAction.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["arn"].write(value.arn)
        try writer["creationTime"].writeTimestamp(value.creationTime, format: .epochSeconds)
        try writer["endTime"].writeTimestamp(value.endTime, format: .epochSeconds)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.ExperimentOptions.write(value:to:))
        try writer["experimentTemplateId"].write(value.experimentTemplateId)
        try writer["id"].write(value.id)
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.ExperimentLogConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["startTime"].writeTimestamp(value.startTime, format: .epochSeconds)
        try writer["state"].write(value.state, with: FisClientTypes.ExperimentState.write(value:to:))
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.ExperimentStopCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetAccountConfigurationsCount"].write(value.targetAccountConfigurationsCount)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.ExperimentTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.Experiment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.Experiment()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.experimentTemplateId = try reader["experimentTemplateId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentState.read(from:))
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.actions = try reader["actions"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentAction.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stopConditions = try reader["stopConditions"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentStopCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logConfiguration = try reader["logConfiguration"].readIfPresent(with: FisClientTypes.ExperimentLogConfiguration.read(from:))
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentOptions.read(from:))
        value.targetAccountConfigurationsCount = try reader["targetAccountConfigurationsCount"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes an experiment.
    public struct Experiment {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentAction]?
        /// The Amazon Resource Name (ARN) of the experiment.
        public var arn: Swift.String?
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The time that the experiment ended.
        public var endTime: ClientRuntime.Date?
        /// The experiment options for the experiment.
        public var experimentOptions: FisClientTypes.ExperimentOptions?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public var roleArn: Swift.String?
        /// The time that the experiment started.
        public var startTime: ClientRuntime.Date?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentStopCondition]?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?
        /// The count of target account configurations for the experiment.
        public var targetAccountConfigurationsCount: Swift.Int?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTarget]?

        public init(
            actions: [Swift.String:FisClientTypes.ExperimentAction]? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            experimentOptions: FisClientTypes.ExperimentOptions? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            logConfiguration: FisClientTypes.ExperimentLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            stopConditions: [FisClientTypes.ExperimentStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetAccountConfigurationsCount: Swift.Int? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        )
        {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentAction {

    static func write(value: FisClientTypes.ExperimentAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["endTime"].writeTimestamp(value.endTime, format: .epochSeconds)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].writeTimestamp(value.startTime, format: .epochSeconds)
        try writer["state"].write(value.state, with: FisClientTypes.ExperimentActionState.write(value:to:))
        try writer["targets"].writeMap(value.targets, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentAction()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentActionState.read(from:))
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension FisClientTypes {
    /// Describes the action for an experiment.
    public struct ExperimentAction {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The time that the action ended.
        public var endTime: ClientRuntime.Date?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before this action starts.
        public var startAfter: [Swift.String]?
        /// The time that the action started.
        public var startTime: ClientRuntime.Date?
        /// The state of the action.
        public var state: FisClientTypes.ExperimentActionState?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentActionState? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.endTime = endTime
            self.parameters = parameters
            self.startAfter = startAfter
            self.startTime = startTime
            self.state = state
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentActionState {

    static func write(value: FisClientTypes.ExperimentActionState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reason"].write(value.reason)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentActionState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentActionState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the state of an action.
    public struct ExperimentActionState {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the action.
        public var status: FisClientTypes.ExperimentActionStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentActionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {

    public enum ExperimentActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case skipped
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentActionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .skipped,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .skipped: return "skipped"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes.ExperimentCloudWatchLogsLogConfiguration {

    static func write(value: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentCloudWatchLogsLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentCloudWatchLogsLogConfiguration()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentCloudWatchLogsLogConfiguration {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentLogConfiguration {

    static func write(value: FisClientTypes.ExperimentLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentS3LogConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentLogConfiguration()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentS3LogConfiguration.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging.
    public struct ExperimentLogConfiguration {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension FisClientTypes.ExperimentOptions {

    static func write(value: FisClientTypes.ExperimentOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountTargeting"].write(value.accountTargeting)
        try writer["actionsMode"].write(value.actionsMode)
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentOptions()
        value.accountTargeting = try reader["accountTargeting"].readIfPresent()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        value.actionsMode = try reader["actionsMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the options for an experiment.
    public struct ExperimentOptions {
        /// The account targeting setting for an experiment.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// The actions mode of the experiment that is set from the StartExperiment API command.
        public var actionsMode: FisClientTypes.ActionsMode?
        /// The empty target resolution mode for an experiment.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            actionsMode: FisClientTypes.ActionsMode? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.actionsMode = actionsMode
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }

}

extension FisClientTypes.ExperimentS3LogConfiguration {

    static func write(value: FisClientTypes.ExperimentS3LogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentS3LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentS3LogConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentS3LogConfiguration {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentState {

    static func write(value: FisClientTypes.ExperimentState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reason"].write(value.reason)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the state of an experiment.
    public struct ExperimentState {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the experiment.
        public var status: FisClientTypes.ExperimentStatus?

        public init(
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {

    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FisClientTypes.ExperimentStopCondition {

    static func write(value: FisClientTypes.ExperimentStopCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentStopCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentStopCondition()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the stop condition for an experiment.
    public struct ExperimentStopCondition {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentSummary {

    static func write(value: FisClientTypes.ExperimentSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["creationTime"].writeTimestamp(value.creationTime, format: .epochSeconds)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.ExperimentOptions.write(value:to:))
        try writer["experimentTemplateId"].write(value.experimentTemplateId)
        try writer["id"].write(value.id)
        try writer["state"].write(value.state, with: FisClientTypes.ExperimentState.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.experimentTemplateId = try reader["experimentTemplateId"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: FisClientTypes.ExperimentState.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentOptions.read(from:))
        return value
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment.
    public struct ExperimentSummary {
        /// The Amazon Resource Name (ARN) of the experiment.
        public var arn: Swift.String?
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The experiment options for the experiment.
        public var experimentOptions: FisClientTypes.ExperimentOptions?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            experimentOptions: FisClientTypes.ExperimentOptions? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTarget {

    static func write(value: FisClientTypes.ExperimentTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTargetFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTargetFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment.
    public struct ExperimentTarget {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTargetFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTargetAccountConfiguration {

    static func write(value: FisClientTypes.ExperimentTargetAccountConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetAccountConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetAccountConfiguration()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a target account configuration for an experiment.
    public struct ExperimentTargetAccountConfiguration {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }

}

extension FisClientTypes.ExperimentTargetAccountConfigurationSummary {

    static func write(value: FisClientTypes.ExperimentTargetAccountConfigurationSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetAccountConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetAccountConfigurationSummary()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Provides a summary of a target account configuration.
    public struct ExperimentTargetAccountConfigurationSummary {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }

}

extension FisClientTypes.ExperimentTargetFilter {

    static func write(value: FisClientTypes.ExperimentTargetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["path"].write(value.path)
        try writer["values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTargetFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTargetFilter()
        value.path = try reader["path"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment.
    public struct ExperimentTargetFilter {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplate {

    static func write(value: FisClientTypes.ExperimentTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.ExperimentTemplateAction.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["arn"].write(value.arn)
        try writer["creationTime"].writeTimestamp(value.creationTime, format: .epochSeconds)
        try writer["description"].write(value.description)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.ExperimentTemplateExperimentOptions.write(value:to:))
        try writer["id"].write(value.id)
        try writer["lastUpdateTime"].writeTimestamp(value.lastUpdateTime, format: .epochSeconds)
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.ExperimentTemplateLogConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.ExperimentTemplateStopCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetAccountConfigurationsCount"].write(value.targetAccountConfigurationsCount)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.ExperimentTemplateTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplate()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTemplateTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.actions = try reader["actions"].readMapIfPresent(valueReadingClosure: FisClientTypes.ExperimentTemplateAction.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stopConditions = try reader["stopConditions"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateStopCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logConfiguration = try reader["logConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateLogConfiguration.read(from:))
        value.experimentOptions = try reader["experimentOptions"].readIfPresent(with: FisClientTypes.ExperimentTemplateExperimentOptions.read(from:))
        value.targetAccountConfigurationsCount = try reader["targetAccountConfigurationsCount"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes an experiment template.
    public struct ExperimentTemplate {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]?
        /// The Amazon Resource Name (ARN) of the experiment template.
        public var arn: Swift.String?
        /// The time the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for the experiment template.
        public var description: Swift.String?
        /// The experiment options for an experiment template.
        public var experimentOptions: FisClientTypes.ExperimentTemplateExperimentOptions?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The configuration for experiment logging.
        public var logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public var roleArn: Swift.String?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?
        /// The count of target account configurations for the experiment template.
        public var targetAccountConfigurationsCount: Swift.Int?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]?

        public init(
            actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            experimentOptions: FisClientTypes.ExperimentTemplateExperimentOptions? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            logConfiguration: FisClientTypes.ExperimentTemplateLogConfiguration? = nil,
            roleArn: Swift.String? = nil,
            stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetAccountConfigurationsCount: Swift.Int? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        )
        {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.experimentOptions = experimentOptions
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateAction {

    static func write(value: FisClientTypes.ExperimentTemplateAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateAction()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes an action for an experiment template.
    public struct ExperimentTemplateAction {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration {

    static func write(value: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfiguration {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput {

    static func write(value: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging to Amazon CloudWatch Logs.
    public struct ExperimentTemplateCloudWatchLogsLogConfigurationInput {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension FisClientTypes.ExperimentTemplateExperimentOptions {

    static func write(value: FisClientTypes.ExperimentTemplateExperimentOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountTargeting"].write(value.accountTargeting)
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateExperimentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateExperimentOptions()
        value.accountTargeting = try reader["accountTargeting"].readIfPresent()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the experiment options for an experiment template.
    public struct ExperimentTemplateExperimentOptions {
        /// The account targeting setting for an experiment template.
        public var accountTargeting: FisClientTypes.AccountTargeting?
        /// The empty target resolution mode for an experiment template.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            accountTargeting: FisClientTypes.AccountTargeting? = nil,
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }

}

extension FisClientTypes.ExperimentTemplateLogConfiguration {

    static func write(value: FisClientTypes.ExperimentTemplateLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentTemplateS3LogConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateLogConfiguration()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentTemplateS3LogConfiguration.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging.
    public struct ExperimentTemplateLogConfiguration {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfiguration? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfiguration? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension FisClientTypes.ExperimentTemplateS3LogConfiguration {

    static func write(value: FisClientTypes.ExperimentTemplateS3LogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateS3LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateS3LogConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfiguration {
        /// The name of the destination bucket.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentTemplateS3LogConfigurationInput {

    static func write(value: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateS3LogConfigurationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateS3LogConfigurationInput()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging to Amazon S3.
    public struct ExperimentTemplateS3LogConfigurationInput {
        /// The name of the destination bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension FisClientTypes.ExperimentTemplateStopCondition {

    static func write(value: FisClientTypes.ExperimentTemplateStopCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateStopCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateStopCondition()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a stop condition for an experiment template.
    public struct ExperimentTemplateStopCondition {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentTemplateSummary {

    static func write(value: FisClientTypes.ExperimentTemplateSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["creationTime"].writeTimestamp(value.creationTime, format: .epochSeconds)
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["lastUpdateTime"].writeTimestamp(value.lastUpdateTime, format: .epochSeconds)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment template.
    public struct ExperimentTemplateSummary {
        /// The Amazon Resource Name (ARN) of the experiment template.
        public var arn: Swift.String?
        /// The time that the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time that the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTemplateTarget {

    static func write(value: FisClientTypes.ExperimentTemplateTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTemplateTargetFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateTargetFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment template.
    public struct ExperimentTemplateTarget {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetFilter {

    static func write(value: FisClientTypes.ExperimentTemplateTargetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["path"].write(value.path)
        try writer["values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateTargetFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateTargetFilter()
        value.path = try reader["path"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment template.
    public struct ExperimentTemplateTargetFilter {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetInputFilter {

    static func write(value: FisClientTypes.ExperimentTemplateTargetInputFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["path"].write(value.path)
        try writer["values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ExperimentTemplateTargetInputFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ExperimentTemplateTargetInputFilter()
        value.path = try reader["path"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Specifies a filter used for the target resource input in an experiment template. For more information, see [Resource filters](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters) in the Fault Injection Service User Guide.
    public struct ExperimentTemplateTargetInputFilter {
        /// The attribute path for the filter.
        /// This member is required.
        public var path: Swift.String?
        /// The attribute values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

public enum FisClientTypes {}

extension GetActionInput {

    static func urlPathProvider(_ value: GetActionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/actions/\(id.urlPercentEncoding())"
    }
}

public struct GetActionInput {
    /// The ID of the action.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetActionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetActionOutput()
        value.action = try reader["action"].readIfPresent(with: FisClientTypes.Action.read(from:))
        return value
    }
}

public struct GetActionOutput {
    /// Information about the action.
    public var action: FisClientTypes.Action?

    public init(
        action: FisClientTypes.Action? = nil
    )
    {
        self.action = action
    }
}

enum GetActionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetExperimentInput {

    static func urlPathProvider(_ value: GetExperimentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentInput {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetExperimentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

public struct GetExperimentOutput {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

enum GetExperimentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetExperimentTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: GetExperimentTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

public struct GetExperimentTargetAccountConfigurationInput {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentId = experimentId
    }
}

extension GetExperimentTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetExperimentTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTargetAccountConfiguration.read(from:))
        return value
    }
}

public struct GetExperimentTargetAccountConfigurationOutput {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.ExperimentTargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.ExperimentTargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

enum GetExperimentTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetExperimentTemplateInput {

    static func urlPathProvider(_ value: GetExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentTemplateInput {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetExperimentTemplateOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

public struct GetExperimentTemplateOutput {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

enum GetExperimentTemplateOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: GetTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

public struct GetTargetAccountConfigurationInput {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.experimentTemplateId = experimentTemplateId
    }
}

extension GetTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

public struct GetTargetAccountConfigurationOutput {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

enum GetTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTargetResourceTypeInput {

    static func urlPathProvider(_ value: GetTargetResourceTypeInput) -> Swift.String? {
        guard let resourceType = value.resourceType else {
            return nil
        }
        return "/targetResourceTypes/\(resourceType.urlPercentEncoding())"
    }
}

public struct GetTargetResourceTypeInput {
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceType: Swift.String? = nil
    )
    {
        self.resourceType = resourceType
    }
}

extension GetTargetResourceTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTargetResourceTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetResourceTypeOutput()
        value.targetResourceType = try reader["targetResourceType"].readIfPresent(with: FisClientTypes.TargetResourceType.read(from:))
        return value
    }
}

public struct GetTargetResourceTypeOutput {
    /// Information about the resource type.
    public var targetResourceType: FisClientTypes.TargetResourceType?

    public init(
        targetResourceType: FisClientTypes.TargetResourceType? = nil
    )
    {
        self.targetResourceType = targetResourceType
    }
}

enum GetTargetResourceTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListActionsInput {

    static func queryItemProvider(_ value: ListActionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListActionsInput {

    static func urlPathProvider(_ value: ListActionsInput) -> Swift.String? {
        return "/actions"
    }
}

public struct ListActionsInput {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListActionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActionsOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: FisClientTypes.ActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListActionsOutput {
    /// The actions.
    public var actions: [FisClientTypes.ActionSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        actions: [FisClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

enum ListActionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListExperimentResolvedTargetsInput {

    static func queryItemProvider(_ value: ListExperimentResolvedTargetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let targetName = value.targetName {
            let targetNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "targetName".urlPercentEncoding(), value: Swift.String(targetName).urlPercentEncoding())
            items.append(targetNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentResolvedTargetsInput {

    static func urlPathProvider(_ value: ListExperimentResolvedTargetsInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/resolvedTargets"
    }
}

public struct ListExperimentResolvedTargetsInput {
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The name of the target.
    public var targetName: Swift.String?

    public init(
        experimentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.experimentId = experimentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetName = targetName
    }
}

extension ListExperimentResolvedTargetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListExperimentResolvedTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentResolvedTargetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resolvedTargets = try reader["resolvedTargets"].readListIfPresent(memberReadingClosure: FisClientTypes.ResolvedTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListExperimentResolvedTargetsOutput {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The resolved targets.
    public var resolvedTargets: [FisClientTypes.ResolvedTarget]?

    public init(
        nextToken: Swift.String? = nil,
        resolvedTargets: [FisClientTypes.ResolvedTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvedTargets = resolvedTargets
    }
}

enum ListExperimentResolvedTargetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListExperimentTargetAccountConfigurationsInput {

    static func queryItemProvider(_ value: ListExperimentTargetAccountConfigurationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentTargetAccountConfigurationsInput {

    static func urlPathProvider(_ value: ListExperimentTargetAccountConfigurationsInput) -> Swift.String? {
        guard let experimentId = value.experimentId else {
            return nil
        }
        return "/experiments/\(experimentId.urlPercentEncoding())/targetAccountConfigurations"
    }
}

public struct ListExperimentTargetAccountConfigurationsInput {
    /// The ID of the experiment.
    /// This member is required.
    public var experimentId: Swift.String?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentId = experimentId
        self.nextToken = nextToken
    }
}

extension ListExperimentTargetAccountConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListExperimentTargetAccountConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentTargetAccountConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetAccountConfigurations = try reader["targetAccountConfigurations"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTargetAccountConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListExperimentTargetAccountConfigurationsOutput {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target account configurations.
    public var targetAccountConfigurations: [FisClientTypes.ExperimentTargetAccountConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetAccountConfigurations: [FisClientTypes.ExperimentTargetAccountConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetAccountConfigurations = targetAccountConfigurations
    }
}

enum ListExperimentTargetAccountConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListExperimentTemplatesInput {

    static func queryItemProvider(_ value: ListExperimentTemplatesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentTemplatesInput {

    static func urlPathProvider(_ value: ListExperimentTemplatesInput) -> Swift.String? {
        return "/experimentTemplates"
    }
}

public struct ListExperimentTemplatesInput {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListExperimentTemplatesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListExperimentTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentTemplatesOutput()
        value.experimentTemplates = try reader["experimentTemplates"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListExperimentTemplatesOutput {
    /// The experiment templates.
    public var experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

enum ListExperimentTemplatesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListExperimentsInput {

    static func queryItemProvider(_ value: ListExperimentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let experimentTemplateId = value.experimentTemplateId {
            let experimentTemplateIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "experimentTemplateId".urlPercentEncoding(), value: Swift.String(experimentTemplateId).urlPercentEncoding())
            items.append(experimentTemplateIdQueryItem)
        }
        return items
    }
}

extension ListExperimentsInput {

    static func urlPathProvider(_ value: ListExperimentsInput) -> Swift.String? {
        return "/experiments"
    }
}

public struct ListExperimentsInput {
    /// The ID of the experiment template.
    public var experimentTemplateId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentTemplateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplateId = experimentTemplateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListExperimentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListExperimentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentsOutput()
        value.experiments = try reader["experiments"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListExperimentsOutput {
    /// The experiments.
    public var experiments: [FisClientTypes.ExperimentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        experiments: [FisClientTypes.ExperimentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

enum ListExperimentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTargetAccountConfigurationsInput {

    static func queryItemProvider(_ value: ListTargetAccountConfigurationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTargetAccountConfigurationsInput {

    static func urlPathProvider(_ value: ListTargetAccountConfigurationsInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations"
    }
}

public struct ListTargetAccountConfigurationsInput {
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        experimentTemplateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplateId = experimentTemplateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTargetAccountConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTargetAccountConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetAccountConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetAccountConfigurations = try reader["targetAccountConfigurations"].readListIfPresent(memberReadingClosure: FisClientTypes.TargetAccountConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTargetAccountConfigurationsOutput {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target account configurations.
    public var targetAccountConfigurations: [FisClientTypes.TargetAccountConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetAccountConfigurations: [FisClientTypes.TargetAccountConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetAccountConfigurations = targetAccountConfigurations
    }
}

enum ListTargetAccountConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTargetResourceTypesInput {

    static func queryItemProvider(_ value: ListTargetResourceTypesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTargetResourceTypesInput {

    static func urlPathProvider(_ value: ListTargetResourceTypesInput) -> Swift.String? {
        return "/targetResourceTypes"
    }
}

public struct ListTargetResourceTypesInput {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTargetResourceTypesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTargetResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetResourceTypesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetResourceTypes = try reader["targetResourceTypes"].readListIfPresent(memberReadingClosure: FisClientTypes.TargetResourceTypeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTargetResourceTypesOutput {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The target resource types.
    public var targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targetResourceTypes: [FisClientTypes.TargetResourceTypeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetResourceTypes = targetResourceTypes
    }
}

enum ListTargetResourceTypesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes.ResolvedTarget {

    static func write(value: FisClientTypes.ResolvedTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceType"].write(value.resourceType)
        try writer["targetInformation"].writeMap(value.targetInformation, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetName"].write(value.targetName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.ResolvedTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.ResolvedTarget()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.targetName = try reader["targetName"].readIfPresent()
        value.targetInformation = try reader["targetInformation"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a resolved target.
    public struct ResolvedTarget {
        /// The resource type of the target.
        public var resourceType: Swift.String?
        /// Information about the target.
        public var targetInformation: [Swift.String:Swift.String]?
        /// The name of the target.
        public var targetName: Swift.String?

        public init(
            resourceType: Swift.String? = nil,
            targetInformation: [Swift.String:Swift.String]? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.targetInformation = targetInformation
            self.targetName = targetName
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FisClientTypes.StartExperimentExperimentOptionsInput {

    static func write(value: FisClientTypes.StartExperimentExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionsMode"].write(value.actionsMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.StartExperimentExperimentOptionsInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.StartExperimentExperimentOptionsInput()
        value.actionsMode = try reader["actionsMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies experiment options for running an experiment.
    public struct StartExperimentExperimentOptionsInput {
        /// Specifies the actions mode for experiment options.
        public var actionsMode: FisClientTypes.ActionsMode?

        public init(
            actionsMode: FisClientTypes.ActionsMode? = nil
        )
        {
            self.actionsMode = actionsMode
        }
    }

}

extension StartExperimentInput {

    static func urlPathProvider(_ value: StartExperimentInput) -> Swift.String? {
        return "/experiments"
    }
}

extension StartExperimentInput {

    static func write(value: StartExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.StartExperimentExperimentOptionsInput.write(value:to:))
        try writer["experimentTemplateId"].write(value.experimentTemplateId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct StartExperimentInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The experiment options for running the experiment.
    public var experimentOptions: FisClientTypes.StartExperimentExperimentOptionsInput?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The tags to apply to the experiment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        experimentOptions: FisClientTypes.StartExperimentExperimentOptionsInput? = nil,
        experimentTemplateId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentOptions = experimentOptions
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

extension StartExperimentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

public struct StartExperimentOutput {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

enum StartExperimentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopExperimentInput {

    static func urlPathProvider(_ value: StopExperimentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct StopExperimentInput {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension StopExperimentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: FisClientTypes.Experiment.read(from:))
        return value
    }
}

public struct StopExperimentOutput {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init(
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

enum StopExperimentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes.TargetAccountConfiguration {

    static func write(value: FisClientTypes.TargetAccountConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetAccountConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetAccountConfiguration()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a target account configuration.
    public struct TargetAccountConfiguration {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }

}

extension FisClientTypes.TargetAccountConfigurationSummary {

    static func write(value: FisClientTypes.TargetAccountConfigurationSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetAccountConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetAccountConfigurationSummary()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Provides a summary of a target account configuration.
    public struct TargetAccountConfigurationSummary {
        /// The Amazon Web Services account ID of the target account.
        public var accountId: Swift.String?
        /// The description of the target account.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public var roleArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }
    }

}

extension FisClientTypes.TargetResourceType {

    static func write(value: FisClientTypes.TargetResourceType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: FisClientTypes.TargetResourceTypeParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceType()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: FisClientTypes.TargetResourceTypeParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Describes a resource type.
    public struct TargetResourceType {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The parameters for the resource type.
        public var parameters: [Swift.String:FisClientTypes.TargetResourceTypeParameter]?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.TargetResourceTypeParameter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.parameters = parameters
            self.resourceType = resourceType
        }
    }

}

extension FisClientTypes.TargetResourceTypeParameter {

    static func write(value: FisClientTypes.TargetResourceTypeParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["required"].write(value.`required`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceTypeParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceTypeParameter()
        value.description = try reader["description"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes the parameters for a resource type. Use parameters to determine which tasks are identified during target resolution.
    public struct TargetResourceTypeParameter {
        /// A description of the parameter.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension FisClientTypes.TargetResourceTypeSummary {

    static func write(value: FisClientTypes.TargetResourceTypeSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["resourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.TargetResourceTypeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.TargetResourceTypeSummary()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Describes a resource type.
    public struct TargetResourceTypeSummary {
        /// A description of the resource type.
        public var description: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            description: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceType = resourceType
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let tagKeys = value.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem {

    static func write(value: FisClientTypes.UpdateExperimentTemplateActionInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["description"].write(value.description)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["startAfter"].writeList(value.startAfter, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.UpdateExperimentTemplateActionInputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.UpdateExperimentTemplateActionInputItem()
        value.actionId = try reader["actionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startAfter = try reader["startAfter"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct UpdateExperimentTemplateActionInputItem {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init(
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["emptyTargetResolutionMode"].write(value.emptyTargetResolutionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput()
        value.emptyTargetResolutionMode = try reader["emptyTargetResolutionMode"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies an experiment option for an experiment template.
    public struct UpdateExperimentTemplateExperimentOptionsInput {
        /// The empty target resolution mode of the experiment template.
        public var emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode?

        public init(
            emptyTargetResolutionMode: FisClientTypes.EmptyTargetResolutionMode? = nil
        )
        {
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }
    }

}

extension UpdateExperimentTemplateInput {

    static func urlPathProvider(_ value: UpdateExperimentTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

extension UpdateExperimentTemplateInput {

    static func write(value: UpdateExperimentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeMap(value.actions, valueWritingClosure: FisClientTypes.UpdateExperimentTemplateActionInputItem.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["experimentOptions"].write(value.experimentOptions, with: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput.write(value:to:))
        try writer["logConfiguration"].write(value.logConfiguration, with: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stopConditions"].writeList(value.stopConditions, memberWritingClosure: FisClientTypes.UpdateExperimentTemplateStopConditionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targets"].writeMap(value.targets, valueWritingClosure: FisClientTypes.UpdateExperimentTemplateTargetInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct UpdateExperimentTemplateInput {
    /// The actions for the experiment.
    public var actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    /// A description for the template.
    public var description: Swift.String?
    /// The experiment options for the experiment template.
    public var experimentOptions: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput?
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration for experiment logging.
    public var logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
    public var roleArn: Swift.String?
    /// The stop conditions for the experiment.
    public var stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?

    public init(
        actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil,
        description: Swift.String? = nil,
        experimentOptions: FisClientTypes.UpdateExperimentTemplateExperimentOptionsInput? = nil,
        id: Swift.String? = nil,
        logConfiguration: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.experimentOptions = experimentOptions
        self.id = id
        self.logConfiguration = logConfiguration
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

extension FisClientTypes.UpdateExperimentTemplateLogConfigurationInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.write(value:to:))
        try writer["logSchemaVersion"].write(value.logSchemaVersion)
        try writer["s3Configuration"].write(value.s3Configuration, with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.UpdateExperimentTemplateLogConfigurationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.UpdateExperimentTemplateLogConfigurationInput()
        value.cloudWatchLogsConfiguration = try reader["cloudWatchLogsConfiguration"].readIfPresent(with: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput.read(from:))
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: FisClientTypes.ExperimentTemplateS3LogConfigurationInput.read(from:))
        value.logSchemaVersion = try reader["logSchemaVersion"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies the configuration for experiment logging.
    public struct UpdateExperimentTemplateLogConfigurationInput {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public var cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        public var logSchemaVersion: Swift.Int?
        /// The configuration for experiment logging to Amazon S3.
        public var s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput?

        public init(
            cloudWatchLogsConfiguration: FisClientTypes.ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil,
            logSchemaVersion: Swift.Int? = nil,
            s3Configuration: FisClientTypes.ExperimentTemplateS3LogConfigurationInput? = nil
        )
        {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }
    }

}

extension UpdateExperimentTemplateOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateExperimentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateExperimentTemplateOutput()
        value.experimentTemplate = try reader["experimentTemplate"].readIfPresent(with: FisClientTypes.ExperimentTemplate.read(from:))
        return value
    }
}

public struct UpdateExperimentTemplateOutput {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init(
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

enum UpdateExperimentTemplateOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateStopConditionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.UpdateExperimentTemplateStopConditionInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.UpdateExperimentTemplateStopConditionInput()
        value.source = try reader["source"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.
    public struct UpdateExperimentTemplateStopConditionInput {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public var value: Swift.String?

        public init(
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.UpdateExperimentTemplateTargetInput {

    static func write(value: FisClientTypes.UpdateExperimentTemplateTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["resourceType"].write(value.resourceType)
        try writer["selectionMode"].write(value.selectionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FisClientTypes.UpdateExperimentTemplateTargetInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FisClientTypes.UpdateExperimentTemplateTargetInput()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: FisClientTypes.ExperimentTemplateTargetInputFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectionMode = try reader["selectionMode"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.
    public struct UpdateExperimentTemplateTargetInput {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init(
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension UpdateTargetAccountConfigurationInput {

    static func urlPathProvider(_ value: UpdateTargetAccountConfigurationInput) -> Swift.String? {
        guard let experimentTemplateId = value.experimentTemplateId else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/experimentTemplates/\(experimentTemplateId.urlPercentEncoding())/targetAccountConfigurations/\(accountId.urlPercentEncoding())"
    }
}

extension UpdateTargetAccountConfigurationInput {

    static func write(value: UpdateTargetAccountConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }
}

public struct UpdateTargetAccountConfigurationInput {
    /// The Amazon Web Services account ID of the target account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The description of the target account.
    public var description: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role for the target account.
    public var roleArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        description: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.description = description
        self.experimentTemplateId = experimentTemplateId
        self.roleArn = roleArn
    }
}

extension UpdateTargetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateTargetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTargetAccountConfigurationOutput()
        value.targetAccountConfiguration = try reader["targetAccountConfiguration"].readIfPresent(with: FisClientTypes.TargetAccountConfiguration.read(from:))
        return value
    }
}

public struct UpdateTargetAccountConfigurationOutput {
    /// Information about the target account configuration.
    public var targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration?

    public init(
        targetAccountConfiguration: FisClientTypes.TargetAccountConfiguration? = nil
    )
    {
        self.targetAccountConfiguration = targetAccountConfiguration
    }
}

enum UpdateTargetAccountConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified input is not valid, or fails to satisfy the constraints for the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
