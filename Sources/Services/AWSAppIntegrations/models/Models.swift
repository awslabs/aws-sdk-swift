// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppIntegrationsClientTypes.ApplicationSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUrlConfig = "ExternalUrlConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUrlConfig = self.externalUrlConfig {
            try encodeContainer.encode(externalUrlConfig, forKey: .externalUrlConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUrlConfigDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ExternalUrlConfig.self, forKey: .externalUrlConfig)
        externalUrlConfig = externalUrlConfigDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration for where the application should be loaded from.
    public struct ApplicationSourceConfig: Swift.Equatable {
        /// The external URL source for the application.
        public var externalUrlConfig: AppIntegrationsClientTypes.ExternalUrlConfig?

        public init(
            externalUrlConfig: AppIntegrationsClientTypes.ExternalUrlConfig? = nil
        )
        {
            self.externalUrlConfig = externalUrlConfig
        }
    }

}

extension AppIntegrationsClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the Application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Application.
        public var arn: Swift.String?
        /// The time when the application was created.
        public var createdTime: ClientRuntime.Date?
        /// A unique identifier for the Application.
        public var id: Swift.String?
        /// The time when the application was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the application.
        public var name: Swift.String?
        /// The namespace of the application.
        public var namespace: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
        }
    }

}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSourceConfig = "ApplicationSourceConfig"
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case namespace = "Namespace"
        case publications = "Publications"
        case subscriptions = "Subscriptions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSourceConfig = self.applicationSourceConfig {
            try encodeContainer.encode(applicationSourceConfig, forKey: .applicationSourceConfig)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let publications = publications {
            var publicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .publications)
            for publication0 in publications {
                try publicationsContainer.encode(publication0)
            }
        }
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The configuration for where the application should be loaded from.
    /// This member is required.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The name of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the application.
    /// This member is required.
    public var namespace: Swift.String?
    /// The events that the application publishes.
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.namespace = namespace
        self.publications = publications
        self.subscriptions = subscriptions
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let namespace: Swift.String?
    let description: Swift.String?
    let applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    let subscriptions: [AppIntegrationsClientTypes.Subscription]?
    let publications: [AppIntegrationsClientTypes.Publication]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSourceConfig = "ApplicationSourceConfig"
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case namespace = "Namespace"
        case publications = "Publications"
        case subscriptions = "Subscriptions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationSourceConfigDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ApplicationSourceConfig.self, forKey: .applicationSourceConfig)
        applicationSourceConfig = applicationSourceConfigDecoded
        let subscriptionsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[AppIntegrationsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [AppIntegrationsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let publicationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Publication?].self, forKey: .publications)
        var publicationsDecoded0:[AppIntegrationsClientTypes.Publication]? = nil
        if let publicationsContainer = publicationsContainer {
            publicationsDecoded0 = [AppIntegrationsClientTypes.Publication]()
            for structure0 in publicationsContainer {
                if let structure0 = structure0 {
                    publicationsDecoded0?.append(structure0)
                }
            }
        }
        publications = publicationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Application.
    public var arn: Swift.String?
    /// A unique identifier for the Application.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededException": return try await ResourceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileConfiguration = "FileConfiguration"
        case kmsKey = "KmsKey"
        case name = "Name"
        case objectConfiguration = "ObjectConfiguration"
        case scheduleConfig = "ScheduleConfig"
        case sourceURI = "SourceURI"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fileConfiguration = self.fileConfiguration {
            try encodeContainer.encode(fileConfiguration, forKey: .fileConfiguration)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectConfiguration = objectConfiguration {
            var objectConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .objectConfiguration)
            for (dictKey0, objectConfiguration0) in objectConfiguration {
                var objectConfiguration0Container = objectConfigurationContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, fieldsMap1) in objectConfiguration0 {
                    var fieldsMap1Container = objectConfiguration0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey1))
                    for fields2 in fieldsMap1 {
                        try fieldsMap1Container.encode(fields2)
                    }
                }
            }
        }
        if let scheduleConfig = self.scheduleConfig {
            try encodeContainer.encode(scheduleConfig, forKey: .scheduleConfig)
        }
        if let sourceURI = self.sourceURI {
            try encodeContainer.encode(sourceURI, forKey: .sourceURI)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDataIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataIntegrations"
    }
}

public struct CreateDataIntegrationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// The KMS key for the DataIntegration.
    /// This member is required.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    /// This member is required.
    public var scheduleConfig: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    /// This member is required.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfig: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfig = scheduleConfig
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

struct CreateDataIntegrationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let kmsKey: Swift.String?
    let sourceURI: Swift.String?
    let scheduleConfig: AppIntegrationsClientTypes.ScheduleConfiguration?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    let objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
}

extension CreateDataIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case fileConfiguration = "FileConfiguration"
        case kmsKey = "KmsKey"
        case name = "Name"
        case objectConfiguration = "ObjectConfiguration"
        case scheduleConfig = "ScheduleConfig"
        case sourceURI = "SourceURI"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let sourceURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceURI)
        sourceURI = sourceURIDecoded
        let scheduleConfigDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfig)
        scheduleConfig = scheduleConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let fileConfigurationDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.FileConfiguration.self, forKey: .fileConfiguration)
        fileConfiguration = fileConfigurationDecoded
        let objectConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .objectConfiguration)
        var objectConfigurationDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let objectConfigurationContainer = objectConfigurationContainer {
            objectConfigurationDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, fieldsmap0) in objectConfigurationContainer {
                var fieldsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let fieldsmap0 = fieldsmap0 {
                    fieldsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, fieldslist1) in fieldsmap0 {
                        var fieldslist1Decoded1: [Swift.String]? = nil
                        if let fieldslist1 = fieldslist1 {
                            fieldslist1Decoded1 = [Swift.String]()
                            for string2 in fieldslist1 {
                                if let string2 = string2 {
                                    fieldslist1Decoded1?.append(string2)
                                }
                            }
                        }
                        fieldsmap0Decoded0?[key1] = fieldslist1Decoded1
                    }
                }
                objectConfigurationDecoded0?[key0] = fieldsmap0Decoded0
            }
        }
        objectConfiguration = objectConfigurationDecoded0
    }
}

extension CreateDataIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientToken = output.clientToken
            self.description = output.description
            self.fileConfiguration = output.fileConfiguration
            self.id = output.id
            self.kmsKey = output.kmsKey
            self.name = output.name
            self.objectConfiguration = output.objectConfiguration
            self.scheduleConfiguration = output.scheduleConfiguration
            self.sourceURI = output.sourceURI
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientToken = nil
            self.description = nil
            self.fileConfiguration = nil
            self.id = nil
            self.kmsKey = nil
            self.name = nil
            self.objectConfiguration = nil
            self.scheduleConfiguration = nil
            self.sourceURI = nil
            self.tags = nil
        }
    }
}

public struct CreateDataIntegrationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// A unique identifier.
    public var id: Swift.String?
    /// The KMS key for the DataIntegration.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    public var scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        id: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.id = id
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

struct CreateDataIntegrationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let kmsKey: Swift.String?
    let sourceURI: Swift.String?
    let scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    let objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
}

extension CreateDataIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientToken = "ClientToken"
        case description = "Description"
        case fileConfiguration = "FileConfiguration"
        case id = "Id"
        case kmsKey = "KmsKey"
        case name = "Name"
        case objectConfiguration = "ObjectConfiguration"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceURI = "SourceURI"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let sourceURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceURI)
        sourceURI = sourceURIDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let fileConfigurationDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.FileConfiguration.self, forKey: .fileConfiguration)
        fileConfiguration = fileConfigurationDecoded
        let objectConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .objectConfiguration)
        var objectConfigurationDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let objectConfigurationContainer = objectConfigurationContainer {
            objectConfigurationDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, fieldsmap0) in objectConfigurationContainer {
                var fieldsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let fieldsmap0 = fieldsmap0 {
                    fieldsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, fieldslist1) in fieldsmap0 {
                        var fieldslist1Decoded1: [Swift.String]? = nil
                        if let fieldslist1 = fieldslist1 {
                            fieldslist1Decoded1 = [Swift.String]()
                            for string2 in fieldslist1 {
                                if let string2 = string2 {
                                    fieldslist1Decoded1?.append(string2)
                                }
                            }
                        }
                        fieldsmap0Decoded0?[key1] = fieldslist1Decoded1
                    }
                }
                objectConfigurationDecoded0?[key0] = fieldsmap0Decoded0
            }
        }
        objectConfiguration = objectConfigurationDecoded0
    }
}

enum CreateDataIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededException": return try await ResourceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeBus = self.eventBridgeBus {
            try encodeContainer.encode(eventBridgeBus, forKey: .eventBridgeBus)
        }
        if let eventFilter = self.eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEventIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/eventIntegrations"
    }
}

public struct CreateEventIntegrationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the event integration.
    public var description: Swift.String?
    /// The EventBridge bus.
    /// This member is required.
    public var eventBridgeBus: Swift.String?
    /// The event filter.
    /// This member is required.
    public var eventFilter: AppIntegrationsClientTypes.EventFilter?
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        eventBridgeBus: Swift.String? = nil,
        eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.name = name
        self.tags = tags
    }
}

struct CreateEventIntegrationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let eventFilter: AppIntegrationsClientTypes.EventFilter?
    let eventBridgeBus: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEventIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventIntegrationArn = output.eventIntegrationArn
        } else {
            self.eventIntegrationArn = nil
        }
    }
}

public struct CreateEventIntegrationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event integration.
    public var eventIntegrationArn: Swift.String?

    public init(
        eventIntegrationArn: Swift.String? = nil
    )
    {
        self.eventIntegrationArn = eventIntegrationArn
    }
}

struct CreateEventIntegrationOutputBody: Swift.Equatable {
    let eventIntegrationArn: Swift.String?
}

extension CreateEventIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventIntegrationArn = "EventIntegrationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
    }
}

enum CreateEventIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededException": return try await ResourceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppIntegrationsClientTypes.DataIntegrationAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "ClientId"
        case dataIntegrationArn = "DataIntegrationArn"
        case dataIntegrationAssociationArn = "DataIntegrationAssociationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let dataIntegrationArn = self.dataIntegrationArn {
            try encodeContainer.encode(dataIntegrationArn, forKey: .dataIntegrationArn)
        }
        if let dataIntegrationAssociationArn = self.dataIntegrationAssociationArn {
            try encodeContainer.encode(dataIntegrationAssociationArn, forKey: .dataIntegrationAssociationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIntegrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataIntegrationAssociationArn)
        dataIntegrationAssociationArn = dataIntegrationAssociationArnDecoded
        let dataIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataIntegrationArn)
        dataIntegrationArn = dataIntegrationArnDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the DataIntegration association.
    public struct DataIntegrationAssociationSummary: Swift.Equatable {
        /// The identifier for the client that is associated with the DataIntegration association.
        public var clientId: Swift.String?
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public var dataIntegrationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the DataIntegration association.
        public var dataIntegrationAssociationArn: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            dataIntegrationArn: Swift.String? = nil,
            dataIntegrationAssociationArn: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.dataIntegrationArn = dataIntegrationArn
            self.dataIntegrationAssociationArn = dataIntegrationAssociationArn
        }
    }

}

extension AppIntegrationsClientTypes.DataIntegrationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case sourceURI = "SourceURI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceURI = self.sourceURI {
            try encodeContainer.encode(sourceURI, forKey: .sourceURI)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceURI)
        sourceURI = sourceURIDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the DataIntegration.
    public struct DataIntegrationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public var arn: Swift.String?
        /// The name of the DataIntegration.
        public var name: Swift.String?
        /// The URI of the data source.
        public var sourceURI: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceURI: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.sourceURI = sourceURI
        }
    }

}

extension DeleteDataIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataIntegrationIdentifier = dataIntegrationIdentifier else {
            return nil
        }
        return "/dataIntegrations/\(dataIntegrationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteDataIntegrationInput: Swift.Equatable {
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var dataIntegrationIdentifier: Swift.String?

    public init(
        dataIntegrationIdentifier: Swift.String? = nil
    )
    {
        self.dataIntegrationIdentifier = dataIntegrationIdentifier
    }
}

struct DeleteDataIntegrationInputBody: Swift.Equatable {
}

extension DeleteDataIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

public struct DeleteEventIntegrationInput: Swift.Equatable {
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventIntegrationInputBody: Swift.Equatable {
}

extension DeleteEventIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource with the specified name already exists.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppIntegrationsClientTypes.EventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// The event filter.
    public struct EventFilter: Swift.Equatable {
        /// The source of the events.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension AppIntegrationsClientTypes.EventIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case eventIntegrationArn = "EventIntegrationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeBus = self.eventBridgeBus {
            try encodeContainer.encode(eventBridgeBus, forKey: .eventBridgeBus)
        }
        if let eventFilter = self.eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let eventIntegrationArn = self.eventIntegrationArn {
            try encodeContainer.encode(eventIntegrationArn, forKey: .eventIntegrationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppIntegrationsClientTypes {
    /// The event integration.
    public struct EventIntegration: Swift.Equatable {
        /// The event integration description.
        public var description: Swift.String?
        /// The Amazon EventBridge bus for the event integration.
        public var eventBridgeBus: Swift.String?
        /// The event integration filter.
        public var eventFilter: AppIntegrationsClientTypes.EventFilter?
        /// The Amazon Resource Name (ARN) of the event integration.
        public var eventIntegrationArn: Swift.String?
        /// The name of the event integration.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            eventBridgeBus: Swift.String? = nil,
            eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
            eventIntegrationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }
    }

}

extension AppIntegrationsClientTypes.EventIntegrationAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAssociationMetadata = "ClientAssociationMetadata"
        case clientId = "ClientId"
        case eventBridgeRuleName = "EventBridgeRuleName"
        case eventIntegrationAssociationArn = "EventIntegrationAssociationArn"
        case eventIntegrationAssociationId = "EventIntegrationAssociationId"
        case eventIntegrationName = "EventIntegrationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAssociationMetadata = clientAssociationMetadata {
            var clientAssociationMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .clientAssociationMetadata)
            for (dictKey0, clientAssociationMetadata0) in clientAssociationMetadata {
                try clientAssociationMetadataContainer.encode(clientAssociationMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let eventBridgeRuleName = self.eventBridgeRuleName {
            try encodeContainer.encode(eventBridgeRuleName, forKey: .eventBridgeRuleName)
        }
        if let eventIntegrationAssociationArn = self.eventIntegrationAssociationArn {
            try encodeContainer.encode(eventIntegrationAssociationArn, forKey: .eventIntegrationAssociationArn)
        }
        if let eventIntegrationAssociationId = self.eventIntegrationAssociationId {
            try encodeContainer.encode(eventIntegrationAssociationId, forKey: .eventIntegrationAssociationId)
        }
        if let eventIntegrationName = self.eventIntegrationName {
            try encodeContainer.encode(eventIntegrationName, forKey: .eventIntegrationName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationAssociationArn)
        eventIntegrationAssociationArn = eventIntegrationAssociationArnDecoded
        let eventIntegrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationAssociationId)
        eventIntegrationAssociationId = eventIntegrationAssociationIdDecoded
        let eventIntegrationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationName)
        eventIntegrationName = eventIntegrationNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let eventBridgeRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBridgeRuleName)
        eventBridgeRuleName = eventBridgeRuleNameDecoded
        let clientAssociationMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .clientAssociationMetadata)
        var clientAssociationMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let clientAssociationMetadataContainer = clientAssociationMetadataContainer {
            clientAssociationMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonblankstring0) in clientAssociationMetadataContainer {
                if let nonblankstring0 = nonblankstring0 {
                    clientAssociationMetadataDecoded0?[key0] = nonblankstring0
                }
            }
        }
        clientAssociationMetadata = clientAssociationMetadataDecoded0
    }
}

extension AppIntegrationsClientTypes {
    /// The event integration association.
    public struct EventIntegrationAssociation: Swift.Equatable {
        /// The metadata associated with the client.
        public var clientAssociationMetadata: [Swift.String:Swift.String]?
        /// The identifier for the client that is associated with the event integration.
        public var clientId: Swift.String?
        /// The name of the EventBridge rule.
        public var eventBridgeRuleName: Swift.String?
        /// The Amazon Resource Name (ARN) for the event integration association.
        public var eventIntegrationAssociationArn: Swift.String?
        /// The identifier for the event integration association.
        public var eventIntegrationAssociationId: Swift.String?
        /// The name of the event integration.
        public var eventIntegrationName: Swift.String?

        public init(
            clientAssociationMetadata: [Swift.String:Swift.String]? = nil,
            clientId: Swift.String? = nil,
            eventBridgeRuleName: Swift.String? = nil,
            eventIntegrationAssociationArn: Swift.String? = nil,
            eventIntegrationAssociationId: Swift.String? = nil,
            eventIntegrationName: Swift.String? = nil
        )
        {
            self.clientAssociationMetadata = clientAssociationMetadata
            self.clientId = clientId
            self.eventBridgeRuleName = eventBridgeRuleName
            self.eventIntegrationAssociationArn = eventIntegrationAssociationArn
            self.eventIntegrationAssociationId = eventIntegrationAssociationId
            self.eventIntegrationName = eventIntegrationName
        }
    }

}

extension AppIntegrationsClientTypes.ExternalUrlConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessUrl = "AccessUrl"
        case approvedOrigins = "ApprovedOrigins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessUrl = self.accessUrl {
            try encodeContainer.encode(accessUrl, forKey: .accessUrl)
        }
        if let approvedOrigins = approvedOrigins {
            var approvedOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedOrigins)
            for applicationtrustedsource0 in approvedOrigins {
                try approvedOriginsContainer.encode(applicationtrustedsource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessUrl)
        accessUrl = accessUrlDecoded
        let approvedOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedOrigins)
        var approvedOriginsDecoded0:[Swift.String]? = nil
        if let approvedOriginsContainer = approvedOriginsContainer {
            approvedOriginsDecoded0 = [Swift.String]()
            for string0 in approvedOriginsContainer {
                if let string0 = string0 {
                    approvedOriginsDecoded0?.append(string0)
                }
            }
        }
        approvedOrigins = approvedOriginsDecoded0
    }
}

extension AppIntegrationsClientTypes {
    /// The external URL source for the application.
    public struct ExternalUrlConfig: Swift.Equatable {
        /// The URL to access the application.
        /// This member is required.
        public var accessUrl: Swift.String?
        /// Additional URLs to allow list if different than the access URL.
        public var approvedOrigins: [Swift.String]?

        public init(
            accessUrl: Swift.String? = nil,
            approvedOrigins: [Swift.String]? = nil
        )
        {
            self.accessUrl = accessUrl
            self.approvedOrigins = approvedOrigins
        }
    }

}

extension AppIntegrationsClientTypes.FileConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case folders = "Folders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, fieldsMap0) in filters {
                var fieldsMap0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for fields1 in fieldsMap0 {
                    try fieldsMap0Container.encode(fields1)
                }
            }
        }
        if let folders = folders {
            var foldersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folders)
            for nonblanklongstring0 in folders {
                try foldersContainer.encode(nonblanklongstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .folders)
        var foldersDecoded0:[Swift.String]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [Swift.String]()
            for string0 in foldersContainer {
                if let string0 = string0 {
                    foldersDecoded0?.append(string0)
                }
            }
        }
        folders = foldersDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, fieldslist0) in filtersContainer {
                var fieldslist0Decoded0: [Swift.String]? = nil
                if let fieldslist0 = fieldslist0 {
                    fieldslist0Decoded0 = [Swift.String]()
                    for string1 in fieldslist0 {
                        if let string1 = string1 {
                            fieldslist0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = fieldslist0Decoded0
            }
        }
        filters = filtersDecoded0
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration for what files should be pulled from the source.
    public struct FileConfiguration: Swift.Equatable {
        /// Restrictions for what files should be pulled from the source.
        public var filters: [Swift.String:[Swift.String]]?
        /// Identifiers for the source folders to pull all files from recursively.
        /// This member is required.
        public var folders: [Swift.String]?

        public init(
            filters: [Swift.String:[Swift.String]]? = nil,
            folders: [Swift.String]? = nil
        )
        {
            self.filters = filters
            self.folders = folders
        }
    }

}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/applications/\(arn.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Application.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationSourceConfig = output.applicationSourceConfig
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.namespace = output.namespace
            self.publications = output.publications
            self.subscriptions = output.subscriptions
            self.tags = output.tags
        } else {
            self.applicationSourceConfig = nil
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.namespace = nil
            self.publications = nil
            self.subscriptions = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The configuration for where the application should be loaded from.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// The Amazon Resource Name (ARN) of the Application.
    public var arn: Swift.String?
    /// The created time of the Application.
    public var createdTime: ClientRuntime.Date?
    /// The description of the application.
    public var description: Swift.String?
    /// A unique identifier for the Application.
    public var id: Swift.String?
    /// The last modified time of the Application.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The namespace of the application.
    public var namespace: Swift.String?
    /// The events that the application publishes.
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.namespace = namespace
        self.publications = publications
        self.subscriptions = subscriptions
        self.tags = tags
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let namespace: Swift.String?
    let description: Swift.String?
    let applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    let subscriptions: [AppIntegrationsClientTypes.Subscription]?
    let publications: [AppIntegrationsClientTypes.Publication]?
    let createdTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSourceConfig = "ApplicationSourceConfig"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case namespace = "Namespace"
        case publications = "Publications"
        case subscriptions = "Subscriptions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationSourceConfigDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ApplicationSourceConfig.self, forKey: .applicationSourceConfig)
        applicationSourceConfig = applicationSourceConfigDecoded
        let subscriptionsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[AppIntegrationsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [AppIntegrationsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let publicationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Publication?].self, forKey: .publications)
        var publicationsDecoded0:[AppIntegrationsClientTypes.Publication]? = nil
        if let publicationsContainer = publicationsContainer {
            publicationsDecoded0 = [AppIntegrationsClientTypes.Publication]()
            for structure0 in publicationsContainer {
                if let structure0 = structure0 {
                    publicationsDecoded0?.append(structure0)
                }
            }
        }
        publications = publicationsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/dataIntegrations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataIntegrationInput: Swift.Equatable {
    /// A unique identifier.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetDataIntegrationInputBody: Swift.Equatable {
}

extension GetDataIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.fileConfiguration = output.fileConfiguration
            self.id = output.id
            self.kmsKey = output.kmsKey
            self.name = output.name
            self.objectConfiguration = output.objectConfiguration
            self.scheduleConfiguration = output.scheduleConfiguration
            self.sourceURI = output.sourceURI
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.fileConfiguration = nil
            self.id = nil
            self.kmsKey = nil
            self.name = nil
            self.objectConfiguration = nil
            self.scheduleConfiguration = nil
            self.sourceURI = nil
            self.tags = nil
        }
    }
}

public struct GetDataIntegrationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the DataIntegration.
    public var arn: Swift.String?
    /// The KMS key for the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// A unique identifier.
    public var id: Swift.String?
    /// The KMS key for the DataIntegration.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    public var scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        id: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.id = id
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

struct GetDataIntegrationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let kmsKey: Swift.String?
    let sourceURI: Swift.String?
    let scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    let tags: [Swift.String:Swift.String]?
    let fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    let objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
}

extension GetDataIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case fileConfiguration = "FileConfiguration"
        case id = "Id"
        case kmsKey = "KmsKey"
        case name = "Name"
        case objectConfiguration = "ObjectConfiguration"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceURI = "SourceURI"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let sourceURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceURI)
        sourceURI = sourceURIDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let fileConfigurationDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.FileConfiguration.self, forKey: .fileConfiguration)
        fileConfiguration = fileConfigurationDecoded
        let objectConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .objectConfiguration)
        var objectConfigurationDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let objectConfigurationContainer = objectConfigurationContainer {
            objectConfigurationDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, fieldsmap0) in objectConfigurationContainer {
                var fieldsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let fieldsmap0 = fieldsmap0 {
                    fieldsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, fieldslist1) in fieldsmap0 {
                        var fieldslist1Decoded1: [Swift.String]? = nil
                        if let fieldslist1 = fieldslist1 {
                            fieldslist1Decoded1 = [Swift.String]()
                            for string2 in fieldslist1 {
                                if let string2 = string2 {
                                    fieldslist1Decoded1?.append(string2)
                                }
                            }
                        }
                        fieldsmap0Decoded0?[key1] = fieldslist1Decoded1
                    }
                }
                objectConfigurationDecoded0?[key0] = fieldsmap0Decoded0
            }
        }
        objectConfiguration = objectConfigurationDecoded0
    }
}

enum GetDataIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

public struct GetEventIntegrationInput: Swift.Equatable {
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEventIntegrationInputBody: Swift.Equatable {
}

extension GetEventIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.eventBridgeBus = output.eventBridgeBus
            self.eventFilter = output.eventFilter
            self.eventIntegrationArn = output.eventIntegrationArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.description = nil
            self.eventBridgeBus = nil
            self.eventFilter = nil
            self.eventIntegrationArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetEventIntegrationOutput: Swift.Equatable {
    /// The description of the event integration.
    public var description: Swift.String?
    /// The EventBridge bus.
    public var eventBridgeBus: Swift.String?
    /// The event filter.
    public var eventFilter: AppIntegrationsClientTypes.EventFilter?
    /// The Amazon Resource Name (ARN) for the event integration.
    public var eventIntegrationArn: Swift.String?
    /// The name of the event integration.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        eventBridgeBus: Swift.String? = nil,
        eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
        eventIntegrationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.eventIntegrationArn = eventIntegrationArn
        self.name = name
        self.tags = tags
    }
}

struct GetEventIntegrationOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let eventIntegrationArn: Swift.String?
    let eventBridgeBus: Swift.String?
    let eventFilter: AppIntegrationsClientTypes.EventFilter?
    let tags: [Swift.String:Swift.String]?
}

extension GetEventIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeBus = "EventBridgeBus"
        case eventFilter = "EventFilter"
        case eventIntegrationArn = "EventIntegrationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIntegrationArn)
        eventIntegrationArn = eventIntegrationArnDecoded
        let eventBridgeBusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBridgeBus)
        eventBridgeBus = eventBridgeBusDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetEventIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request processing failed due to an error or failure with the service.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The Applications associated with this account.
    public var applications: [AppIntegrationsClientTypes.ApplicationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [AppIntegrationsClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [AppIntegrationsClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[AppIntegrationsClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppIntegrationsClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataIntegrationAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataIntegrationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataIntegrationIdentifier = dataIntegrationIdentifier else {
            return nil
        }
        return "/dataIntegrations/\(dataIntegrationIdentifier.urlPercentEncoding())/associations"
    }
}

public struct ListDataIntegrationAssociationsInput: Swift.Equatable {
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var dataIntegrationIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrationIdentifier = dataIntegrationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataIntegrationAssociationsInputBody: Swift.Equatable {
}

extension ListDataIntegrationAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataIntegrationAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataIntegrationAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataIntegrationAssociations = output.dataIntegrationAssociations
            self.nextToken = output.nextToken
        } else {
            self.dataIntegrationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataIntegrationAssociationsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) and unique ID of the DataIntegration association.
    public var dataIntegrationAssociations: [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrationAssociations: [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrationAssociations = dataIntegrationAssociations
        self.nextToken = nextToken
    }
}

struct ListDataIntegrationAssociationsOutputBody: Swift.Equatable {
    let dataIntegrationAssociations: [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListDataIntegrationAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataIntegrationAssociations = "DataIntegrationAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIntegrationAssociationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.DataIntegrationAssociationSummary?].self, forKey: .dataIntegrationAssociations)
        var dataIntegrationAssociationsDecoded0:[AppIntegrationsClientTypes.DataIntegrationAssociationSummary]? = nil
        if let dataIntegrationAssociationsContainer = dataIntegrationAssociationsContainer {
            dataIntegrationAssociationsDecoded0 = [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]()
            for structure0 in dataIntegrationAssociationsContainer {
                if let structure0 = structure0 {
                    dataIntegrationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        dataIntegrationAssociations = dataIntegrationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataIntegrationAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataIntegrations"
    }
}

public struct ListDataIntegrationsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataIntegrationsInputBody: Swift.Equatable {
}

extension ListDataIntegrationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataIntegrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataIntegrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataIntegrations = output.dataIntegrations
            self.nextToken = output.nextToken
        } else {
            self.dataIntegrations = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataIntegrationsOutput: Swift.Equatable {
    /// The DataIntegrations associated with this account.
    public var dataIntegrations: [AppIntegrationsClientTypes.DataIntegrationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrations: [AppIntegrationsClientTypes.DataIntegrationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrations = dataIntegrations
        self.nextToken = nextToken
    }
}

struct ListDataIntegrationsOutputBody: Swift.Equatable {
    let dataIntegrations: [AppIntegrationsClientTypes.DataIntegrationSummary]?
    let nextToken: Swift.String?
}

extension ListDataIntegrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataIntegrations = "DataIntegrations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIntegrationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.DataIntegrationSummary?].self, forKey: .dataIntegrations)
        var dataIntegrationsDecoded0:[AppIntegrationsClientTypes.DataIntegrationSummary]? = nil
        if let dataIntegrationsContainer = dataIntegrationsContainer {
            dataIntegrationsDecoded0 = [AppIntegrationsClientTypes.DataIntegrationSummary]()
            for structure0 in dataIntegrationsContainer {
                if let structure0 = structure0 {
                    dataIntegrationsDecoded0?.append(structure0)
                }
            }
        }
        dataIntegrations = dataIntegrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataIntegrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventIntegrationAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEventIntegrationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let eventIntegrationName = eventIntegrationName else {
            return nil
        }
        return "/eventIntegrations/\(eventIntegrationName.urlPercentEncoding())/associations"
    }
}

public struct ListEventIntegrationAssociationsInput: Swift.Equatable {
    /// The name of the event integration.
    /// This member is required.
    public var eventIntegrationName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrationName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrationName = eventIntegrationName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationAssociationsInputBody: Swift.Equatable {
}

extension ListEventIntegrationAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventIntegrationAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventIntegrationAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventIntegrationAssociations = output.eventIntegrationAssociations
            self.nextToken = output.nextToken
        } else {
            self.eventIntegrationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventIntegrationAssociationsOutput: Swift.Equatable {
    /// The event integration associations.
    public var eventIntegrationAssociations: [AppIntegrationsClientTypes.EventIntegrationAssociation]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrationAssociations: [AppIntegrationsClientTypes.EventIntegrationAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrationAssociations = eventIntegrationAssociations
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationAssociationsOutputBody: Swift.Equatable {
    let eventIntegrationAssociations: [AppIntegrationsClientTypes.EventIntegrationAssociation]?
    let nextToken: Swift.String?
}

extension ListEventIntegrationAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventIntegrationAssociations = "EventIntegrationAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationAssociationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.EventIntegrationAssociation?].self, forKey: .eventIntegrationAssociations)
        var eventIntegrationAssociationsDecoded0:[AppIntegrationsClientTypes.EventIntegrationAssociation]? = nil
        if let eventIntegrationAssociationsContainer = eventIntegrationAssociationsContainer {
            eventIntegrationAssociationsDecoded0 = [AppIntegrationsClientTypes.EventIntegrationAssociation]()
            for structure0 in eventIntegrationAssociationsContainer {
                if let structure0 = structure0 {
                    eventIntegrationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        eventIntegrationAssociations = eventIntegrationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventIntegrationAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEventIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/eventIntegrations"
    }
}

public struct ListEventIntegrationsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationsInputBody: Swift.Equatable {
}

extension ListEventIntegrationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventIntegrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventIntegrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventIntegrations = output.eventIntegrations
            self.nextToken = output.nextToken
        } else {
            self.eventIntegrations = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventIntegrationsOutput: Swift.Equatable {
    /// The event integrations.
    public var eventIntegrations: [AppIntegrationsClientTypes.EventIntegration]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrations: [AppIntegrationsClientTypes.EventIntegration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrations = eventIntegrations
        self.nextToken = nextToken
    }
}

struct ListEventIntegrationsOutputBody: Swift.Equatable {
    let eventIntegrations: [AppIntegrationsClientTypes.EventIntegration]?
    let nextToken: Swift.String?
}

extension ListEventIntegrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventIntegrations = "EventIntegrations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIntegrationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.EventIntegration?].self, forKey: .eventIntegrations)
        var eventIntegrationsDecoded0:[AppIntegrationsClientTypes.EventIntegration]? = nil
        if let eventIntegrationsContainer = eventIntegrationsContainer {
            eventIntegrationsDecoded0 = [AppIntegrationsClientTypes.EventIntegration]()
            for structure0 in eventIntegrationsContainer {
                if let structure0 = structure0 {
                    eventIntegrationsDecoded0?.append(structure0)
                }
            }
        }
        eventIntegrations = eventIntegrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventIntegrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppIntegrationsClientTypes.Publication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case event = "Event"
        case schema = "Schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration of an event that the application publishes.
    public struct Publication: Swift.Equatable {
        /// The description of the publication.
        public var description: Swift.String?
        /// The name of the publication.
        /// This member is required.
        public var event: Swift.String?
        /// The JSON schema of the publication event.
        /// This member is required.
        public var schema: Swift.String?

        public init(
            description: Swift.String? = nil,
            event: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.description = description
            self.event = event
            self.schema = schema
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The allowed quota for the resource has been exceeded.
public struct ResourceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppIntegrationsClientTypes.ScheduleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstExecutionFrom = "FirstExecutionFrom"
        case object = "Object"
        case scheduleExpression = "ScheduleExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstExecutionFrom = self.firstExecutionFrom {
            try encodeContainer.encode(firstExecutionFrom, forKey: .firstExecutionFrom)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstExecutionFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// The name of the data and how often it should be pulled from the source.
    public struct ScheduleConfiguration: Swift.Equatable {
        /// The start date for objects to import in the first flow run as an Unix/epoch timestamp in milliseconds or in ISO-8601 format.
        public var firstExecutionFrom: Swift.String?
        /// The name of the object to pull from the data source.
        public var object: Swift.String?
        /// How often the data should be pulled from data source.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init(
            firstExecutionFrom: Swift.String? = nil,
            object: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil
        )
        {
            self.firstExecutionFrom = firstExecutionFrom
            self.object = object
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension AppIntegrationsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case event = "Event"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration of an event that the application subscribes.
    public struct Subscription: Swift.Equatable {
        /// The description of the subscription.
        public var description: Swift.String?
        /// The name of the subscription.
        /// This member is required.
        public var event: Swift.String?

        public init(
            description: Swift.String? = nil,
            event: Swift.String? = nil
        )
        {
            self.description = description
            self.event = event
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSourceConfig = "ApplicationSourceConfig"
        case description = "Description"
        case name = "Name"
        case publications = "Publications"
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSourceConfig = self.applicationSourceConfig {
            try encodeContainer.encode(applicationSourceConfig, forKey: .applicationSourceConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publications = publications {
            var publicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .publications)
            for publication0 in publications {
                try publicationsContainer.encode(publication0)
            }
        }
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/applications/\(arn.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The configuration for where the application should be loaded from.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// The Amazon Resource Name (ARN) of the Application.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The name of the application.
    public var name: Swift.String?
    /// The events that the application publishes.
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.arn = arn
        self.description = description
        self.name = name
        self.publications = publications
        self.subscriptions = subscriptions
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    let subscriptions: [AppIntegrationsClientTypes.Subscription]?
    let publications: [AppIntegrationsClientTypes.Publication]?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSourceConfig = "ApplicationSourceConfig"
        case description = "Description"
        case name = "Name"
        case publications = "Publications"
        case subscriptions = "Subscriptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationSourceConfigDecoded = try containerValues.decodeIfPresent(AppIntegrationsClientTypes.ApplicationSourceConfig.self, forKey: .applicationSourceConfig)
        applicationSourceConfig = applicationSourceConfigDecoded
        let subscriptionsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[AppIntegrationsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [AppIntegrationsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let publicationsContainer = try containerValues.decodeIfPresent([AppIntegrationsClientTypes.Publication?].self, forKey: .publications)
        var publicationsDecoded0:[AppIntegrationsClientTypes.Publication]? = nil
        if let publicationsContainer = publicationsContainer {
            publicationsDecoded0 = [AppIntegrationsClientTypes.Publication]()
            for structure0 in publicationsContainer {
                if let structure0 = structure0 {
                    publicationsDecoded0?.append(structure0)
                }
            }
        }
        publications = publicationsDecoded0
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDataIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/dataIntegrations/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateDataIntegrationInput: Swift.Equatable {
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.name = name
    }
}

struct UpdateDataIntegrationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateDataIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDataIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateEventIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

public struct UpdateEventIntegrationInput: Swift.Equatable {
    /// The description of the event integration.
    public var description: Swift.String?
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateEventIntegrationInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateEventIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateEventIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEventIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEventIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
