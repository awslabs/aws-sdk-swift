// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum AppIntegrationsClientTypes {}

extension AppIntegrationsClientTypes.ApplicationAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.ApplicationAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.ApplicationAssociationSummary()
        value.applicationAssociationArn = try reader["ApplicationAssociationArn"].readIfPresent()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.clientId = try reader["ClientId"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the Application Association.
    public struct ApplicationAssociationSummary {
        /// The Amazon Resource Name (ARN) of the Application.
        public var applicationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Application Association.
        public var applicationAssociationArn: Swift.String?
        /// The identifier for the client that is associated with the Application Association.
        public var clientId: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            applicationAssociationArn: Swift.String? = nil,
            clientId: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.applicationAssociationArn = applicationAssociationArn
            self.clientId = clientId
        }
    }

}

extension AppIntegrationsClientTypes.ApplicationSourceConfig {

    static func write(value: AppIntegrationsClientTypes.ApplicationSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalUrlConfig"].write(value.externalUrlConfig, with: AppIntegrationsClientTypes.ExternalUrlConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.ApplicationSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.ApplicationSourceConfig()
        value.externalUrlConfig = try reader["ExternalUrlConfig"].readIfPresent(with: AppIntegrationsClientTypes.ExternalUrlConfig.read(from:))
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration for where the application should be loaded from.
    public struct ApplicationSourceConfig {
        /// The external URL source for the application.
        public var externalUrlConfig: AppIntegrationsClientTypes.ExternalUrlConfig?

        public init(
            externalUrlConfig: AppIntegrationsClientTypes.ExternalUrlConfig? = nil
        )
        {
            self.externalUrlConfig = externalUrlConfig
        }
    }

}

extension AppIntegrationsClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.ApplicationSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the Application.
    public struct ApplicationSummary {
        /// The Amazon Resource Name (ARN) of the Application.
        public var arn: Swift.String?
        /// The time when the application was created.
        public var createdTime: ClientRuntime.Date?
        /// A unique identifier for the Application.
        public var id: Swift.String?
        /// The time when the application was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the application.
        public var name: Swift.String?
        /// The namespace of the application.
        public var namespace: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
        }
    }

}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationSourceConfig"].write(value.applicationSourceConfig, with: AppIntegrationsClientTypes.ApplicationSourceConfig.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Namespace"].write(value.namespace)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Publications"].writeList(value.publications, memberWritingClosure: AppIntegrationsClientTypes.Publication.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: AppIntegrationsClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateApplicationInput {
    /// The configuration for where the application should be loaded from.
    /// This member is required.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The name of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the application.
    /// This member is required.
    public var namespace: Swift.String?
    /// The configuration of events or requests that the application has access to.
    public var permissions: [Swift.String]?
    /// The events that the application publishes.
    @available(*, deprecated, message: "Publications has been replaced with Permissions")
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    @available(*, deprecated, message: "Subscriptions has been replaced with Permissions")
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.namespace = namespace
        self.permissions = permissions
        self.publications = publications
        self.subscriptions = subscriptions
        self.tags = tags
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

public struct CreateApplicationOutput {
    /// The Amazon Resource Name (ARN) of the Application.
    public var arn: Swift.String?
    /// A unique identifier for the Application.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceQuotaExceededException": return try ResourceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDataIntegrationInput {

    static func urlPathProvider(_ value: CreateDataIntegrationInput) -> Swift.String? {
        return "/dataIntegrations"
    }
}

extension CreateDataIntegrationInput {

    static func write(value: CreateDataIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["FileConfiguration"].write(value.fileConfiguration, with: AppIntegrationsClientTypes.FileConfiguration.write(value:to:))
        try writer["KmsKey"].write(value.kmsKey)
        try writer["Name"].write(value.name)
        try writer["ObjectConfiguration"].writeMap(value.objectConfiguration, valueWritingClosure: mapWritingClosure(valueWritingClosure: listWritingClosure(memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ScheduleConfig"].write(value.scheduleConfig, with: AppIntegrationsClientTypes.ScheduleConfiguration.write(value:to:))
        try writer["SourceURI"].write(value.sourceURI)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateDataIntegrationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// The KMS key for the DataIntegration.
    /// This member is required.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    public var scheduleConfig: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    /// This member is required.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfig: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfig = scheduleConfig
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

extension CreateDataIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDataIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataIntegrationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.clientToken = try reader["ClientToken"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.fileConfiguration = try reader["FileConfiguration"].readIfPresent(with: AppIntegrationsClientTypes.FileConfiguration.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.kmsKey = try reader["KmsKey"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.objectConfiguration = try reader["ObjectConfiguration"].readMapIfPresent(valueReadingClosure: mapReadingClosure(valueReadingClosure: listReadingClosure(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.scheduleConfiguration = try reader["ScheduleConfiguration"].readIfPresent(with: AppIntegrationsClientTypes.ScheduleConfiguration.read(from:))
        value.sourceURI = try reader["SourceURI"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateDataIntegrationOutput {
    /// The Amazon Resource Name (ARN)
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// A unique identifier.
    public var id: Swift.String?
    /// The KMS key for the DataIntegration.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    public var scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        id: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.id = id
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

enum CreateDataIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceQuotaExceededException": return try ResourceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateEventIntegrationInput {

    static func urlPathProvider(_ value: CreateEventIntegrationInput) -> Swift.String? {
        return "/eventIntegrations"
    }
}

extension CreateEventIntegrationInput {

    static func write(value: CreateEventIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["EventBridgeBus"].write(value.eventBridgeBus)
        try writer["EventFilter"].write(value.eventFilter, with: AppIntegrationsClientTypes.EventFilter.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateEventIntegrationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the event integration.
    public var description: Swift.String?
    /// The EventBridge bus.
    /// This member is required.
    public var eventBridgeBus: Swift.String?
    /// The event filter.
    /// This member is required.
    public var eventFilter: AppIntegrationsClientTypes.EventFilter?
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        eventBridgeBus: Swift.String? = nil,
        eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.name = name
        self.tags = tags
    }
}

extension CreateEventIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateEventIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventIntegrationOutput()
        value.eventIntegrationArn = try reader["EventIntegrationArn"].readIfPresent()
        return value
    }
}

public struct CreateEventIntegrationOutput {
    /// The Amazon Resource Name (ARN) of the event integration.
    public var eventIntegrationArn: Swift.String?

    public init(
        eventIntegrationArn: Swift.String? = nil
    )
    {
        self.eventIntegrationArn = eventIntegrationArn
    }
}

enum CreateEventIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceQuotaExceededException": return try ResourceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppIntegrationsClientTypes.DataIntegrationAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.DataIntegrationAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.DataIntegrationAssociationSummary()
        value.dataIntegrationAssociationArn = try reader["DataIntegrationAssociationArn"].readIfPresent()
        value.dataIntegrationArn = try reader["DataIntegrationArn"].readIfPresent()
        value.clientId = try reader["ClientId"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the DataIntegration association.
    public struct DataIntegrationAssociationSummary {
        /// The identifier for the client that is associated with the DataIntegration association.
        public var clientId: Swift.String?
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public var dataIntegrationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the DataIntegration association.
        public var dataIntegrationAssociationArn: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            dataIntegrationArn: Swift.String? = nil,
            dataIntegrationAssociationArn: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.dataIntegrationArn = dataIntegrationArn
            self.dataIntegrationAssociationArn = dataIntegrationAssociationArn
        }
    }

}

extension AppIntegrationsClientTypes.DataIntegrationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.DataIntegrationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.DataIntegrationSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.sourceURI = try reader["SourceURI"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// Summary information about the DataIntegration.
    public struct DataIntegrationSummary {
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public var arn: Swift.String?
        /// The name of the DataIntegration.
        public var name: Swift.String?
        /// The URI of the data source.
        public var sourceURI: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceURI: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.sourceURI = sourceURI
        }
    }

}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/applications/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput {
    /// The Amazon Resource Name (ARN) of the Application.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDataIntegrationInput {

    static func urlPathProvider(_ value: DeleteDataIntegrationInput) -> Swift.String? {
        guard let dataIntegrationIdentifier = value.dataIntegrationIdentifier else {
            return nil
        }
        return "/dataIntegrations/\(dataIntegrationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteDataIntegrationInput {
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var dataIntegrationIdentifier: Swift.String?

    public init(
        dataIntegrationIdentifier: Swift.String? = nil
    )
    {
        self.dataIntegrationIdentifier = dataIntegrationIdentifier
    }
}

extension DeleteDataIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDataIntegrationOutput {
        return DeleteDataIntegrationOutput()
    }
}

public struct DeleteDataIntegrationOutput {

    public init() { }
}

enum DeleteDataIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteEventIntegrationInput {

    static func urlPathProvider(_ value: DeleteEventIntegrationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

public struct DeleteEventIntegrationInput {
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension DeleteEventIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteEventIntegrationOutput {
        return DeleteEventIntegrationOutput()
    }
}

public struct DeleteEventIntegrationOutput {

    public init() { }
}

enum DeleteEventIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DuplicateResourceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DuplicateResourceException {
        let reader = baseError.errorBodyReader
        var value = DuplicateResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A resource with the specified name already exists.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppIntegrationsClientTypes.EventFilter {

    static func write(value: AppIntegrationsClientTypes.EventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Source"].write(value.source)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.EventFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.EventFilter()
        value.source = try reader["Source"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The event filter.
    public struct EventFilter {
        /// The source of the events.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension AppIntegrationsClientTypes.EventIntegration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.EventIntegration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.EventIntegration()
        value.eventIntegrationArn = try reader["EventIntegrationArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.eventFilter = try reader["EventFilter"].readIfPresent(with: AppIntegrationsClientTypes.EventFilter.read(from:))
        value.eventBridgeBus = try reader["EventBridgeBus"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The event integration.
    public struct EventIntegration {
        /// The event integration description.
        public var description: Swift.String?
        /// The Amazon EventBridge bus for the event integration.
        public var eventBridgeBus: Swift.String?
        /// The event integration filter.
        public var eventFilter: AppIntegrationsClientTypes.EventFilter?
        /// The Amazon Resource Name (ARN) of the event integration.
        public var eventIntegrationArn: Swift.String?
        /// The name of the event integration.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            eventBridgeBus: Swift.String? = nil,
            eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
            eventIntegrationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }
    }

}

extension AppIntegrationsClientTypes.EventIntegrationAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.EventIntegrationAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.EventIntegrationAssociation()
        value.eventIntegrationAssociationArn = try reader["EventIntegrationAssociationArn"].readIfPresent()
        value.eventIntegrationAssociationId = try reader["EventIntegrationAssociationId"].readIfPresent()
        value.eventIntegrationName = try reader["EventIntegrationName"].readIfPresent()
        value.clientId = try reader["ClientId"].readIfPresent()
        value.eventBridgeRuleName = try reader["EventBridgeRuleName"].readIfPresent()
        value.clientAssociationMetadata = try reader["ClientAssociationMetadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The event integration association.
    public struct EventIntegrationAssociation {
        /// The metadata associated with the client.
        public var clientAssociationMetadata: [Swift.String:Swift.String]?
        /// The identifier for the client that is associated with the event integration.
        public var clientId: Swift.String?
        /// The name of the EventBridge rule.
        public var eventBridgeRuleName: Swift.String?
        /// The Amazon Resource Name (ARN) for the event integration association.
        public var eventIntegrationAssociationArn: Swift.String?
        /// The identifier for the event integration association.
        public var eventIntegrationAssociationId: Swift.String?
        /// The name of the event integration.
        public var eventIntegrationName: Swift.String?

        public init(
            clientAssociationMetadata: [Swift.String:Swift.String]? = nil,
            clientId: Swift.String? = nil,
            eventBridgeRuleName: Swift.String? = nil,
            eventIntegrationAssociationArn: Swift.String? = nil,
            eventIntegrationAssociationId: Swift.String? = nil,
            eventIntegrationName: Swift.String? = nil
        )
        {
            self.clientAssociationMetadata = clientAssociationMetadata
            self.clientId = clientId
            self.eventBridgeRuleName = eventBridgeRuleName
            self.eventIntegrationAssociationArn = eventIntegrationAssociationArn
            self.eventIntegrationAssociationId = eventIntegrationAssociationId
            self.eventIntegrationName = eventIntegrationName
        }
    }

}

extension AppIntegrationsClientTypes.ExternalUrlConfig {

    static func write(value: AppIntegrationsClientTypes.ExternalUrlConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessUrl"].write(value.accessUrl)
        try writer["ApprovedOrigins"].writeList(value.approvedOrigins, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.ExternalUrlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.ExternalUrlConfig()
        value.accessUrl = try reader["AccessUrl"].readIfPresent()
        value.approvedOrigins = try reader["ApprovedOrigins"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The external URL source for the application.
    public struct ExternalUrlConfig {
        /// The URL to access the application.
        /// This member is required.
        public var accessUrl: Swift.String?
        /// Additional URLs to allow list if different than the access URL.
        public var approvedOrigins: [Swift.String]?

        public init(
            accessUrl: Swift.String? = nil,
            approvedOrigins: [Swift.String]? = nil
        )
        {
            self.accessUrl = accessUrl
            self.approvedOrigins = approvedOrigins
        }
    }

}

extension AppIntegrationsClientTypes.FileConfiguration {

    static func write(value: AppIntegrationsClientTypes.FileConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: listWritingClosure(memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Folders"].writeList(value.folders, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.FileConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.FileConfiguration()
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filters = try reader["Filters"].readMapIfPresent(valueReadingClosure: listReadingClosure(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration for what files should be pulled from the source.
    public struct FileConfiguration {
        /// Restrictions for what files should be pulled from the source.
        public var filters: [Swift.String:[Swift.String]]?
        /// Identifiers for the source folders to pull all files from recursively.
        /// This member is required.
        public var folders: [Swift.String]?

        public init(
            filters: [Swift.String:[Swift.String]]? = nil,
            folders: [Swift.String]? = nil
        )
        {
            self.filters = filters
            self.folders = folders
        }
    }

}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/applications/\(arn.urlPercentEncoding())"
    }
}

public struct GetApplicationInput {
    /// The Amazon Resource Name (ARN) of the Application.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.applicationSourceConfig = try reader["ApplicationSourceConfig"].readIfPresent(with: AppIntegrationsClientTypes.ApplicationSourceConfig.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.publications = try reader["Publications"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.Publication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetApplicationOutput {
    /// The configuration for where the application should be loaded from.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// The Amazon Resource Name (ARN) of the Application.
    public var arn: Swift.String?
    /// The created time of the Application.
    public var createdTime: ClientRuntime.Date?
    /// The description of the application.
    public var description: Swift.String?
    /// A unique identifier for the Application.
    public var id: Swift.String?
    /// The last modified time of the Application.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The namespace of the application.
    public var namespace: Swift.String?
    /// The configuration of events or requests that the application has access to.
    public var permissions: [Swift.String]?
    /// The events that the application publishes.
    @available(*, deprecated, message: "Publications has been replaced with Permissions")
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    @available(*, deprecated, message: "Subscriptions has been replaced with Permissions")
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.namespace = namespace
        self.permissions = permissions
        self.publications = publications
        self.subscriptions = subscriptions
        self.tags = tags
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDataIntegrationInput {

    static func urlPathProvider(_ value: GetDataIntegrationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/dataIntegrations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataIntegrationInput {
    /// A unique identifier.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

extension GetDataIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDataIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataIntegrationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.fileConfiguration = try reader["FileConfiguration"].readIfPresent(with: AppIntegrationsClientTypes.FileConfiguration.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.kmsKey = try reader["KmsKey"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.objectConfiguration = try reader["ObjectConfiguration"].readMapIfPresent(valueReadingClosure: mapReadingClosure(valueReadingClosure: listReadingClosure(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.scheduleConfiguration = try reader["ScheduleConfiguration"].readIfPresent(with: AppIntegrationsClientTypes.ScheduleConfiguration.read(from:))
        value.sourceURI = try reader["SourceURI"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetDataIntegrationOutput {
    /// The Amazon Resource Name (ARN) for the DataIntegration.
    public var arn: Swift.String?
    /// The KMS key for the DataIntegration.
    public var description: Swift.String?
    /// The configuration for what files should be pulled from the source.
    public var fileConfiguration: AppIntegrationsClientTypes.FileConfiguration?
    /// A unique identifier.
    public var id: Swift.String?
    /// The KMS key for the DataIntegration.
    public var kmsKey: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?
    /// The configuration for what data should be pulled from the source.
    public var objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]?
    /// The name of the data and how often it should be pulled from the source.
    public var scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration?
    /// The URI of the data source.
    public var sourceURI: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        fileConfiguration: AppIntegrationsClientTypes.FileConfiguration? = nil,
        id: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        objectConfiguration: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        scheduleConfiguration: AppIntegrationsClientTypes.ScheduleConfiguration? = nil,
        sourceURI: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.fileConfiguration = fileConfiguration
        self.id = id
        self.kmsKey = kmsKey
        self.name = name
        self.objectConfiguration = objectConfiguration
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceURI = sourceURI
        self.tags = tags
    }
}

enum GetDataIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEventIntegrationInput {

    static func urlPathProvider(_ value: GetEventIntegrationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

public struct GetEventIntegrationInput {
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GetEventIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEventIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventIntegrationOutput()
        value.description = try reader["Description"].readIfPresent()
        value.eventBridgeBus = try reader["EventBridgeBus"].readIfPresent()
        value.eventFilter = try reader["EventFilter"].readIfPresent(with: AppIntegrationsClientTypes.EventFilter.read(from:))
        value.eventIntegrationArn = try reader["EventIntegrationArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetEventIntegrationOutput {
    /// The description of the event integration.
    public var description: Swift.String?
    /// The EventBridge bus.
    public var eventBridgeBus: Swift.String?
    /// The event filter.
    public var eventFilter: AppIntegrationsClientTypes.EventFilter?
    /// The Amazon Resource Name (ARN) for the event integration.
    public var eventIntegrationArn: Swift.String?
    /// The name of the event integration.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        eventBridgeBus: Swift.String? = nil,
        eventFilter: AppIntegrationsClientTypes.EventFilter? = nil,
        eventIntegrationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.eventBridgeBus = eventBridgeBus
        self.eventFilter = eventFilter
        self.eventIntegrationArn = eventIntegrationArn
        self.name = name
        self.tags = tags
    }
}

enum GetEventIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServiceError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceError {
        let reader = baseError.errorBodyReader
        var value = InternalServiceError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Request processing failed due to an error or failure with the service.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListApplicationAssociationsInput {

    static func queryItemProvider(_ value: ListApplicationAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationAssociationsInput {

    static func urlPathProvider(_ value: ListApplicationAssociationsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/associations"
    }
}

public struct ListApplicationAssociationsInput {
    /// A unique identifier for the Application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListApplicationAssociationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListApplicationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationAssociationsOutput()
        value.applicationAssociations = try reader["ApplicationAssociations"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.ApplicationAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListApplicationAssociationsOutput {
    /// List of Application Associations for the Application.
    public var applicationAssociations: [AppIntegrationsClientTypes.ApplicationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationAssociations: [AppIntegrationsClientTypes.ApplicationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationAssociations = applicationAssociations
        self.nextToken = nextToken
    }
}

enum ListApplicationAssociationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListApplicationsOutput {
    /// The Applications associated with this account.
    public var applications: [AppIntegrationsClientTypes.ApplicationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [AppIntegrationsClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataIntegrationAssociationsInput {

    static func queryItemProvider(_ value: ListDataIntegrationAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataIntegrationAssociationsInput {

    static func urlPathProvider(_ value: ListDataIntegrationAssociationsInput) -> Swift.String? {
        guard let dataIntegrationIdentifier = value.dataIntegrationIdentifier else {
            return nil
        }
        return "/dataIntegrations/\(dataIntegrationIdentifier.urlPercentEncoding())/associations"
    }
}

public struct ListDataIntegrationAssociationsInput {
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var dataIntegrationIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrationIdentifier = dataIntegrationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDataIntegrationAssociationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataIntegrationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataIntegrationAssociationsOutput()
        value.dataIntegrationAssociations = try reader["DataIntegrationAssociations"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.DataIntegrationAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDataIntegrationAssociationsOutput {
    /// The Amazon Resource Name (ARN) and unique ID of the DataIntegration association.
    public var dataIntegrationAssociations: [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrationAssociations: [AppIntegrationsClientTypes.DataIntegrationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrationAssociations = dataIntegrationAssociations
        self.nextToken = nextToken
    }
}

enum ListDataIntegrationAssociationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataIntegrationsInput {

    static func queryItemProvider(_ value: ListDataIntegrationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataIntegrationsInput {

    static func urlPathProvider(_ value: ListDataIntegrationsInput) -> Swift.String? {
        return "/dataIntegrations"
    }
}

public struct ListDataIntegrationsInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDataIntegrationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataIntegrationsOutput()
        value.dataIntegrations = try reader["DataIntegrations"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.DataIntegrationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDataIntegrationsOutput {
    /// The DataIntegrations associated with this account.
    public var dataIntegrations: [AppIntegrationsClientTypes.DataIntegrationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dataIntegrations: [AppIntegrationsClientTypes.DataIntegrationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataIntegrations = dataIntegrations
        self.nextToken = nextToken
    }
}

enum ListDataIntegrationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEventIntegrationAssociationsInput {

    static func queryItemProvider(_ value: ListEventIntegrationAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventIntegrationAssociationsInput {

    static func urlPathProvider(_ value: ListEventIntegrationAssociationsInput) -> Swift.String? {
        guard let eventIntegrationName = value.eventIntegrationName else {
            return nil
        }
        return "/eventIntegrations/\(eventIntegrationName.urlPercentEncoding())/associations"
    }
}

public struct ListEventIntegrationAssociationsInput {
    /// The name of the event integration.
    /// This member is required.
    public var eventIntegrationName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrationName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrationName = eventIntegrationName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEventIntegrationAssociationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEventIntegrationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventIntegrationAssociationsOutput()
        value.eventIntegrationAssociations = try reader["EventIntegrationAssociations"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.EventIntegrationAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListEventIntegrationAssociationsOutput {
    /// The event integration associations.
    public var eventIntegrationAssociations: [AppIntegrationsClientTypes.EventIntegrationAssociation]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrationAssociations: [AppIntegrationsClientTypes.EventIntegrationAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrationAssociations = eventIntegrationAssociations
        self.nextToken = nextToken
    }
}

enum ListEventIntegrationAssociationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEventIntegrationsInput {

    static func queryItemProvider(_ value: ListEventIntegrationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventIntegrationsInput {

    static func urlPathProvider(_ value: ListEventIntegrationsInput) -> Swift.String? {
        return "/eventIntegrations"
    }
}

public struct ListEventIntegrationsInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEventIntegrationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEventIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventIntegrationsOutput()
        value.eventIntegrations = try reader["EventIntegrations"].readListIfPresent(memberReadingClosure: AppIntegrationsClientTypes.EventIntegration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListEventIntegrationsOutput {
    /// The event integrations.
    public var eventIntegrations: [AppIntegrationsClientTypes.EventIntegration]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventIntegrations: [AppIntegrationsClientTypes.EventIntegration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventIntegrations = eventIntegrations
        self.nextToken = nextToken
    }
}

enum ListEventIntegrationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppIntegrationsClientTypes.Publication {

    static func write(value: AppIntegrationsClientTypes.Publication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Event"].write(value.event)
        try writer["Schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.Publication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.Publication()
        value.event = try reader["Event"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration of an event that the application publishes.
    public struct Publication {
        /// The description of the publication.
        public var description: Swift.String?
        /// The name of the publication.
        /// This member is required.
        public var event: Swift.String?
        /// The JSON schema of the publication event.
        /// This member is required.
        public var schema: Swift.String?

        public init(
            description: Swift.String? = nil,
            event: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.description = description
            self.event = event
            self.schema = schema
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The allowed quota for the resource has been exceeded.
public struct ResourceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppIntegrationsClientTypes.ScheduleConfiguration {

    static func write(value: AppIntegrationsClientTypes.ScheduleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirstExecutionFrom"].write(value.firstExecutionFrom)
        try writer["Object"].write(value.object)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.ScheduleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.ScheduleConfiguration()
        value.firstExecutionFrom = try reader["FirstExecutionFrom"].readIfPresent()
        value.object = try reader["Object"].readIfPresent()
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The name of the data and how often it should be pulled from the source.
    public struct ScheduleConfiguration {
        /// The start date for objects to import in the first flow run as an Unix/epoch timestamp in milliseconds or in ISO-8601 format.
        public var firstExecutionFrom: Swift.String?
        /// The name of the object to pull from the data source.
        public var object: Swift.String?
        /// How often the data should be pulled from data source.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init(
            firstExecutionFrom: Swift.String? = nil,
            object: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil
        )
        {
            self.firstExecutionFrom = firstExecutionFrom
            self.object = object
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension AppIntegrationsClientTypes.Subscription {

    static func write(value: AppIntegrationsClientTypes.Subscription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Event"].write(value.event)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppIntegrationsClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppIntegrationsClientTypes.Subscription()
        value.event = try reader["Event"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AppIntegrationsClientTypes {
    /// The configuration of an event that the application subscribes.
    public struct Subscription {
        /// The description of the subscription.
        public var description: Swift.String?
        /// The name of the subscription.
        /// This member is required.
        public var event: Swift.String?

        public init(
            description: Swift.String? = nil,
            event: Swift.String? = nil
        )
        {
            self.description = description
            self.event = event
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/applications/\(arn.urlPercentEncoding())"
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationSourceConfig"].write(value.applicationSourceConfig, with: AppIntegrationsClientTypes.ApplicationSourceConfig.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Publications"].writeList(value.publications, memberWritingClosure: AppIntegrationsClientTypes.Publication.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: AppIntegrationsClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateApplicationInput {
    /// The configuration for where the application should be loaded from.
    public var applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig?
    /// The Amazon Resource Name (ARN) of the Application.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The name of the application.
    public var name: Swift.String?
    /// The configuration of events or requests that the application has access to.
    public var permissions: [Swift.String]?
    /// The events that the application publishes.
    @available(*, deprecated, message: "Publications has been replaced with Permissions")
    public var publications: [AppIntegrationsClientTypes.Publication]?
    /// The events that the application subscribes.
    @available(*, deprecated, message: "Subscriptions has been replaced with Permissions")
    public var subscriptions: [AppIntegrationsClientTypes.Subscription]?

    public init(
        applicationSourceConfig: AppIntegrationsClientTypes.ApplicationSourceConfig? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        publications: [AppIntegrationsClientTypes.Publication]? = nil,
        subscriptions: [AppIntegrationsClientTypes.Subscription]? = nil
    )
    {
        self.applicationSourceConfig = applicationSourceConfig
        self.arn = arn
        self.description = description
        self.name = name
        self.permissions = permissions
        self.publications = publications
        self.subscriptions = subscriptions
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

public struct UpdateApplicationOutput {

    public init() { }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDataIntegrationInput {

    static func urlPathProvider(_ value: UpdateDataIntegrationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/dataIntegrations/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDataIntegrationInput {

    static func write(value: UpdateDataIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

public struct UpdateDataIntegrationInput {
    /// A description of the DataIntegration.
    public var description: Swift.String?
    /// A unique identifier for the DataIntegration.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the DataIntegration.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateDataIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDataIntegrationOutput {
        return UpdateDataIntegrationOutput()
    }
}

public struct UpdateDataIntegrationOutput {

    public init() { }
}

enum UpdateDataIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateEventIntegrationInput {

    static func urlPathProvider(_ value: UpdateEventIntegrationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/eventIntegrations/\(name.urlPercentEncoding())"
    }
}

extension UpdateEventIntegrationInput {

    static func write(value: UpdateEventIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

public struct UpdateEventIntegrationInput {
    /// The description of the event integration.
    public var description: Swift.String?
    /// The name of the event integration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

extension UpdateEventIntegrationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateEventIntegrationOutput {
        return UpdateEventIntegrationOutput()
    }
}

public struct UpdateEventIntegrationOutput {

    public init() { }
}

enum UpdateEventIntegrationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}
