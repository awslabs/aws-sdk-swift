//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error occurred during processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request caused a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints set by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MedicalImagingClientTypes {
    /// Copy the destination image set.
    public struct CopyDestinationImageSet {
        /// The image set identifier for the destination image set.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The latest version identifier for the destination image set.
        /// This member is required.
        public var latestVersionId: Swift.String?

        public init(
            imageSetId: Swift.String? = nil,
            latestVersionId: Swift.String? = nil
        )
        {
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
        }
    }

}

extension MedicalImagingClientTypes {
    /// Copy source image set information.
    public struct CopySourceImageSetInformation {
        /// The latest version identifier for the source image set.
        /// This member is required.
        public var latestVersionId: Swift.String?

        public init(
            latestVersionId: Swift.String? = nil
        )
        {
            self.latestVersionId = latestVersionId
        }
    }

}

extension MedicalImagingClientTypes {
    /// Copy image set information.
    public struct CopyImageSetInformation {
        /// The destination image set.
        public var destinationImageSet: MedicalImagingClientTypes.CopyDestinationImageSet?
        /// The source image set.
        /// This member is required.
        public var sourceImageSet: MedicalImagingClientTypes.CopySourceImageSetInformation?

        public init(
            destinationImageSet: MedicalImagingClientTypes.CopyDestinationImageSet? = nil,
            sourceImageSet: MedicalImagingClientTypes.CopySourceImageSetInformation? = nil
        )
        {
            self.destinationImageSet = destinationImageSet
            self.sourceImageSet = sourceImageSet
        }
    }

}

public struct CopyImageSetInput {
    /// Copy image set information.
    /// This member is required.
    public var copyImageSetInformation: MedicalImagingClientTypes.CopyImageSetInformation?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The source image set identifier.
    /// This member is required.
    public var sourceImageSetId: Swift.String?

    public init(
        copyImageSetInformation: MedicalImagingClientTypes.CopyImageSetInformation? = nil,
        datastoreId: Swift.String? = nil,
        sourceImageSetId: Swift.String? = nil
    )
    {
        self.copyImageSetInformation = copyImageSetInformation
        self.datastoreId = datastoreId
        self.sourceImageSetId = sourceImageSetId
    }
}

extension MedicalImagingClientTypes {

    public enum ImageSetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case locked
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSetState] {
            return [
                .active,
                .deleted,
                .locked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .locked: return "LOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {

    public enum ImageSetWorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case copied
        case copying
        case copyingWithReadOnlyAccess
        case copyFailed
        case created
        case deleted
        case deleting
        case updated
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSetWorkflowStatus] {
            return [
                .copied,
                .copying,
                .copyingWithReadOnlyAccess,
                .copyFailed,
                .created,
                .deleted,
                .deleting,
                .updated,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .copied: return "COPIED"
            case .copying: return "COPYING"
            case .copyingWithReadOnlyAccess: return "COPYING_WITH_READ_ONLY_ACCESS"
            case .copyFailed: return "COPY_FAILED"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updated: return "UPDATED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {
    /// Copy the image set properties of the destination image set.
    public struct CopyDestinationImageSetProperties {
        /// The timestamp when the destination image set properties were created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) assigned to the destination image set.
        public var imageSetArn: Swift.String?
        /// The image set identifier of the copied image set properties.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state of the destination image set properties.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The image set workflow status of the destination image set properties.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The latest version identifier for the destination image set properties.
        /// This member is required.
        public var latestVersionId: Swift.String?
        /// The timestamp when the destination image set properties were last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            imageSetArn: Swift.String? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            latestVersionId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }
    }

}

extension MedicalImagingClientTypes {
    /// Copy source image set properties.
    public struct CopySourceImageSetProperties {
        /// The timestamp when the source image set properties were created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) assigned to the source image set.
        public var imageSetArn: Swift.String?
        /// The image set identifier for the copied source image set.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state of the copied source image set.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The workflow status of the copied source image set.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The latest version identifier for the copied source image set.
        /// This member is required.
        public var latestVersionId: Swift.String?
        /// The timestamp when the source image set properties were updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            imageSetArn: Swift.String? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            latestVersionId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }
    }

}

public struct CopyImageSetOutput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The properties of the destination image set.
    /// This member is required.
    public var destinationImageSetProperties: MedicalImagingClientTypes.CopyDestinationImageSetProperties?
    /// The properties of the source image set.
    /// This member is required.
    public var sourceImageSetProperties: MedicalImagingClientTypes.CopySourceImageSetProperties?

    public init(
        datastoreId: Swift.String? = nil,
        destinationImageSetProperties: MedicalImagingClientTypes.CopyDestinationImageSetProperties? = nil,
        sourceImageSetProperties: MedicalImagingClientTypes.CopySourceImageSetProperties? = nil
    )
    {
        self.datastoreId = datastoreId
        self.destinationImageSetProperties = destinationImageSetProperties
        self.sourceImageSetProperties = sourceImageSetProperties
    }
}

public struct CreateDatastoreInput {
    /// A unique identifier for API idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data store name.
    public var datastoreName: Swift.String?
    /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
    public var kmsKeyArn: Swift.String?
    /// The tags provided when creating a data store.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

extension MedicalImagingClientTypes {

    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDatastoreOutput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?

    public init(
        datastoreId: Swift.String? = nil,
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

public struct DeleteDatastoreInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

public struct DeleteDatastoreOutput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?

    public init(
        datastoreId: Swift.String? = nil,
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

public struct GetDatastoreInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

extension MedicalImagingClientTypes {
    /// The properties associated with the data store.
    public struct DatastoreProperties {
        /// The timestamp when the data store was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public var datastoreArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The data store name.
        /// This member is required.
        public var datastoreName: Swift.String?
        /// The data store status.
        /// This member is required.
        public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
        /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
        public var kmsKeyArn: Swift.String?
        /// The timestamp when the data store was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
            kmsKeyArn: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
        }
    }

}

public struct GetDatastoreOutput {
    /// The data store properties.
    /// This member is required.
    public var datastoreProperties: MedicalImagingClientTypes.DatastoreProperties?

    public init(
        datastoreProperties: MedicalImagingClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

public struct ListDatastoresInput {
    /// The data store status.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
    /// Valid Range: Minimum value of 1. Maximum value of 50.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of data stores on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreStatus = datastoreStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MedicalImagingClientTypes {
    /// List of summaries of data stores.
    public struct DatastoreSummary {
        /// The timestamp when the data store was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public var datastoreArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The data store name.
        /// This member is required.
        public var datastoreName: Swift.String?
        /// The data store status.
        /// This member is required.
        public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
        /// The timestamp when the data store was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.updatedAt = updatedAt
        }
    }

}

public struct ListDatastoresOutput {
    /// The list of summaries of data stores.
    public var datastoreSummaries: [MedicalImagingClientTypes.DatastoreSummary]?
    /// The pagination token used to retrieve the list of data stores on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreSummaries: [MedicalImagingClientTypes.DatastoreSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreSummaries = datastoreSummaries
        self.nextToken = nextToken
    }
}

public struct DeleteImageSetInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
    }
}

public struct DeleteImageSetOutput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    /// This member is required.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
    }
}

public struct GetDICOMImportJobInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

extension MedicalImagingClientTypes {

    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {
    /// Properties of the import job.
    public struct DICOMImportJobProperties {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The timestamp for when the import job was ended.
        public var endedAt: Foundation.Date?
        /// The input prefix path for the S3 bucket that contains the DICOM P10 files to be imported.
        /// This member is required.
        public var inputS3Uri: Swift.String?
        /// The import job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The import job name.
        /// This member is required.
        public var jobName: Swift.String?
        /// The filters for listing import jobs based on status.
        /// This member is required.
        public var jobStatus: MedicalImagingClientTypes.JobStatus?
        /// The error message thrown if an import job fails.
        public var message: Swift.String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        /// This member is required.
        public var outputS3Uri: Swift.String?
        /// The timestamp for when the import job was submitted.
        public var submittedAt: Foundation.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            inputS3Uri: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputS3Uri: Swift.String? = nil,
            submittedAt: Foundation.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.inputS3Uri = inputS3Uri
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputS3Uri = outputS3Uri
            self.submittedAt = submittedAt
        }
    }

}

public struct GetDICOMImportJobOutput {
    /// The properties of the import job.
    /// This member is required.
    public var jobProperties: MedicalImagingClientTypes.DICOMImportJobProperties?

    public init(
        jobProperties: MedicalImagingClientTypes.DICOMImportJobProperties? = nil
    )
    {
        self.jobProperties = jobProperties
    }
}

extension MedicalImagingClientTypes {
    /// Information about the image frame (pixel data) identifier.
    public struct ImageFrameInformation {
        /// The image frame (pixel data) identifier.
        /// This member is required.
        public var imageFrameId: Swift.String?

        public init(
            imageFrameId: Swift.String? = nil
        )
        {
            self.imageFrameId = imageFrameId
        }
    }

}

public struct GetImageFrameInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// Information about the image frame (pixel data) identifier.
    /// This member is required.
    public var imageFrameInformation: MedicalImagingClientTypes.ImageFrameInformation?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageFrameInformation: MedicalImagingClientTypes.ImageFrameInformation? = nil,
        imageSetId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageFrameInformation = imageFrameInformation
        self.imageSetId = imageSetId
    }
}

public struct GetImageFrameOutput {
    /// The format in which the image frame information is returned to the customer. Default is application/octet-stream.
    public var contentType: Swift.String?
    /// The blob containing the aggregated image frame information.
    /// This member is required.
    public var imageFrameBlob: Smithy.ByteStream?

    public init(
        contentType: Swift.String? = nil,
        imageFrameBlob: Smithy.ByteStream? = nil
    )
    {
        self.contentType = contentType
        self.imageFrameBlob = imageFrameBlob
    }
}

public struct GetImageSetInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set version identifier.
    public var versionId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.versionId = versionId
    }
}

public struct GetImageSetOutput {
    /// The timestamp when image set properties were created.
    public var createdAt: Foundation.Date?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The timestamp when the image set properties were deleted.
    public var deletedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) assigned to the image set.
    public var imageSetArn: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    /// The error message thrown if an image set action fails.
    public var message: Swift.String?
    /// The timestamp when image set properties were updated.
    public var updatedAt: Foundation.Date?
    /// The image set version identifier.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        datastoreId: Swift.String? = nil,
        deletedAt: Foundation.Date? = nil,
        imageSetArn: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
        message: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.datastoreId = datastoreId
        self.deletedAt = deletedAt
        self.imageSetArn = imageSetArn
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
        self.message = message
        self.updatedAt = updatedAt
        self.versionId = versionId
    }
}

public struct GetImageSetMetadataInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set version identifier.
    public var versionId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.versionId = versionId
    }
}

public struct GetImageSetMetadataOutput {
    /// The compression format in which image set metadata attributes are returned.
    public var contentEncoding: Swift.String?
    /// The format in which the study metadata is returned to the customer. Default is text/plain.
    public var contentType: Swift.String?
    /// The blob containing the aggregated metadata information for the image set.
    /// This member is required.
    public var imageSetMetadataBlob: Smithy.ByteStream?

    public init(
        contentEncoding: Swift.String? = nil,
        contentType: Swift.String? = nil,
        imageSetMetadataBlob: Smithy.ByteStream? = nil
    )
    {
        self.contentEncoding = contentEncoding
        self.contentType = contentType
        self.imageSetMetadataBlob = imageSetMetadataBlob
    }
}

public struct ListDICOMImportJobsInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The filters for listing import jobs based on status.
    public var jobStatus: MedicalImagingClientTypes.JobStatus?
    /// The max results count. The upper bound is determined by load testing.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of import jobs on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MedicalImagingClientTypes {
    /// Summary of import job.
    public struct DICOMImportJobSummary {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The timestamp when an import job ended.
        public var endedAt: Foundation.Date?
        /// The import job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The import job name.
        /// This member is required.
        public var jobName: Swift.String?
        /// The filters for listing import jobs based on status.
        /// This member is required.
        public var jobStatus: MedicalImagingClientTypes.JobStatus?
        /// The error message thrown if an import job fails.
        public var message: Swift.String?
        /// The timestamp when an import job was submitted.
        public var submittedAt: Foundation.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submittedAt: Foundation.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.submittedAt = submittedAt
        }
    }

}

public struct ListDICOMImportJobsOutput {
    /// A list of job summaries.
    /// This member is required.
    public var jobSummaries: [MedicalImagingClientTypes.DICOMImportJobSummary]?
    /// The pagination token used to retrieve the list of import jobs on the next page.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [MedicalImagingClientTypes.DICOMImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct ListImageSetVersionsInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The max results count.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of image set versions on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MedicalImagingClientTypes {
    /// The image set properties.
    public struct ImageSetProperties {
        /// The timestamp when the image set properties were created.
        public var createdAt: Foundation.Date?
        /// The timestamp when the image set properties were deleted.
        public var deletedAt: Foundation.Date?
        /// The image set identifier.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state.
        /// This member is required.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The image set workflow status.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public var message: Swift.String?
        /// The timestamp when the image set properties were updated.
        public var updatedAt: Foundation.Date?
        /// The image set version identifier.
        /// This member is required.
        public var versionId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            message: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.updatedAt = updatedAt
            self.versionId = versionId
        }
    }

}

public struct ListImageSetVersionsOutput {
    /// Lists all properties associated with an image set.
    /// This member is required.
    public var imageSetPropertiesList: [MedicalImagingClientTypes.ImageSetProperties]?
    /// The pagination token used to retrieve the list of image set versions on the next page.
    public var nextToken: Swift.String?

    public init(
        imageSetPropertiesList: [MedicalImagingClientTypes.ImageSetProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageSetPropertiesList = imageSetPropertiesList
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the medical imaging resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A list of all tags associated with a medical imaging resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension MedicalImagingClientTypes {

    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .between,
                .equal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {
    /// The aggregated structure to store DICOM study date and study time for search capabilities.
    public struct DICOMStudyDateAndTime {
        /// The DICOM study date provided in yyMMdd format.
        /// This member is required.
        public var dicomStudyDate: Swift.String?
        /// The DICOM study time provided in HHmmss.FFFFFF format.
        public var dicomStudyTime: Swift.String?

        public init(
            dicomStudyDate: Swift.String? = nil,
            dicomStudyTime: Swift.String? = nil
        )
        {
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyTime = dicomStudyTime
        }
    }

}

extension MedicalImagingClientTypes.DICOMStudyDateAndTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMStudyDateAndTime(dicomStudyDate: \"CONTENT_REDACTED\", dicomStudyTime: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// The search input attribute value.
    public enum SearchByAttributeValue {
        /// The patient ID input for search.
        case dicompatientid(Swift.String)
        /// The DICOM accession number for search.
        case dicomaccessionnumber(Swift.String)
        /// The DICOM study ID for search.
        case dicomstudyid(Swift.String)
        /// The DICOM study instance UID for search.
        case dicomstudyinstanceuid(Swift.String)
        /// The Series Instance UID input for search.
        case dicomseriesinstanceuid(Swift.String)
        /// The created at time of the image set provided for search.
        case createdat(Foundation.Date)
        /// The timestamp input for search.
        case updatedat(Foundation.Date)
        /// The aggregated structure containing DICOM study date and study time for search.
        case dicomstudydateandtime(MedicalImagingClientTypes.DICOMStudyDateAndTime)
        case sdkUnknown(Swift.String)
    }

}

extension MedicalImagingClientTypes {
    /// The search filter.
    public struct SearchFilter {
        /// The search filter operator for imageSetDateTime.
        /// This member is required.
        public var `operator`: MedicalImagingClientTypes.Operator?
        /// The search filter values.
        /// This member is required.
        public var values: [MedicalImagingClientTypes.SearchByAttributeValue]?

        public init(
            `operator`: MedicalImagingClientTypes.Operator? = nil,
            values: [MedicalImagingClientTypes.SearchByAttributeValue]? = nil
        )
        {
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MedicalImagingClientTypes {

    public enum SortField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dicomstudydateandtime
        case createdat
        case updatedat
        case sdkUnknown(Swift.String)

        public static var allCases: [SortField] {
            return [
                .dicomstudydateandtime,
                .createdat,
                .updatedat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dicomstudydateandtime: return "DICOMStudyDateAndTime"
            case .createdat: return "createdAt"
            case .updatedat: return "updatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MedicalImagingClientTypes {
    /// Sort search results.
    public struct Sort {
        /// The sort field for search criteria.
        /// This member is required.
        public var sortField: MedicalImagingClientTypes.SortField?
        /// The sort order for search criteria.
        /// This member is required.
        public var sortOrder: MedicalImagingClientTypes.SortOrder?

        public init(
            sortField: MedicalImagingClientTypes.SortField? = nil,
            sortOrder: MedicalImagingClientTypes.SortOrder? = nil
        )
        {
            self.sortField = sortField
            self.sortOrder = sortOrder
        }
    }

}

extension MedicalImagingClientTypes {
    /// The search criteria.
    public struct SearchCriteria {
        /// The filters for the search criteria.
        public var filters: [MedicalImagingClientTypes.SearchFilter]?
        /// The sort input for search criteria.
        public var sort: MedicalImagingClientTypes.Sort?

        public init(
            filters: [MedicalImagingClientTypes.SearchFilter]? = nil,
            sort: MedicalImagingClientTypes.Sort? = nil
        )
        {
            self.filters = filters
            self.sort = sort
        }
    }

}

extension MedicalImagingClientTypes.SearchCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct SearchImageSetsInput {
    /// The identifier of the data store where the image sets reside.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The maximum number of results that can be returned in a search.
    public var maxResults: Swift.Int?
    /// The token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
    public var nextToken: Swift.String?
    /// The search criteria that filters by applying a maximum of 1 item to SearchByAttribute.
    public var searchCriteria: MedicalImagingClientTypes.SearchCriteria?

    public init(
        datastoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: MedicalImagingClientTypes.SearchCriteria? = nil
    )
    {
        self.datastoreId = datastoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
    }
}

extension SearchImageSetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchImageSetsInput(datastoreId: \(Swift.String(describing: datastoreId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchCriteria: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// The DICOM attributes returned as a part of a response. Each image set has these properties as part of a search result.
    public struct DICOMTags {
        /// The accession number for the DICOM study.
        public var dicomAccessionNumber: Swift.String?
        /// The total number of instances in the DICOM study.
        public var dicomNumberOfStudyRelatedInstances: Swift.Int
        /// The total number of series in the DICOM study.
        public var dicomNumberOfStudyRelatedSeries: Swift.Int
        /// The patient birth date.
        public var dicomPatientBirthDate: Swift.String?
        /// The unique identifier for a patient in a DICOM Study.
        public var dicomPatientId: Swift.String?
        /// The patient name.
        public var dicomPatientName: Swift.String?
        /// The patient sex.
        public var dicomPatientSex: Swift.String?
        /// The DICOM provided identifier for the series Body Part Examined.
        public var dicomSeriesBodyPart: Swift.String?
        /// The DICOM provided identifier for the Series Instance UID.
        public var dicomSeriesInstanceUID: Swift.String?
        /// The DICOM provided identifier for the series Modality.
        public var dicomSeriesModality: Swift.String?
        /// The DICOM provided identifier for the Series Number.
        public var dicomSeriesNumber: Swift.Int?
        /// The study date.
        public var dicomStudyDate: Swift.String?
        /// The DICOM provided Study Description.
        public var dicomStudyDescription: Swift.String?
        /// The DICOM provided identifier for the Study ID.
        public var dicomStudyId: Swift.String?
        /// The DICOM provided identifier for the Study Instance UID.
        public var dicomStudyInstanceUID: Swift.String?
        /// The study time.
        public var dicomStudyTime: Swift.String?

        public init(
            dicomAccessionNumber: Swift.String? = nil,
            dicomNumberOfStudyRelatedInstances: Swift.Int = 0,
            dicomNumberOfStudyRelatedSeries: Swift.Int = 0,
            dicomPatientBirthDate: Swift.String? = nil,
            dicomPatientId: Swift.String? = nil,
            dicomPatientName: Swift.String? = nil,
            dicomPatientSex: Swift.String? = nil,
            dicomSeriesBodyPart: Swift.String? = nil,
            dicomSeriesInstanceUID: Swift.String? = nil,
            dicomSeriesModality: Swift.String? = nil,
            dicomSeriesNumber: Swift.Int? = nil,
            dicomStudyDate: Swift.String? = nil,
            dicomStudyDescription: Swift.String? = nil,
            dicomStudyId: Swift.String? = nil,
            dicomStudyInstanceUID: Swift.String? = nil,
            dicomStudyTime: Swift.String? = nil
        )
        {
            self.dicomAccessionNumber = dicomAccessionNumber
            self.dicomNumberOfStudyRelatedInstances = dicomNumberOfStudyRelatedInstances
            self.dicomNumberOfStudyRelatedSeries = dicomNumberOfStudyRelatedSeries
            self.dicomPatientBirthDate = dicomPatientBirthDate
            self.dicomPatientId = dicomPatientId
            self.dicomPatientName = dicomPatientName
            self.dicomPatientSex = dicomPatientSex
            self.dicomSeriesBodyPart = dicomSeriesBodyPart
            self.dicomSeriesInstanceUID = dicomSeriesInstanceUID
            self.dicomSeriesModality = dicomSeriesModality
            self.dicomSeriesNumber = dicomSeriesNumber
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyDescription = dicomStudyDescription
            self.dicomStudyId = dicomStudyId
            self.dicomStudyInstanceUID = dicomStudyInstanceUID
            self.dicomStudyTime = dicomStudyTime
        }
    }

}

extension MedicalImagingClientTypes.DICOMTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMTags(dicomNumberOfStudyRelatedInstances: \(Swift.String(describing: dicomNumberOfStudyRelatedInstances)), dicomNumberOfStudyRelatedSeries: \(Swift.String(describing: dicomNumberOfStudyRelatedSeries)), dicomAccessionNumber: \"CONTENT_REDACTED\", dicomPatientBirthDate: \"CONTENT_REDACTED\", dicomPatientId: \"CONTENT_REDACTED\", dicomPatientName: \"CONTENT_REDACTED\", dicomPatientSex: \"CONTENT_REDACTED\", dicomSeriesBodyPart: \"CONTENT_REDACTED\", dicomSeriesInstanceUID: \"CONTENT_REDACTED\", dicomSeriesModality: \"CONTENT_REDACTED\", dicomSeriesNumber: \"CONTENT_REDACTED\", dicomStudyDate: \"CONTENT_REDACTED\", dicomStudyDescription: \"CONTENT_REDACTED\", dicomStudyId: \"CONTENT_REDACTED\", dicomStudyInstanceUID: \"CONTENT_REDACTED\", dicomStudyTime: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// Summary of the image set metadata.
    public struct ImageSetsMetadataSummary {
        /// The time an image set is created. Sample creation date is provided in 1985-04-12T23:20:50.52Z format.
        public var createdAt: Foundation.Date?
        /// The DICOM tags associated with the image set.
        public var dicomTags: MedicalImagingClientTypes.DICOMTags?
        /// The image set identifier.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The time an image set was last updated.
        public var updatedAt: Foundation.Date?
        /// The image set version.
        public var version: Swift.Int?

        public init(
            createdAt: Foundation.Date? = nil,
            dicomTags: MedicalImagingClientTypes.DICOMTags? = nil,
            imageSetId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.Int? = nil
        )
        {
            self.createdAt = createdAt
            self.dicomTags = dicomTags
            self.imageSetId = imageSetId
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

public struct SearchImageSetsOutput {
    /// The model containing the image set results.
    /// This member is required.
    public var imageSetsMetadataSummaries: [MedicalImagingClientTypes.ImageSetsMetadataSummary]?
    /// The token for pagination results.
    public var nextToken: Swift.String?
    /// The sort order for image set search results.
    public var sort: MedicalImagingClientTypes.Sort?

    public init(
        imageSetsMetadataSummaries: [MedicalImagingClientTypes.ImageSetsMetadataSummary]? = nil,
        nextToken: Swift.String? = nil,
        sort: MedicalImagingClientTypes.Sort? = nil
    )
    {
        self.imageSetsMetadataSummaries = imageSetsMetadataSummaries
        self.nextToken = nextToken
        self.sort = sort
    }
}

public struct StartDICOMImportJobInput {
    /// A unique identifier for API idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that grants permission to access medical imaging resources.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The account ID of the source S3 bucket owner.
    public var inputOwnerAccountId: Swift.String?
    /// The input prefix path for the S3 bucket that contains the DICOM files to be imported.
    /// This member is required.
    public var inputS3Uri: Swift.String?
    /// The import job name.
    public var jobName: Swift.String?
    /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
    /// This member is required.
    public var outputS3Uri: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputOwnerAccountId: Swift.String? = nil,
        inputS3Uri: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputS3Uri: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputOwnerAccountId = inputOwnerAccountId
        self.inputS3Uri = inputS3Uri
        self.jobName = jobName
        self.outputS3Uri = outputS3Uri
    }
}

public struct StartDICOMImportJobOutput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?
    /// The import job status.
    /// This member is required.
    public var jobStatus: MedicalImagingClientTypes.JobStatus?
    /// The timestamp when the import job was submitted.
    /// This member is required.
    public var submittedAt: Foundation.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
        submittedAt: Foundation.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.submittedAt = submittedAt
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being added to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The user-specified key and value tag pairs added to a medical imaging resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys for the tags to be removed from the medical imaging resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension MedicalImagingClientTypes {
    /// The object containing removableAttributes and updatableAttributes.
    public struct DICOMUpdates {
        /// The DICOM tags to be removed from ImageSetMetadata.
        public var removableAttributes: Foundation.Data?
        /// The DICOM tags that need to be updated in ImageSetMetadata.
        public var updatableAttributes: Foundation.Data?

        public init(
            removableAttributes: Foundation.Data? = nil,
            updatableAttributes: Foundation.Data? = nil
        )
        {
            self.removableAttributes = removableAttributes
            self.updatableAttributes = updatableAttributes
        }
    }

}

extension MedicalImagingClientTypes.DICOMUpdates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMUpdates(removableAttributes: \"CONTENT_REDACTED\", updatableAttributes: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// Contains DICOMUpdates.
    public enum MetadataUpdates {
        /// The object containing removableAttributes and updatableAttributes.
        case dicomupdates(MedicalImagingClientTypes.DICOMUpdates)
        case sdkUnknown(Swift.String)
    }

}

public struct UpdateImageSetMetadataInput {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The latest image set version identifier.
    /// This member is required.
    public var latestVersionId: Swift.String?
    /// Update image set metadata updates.
    /// This member is required.
    public var updateImageSetMetadataUpdates: MedicalImagingClientTypes.MetadataUpdates?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        latestVersionId: Swift.String? = nil,
        updateImageSetMetadataUpdates: MedicalImagingClientTypes.MetadataUpdates? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.latestVersionId = latestVersionId
        self.updateImageSetMetadataUpdates = updateImageSetMetadataUpdates
    }
}

public struct UpdateImageSetMetadataOutput {
    /// The timestamp when image set metadata was created.
    public var createdAt: Foundation.Date?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    /// The latest image set version identifier.
    /// This member is required.
    public var latestVersionId: Swift.String?
    /// The error message thrown if an update image set metadata action fails.
    public var message: Swift.String?
    /// The timestamp when image set metadata was updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
        latestVersionId: Swift.String? = nil,
        message: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
        self.latestVersionId = latestVersionId
        self.message = message
        self.updatedAt = updatedAt
    }
}

extension CopyImageSetInput {

    static func urlPathProvider(_ value: CopyImageSetInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let sourceImageSetId = value.sourceImageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(sourceImageSetId.urlPercentEncoding())/copyImageSet"
    }
}

extension CreateDatastoreInput {

    static func urlPathProvider(_ value: CreateDatastoreInput) -> Swift.String? {
        return "/datastore"
    }
}

extension DeleteDatastoreInput {

    static func urlPathProvider(_ value: DeleteDatastoreInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

extension DeleteImageSetInput {

    static func urlPathProvider(_ value: DeleteImageSetInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/deleteImageSet"
    }
}

extension GetDatastoreInput {

    static func urlPathProvider(_ value: GetDatastoreInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

extension GetDICOMImportJobInput {

    static func urlPathProvider(_ value: GetDICOMImportJobInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/getDICOMImportJob/datastore/\(datastoreId.urlPercentEncoding())/job/\(jobId.urlPercentEncoding())"
    }
}

extension GetImageFrameInput {

    static func urlPathProvider(_ value: GetImageFrameInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageFrame"
    }
}

extension GetImageSetInput {

    static func urlPathProvider(_ value: GetImageSetInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageSet"
    }
}

extension GetImageSetInput {

    static func queryItemProvider(_ value: GetImageSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionId = value.versionId {
            let versionIdQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension GetImageSetMetadataInput {

    static func urlPathProvider(_ value: GetImageSetMetadataInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageSetMetadata"
    }
}

extension GetImageSetMetadataInput {

    static func queryItemProvider(_ value: GetImageSetMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionId = value.versionId {
            let versionIdQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension ListDatastoresInput {

    static func urlPathProvider(_ value: ListDatastoresInput) -> Swift.String? {
        return "/datastore"
    }
}

extension ListDatastoresInput {

    static func queryItemProvider(_ value: ListDatastoresInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let datastoreStatus = value.datastoreStatus {
            let datastoreStatusQueryItem = Smithy.URIQueryItem(name: "datastoreStatus".urlPercentEncoding(), value: Swift.String(datastoreStatus.rawValue).urlPercentEncoding())
            items.append(datastoreStatusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDICOMImportJobsInput {

    static func urlPathProvider(_ value: ListDICOMImportJobsInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        return "/listDICOMImportJobs/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

extension ListDICOMImportJobsInput {

    static func queryItemProvider(_ value: ListDICOMImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let jobStatus = value.jobStatus {
            let jobStatusQueryItem = Smithy.URIQueryItem(name: "jobStatus".urlPercentEncoding(), value: Swift.String(jobStatus.rawValue).urlPercentEncoding())
            items.append(jobStatusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImageSetVersionsInput {

    static func urlPathProvider(_ value: ListImageSetVersionsInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/listImageSetVersions"
    }
}

extension ListImageSetVersionsInput {

    static func queryItemProvider(_ value: ListImageSetVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension SearchImageSetsInput {

    static func urlPathProvider(_ value: SearchImageSetsInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/searchImageSets"
    }
}

extension SearchImageSetsInput {

    static func queryItemProvider(_ value: SearchImageSetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension StartDICOMImportJobInput {

    static func urlPathProvider(_ value: StartDICOMImportJobInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        return "/startDICOMImportJob/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateImageSetMetadataInput {

    static func urlPathProvider(_ value: UpdateImageSetMetadataInput) -> Swift.String? {
        guard let datastoreId = value.datastoreId else {
            return nil
        }
        guard let imageSetId = value.imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/updateImageSetMetadata"
    }
}

extension UpdateImageSetMetadataInput {

    static func queryItemProvider(_ value: UpdateImageSetMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let latestVersionId = value.latestVersionId else {
            let message = "Creating a URL Query Item failed. latestVersionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let latestVersionIdQueryItem = Smithy.URIQueryItem(name: "latestVersion".urlPercentEncoding(), value: Swift.String(latestVersionId).urlPercentEncoding())
        items.append(latestVersionIdQueryItem)
        return items
    }
}

extension CopyImageSetInput {

    static func write(value: CopyImageSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["copyImageSetInformation"].write(value.copyImageSetInformation, with: MedicalImagingClientTypes.CopyImageSetInformation.write(value:to:))
    }
}

extension CreateDatastoreInput {

    static func write(value: CreateDatastoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["datastoreName"].write(value.datastoreName)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetImageFrameInput {

    static func write(value: GetImageFrameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageFrameInformation"].write(value.imageFrameInformation, with: MedicalImagingClientTypes.ImageFrameInformation.write(value:to:))
    }
}

extension SearchImageSetsInput {

    static func write(value: SearchImageSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchCriteria"].write(value.searchCriteria, with: MedicalImagingClientTypes.SearchCriteria.write(value:to:))
    }
}

extension StartDICOMImportJobInput {

    static func write(value: StartDICOMImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["inputOwnerAccountId"].write(value.inputOwnerAccountId)
        try writer["inputS3Uri"].write(value.inputS3Uri)
        try writer["jobName"].write(value.jobName)
        try writer["outputS3Uri"].write(value.outputS3Uri)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateImageSetMetadataInput {

    static func write(value: UpdateImageSetMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["updateImageSetMetadataUpdates"].write(value.updateImageSetMetadataUpdates, with: MedicalImagingClientTypes.MetadataUpdates.write(value:to:))
    }
}

extension CopyImageSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyImageSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyImageSetOutput()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.destinationImageSetProperties = try reader["destinationImageSetProperties"].readIfPresent(with: MedicalImagingClientTypes.CopyDestinationImageSetProperties.read(from:))
        value.sourceImageSetProperties = try reader["sourceImageSetProperties"].readIfPresent(with: MedicalImagingClientTypes.CopySourceImageSetProperties.read(from:))
        return value
    }
}

extension CreateDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatastoreOutput()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["datastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDatastoreOutput()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["datastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteImageSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImageSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImageSetOutput()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent() ?? .sdkUnknown("")
        value.imageSetWorkflowStatus = try reader["imageSetWorkflowStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetDatastoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDatastoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDatastoreOutput()
        value.datastoreProperties = try reader["datastoreProperties"].readIfPresent(with: MedicalImagingClientTypes.DatastoreProperties.read(from:))
        return value
    }
}

extension GetDICOMImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDICOMImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDICOMImportJobOutput()
        value.jobProperties = try reader["jobProperties"].readIfPresent(with: MedicalImagingClientTypes.DICOMImportJobProperties.read(from:))
        return value
    }
}

extension GetImageFrameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageFrameOutput {
        var value = GetImageFrameOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.imageFrameBlob = .data(data)
        case .stream(let stream):
            value.imageFrameBlob = .stream(stream)
        case .noStream:
            value.imageFrameBlob = nil
        }
        return value
    }
}

extension GetImageSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImageSetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.deletedAt = try reader["deletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.imageSetArn = try reader["imageSetArn"].readIfPresent()
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent() ?? .sdkUnknown("")
        value.imageSetWorkflowStatus = try reader["imageSetWorkflowStatus"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionId = try reader["versionId"].readIfPresent() ?? ""
        return value
    }
}

extension GetImageSetMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageSetMetadataOutput {
        var value = GetImageSetMetadataOutput()
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            value.contentEncoding = contentEncodingHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.imageSetMetadataBlob = .data(data)
        case .stream(let stream):
            value.imageSetMetadataBlob = .stream(stream)
        case .noStream:
            value.imageSetMetadataBlob = nil
        }
        return value
    }
}

extension ListDatastoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatastoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatastoresOutput()
        value.datastoreSummaries = try reader["datastoreSummaries"].readListIfPresent(memberReadingClosure: MedicalImagingClientTypes.DatastoreSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDICOMImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDICOMImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDICOMImportJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: MedicalImagingClientTypes.DICOMImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImageSetVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImageSetVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImageSetVersionsOutput()
        value.imageSetPropertiesList = try reader["imageSetPropertiesList"].readListIfPresent(memberReadingClosure: MedicalImagingClientTypes.ImageSetProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension SearchImageSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchImageSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchImageSetsOutput()
        value.imageSetsMetadataSummaries = try reader["imageSetsMetadataSummaries"].readListIfPresent(memberReadingClosure: MedicalImagingClientTypes.ImageSetsMetadataSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sort = try reader["sort"].readIfPresent(with: MedicalImagingClientTypes.Sort.read(from:))
        return value
    }
}

extension StartDICOMImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDICOMImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDICOMImportJobOutput()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.submittedAt = try reader["submittedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateImageSetMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateImageSetMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateImageSetMetadataOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent() ?? .sdkUnknown("")
        value.imageSetWorkflowStatus = try reader["imageSetWorkflowStatus"].readIfPresent()
        value.latestVersionId = try reader["latestVersionId"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

enum CopyImageSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImageSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDatastoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDICOMImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageFrameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageSetMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatastoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDICOMImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImageSetVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchImageSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDICOMImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateImageSetMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MedicalImagingClientTypes.CopySourceImageSetProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.CopySourceImageSetProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.CopySourceImageSetProperties()
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.latestVersionId = try reader["latestVersionId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent()
        value.imageSetWorkflowStatus = try reader["imageSetWorkflowStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.imageSetArn = try reader["imageSetArn"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.CopyDestinationImageSetProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.CopyDestinationImageSetProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.CopyDestinationImageSetProperties()
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.latestVersionId = try reader["latestVersionId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent()
        value.imageSetWorkflowStatus = try reader["imageSetWorkflowStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.imageSetArn = try reader["imageSetArn"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.DatastoreProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.DatastoreProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.DatastoreProperties()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.datastoreName = try reader["datastoreName"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["datastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.datastoreArn = try reader["datastoreArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MedicalImagingClientTypes.DICOMImportJobProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.DICOMImportJobProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.DICOMImportJobProperties()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.dataAccessRoleArn = try reader["dataAccessRoleArn"].readIfPresent() ?? ""
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.submittedAt = try reader["submittedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inputS3Uri = try reader["inputS3Uri"].readIfPresent() ?? ""
        value.outputS3Uri = try reader["outputS3Uri"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.DatastoreSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.DatastoreSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.DatastoreSummary()
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.datastoreName = try reader["datastoreName"].readIfPresent() ?? ""
        value.datastoreStatus = try reader["datastoreStatus"].readIfPresent() ?? .sdkUnknown("")
        value.datastoreArn = try reader["datastoreArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MedicalImagingClientTypes.DICOMImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.DICOMImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.DICOMImportJobSummary()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.datastoreId = try reader["datastoreId"].readIfPresent() ?? ""
        value.dataAccessRoleArn = try reader["dataAccessRoleArn"].readIfPresent()
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.submittedAt = try reader["submittedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.ImageSetProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.ImageSetProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.ImageSetProperties()
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.versionId = try reader["versionId"].readIfPresent() ?? ""
        value.imageSetState = try reader["imageSetState"].readIfPresent() ?? .sdkUnknown("")
        value.imageSetWorkflowStatus = try reader["ImageSetWorkflowStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletedAt = try reader["deletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.ImageSetsMetadataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.ImageSetsMetadataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.ImageSetsMetadataSummary()
        value.imageSetId = try reader["imageSetId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dicomTags = try reader["DICOMTags"].readIfPresent(with: MedicalImagingClientTypes.DICOMTags.read(from:))
        return value
    }
}

extension MedicalImagingClientTypes.DICOMTags {

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.DICOMTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.DICOMTags()
        value.dicomPatientId = try reader["DICOMPatientId"].readIfPresent()
        value.dicomPatientName = try reader["DICOMPatientName"].readIfPresent()
        value.dicomPatientBirthDate = try reader["DICOMPatientBirthDate"].readIfPresent()
        value.dicomPatientSex = try reader["DICOMPatientSex"].readIfPresent()
        value.dicomStudyInstanceUID = try reader["DICOMStudyInstanceUID"].readIfPresent()
        value.dicomStudyId = try reader["DICOMStudyId"].readIfPresent()
        value.dicomStudyDescription = try reader["DICOMStudyDescription"].readIfPresent()
        value.dicomNumberOfStudyRelatedSeries = try reader["DICOMNumberOfStudyRelatedSeries"].readIfPresent() ?? 0
        value.dicomNumberOfStudyRelatedInstances = try reader["DICOMNumberOfStudyRelatedInstances"].readIfPresent() ?? 0
        value.dicomAccessionNumber = try reader["DICOMAccessionNumber"].readIfPresent()
        value.dicomSeriesInstanceUID = try reader["DICOMSeriesInstanceUID"].readIfPresent()
        value.dicomSeriesModality = try reader["DICOMSeriesModality"].readIfPresent()
        value.dicomSeriesBodyPart = try reader["DICOMSeriesBodyPart"].readIfPresent()
        value.dicomSeriesNumber = try reader["DICOMSeriesNumber"].readIfPresent()
        value.dicomStudyDate = try reader["DICOMStudyDate"].readIfPresent()
        value.dicomStudyTime = try reader["DICOMStudyTime"].readIfPresent()
        return value
    }
}

extension MedicalImagingClientTypes.Sort {

    static func write(value: MedicalImagingClientTypes.Sort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortField"].write(value.sortField)
        try writer["sortOrder"].write(value.sortOrder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MedicalImagingClientTypes.Sort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MedicalImagingClientTypes.Sort()
        value.sortOrder = try reader["sortOrder"].readIfPresent() ?? .sdkUnknown("")
        value.sortField = try reader["sortField"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MedicalImagingClientTypes.CopyImageSetInformation {

    static func write(value: MedicalImagingClientTypes.CopyImageSetInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationImageSet"].write(value.destinationImageSet, with: MedicalImagingClientTypes.CopyDestinationImageSet.write(value:to:))
        try writer["sourceImageSet"].write(value.sourceImageSet, with: MedicalImagingClientTypes.CopySourceImageSetInformation.write(value:to:))
    }
}

extension MedicalImagingClientTypes.CopyDestinationImageSet {

    static func write(value: MedicalImagingClientTypes.CopyDestinationImageSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageSetId"].write(value.imageSetId)
        try writer["latestVersionId"].write(value.latestVersionId)
    }
}

extension MedicalImagingClientTypes.CopySourceImageSetInformation {

    static func write(value: MedicalImagingClientTypes.CopySourceImageSetInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["latestVersionId"].write(value.latestVersionId)
    }
}

extension MedicalImagingClientTypes.ImageFrameInformation {

    static func write(value: MedicalImagingClientTypes.ImageFrameInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageFrameId"].write(value.imageFrameId)
    }
}

extension MedicalImagingClientTypes.SearchCriteria {

    static func write(value: MedicalImagingClientTypes.SearchCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: MedicalImagingClientTypes.SearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sort"].write(value.sort, with: MedicalImagingClientTypes.Sort.write(value:to:))
    }
}

extension MedicalImagingClientTypes.SearchFilter {

    static func write(value: MedicalImagingClientTypes.SearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: MedicalImagingClientTypes.SearchByAttributeValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MedicalImagingClientTypes.SearchByAttributeValue {

    static func write(value: MedicalImagingClientTypes.SearchByAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dicomaccessionnumber(dicomaccessionnumber):
                try writer["DICOMAccessionNumber"].write(dicomaccessionnumber)
            case let .dicompatientid(dicompatientid):
                try writer["DICOMPatientId"].write(dicompatientid)
            case let .dicomseriesinstanceuid(dicomseriesinstanceuid):
                try writer["DICOMSeriesInstanceUID"].write(dicomseriesinstanceuid)
            case let .dicomstudydateandtime(dicomstudydateandtime):
                try writer["DICOMStudyDateAndTime"].write(dicomstudydateandtime, with: MedicalImagingClientTypes.DICOMStudyDateAndTime.write(value:to:))
            case let .dicomstudyid(dicomstudyid):
                try writer["DICOMStudyId"].write(dicomstudyid)
            case let .dicomstudyinstanceuid(dicomstudyinstanceuid):
                try writer["DICOMStudyInstanceUID"].write(dicomstudyinstanceuid)
            case let .createdat(createdat):
                try writer["createdAt"].writeTimestamp(createdat, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .updatedat(updatedat):
                try writer["updatedAt"].writeTimestamp(updatedat, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MedicalImagingClientTypes.DICOMStudyDateAndTime {

    static func write(value: MedicalImagingClientTypes.DICOMStudyDateAndTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DICOMStudyDate"].write(value.dicomStudyDate)
        try writer["DICOMStudyTime"].write(value.dicomStudyTime)
    }
}

extension MedicalImagingClientTypes.MetadataUpdates {

    static func write(value: MedicalImagingClientTypes.MetadataUpdates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dicomupdates(dicomupdates):
                try writer["DICOMUpdates"].write(dicomupdates, with: MedicalImagingClientTypes.DICOMUpdates.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MedicalImagingClientTypes.DICOMUpdates {

    static func write(value: MedicalImagingClientTypes.DICOMUpdates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["removableAttributes"].write(value.removableAttributes)
        try writer["updatableAttributes"].write(value.updatableAttributes)
    }
}

public enum MedicalImagingClientTypes {}
