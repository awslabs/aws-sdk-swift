// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes.CopyDestinationImageSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSetId
        case latestVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageSetId = self.imageSetId {
            try encodeContainer.encode(imageSetId, forKey: .imageSetId)
        }
        if let latestVersionId = self.latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Copy the destination image set.
    public struct CopyDestinationImageSet: Swift.Equatable {
        /// The image set identifier for the destination image set.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The latest version identifier for the destination image set.
        /// This member is required.
        public var latestVersionId: Swift.String?

        public init(
            imageSetId: Swift.String? = nil,
            latestVersionId: Swift.String? = nil
        )
        {
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
        }
    }

}

extension MedicalImagingClientTypes.CopyDestinationImageSetProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case imageSetArn
        case imageSetId
        case imageSetState
        case imageSetWorkflowStatus
        case latestVersionId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageSetArn = self.imageSetArn {
            try encodeContainer.encode(imageSetArn, forKey: .imageSetArn)
        }
        if let imageSetId = self.imageSetId {
            try encodeContainer.encode(imageSetId, forKey: .imageSetId)
        }
        if let imageSetState = self.imageSetState {
            try encodeContainer.encode(imageSetState.rawValue, forKey: .imageSetState)
        }
        if let imageSetWorkflowStatus = self.imageSetWorkflowStatus {
            try encodeContainer.encode(imageSetWorkflowStatus.rawValue, forKey: .imageSetWorkflowStatus)
        }
        if let latestVersionId = self.latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let imageSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetArn)
        imageSetArn = imageSetArnDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Copy the image set properties of the destination image set.
    public struct CopyDestinationImageSetProperties: Swift.Equatable {
        /// The timestamp when the destination image set properties were created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) assigned to the destination image set.
        public var imageSetArn: Swift.String?
        /// The image set identifier of the copied image set properties.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state of the destination image set properties.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The image set workflow status of the destination image set properties.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The latest version identifier for the destination image set properties.
        /// This member is required.
        public var latestVersionId: Swift.String?
        /// The timestamp when the destination image set properties were last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            imageSetArn: Swift.String? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            latestVersionId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }
    }

}

extension MedicalImagingClientTypes.CopyImageSetInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageSet
        case sourceImageSet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationImageSet = self.destinationImageSet {
            try encodeContainer.encode(destinationImageSet, forKey: .destinationImageSet)
        }
        if let sourceImageSet = self.sourceImageSet {
            try encodeContainer.encode(sourceImageSet, forKey: .sourceImageSet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceImageSetDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.CopySourceImageSetInformation.self, forKey: .sourceImageSet)
        sourceImageSet = sourceImageSetDecoded
        let destinationImageSetDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.CopyDestinationImageSet.self, forKey: .destinationImageSet)
        destinationImageSet = destinationImageSetDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Copy image set information.
    public struct CopyImageSetInformation: Swift.Equatable {
        /// The destination image set.
        public var destinationImageSet: MedicalImagingClientTypes.CopyDestinationImageSet?
        /// The source image set.
        /// This member is required.
        public var sourceImageSet: MedicalImagingClientTypes.CopySourceImageSetInformation?

        public init(
            destinationImageSet: MedicalImagingClientTypes.CopyDestinationImageSet? = nil,
            sourceImageSet: MedicalImagingClientTypes.CopySourceImageSetInformation? = nil
        )
        {
            self.destinationImageSet = destinationImageSet
            self.sourceImageSet = sourceImageSet
        }
    }

}

public struct CopyImageSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyImageSetInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CopyImageSetOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let copyImageSetInformation = input.operationInput.copyImageSetInformation {
                let copyImageSetInformationData = try encoder.encode(copyImageSetInformation)
                let copyImageSetInformationBody = ClientRuntime.HttpBody.data(copyImageSetInformationData)
                input.builder.withBody(copyImageSetInformationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let copyImageSetInformationData = "{}".data(using: .utf8)!
                    let copyImageSetInformationBody = ClientRuntime.HttpBody.data(copyImageSetInformationData)
                    input.builder.withBody(copyImageSetInformationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyImageSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageSetOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CopyImageSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyImageSetInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyImageSetInformation = self.copyImageSetInformation {
            try encodeContainer.encode(copyImageSetInformation, forKey: .copyImageSetInformation)
        }
    }
}

extension CopyImageSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let sourceImageSetId = sourceImageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(sourceImageSetId.urlPercentEncoding())/copyImageSet"
    }
}

public struct CopyImageSetInput: Swift.Equatable {
    /// Copy image set information.
    /// This member is required.
    public var copyImageSetInformation: MedicalImagingClientTypes.CopyImageSetInformation?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The source image set identifier.
    /// This member is required.
    public var sourceImageSetId: Swift.String?

    public init(
        copyImageSetInformation: MedicalImagingClientTypes.CopyImageSetInformation? = nil,
        datastoreId: Swift.String? = nil,
        sourceImageSetId: Swift.String? = nil
    )
    {
        self.copyImageSetInformation = copyImageSetInformation
        self.datastoreId = datastoreId
        self.sourceImageSetId = sourceImageSetId
    }
}

struct CopyImageSetInputBody: Swift.Equatable {
    let copyImageSetInformation: MedicalImagingClientTypes.CopyImageSetInformation?
}

extension CopyImageSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyImageSetInformation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyImageSetInformationDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.CopyImageSetInformation.self, forKey: .copyImageSetInformation)
        copyImageSetInformation = copyImageSetInformationDecoded
    }
}

extension CopyImageSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyImageSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.destinationImageSetProperties = output.destinationImageSetProperties
            self.sourceImageSetProperties = output.sourceImageSetProperties
        } else {
            self.datastoreId = nil
            self.destinationImageSetProperties = nil
            self.sourceImageSetProperties = nil
        }
    }
}

public struct CopyImageSetOutput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The properties of the destination image set.
    /// This member is required.
    public var destinationImageSetProperties: MedicalImagingClientTypes.CopyDestinationImageSetProperties?
    /// The properties of the source image set.
    /// This member is required.
    public var sourceImageSetProperties: MedicalImagingClientTypes.CopySourceImageSetProperties?

    public init(
        datastoreId: Swift.String? = nil,
        destinationImageSetProperties: MedicalImagingClientTypes.CopyDestinationImageSetProperties? = nil,
        sourceImageSetProperties: MedicalImagingClientTypes.CopySourceImageSetProperties? = nil
    )
    {
        self.datastoreId = datastoreId
        self.destinationImageSetProperties = destinationImageSetProperties
        self.sourceImageSetProperties = sourceImageSetProperties
    }
}

struct CopyImageSetOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let sourceImageSetProperties: MedicalImagingClientTypes.CopySourceImageSetProperties?
    let destinationImageSetProperties: MedicalImagingClientTypes.CopyDestinationImageSetProperties?
}

extension CopyImageSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId
        case destinationImageSetProperties
        case sourceImageSetProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let sourceImageSetPropertiesDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.CopySourceImageSetProperties.self, forKey: .sourceImageSetProperties)
        sourceImageSetProperties = sourceImageSetPropertiesDecoded
        let destinationImageSetPropertiesDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.CopyDestinationImageSetProperties.self, forKey: .destinationImageSetProperties)
        destinationImageSetProperties = destinationImageSetPropertiesDecoded
    }
}

enum CopyImageSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MedicalImagingClientTypes.CopySourceImageSetInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestVersionId = self.latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Copy source image set information.
    public struct CopySourceImageSetInformation: Swift.Equatable {
        /// The latest version identifier for the source image set.
        /// This member is required.
        public var latestVersionId: Swift.String?

        public init(
            latestVersionId: Swift.String? = nil
        )
        {
            self.latestVersionId = latestVersionId
        }
    }

}

extension MedicalImagingClientTypes.CopySourceImageSetProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case imageSetArn
        case imageSetId
        case imageSetState
        case imageSetWorkflowStatus
        case latestVersionId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageSetArn = self.imageSetArn {
            try encodeContainer.encode(imageSetArn, forKey: .imageSetArn)
        }
        if let imageSetId = self.imageSetId {
            try encodeContainer.encode(imageSetId, forKey: .imageSetId)
        }
        if let imageSetState = self.imageSetState {
            try encodeContainer.encode(imageSetState.rawValue, forKey: .imageSetState)
        }
        if let imageSetWorkflowStatus = self.imageSetWorkflowStatus {
            try encodeContainer.encode(imageSetWorkflowStatus.rawValue, forKey: .imageSetWorkflowStatus)
        }
        if let latestVersionId = self.latestVersionId {
            try encodeContainer.encode(latestVersionId, forKey: .latestVersionId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let imageSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetArn)
        imageSetArn = imageSetArnDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Copy source image set properties.
    public struct CopySourceImageSetProperties: Swift.Equatable {
        /// The timestamp when the source image set properties were created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) assigned to the source image set.
        public var imageSetArn: Swift.String?
        /// The image set identifier for the copied source image set.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state of the copied source image set.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The workflow status of the copied source image set.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The latest version identifier for the copied source image set.
        /// This member is required.
        public var latestVersionId: Swift.String?
        /// The timestamp when the source image set properties were updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            imageSetArn: Swift.String? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            latestVersionId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }
    }

}

extension CreateDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case datastoreName
        case kmsKeyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datastore"
    }
}

public struct CreateDatastoreInput: Swift.Equatable {
    /// A unique identifier for API idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data store name.
    public var datastoreName: Swift.String?
    /// The Amazon Resource Name (ARN) assigned to the AWS Key Management Service (AWS KMS) key for accessing encrypted data.
    public var kmsKeyArn: Swift.String?
    /// The tags provided when creating a data store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateDatastoreInputBody: Swift.Equatable {
    let datastoreName: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyArn: Swift.String?
}

extension CreateDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case datastoreName
        case kmsKeyArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CreateDatastoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatastoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateDatastoreOutput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?

    public init(
        datastoreId: Swift.String? = nil,
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateDatastoreOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
}

extension CreateDatastoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId
        case datastoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
    }
}

enum CreateDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MedicalImagingClientTypes.DICOMImportJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn
        case datastoreId
        case endedAt
        case inputS3Uri
        case jobId
        case jobName
        case jobStatus
        case message
        case outputS3Uri
        case submittedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let inputS3Uri = self.inputS3Uri {
            try encodeContainer.encode(inputS3Uri, forKey: .inputS3Uri)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputS3Uri = self.outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
        if let submittedAt = self.submittedAt {
            try encodeContainer.encodeTimestamp(submittedAt, format: .epochSeconds, forKey: .submittedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let submittedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAt)
        submittedAt = submittedAtDecoded
        let inputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Uri)
        inputS3Uri = inputS3UriDecoded
        let outputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Properties of the import job.
    public struct DICOMImportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The timestamp for when the import job was ended.
        public var endedAt: ClientRuntime.Date?
        /// The input prefix path for the S3 bucket that contains the DICOM P10 files to be imported.
        /// This member is required.
        public var inputS3Uri: Swift.String?
        /// The import job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The import job name.
        /// This member is required.
        public var jobName: Swift.String?
        /// The filters for listing import jobs based on status.
        /// This member is required.
        public var jobStatus: MedicalImagingClientTypes.JobStatus?
        /// The error message thrown if an import job fails.
        public var message: Swift.String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        /// This member is required.
        public var outputS3Uri: Swift.String?
        /// The timestamp for when the import job was submitted.
        public var submittedAt: ClientRuntime.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            inputS3Uri: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputS3Uri: Swift.String? = nil,
            submittedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.inputS3Uri = inputS3Uri
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputS3Uri = outputS3Uri
            self.submittedAt = submittedAt
        }
    }

}

extension MedicalImagingClientTypes.DICOMImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn
        case datastoreId
        case endedAt
        case jobId
        case jobName
        case jobStatus
        case message
        case submittedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submittedAt = self.submittedAt {
            try encodeContainer.encodeTimestamp(submittedAt, format: .epochSeconds, forKey: .submittedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let submittedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAt)
        submittedAt = submittedAtDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Summary of import job.
    public struct DICOMImportJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public var dataAccessRoleArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The timestamp when an import job ended.
        public var endedAt: ClientRuntime.Date?
        /// The import job identifier.
        /// This member is required.
        public var jobId: Swift.String?
        /// The import job name.
        /// This member is required.
        public var jobName: Swift.String?
        /// The filters for listing import jobs based on status.
        /// This member is required.
        public var jobStatus: MedicalImagingClientTypes.JobStatus?
        /// The error message thrown if an import job fails.
        public var message: Swift.String?
        /// The timestamp when an import job was submitted.
        public var submittedAt: ClientRuntime.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submittedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.submittedAt = submittedAt
        }
    }

}

extension MedicalImagingClientTypes.DICOMStudyDateAndTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dicomStudyDate = "DICOMStudyDate"
        case dicomStudyTime = "DICOMStudyTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dicomStudyDate = self.dicomStudyDate {
            try encodeContainer.encode(dicomStudyDate, forKey: .dicomStudyDate)
        }
        if let dicomStudyTime = self.dicomStudyTime {
            try encodeContainer.encode(dicomStudyTime, forKey: .dicomStudyTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dicomStudyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyDate)
        dicomStudyDate = dicomStudyDateDecoded
        let dicomStudyTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyTime)
        dicomStudyTime = dicomStudyTimeDecoded
    }
}

extension MedicalImagingClientTypes.DICOMStudyDateAndTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMStudyDateAndTime(dicomStudyDate: \"CONTENT_REDACTED\", dicomStudyTime: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// The aggregated structure to store DICOM study date and study time for search capabilities.
    public struct DICOMStudyDateAndTime: Swift.Equatable {
        /// The DICOM study date provided in yyMMdd format.
        /// This member is required.
        public var dicomStudyDate: Swift.String?
        /// The DICOM study time provided in HHmmss.FFFFFF format.
        public var dicomStudyTime: Swift.String?

        public init(
            dicomStudyDate: Swift.String? = nil,
            dicomStudyTime: Swift.String? = nil
        )
        {
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyTime = dicomStudyTime
        }
    }

}

extension MedicalImagingClientTypes.DICOMTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dicomAccessionNumber = "DICOMAccessionNumber"
        case dicomNumberOfStudyRelatedInstances = "DICOMNumberOfStudyRelatedInstances"
        case dicomNumberOfStudyRelatedSeries = "DICOMNumberOfStudyRelatedSeries"
        case dicomPatientBirthDate = "DICOMPatientBirthDate"
        case dicomPatientId = "DICOMPatientId"
        case dicomPatientName = "DICOMPatientName"
        case dicomPatientSex = "DICOMPatientSex"
        case dicomStudyDate = "DICOMStudyDate"
        case dicomStudyDescription = "DICOMStudyDescription"
        case dicomStudyId = "DICOMStudyId"
        case dicomStudyInstanceUID = "DICOMStudyInstanceUID"
        case dicomStudyTime = "DICOMStudyTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dicomAccessionNumber = self.dicomAccessionNumber {
            try encodeContainer.encode(dicomAccessionNumber, forKey: .dicomAccessionNumber)
        }
        if dicomNumberOfStudyRelatedInstances != 0 {
            try encodeContainer.encode(dicomNumberOfStudyRelatedInstances, forKey: .dicomNumberOfStudyRelatedInstances)
        }
        if dicomNumberOfStudyRelatedSeries != 0 {
            try encodeContainer.encode(dicomNumberOfStudyRelatedSeries, forKey: .dicomNumberOfStudyRelatedSeries)
        }
        if let dicomPatientBirthDate = self.dicomPatientBirthDate {
            try encodeContainer.encode(dicomPatientBirthDate, forKey: .dicomPatientBirthDate)
        }
        if let dicomPatientId = self.dicomPatientId {
            try encodeContainer.encode(dicomPatientId, forKey: .dicomPatientId)
        }
        if let dicomPatientName = self.dicomPatientName {
            try encodeContainer.encode(dicomPatientName, forKey: .dicomPatientName)
        }
        if let dicomPatientSex = self.dicomPatientSex {
            try encodeContainer.encode(dicomPatientSex, forKey: .dicomPatientSex)
        }
        if let dicomStudyDate = self.dicomStudyDate {
            try encodeContainer.encode(dicomStudyDate, forKey: .dicomStudyDate)
        }
        if let dicomStudyDescription = self.dicomStudyDescription {
            try encodeContainer.encode(dicomStudyDescription, forKey: .dicomStudyDescription)
        }
        if let dicomStudyId = self.dicomStudyId {
            try encodeContainer.encode(dicomStudyId, forKey: .dicomStudyId)
        }
        if let dicomStudyInstanceUID = self.dicomStudyInstanceUID {
            try encodeContainer.encode(dicomStudyInstanceUID, forKey: .dicomStudyInstanceUID)
        }
        if let dicomStudyTime = self.dicomStudyTime {
            try encodeContainer.encode(dicomStudyTime, forKey: .dicomStudyTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dicomPatientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomPatientId)
        dicomPatientId = dicomPatientIdDecoded
        let dicomPatientNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomPatientName)
        dicomPatientName = dicomPatientNameDecoded
        let dicomPatientBirthDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomPatientBirthDate)
        dicomPatientBirthDate = dicomPatientBirthDateDecoded
        let dicomPatientSexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomPatientSex)
        dicomPatientSex = dicomPatientSexDecoded
        let dicomStudyInstanceUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyInstanceUID)
        dicomStudyInstanceUID = dicomStudyInstanceUIDDecoded
        let dicomStudyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyId)
        dicomStudyId = dicomStudyIdDecoded
        let dicomStudyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyDescription)
        dicomStudyDescription = dicomStudyDescriptionDecoded
        let dicomNumberOfStudyRelatedSeriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dicomNumberOfStudyRelatedSeries) ?? 0
        dicomNumberOfStudyRelatedSeries = dicomNumberOfStudyRelatedSeriesDecoded
        let dicomNumberOfStudyRelatedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dicomNumberOfStudyRelatedInstances) ?? 0
        dicomNumberOfStudyRelatedInstances = dicomNumberOfStudyRelatedInstancesDecoded
        let dicomAccessionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomAccessionNumber)
        dicomAccessionNumber = dicomAccessionNumberDecoded
        let dicomStudyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyDate)
        dicomStudyDate = dicomStudyDateDecoded
        let dicomStudyTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dicomStudyTime)
        dicomStudyTime = dicomStudyTimeDecoded
    }
}

extension MedicalImagingClientTypes.DICOMTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMTags(dicomNumberOfStudyRelatedInstances: \(Swift.String(describing: dicomNumberOfStudyRelatedInstances)), dicomNumberOfStudyRelatedSeries: \(Swift.String(describing: dicomNumberOfStudyRelatedSeries)), dicomAccessionNumber: \"CONTENT_REDACTED\", dicomPatientBirthDate: \"CONTENT_REDACTED\", dicomPatientId: \"CONTENT_REDACTED\", dicomPatientName: \"CONTENT_REDACTED\", dicomPatientSex: \"CONTENT_REDACTED\", dicomStudyDate: \"CONTENT_REDACTED\", dicomStudyDescription: \"CONTENT_REDACTED\", dicomStudyId: \"CONTENT_REDACTED\", dicomStudyInstanceUID: \"CONTENT_REDACTED\", dicomStudyTime: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// The DICOM attributes returned as a part of a response. Each image set has these properties as part of a search result.
    public struct DICOMTags: Swift.Equatable {
        /// The accession number for the DICOM study.
        public var dicomAccessionNumber: Swift.String?
        /// The total number of instances in the DICOM study.
        public var dicomNumberOfStudyRelatedInstances: Swift.Int
        /// The total number of series in the DICOM study.
        public var dicomNumberOfStudyRelatedSeries: Swift.Int
        /// The patient birth date.
        public var dicomPatientBirthDate: Swift.String?
        /// The unique identifier for a patient in a DICOM Study.
        public var dicomPatientId: Swift.String?
        /// The patient name.
        public var dicomPatientName: Swift.String?
        /// The patient sex.
        public var dicomPatientSex: Swift.String?
        /// The study date.
        public var dicomStudyDate: Swift.String?
        /// The description of the study.
        public var dicomStudyDescription: Swift.String?
        /// The DICOM provided studyId.
        public var dicomStudyId: Swift.String?
        /// The DICOM provided identifier for studyInstanceUid.>
        public var dicomStudyInstanceUID: Swift.String?
        /// The study time.
        public var dicomStudyTime: Swift.String?

        public init(
            dicomAccessionNumber: Swift.String? = nil,
            dicomNumberOfStudyRelatedInstances: Swift.Int = 0,
            dicomNumberOfStudyRelatedSeries: Swift.Int = 0,
            dicomPatientBirthDate: Swift.String? = nil,
            dicomPatientId: Swift.String? = nil,
            dicomPatientName: Swift.String? = nil,
            dicomPatientSex: Swift.String? = nil,
            dicomStudyDate: Swift.String? = nil,
            dicomStudyDescription: Swift.String? = nil,
            dicomStudyId: Swift.String? = nil,
            dicomStudyInstanceUID: Swift.String? = nil,
            dicomStudyTime: Swift.String? = nil
        )
        {
            self.dicomAccessionNumber = dicomAccessionNumber
            self.dicomNumberOfStudyRelatedInstances = dicomNumberOfStudyRelatedInstances
            self.dicomNumberOfStudyRelatedSeries = dicomNumberOfStudyRelatedSeries
            self.dicomPatientBirthDate = dicomPatientBirthDate
            self.dicomPatientId = dicomPatientId
            self.dicomPatientName = dicomPatientName
            self.dicomPatientSex = dicomPatientSex
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyDescription = dicomStudyDescription
            self.dicomStudyId = dicomStudyId
            self.dicomStudyInstanceUID = dicomStudyInstanceUID
            self.dicomStudyTime = dicomStudyTime
        }
    }

}

extension MedicalImagingClientTypes.DICOMUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removableAttributes
        case updatableAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let removableAttributes = self.removableAttributes {
            try encodeContainer.encode(removableAttributes.base64EncodedString(), forKey: .removableAttributes)
        }
        if let updatableAttributes = self.updatableAttributes {
            try encodeContainer.encode(updatableAttributes.base64EncodedString(), forKey: .updatableAttributes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let removableAttributesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .removableAttributes)
        removableAttributes = removableAttributesDecoded
        let updatableAttributesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .updatableAttributes)
        updatableAttributes = updatableAttributesDecoded
    }
}

extension MedicalImagingClientTypes.DICOMUpdates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DICOMUpdates(removableAttributes: \"CONTENT_REDACTED\", updatableAttributes: \"CONTENT_REDACTED\")"}
}

extension MedicalImagingClientTypes {
    /// The object containing removableAttributes and updatableAttributes.
    public struct DICOMUpdates: Swift.Equatable {
        /// The DICOM tags to be removed from ImageSetMetadata.
        public var removableAttributes: ClientRuntime.Data?
        /// The DICOM tags that need to be updated in ImageSetMetadata.
        public var updatableAttributes: ClientRuntime.Data?

        public init(
            removableAttributes: ClientRuntime.Data? = nil,
            updatableAttributes: ClientRuntime.Data? = nil
        )
        {
            self.removableAttributes = removableAttributes
            self.updatableAttributes = updatableAttributes
        }
    }

}

extension MedicalImagingClientTypes.DatastoreProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case datastoreArn
        case datastoreId
        case datastoreName
        case datastoreStatus
        case kmsKeyArn
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let datastoreArn = self.datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension MedicalImagingClientTypes {
    /// The properties associated with the data store.
    public struct DatastoreProperties: Swift.Equatable {
        /// The timestamp when the data store was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public var datastoreArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The data store name.
        /// This member is required.
        public var datastoreName: Swift.String?
        /// The data store status.
        /// This member is required.
        public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
        /// The Amazon Resource Name (ARN) assigned to the AWS Key Management Service (AWS KMS) key for accessing encrypted data.
        public var kmsKeyArn: Swift.String?
        /// The timestamp when the data store was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
            kmsKeyArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
        }
    }

}

extension MedicalImagingClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension MedicalImagingClientTypes.DatastoreSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case datastoreArn
        case datastoreId
        case datastoreName
        case datastoreStatus
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let datastoreArn = self.datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension MedicalImagingClientTypes {
    /// List of summaries of data stores.
    public struct DatastoreSummary: Swift.Equatable {
        /// The timestamp when the data store was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public var datastoreArn: Swift.String?
        /// The data store identifier.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The data store name.
        /// This member is required.
        public var datastoreName: Swift.String?
        /// The data store status.
        /// This member is required.
        public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
        /// The timestamp when the data store was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.updatedAt = updatedAt
        }
    }

}

extension DeleteDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

public struct DeleteDatastoreInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteDatastoreInputBody: Swift.Equatable {
}

extension DeleteDatastoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatastoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDatastoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteDatastoreOutput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The data store status.
    /// This member is required.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?

    public init(
        datastoreId: Swift.String? = nil,
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteDatastoreOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
}

extension DeleteDatastoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId
        case datastoreStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
    }
}

enum DeleteDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImageSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/deleteImageSet"
    }
}

public struct DeleteImageSetInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
    }
}

struct DeleteImageSetInputBody: Swift.Equatable {
}

extension DeleteImageSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImageSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.imageSetId = output.imageSetId
            self.imageSetState = output.imageSetState
            self.imageSetWorkflowStatus = output.imageSetWorkflowStatus
        } else {
            self.datastoreId = nil
            self.imageSetId = nil
            self.imageSetState = nil
            self.imageSetWorkflowStatus = nil
        }
    }
}

public struct DeleteImageSetOutput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    /// This member is required.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
    }
}

struct DeleteImageSetOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let imageSetId: Swift.String?
    let imageSetState: MedicalImagingClientTypes.ImageSetState?
    let imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
}

extension DeleteImageSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId
        case imageSetId
        case imageSetState
        case imageSetWorkflowStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
    }
}

enum DeleteImageSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDICOMImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/getDICOMImportJob/datastore/\(datastoreId.urlPercentEncoding())/job/\(jobId.urlPercentEncoding())"
    }
}

public struct GetDICOMImportJobInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct GetDICOMImportJobInputBody: Swift.Equatable {
}

extension GetDICOMImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDICOMImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDICOMImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobProperties = output.jobProperties
        } else {
            self.jobProperties = nil
        }
    }
}

public struct GetDICOMImportJobOutput: Swift.Equatable {
    /// The properties of the import job.
    /// This member is required.
    public var jobProperties: MedicalImagingClientTypes.DICOMImportJobProperties?

    public init(
        jobProperties: MedicalImagingClientTypes.DICOMImportJobProperties? = nil
    )
    {
        self.jobProperties = jobProperties
    }
}

struct GetDICOMImportJobOutputBody: Swift.Equatable {
    let jobProperties: MedicalImagingClientTypes.DICOMImportJobProperties?
}

extension GetDICOMImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobPropertiesDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DICOMImportJobProperties.self, forKey: .jobProperties)
        jobProperties = jobPropertiesDecoded
    }
}

enum GetDICOMImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

public struct GetDatastoreInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct GetDatastoreInputBody: Swift.Equatable {
}

extension GetDatastoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDatastoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDatastoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct GetDatastoreOutput: Swift.Equatable {
    /// The data store properties.
    /// This member is required.
    public var datastoreProperties: MedicalImagingClientTypes.DatastoreProperties?

    public init(
        datastoreProperties: MedicalImagingClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct GetDatastoreOutputBody: Swift.Equatable {
    let datastoreProperties: MedicalImagingClientTypes.DatastoreProperties?
}

extension GetDatastoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

enum GetDatastoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct GetImageFrameInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageFrameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageFrameInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<GetImageFrameOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let imageFrameInformation = input.operationInput.imageFrameInformation {
                let imageFrameInformationData = try encoder.encode(imageFrameInformation)
                let imageFrameInformationBody = ClientRuntime.HttpBody.data(imageFrameInformationData)
                input.builder.withBody(imageFrameInformationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let imageFrameInformationData = "{}".data(using: .utf8)!
                    let imageFrameInformationBody = ClientRuntime.HttpBody.data(imageFrameInformationData)
                    input.builder.withBody(imageFrameInformationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageFrameInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageFrameOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension GetImageFrameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageFrameInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageFrameInformation = self.imageFrameInformation {
            try encodeContainer.encode(imageFrameInformation, forKey: .imageFrameInformation)
        }
    }
}

extension GetImageFrameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageFrame"
    }
}

public struct GetImageFrameInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// Information about the image frame (pixel data) identifier.
    /// This member is required.
    public var imageFrameInformation: MedicalImagingClientTypes.ImageFrameInformation?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageFrameInformation: MedicalImagingClientTypes.ImageFrameInformation? = nil,
        imageSetId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageFrameInformation = imageFrameInformation
        self.imageSetId = imageSetId
    }
}

struct GetImageFrameInputBody: Swift.Equatable {
    let imageFrameInformation: MedicalImagingClientTypes.ImageFrameInformation?
}

extension GetImageFrameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageFrameInformation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageFrameInformationDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageFrameInformation.self, forKey: .imageFrameInformation)
        imageFrameInformation = imageFrameInformationDecoded
    }
}

extension GetImageFrameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.imageFrameBlob = .data(data)
        case .stream(let stream):
            self.imageFrameBlob = .stream(stream)
        case .none:
            self.imageFrameBlob = nil
        }
    }
}

public struct GetImageFrameOutput: Swift.Equatable {
    /// The format in which the image frame information is returned to the customer. Default is application/octet-stream.
    public var contentType: Swift.String?
    /// The blob containing the aggregated image frame information.
    /// This member is required.
    public var imageFrameBlob: ClientRuntime.ByteStream?

    public init(
        contentType: Swift.String? = nil,
        imageFrameBlob: ClientRuntime.ByteStream? = nil
    )
    {
        self.contentType = contentType
        self.imageFrameBlob = imageFrameBlob
    }
}

struct GetImageFrameOutputBody: Swift.Equatable {
    let imageFrameBlob: ClientRuntime.ByteStream?
}

extension GetImageFrameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageFrameBlob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageFrameBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .imageFrameBlob)
        imageFrameBlob = imageFrameBlobDecoded
    }
}

enum GetImageFrameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImageSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            return items
        }
    }
}

extension GetImageSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageSet"
    }
}

public struct GetImageSetInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set version identifier.
    public var versionId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.versionId = versionId
    }
}

struct GetImageSetInputBody: Swift.Equatable {
}

extension GetImageSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImageSetMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            return items
        }
    }
}

extension GetImageSetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/getImageSetMetadata"
    }
}

public struct GetImageSetMetadataInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set version identifier.
    public var versionId: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.versionId = versionId
    }
}

struct GetImageSetMetadataInputBody: Swift.Equatable {
}

extension GetImageSetMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImageSetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.imageSetMetadataBlob = .data(data)
        case .stream(let stream):
            self.imageSetMetadataBlob = .stream(stream)
        case .none:
            self.imageSetMetadataBlob = nil
        }
    }
}

public struct GetImageSetMetadataOutput: Swift.Equatable {
    /// The compression format in which image set metadata attributes are returned.
    public var contentEncoding: Swift.String?
    /// The format in which the study metadata is returned to the customer. Default is text/plain.
    public var contentType: Swift.String?
    /// The blob containing the aggregated metadata information for the image set.
    /// This member is required.
    public var imageSetMetadataBlob: ClientRuntime.ByteStream?

    public init(
        contentEncoding: Swift.String? = nil,
        contentType: Swift.String? = nil,
        imageSetMetadataBlob: ClientRuntime.ByteStream? = nil
    )
    {
        self.contentEncoding = contentEncoding
        self.contentType = contentType
        self.imageSetMetadataBlob = imageSetMetadataBlob
    }
}

struct GetImageSetMetadataOutputBody: Swift.Equatable {
    let imageSetMetadataBlob: ClientRuntime.ByteStream?
}

extension GetImageSetMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSetMetadataBlob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetMetadataBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .imageSetMetadataBlob)
        imageSetMetadataBlob = imageSetMetadataBlobDecoded
    }
}

enum GetImageSetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImageSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImageSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.datastoreId = output.datastoreId
            self.deletedAt = output.deletedAt
            self.imageSetArn = output.imageSetArn
            self.imageSetId = output.imageSetId
            self.imageSetState = output.imageSetState
            self.imageSetWorkflowStatus = output.imageSetWorkflowStatus
            self.message = output.message
            self.updatedAt = output.updatedAt
            self.versionId = output.versionId
        } else {
            self.createdAt = nil
            self.datastoreId = nil
            self.deletedAt = nil
            self.imageSetArn = nil
            self.imageSetId = nil
            self.imageSetState = nil
            self.imageSetWorkflowStatus = nil
            self.message = nil
            self.updatedAt = nil
            self.versionId = nil
        }
    }
}

public struct GetImageSetOutput: Swift.Equatable {
    /// The timestamp when image set properties were created.
    public var createdAt: ClientRuntime.Date?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The timestamp when the image set properties were deleted.
    public var deletedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) assigned to the image set.
    public var imageSetArn: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    /// The error message thrown if an image set action fails.
    public var message: Swift.String?
    /// The timestamp when image set properties were updated.
    public var updatedAt: ClientRuntime.Date?
    /// The image set version identifier.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        datastoreId: Swift.String? = nil,
        deletedAt: ClientRuntime.Date? = nil,
        imageSetArn: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
        message: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.datastoreId = datastoreId
        self.deletedAt = deletedAt
        self.imageSetArn = imageSetArn
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
        self.message = message
        self.updatedAt = updatedAt
        self.versionId = versionId
    }
}

struct GetImageSetOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let imageSetId: Swift.String?
    let versionId: Swift.String?
    let imageSetState: MedicalImagingClientTypes.ImageSetState?
    let imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let deletedAt: ClientRuntime.Date?
    let message: Swift.String?
    let imageSetArn: Swift.String?
}

extension GetImageSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case datastoreId
        case deletedAt
        case imageSetArn
        case imageSetId
        case imageSetState
        case imageSetWorkflowStatus
        case message
        case updatedAt
        case versionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let imageSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetArn)
        imageSetArn = imageSetArnDecoded
    }
}

enum GetImageSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MedicalImagingClientTypes.ImageFrameInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageFrameId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageFrameId = self.imageFrameId {
            try encodeContainer.encode(imageFrameId, forKey: .imageFrameId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageFrameIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageFrameId)
        imageFrameId = imageFrameIdDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Information about the image frame (pixel data) identifier.
    public struct ImageFrameInformation: Swift.Equatable {
        /// The image frame (pixel data) identifier.
        /// This member is required.
        public var imageFrameId: Swift.String?

        public init(
            imageFrameId: Swift.String? = nil
        )
        {
            self.imageFrameId = imageFrameId
        }
    }

}

extension MedicalImagingClientTypes.ImageSetProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSetWorkflowStatus = "ImageSetWorkflowStatus"
        case createdAt
        case deletedAt
        case imageSetId
        case imageSetState
        case message
        case updatedAt
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageSetWorkflowStatus = self.imageSetWorkflowStatus {
            try encodeContainer.encode(imageSetWorkflowStatus.rawValue, forKey: .imageSetWorkflowStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if let imageSetId = self.imageSetId {
            try encodeContainer.encode(imageSetId, forKey: .imageSetId)
        }
        if let imageSetState = self.imageSetState {
            try encodeContainer.encode(imageSetState.rawValue, forKey: .imageSetState)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes {
    /// The image set properties.
    public struct ImageSetProperties: Swift.Equatable {
        /// The timestamp when the image set properties were created.
        public var createdAt: ClientRuntime.Date?
        /// The timestamp when the image set properties were deleted.
        public var deletedAt: ClientRuntime.Date?
        /// The image set identifier.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The image set state.
        /// This member is required.
        public var imageSetState: MedicalImagingClientTypes.ImageSetState?
        /// The image set workflow status.
        public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public var message: Swift.String?
        /// The timestamp when the image set properties were updated.
        public var updatedAt: ClientRuntime.Date?
        /// The image set version identifier.
        /// This member is required.
        public var versionId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            imageSetId: Swift.String? = nil,
            imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
            imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
            message: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.updatedAt = updatedAt
            self.versionId = versionId
        }
    }

}

extension MedicalImagingClientTypes {
    public enum ImageSetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case locked
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSetState] {
            return [
                .active,
                .deleted,
                .locked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .locked: return "LOCKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageSetState(rawValue: rawValue) ?? ImageSetState.sdkUnknown(rawValue)
        }
    }
}

extension MedicalImagingClientTypes {
    public enum ImageSetWorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copied
        case copying
        case copyingWithReadOnlyAccess
        case copyFailed
        case created
        case deleted
        case deleting
        case updated
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSetWorkflowStatus] {
            return [
                .copied,
                .copying,
                .copyingWithReadOnlyAccess,
                .copyFailed,
                .created,
                .deleted,
                .deleting,
                .updated,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copied: return "COPIED"
            case .copying: return "COPYING"
            case .copyingWithReadOnlyAccess: return "COPYING_WITH_READ_ONLY_ACCESS"
            case .copyFailed: return "COPY_FAILED"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updated: return "UPDATED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageSetWorkflowStatus(rawValue: rawValue) ?? ImageSetWorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension MedicalImagingClientTypes.ImageSetsMetadataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dicomTags = "DICOMTags"
        case createdAt
        case imageSetId
        case updatedAt
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dicomTags = self.dicomTags {
            try encodeContainer.encode(dicomTags, forKey: .dicomTags)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageSetId = self.imageSetId {
            try encodeContainer.encode(imageSetId, forKey: .imageSetId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dicomTagsDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.DICOMTags.self, forKey: .dicomTags)
        dicomTags = dicomTagsDecoded
    }
}

extension MedicalImagingClientTypes {
    /// Summary of the image set metadata.
    public struct ImageSetsMetadataSummary: Swift.Equatable {
        /// The time an image set is created in AWS HealthImaging. Sample creation date is provided in 1985-04-12T23:20:50.52Z format.
        public var createdAt: ClientRuntime.Date?
        /// The DICOM tags associated with the image set.
        public var dicomTags: MedicalImagingClientTypes.DICOMTags?
        /// The image set identifier.
        /// This member is required.
        public var imageSetId: Swift.String?
        /// The time when an image was last updated in AWS HealthImaging.
        public var updatedAt: ClientRuntime.Date?
        /// The image set version.
        public var version: Swift.Int?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dicomTags: MedicalImagingClientTypes.DICOMTags? = nil,
            imageSetId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            version: Swift.Int? = nil
        )
        {
            self.createdAt = createdAt
            self.dicomTags = dicomTags
            self.imageSetId = imageSetId
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred during processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListDICOMImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let jobStatus = jobStatus {
                let jobStatusQueryItem = ClientRuntime.URLQueryItem(name: "jobStatus".urlPercentEncoding(), value: Swift.String(jobStatus.rawValue).urlPercentEncoding())
                items.append(jobStatusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDICOMImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        return "/listDICOMImportJobs/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

public struct ListDICOMImportJobsInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The filters for listing import jobs based on status.
    public var jobStatus: MedicalImagingClientTypes.JobStatus?
    /// The max results count. The upper bound is determined by load testing.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of import jobs on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDICOMImportJobsInputBody: Swift.Equatable {
}

extension ListDICOMImportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDICOMImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDICOMImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDICOMImportJobsOutput: Swift.Equatable {
    /// A list of job summaries.
    /// This member is required.
    public var jobSummaries: [MedicalImagingClientTypes.DICOMImportJobSummary]?
    /// The pagination token used to retrieve the list of import jobs on the next page.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [MedicalImagingClientTypes.DICOMImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListDICOMImportJobsOutputBody: Swift.Equatable {
    let jobSummaries: [MedicalImagingClientTypes.DICOMImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDICOMImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.DICOMImportJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[MedicalImagingClientTypes.DICOMImportJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [MedicalImagingClientTypes.DICOMImportJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDICOMImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatastoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let datastoreStatus = datastoreStatus {
                let datastoreStatusQueryItem = ClientRuntime.URLQueryItem(name: "datastoreStatus".urlPercentEncoding(), value: Swift.String(datastoreStatus.rawValue).urlPercentEncoding())
                items.append(datastoreStatusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDatastoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datastore"
    }
}

public struct ListDatastoresInput: Swift.Equatable {
    /// The data store status.
    public var datastoreStatus: MedicalImagingClientTypes.DatastoreStatus?
    /// Valid Range: Minimum value of 1. Maximum value of 50.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of data stores on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreStatus: MedicalImagingClientTypes.DatastoreStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreStatus = datastoreStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatastoresInputBody: Swift.Equatable {
}

extension ListDatastoresInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDatastoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatastoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreSummaries = output.datastoreSummaries
            self.nextToken = output.nextToken
        } else {
            self.datastoreSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatastoresOutput: Swift.Equatable {
    /// The list of summaries of data stores.
    public var datastoreSummaries: [MedicalImagingClientTypes.DatastoreSummary]?
    /// The pagination token used to retrieve the list of data stores on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreSummaries: [MedicalImagingClientTypes.DatastoreSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreSummaries = datastoreSummaries
        self.nextToken = nextToken
    }
}

struct ListDatastoresOutputBody: Swift.Equatable {
    let datastoreSummaries: [MedicalImagingClientTypes.DatastoreSummary]?
    let nextToken: Swift.String?
}

extension ListDatastoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreSummariesContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.DatastoreSummary?].self, forKey: .datastoreSummaries)
        var datastoreSummariesDecoded0:[MedicalImagingClientTypes.DatastoreSummary]? = nil
        if let datastoreSummariesContainer = datastoreSummariesContainer {
            datastoreSummariesDecoded0 = [MedicalImagingClientTypes.DatastoreSummary]()
            for structure0 in datastoreSummariesContainer {
                if let structure0 = structure0 {
                    datastoreSummariesDecoded0?.append(structure0)
                }
            }
        }
        datastoreSummaries = datastoreSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatastoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImageSetVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListImageSetVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/listImageSetVersions"
    }
}

public struct ListImageSetVersionsInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The max results count.
    public var maxResults: Swift.Int?
    /// The pagination token used to request the list of image set versions on the next page.
    public var nextToken: Swift.String?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageSetVersionsInputBody: Swift.Equatable {
}

extension ListImageSetVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListImageSetVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImageSetVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageSetPropertiesList = output.imageSetPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.imageSetPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListImageSetVersionsOutput: Swift.Equatable {
    /// Lists all properties associated with an image set.
    /// This member is required.
    public var imageSetPropertiesList: [MedicalImagingClientTypes.ImageSetProperties]?
    /// The pagination token used to retrieve the list of image set versions on the next page.
    public var nextToken: Swift.String?

    public init(
        imageSetPropertiesList: [MedicalImagingClientTypes.ImageSetProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageSetPropertiesList = imageSetPropertiesList
        self.nextToken = nextToken
    }
}

struct ListImageSetVersionsOutputBody: Swift.Equatable {
    let imageSetPropertiesList: [MedicalImagingClientTypes.ImageSetProperties]?
    let nextToken: Swift.String?
}

extension ListImageSetVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSetPropertiesList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetPropertiesListContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.ImageSetProperties?].self, forKey: .imageSetPropertiesList)
        var imageSetPropertiesListDecoded0:[MedicalImagingClientTypes.ImageSetProperties]? = nil
        if let imageSetPropertiesListContainer = imageSetPropertiesListContainer {
            imageSetPropertiesListDecoded0 = [MedicalImagingClientTypes.ImageSetProperties]()
            for structure0 in imageSetPropertiesListContainer {
                if let structure0 = structure0 {
                    imageSetPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        imageSetPropertiesList = imageSetPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImageSetVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the medical imaging resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of all tags associated with a medical imaging resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MedicalImagingClientTypes.MetadataUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dicomupdates = "DICOMUpdates"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .dicomupdates(dicomupdates):
                try container.encode(dicomupdates, forKey: .dicomupdates)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dicomupdatesDecoded = try values.decodeIfPresent(MedicalImagingClientTypes.DICOMUpdates.self, forKey: .dicomupdates)
        if let dicomupdates = dicomupdatesDecoded {
            self = .dicomupdates(dicomupdates)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MedicalImagingClientTypes {
    /// Contains DICOMUpdates.
    public enum MetadataUpdates: Swift.Equatable {
        /// The object containing removableAttributes and updatableAttributes.
        case dicomupdates(MedicalImagingClientTypes.DICOMUpdates)
        case sdkUnknown(Swift.String)
    }

}

extension MedicalImagingClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .between,
                .equal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MedicalImagingClientTypes.SearchByAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dicomaccessionnumber = "DICOMAccessionNumber"
        case dicompatientid = "DICOMPatientId"
        case dicomstudydateandtime = "DICOMStudyDateAndTime"
        case dicomstudyid = "DICOMStudyId"
        case dicomstudyinstanceuid = "DICOMStudyInstanceUID"
        case createdat = "createdAt"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .dicomaccessionnumber(dicomaccessionnumber):
                try container.encode(dicomaccessionnumber, forKey: .dicomaccessionnumber)
            case let .dicompatientid(dicompatientid):
                try container.encode(dicompatientid, forKey: .dicompatientid)
            case let .dicomstudydateandtime(dicomstudydateandtime):
                try container.encode(dicomstudydateandtime, forKey: .dicomstudydateandtime)
            case let .dicomstudyid(dicomstudyid):
                try container.encode(dicomstudyid, forKey: .dicomstudyid)
            case let .dicomstudyinstanceuid(dicomstudyinstanceuid):
                try container.encode(dicomstudyinstanceuid, forKey: .dicomstudyinstanceuid)
            case let .createdat(createdat):
                try container.encodeTimestamp(createdat, format: .epochSeconds, forKey: .createdat)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dicompatientidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .dicompatientid)
        if let dicompatientid = dicompatientidDecoded {
            self = .dicompatientid(dicompatientid)
            return
        }
        let dicomaccessionnumberDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .dicomaccessionnumber)
        if let dicomaccessionnumber = dicomaccessionnumberDecoded {
            self = .dicomaccessionnumber(dicomaccessionnumber)
            return
        }
        let dicomstudyidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .dicomstudyid)
        if let dicomstudyid = dicomstudyidDecoded {
            self = .dicomstudyid(dicomstudyid)
            return
        }
        let dicomstudyinstanceuidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .dicomstudyinstanceuid)
        if let dicomstudyinstanceuid = dicomstudyinstanceuidDecoded {
            self = .dicomstudyinstanceuid(dicomstudyinstanceuid)
            return
        }
        let createdatDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .createdat)
        if let createdat = createdatDecoded {
            self = .createdat(createdat)
            return
        }
        let dicomstudydateandtimeDecoded = try values.decodeIfPresent(MedicalImagingClientTypes.DICOMStudyDateAndTime.self, forKey: .dicomstudydateandtime)
        if let dicomstudydateandtime = dicomstudydateandtimeDecoded {
            self = .dicomstudydateandtime(dicomstudydateandtime)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MedicalImagingClientTypes {
    /// The search input attribute value.
    public enum SearchByAttributeValue: Swift.Equatable {
        /// The patient ID input for search.
        case dicompatientid(Swift.String)
        /// The DICOM accession number for search.
        case dicomaccessionnumber(Swift.String)
        /// The DICOM study ID for search.
        case dicomstudyid(Swift.String)
        /// The DICOM study instance UID for search.
        case dicomstudyinstanceuid(Swift.String)
        /// The created at time of the image set provided for search.
        case createdat(ClientRuntime.Date)
        /// The aggregated structure containing DICOM study date and study time for search.
        case dicomstudydateandtime(MedicalImagingClientTypes.DICOMStudyDateAndTime)
        case sdkUnknown(Swift.String)
    }

}

extension MedicalImagingClientTypes.SearchCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchfilter0 in filters {
                try filtersContainer.encode(searchfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.SearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[MedicalImagingClientTypes.SearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MedicalImagingClientTypes.SearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension MedicalImagingClientTypes.SearchCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension MedicalImagingClientTypes {
    /// The search criteria.
    public struct SearchCriteria: Swift.Equatable {
        /// The filters for the search criteria.
        public var filters: [MedicalImagingClientTypes.SearchFilter]?

        public init(
            filters: [MedicalImagingClientTypes.SearchFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension MedicalImagingClientTypes.SearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for searchbyattributevalue0 in values {
                try valuesContainer.encode(searchbyattributevalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.SearchByAttributeValue?].self, forKey: .values)
        var valuesDecoded0:[MedicalImagingClientTypes.SearchByAttributeValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [MedicalImagingClientTypes.SearchByAttributeValue]()
            for union0 in valuesContainer {
                if let union0 = union0 {
                    valuesDecoded0?.append(union0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension MedicalImagingClientTypes {
    /// The search filter.
    public struct SearchFilter: Swift.Equatable {
        /// The search filter operator for imageSetDateTime.
        /// This member is required.
        public var `operator`: MedicalImagingClientTypes.Operator?
        /// The search filter values.
        /// This member is required.
        public var values: [MedicalImagingClientTypes.SearchByAttributeValue]?

        public init(
            `operator`: MedicalImagingClientTypes.Operator? = nil,
            values: [MedicalImagingClientTypes.SearchByAttributeValue]? = nil
        )
        {
            self.`operator` = `operator`
            self.values = values
        }
    }

}

public struct SearchImageSetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchImageSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchImageSetsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SearchImageSetsOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let searchCriteria = input.operationInput.searchCriteria {
                let searchCriteriaData = try encoder.encode(searchCriteria)
                let searchCriteriaBody = ClientRuntime.HttpBody.data(searchCriteriaData)
                input.builder.withBody(searchCriteriaBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let searchCriteriaData = "{}".data(using: .utf8)!
                    let searchCriteriaBody = ClientRuntime.HttpBody.data(searchCriteriaData)
                    input.builder.withBody(searchCriteriaBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchImageSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchImageSetsOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension SearchImageSetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchImageSetsInput(datastoreId: \(Swift.String(describing: datastoreId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchCriteria: \"CONTENT_REDACTED\")"}
}

extension SearchImageSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchCriteria = self.searchCriteria {
            try encodeContainer.encode(searchCriteria, forKey: .searchCriteria)
        }
    }
}

extension SearchImageSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension SearchImageSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/searchImageSets"
    }
}

public struct SearchImageSetsInput: Swift.Equatable {
    /// The identifier of the data store where the image sets reside.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The maximum number of results that can be returned in a search.
    public var maxResults: Swift.Int?
    /// The token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
    public var nextToken: Swift.String?
    /// The search criteria that filters by applying a maximum of 1 item to SearchByAttribute.
    public var searchCriteria: MedicalImagingClientTypes.SearchCriteria?

    public init(
        datastoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchCriteria: MedicalImagingClientTypes.SearchCriteria? = nil
    )
    {
        self.datastoreId = datastoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchCriteria = searchCriteria
    }
}

struct SearchImageSetsInputBody: Swift.Equatable {
    let searchCriteria: MedicalImagingClientTypes.SearchCriteria?
}

extension SearchImageSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchCriteria
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchCriteriaDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.SearchCriteria.self, forKey: .searchCriteria)
        searchCriteria = searchCriteriaDecoded
    }
}

extension SearchImageSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchImageSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageSetsMetadataSummaries = output.imageSetsMetadataSummaries
            self.nextToken = output.nextToken
        } else {
            self.imageSetsMetadataSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct SearchImageSetsOutput: Swift.Equatable {
    /// The model containing the image set results.
    /// This member is required.
    public var imageSetsMetadataSummaries: [MedicalImagingClientTypes.ImageSetsMetadataSummary]?
    /// The token for pagination results.
    public var nextToken: Swift.String?

    public init(
        imageSetsMetadataSummaries: [MedicalImagingClientTypes.ImageSetsMetadataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageSetsMetadataSummaries = imageSetsMetadataSummaries
        self.nextToken = nextToken
    }
}

struct SearchImageSetsOutputBody: Swift.Equatable {
    let imageSetsMetadataSummaries: [MedicalImagingClientTypes.ImageSetsMetadataSummary]?
    let nextToken: Swift.String?
}

extension SearchImageSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSetsMetadataSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageSetsMetadataSummariesContainer = try containerValues.decodeIfPresent([MedicalImagingClientTypes.ImageSetsMetadataSummary?].self, forKey: .imageSetsMetadataSummaries)
        var imageSetsMetadataSummariesDecoded0:[MedicalImagingClientTypes.ImageSetsMetadataSummary]? = nil
        if let imageSetsMetadataSummariesContainer = imageSetsMetadataSummariesContainer {
            imageSetsMetadataSummariesDecoded0 = [MedicalImagingClientTypes.ImageSetsMetadataSummary]()
            for structure0 in imageSetsMetadataSummariesContainer {
                if let structure0 = structure0 {
                    imageSetsMetadataSummariesDecoded0?.append(structure0)
                }
            }
        }
        imageSetsMetadataSummaries = imageSetsMetadataSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchImageSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request caused a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDICOMImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataAccessRoleArn
        case inputS3Uri
        case jobName
        case outputS3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputS3Uri = self.inputS3Uri {
            try encodeContainer.encode(inputS3Uri, forKey: .inputS3Uri)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputS3Uri = self.outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
    }
}

extension StartDICOMImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        return "/startDICOMImportJob/datastore/\(datastoreId.urlPercentEncoding())"
    }
}

public struct StartDICOMImportJobInput: Swift.Equatable {
    /// A unique identifier for API idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that grants permission to access medical imaging resources.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input prefix path for the S3 bucket that contains the DICOM files to be imported.
    /// This member is required.
    public var inputS3Uri: Swift.String?
    /// The import job name.
    public var jobName: Swift.String?
    /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
    /// This member is required.
    public var outputS3Uri: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputS3Uri: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputS3Uri: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputS3Uri = inputS3Uri
        self.jobName = jobName
        self.outputS3Uri = outputS3Uri
    }
}

struct StartDICOMImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let clientToken: Swift.String?
    let inputS3Uri: Swift.String?
    let outputS3Uri: Swift.String?
}

extension StartDICOMImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataAccessRoleArn
        case inputS3Uri
        case jobName
        case outputS3Uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let inputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Uri)
        inputS3Uri = inputS3UriDecoded
        let outputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
    }
}

extension StartDICOMImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDICOMImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
            self.submittedAt = output.submittedAt
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
            self.submittedAt = nil
        }
    }
}

public struct StartDICOMImportJobOutput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The import job identifier.
    /// This member is required.
    public var jobId: Swift.String?
    /// The import job status.
    /// This member is required.
    public var jobStatus: MedicalImagingClientTypes.JobStatus?
    /// The timestamp when the import job was submitted.
    /// This member is required.
    public var submittedAt: ClientRuntime.Date?

    public init(
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: MedicalImagingClientTypes.JobStatus? = nil,
        submittedAt: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.submittedAt = submittedAt
    }
}

struct StartDICOMImportJobOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let jobId: Swift.String?
    let jobStatus: MedicalImagingClientTypes.JobStatus?
    let submittedAt: ClientRuntime.Date?
}

extension StartDICOMImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId
        case jobId
        case jobStatus
        case submittedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAt)
        submittedAt = submittedAtDecoded
    }
}

enum StartDICOMImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being added to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The user-specified key and value tag pairs added to a medical imaging resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys for the tags to be removed from the medical imaging resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct UpdateImageSetMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImageSetMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImageSetMetadataInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateImageSetMetadataOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updateImageSetMetadataUpdates = input.operationInput.updateImageSetMetadataUpdates {
                let updateImageSetMetadataUpdatesData = try encoder.encode(updateImageSetMetadataUpdates)
                let updateImageSetMetadataUpdatesBody = ClientRuntime.HttpBody.data(updateImageSetMetadataUpdatesData)
                input.builder.withBody(updateImageSetMetadataUpdatesBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updateImageSetMetadataUpdatesData = "{}".data(using: .utf8)!
                    let updateImageSetMetadataUpdatesBody = ClientRuntime.HttpBody.data(updateImageSetMetadataUpdatesData)
                    input.builder.withBody(updateImageSetMetadataUpdatesBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImageSetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImageSetMetadataOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateImageSetMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateImageSetMetadataUpdates
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateImageSetMetadataUpdates = self.updateImageSetMetadataUpdates {
            try encodeContainer.encode(updateImageSetMetadataUpdates, forKey: .updateImageSetMetadataUpdates)
        }
    }
}

extension UpdateImageSetMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let latestVersionId = latestVersionId else {
                let message = "Creating a URL Query Item failed. latestVersionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let latestVersionIdQueryItem = ClientRuntime.URLQueryItem(name: "latestVersion".urlPercentEncoding(), value: Swift.String(latestVersionId).urlPercentEncoding())
            items.append(latestVersionIdQueryItem)
            return items
        }
    }
}

extension UpdateImageSetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datastoreId = datastoreId else {
            return nil
        }
        guard let imageSetId = imageSetId else {
            return nil
        }
        return "/datastore/\(datastoreId.urlPercentEncoding())/imageSet/\(imageSetId.urlPercentEncoding())/updateImageSetMetadata"
    }
}

public struct UpdateImageSetMetadataInput: Swift.Equatable {
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The latest image set version identifier.
    /// This member is required.
    public var latestVersionId: Swift.String?
    /// Update image set metadata updates.
    /// This member is required.
    public var updateImageSetMetadataUpdates: MedicalImagingClientTypes.MetadataUpdates?

    public init(
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        latestVersionId: Swift.String? = nil,
        updateImageSetMetadataUpdates: MedicalImagingClientTypes.MetadataUpdates? = nil
    )
    {
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.latestVersionId = latestVersionId
        self.updateImageSetMetadataUpdates = updateImageSetMetadataUpdates
    }
}

struct UpdateImageSetMetadataInputBody: Swift.Equatable {
    let updateImageSetMetadataUpdates: MedicalImagingClientTypes.MetadataUpdates?
}

extension UpdateImageSetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateImageSetMetadataUpdates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateImageSetMetadataUpdatesDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.MetadataUpdates.self, forKey: .updateImageSetMetadataUpdates)
        updateImageSetMetadataUpdates = updateImageSetMetadataUpdatesDecoded
    }
}

extension UpdateImageSetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateImageSetMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.datastoreId = output.datastoreId
            self.imageSetId = output.imageSetId
            self.imageSetState = output.imageSetState
            self.imageSetWorkflowStatus = output.imageSetWorkflowStatus
            self.latestVersionId = output.latestVersionId
            self.message = output.message
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.datastoreId = nil
            self.imageSetId = nil
            self.imageSetState = nil
            self.imageSetWorkflowStatus = nil
            self.latestVersionId = nil
            self.message = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateImageSetMetadataOutput: Swift.Equatable {
    /// The timestamp when image set metadata was created.
    public var createdAt: ClientRuntime.Date?
    /// The data store identifier.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The image set identifier.
    /// This member is required.
    public var imageSetId: Swift.String?
    /// The image set state.
    /// This member is required.
    public var imageSetState: MedicalImagingClientTypes.ImageSetState?
    /// The image set workflow status.
    public var imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    /// The latest image set version identifier.
    /// This member is required.
    public var latestVersionId: Swift.String?
    /// The error message thrown if an update image set metadata action fails.
    public var message: Swift.String?
    /// The timestamp when image set metadata was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        datastoreId: Swift.String? = nil,
        imageSetId: Swift.String? = nil,
        imageSetState: MedicalImagingClientTypes.ImageSetState? = nil,
        imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus? = nil,
        latestVersionId: Swift.String? = nil,
        message: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.datastoreId = datastoreId
        self.imageSetId = imageSetId
        self.imageSetState = imageSetState
        self.imageSetWorkflowStatus = imageSetWorkflowStatus
        self.latestVersionId = latestVersionId
        self.message = message
        self.updatedAt = updatedAt
    }
}

struct UpdateImageSetMetadataOutputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let imageSetId: Swift.String?
    let latestVersionId: Swift.String?
    let imageSetState: MedicalImagingClientTypes.ImageSetState?
    let imageSetWorkflowStatus: MedicalImagingClientTypes.ImageSetWorkflowStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let message: Swift.String?
}

extension UpdateImageSetMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case datastoreId
        case imageSetId
        case imageSetState
        case imageSetWorkflowStatus
        case latestVersionId
        case message
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let imageSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSetId)
        imageSetId = imageSetIdDecoded
        let latestVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionId)
        latestVersionId = latestVersionIdDecoded
        let imageSetStateDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetState.self, forKey: .imageSetState)
        imageSetState = imageSetStateDecoded
        let imageSetWorkflowStatusDecoded = try containerValues.decodeIfPresent(MedicalImagingClientTypes.ImageSetWorkflowStatus.self, forKey: .imageSetWorkflowStatus)
        imageSetWorkflowStatus = imageSetWorkflowStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum UpdateImageSetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
