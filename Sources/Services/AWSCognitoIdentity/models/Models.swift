// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CognitoIdentityClientTypes {
    public enum AmbiguousRoleResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRole
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AmbiguousRoleResolutionType] {
            return [
                .authenticatedRole,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRole: return "AuthenticatedRole"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmbiguousRoleResolutionType(rawValue: rawValue) ?? AmbiguousRoleResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.CognitoIdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "ClientId"
        case providerName = "ProviderName"
        case serverSideTokenCheck = "ServerSideTokenCheck"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let serverSideTokenCheck = self.serverSideTokenCheck {
            try encodeContainer.encode(serverSideTokenCheck, forKey: .serverSideTokenCheck)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let serverSideTokenCheckDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .serverSideTokenCheck)
        serverSideTokenCheck = serverSideTokenCheckDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A provider representing an Amazon Cognito user pool and its client ID.
    public struct CognitoIdentityProvider: Swift.Equatable {
        /// The client ID for the Amazon Cognito user pool.
        public var clientId: Swift.String?
        /// The provider name for an Amazon Cognito user pool. For example, cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789.
        public var providerName: Swift.String?
        /// TRUE if server-side token validation is enabled for the identity providerâ€™s token. Once you set ServerSideTokenCheck to TRUE for an identity pool, that identity pool will check with the integrated user pools to make sure that the user has not been globally signed out or deleted before the identity pool provides an OIDC token or AWS credentials for the user. If the user is signed out or deleted, the identity pool will return a 400 Not Authorized error.
        public var serverSideTokenCheck: Swift.Bool?

        public init(
            clientId: Swift.String? = nil,
            providerName: Swift.String? = nil,
            serverSideTokenCheck: Swift.Bool? = nil
        )
        {
            self.clientId = clientId
            self.providerName = providerName
            self.serverSideTokenCheck = serverSideTokenCheck
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if there are parallel requests to modify a resource.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a ConcurrentModificationException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = self.allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if let allowUnauthenticatedIdentities = self.allowUnauthenticatedIdentities {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityprovider0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityprovider0)
            }
        }
        if let developerProviderName = self.developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolName = self.identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identityPoolTagsType0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identityPoolTagsType0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for arnstring0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(arnstring0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for arnstring0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(arnstring0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityProviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityProviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the CreateIdentityPool action.
public struct CreateIdentityPoolInput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool?
    /// An array of Amazon Cognito user pools and their client IDs.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. For the DeveloperProviderName, you can use letters as well as period (.), underscore (_), and dash (-). Once you have set a developer provider name, you cannot change it. Please take care in setting this parameter.
    public var developerProviderName: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// Tags to assign to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The Amazon Resource Names (ARN) of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init(
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool? = nil,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolInputBody: Swift.Equatable {
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool?
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CreateIdentityPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdentityPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct CreateIdentityPoolOutput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init(
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities) ?? false
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

enum CreateIdentityPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoIdentityClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretKey = "SecretKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let expiration = self.expiration {
            try encodeContainer.encodeTimestamp(expiration, format: .epochSeconds, forKey: .expiration)
        }
        if let secretKey = self.secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// Credentials for the provided identity ID.
    public struct Credentials: Swift.Equatable {
        /// The Access Key portion of the credentials.
        public var accessKeyId: Swift.String?
        /// The date at which these credentials will expire.
        public var expiration: ClientRuntime.Date?
        /// The Secret Access Key portion of the credentials
        public var secretKey: Swift.String?
        /// The Session Token portion of the credentials
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretKey = secretKey
            self.sessionToken = sessionToken
        }
    }

}

extension DeleteIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityIdsToDelete = identityIdsToDelete {
            var identityIdsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityIdsToDelete)
            for identityid0 in identityIdsToDelete {
                try identityIdsToDeleteContainer.encode(identityid0)
            }
        }
    }
}

extension DeleteIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DeleteIdentities action.
public struct DeleteIdentitiesInput: Swift.Equatable {
    /// A list of 1-60 identities that you want to delete.
    /// This member is required.
    public var identityIdsToDelete: [Swift.String]?

    public init(
        identityIdsToDelete: [Swift.String]? = nil
    )
    {
        self.identityIdsToDelete = identityIdsToDelete
    }
}

struct DeleteIdentitiesInputBody: Swift.Equatable {
    let identityIdsToDelete: [Swift.String]?
}

extension DeleteIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdsToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityIdsToDelete)
        var identityIdsToDeleteDecoded0:[Swift.String]? = nil
        if let identityIdsToDeleteContainer = identityIdsToDeleteContainer {
            identityIdsToDeleteDecoded0 = [Swift.String]()
            for string0 in identityIdsToDeleteContainer {
                if let string0 = string0 {
                    identityIdsToDeleteDecoded0?.append(string0)
                }
            }
        }
        identityIdsToDelete = identityIdsToDeleteDecoded0
    }
}

extension DeleteIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedIdentityIds = output.unprocessedIdentityIds
        } else {
            self.unprocessedIdentityIds = nil
        }
    }
}

/// Returned in response to a successful DeleteIdentities operation.
public struct DeleteIdentitiesOutput: Swift.Equatable {
    /// An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and IdentityId.
    public var unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?

    public init(
        unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
    )
    {
        self.unprocessedIdentityIds = unprocessedIdentityIds
    }
}

struct DeleteIdentitiesOutputBody: Swift.Equatable {
    let unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?
}

extension DeleteIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedIdentityIds = "UnprocessedIdentityIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedIdentityIdsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.UnprocessedIdentityId?].self, forKey: .unprocessedIdentityIds)
        var unprocessedIdentityIdsDecoded0:[CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
        if let unprocessedIdentityIdsContainer = unprocessedIdentityIdsContainer {
            unprocessedIdentityIdsDecoded0 = [CognitoIdentityClientTypes.UnprocessedIdentityId]()
            for structure0 in unprocessedIdentityIdsContainer {
                if let structure0 = structure0 {
                    unprocessedIdentityIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentityIds = unprocessedIdentityIdsDecoded0
    }
}

enum DeleteIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension DeleteIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DeleteIdentityPool action.
public struct DeleteIdentityPoolInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DeleteIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension DeleteIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DeleteIdentityPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIdentityPoolOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIdentityPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }
}

extension DescribeIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DescribeIdentity action.
public struct DescribeIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?

    public init(
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct DescribeIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension DescribeIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension DescribeIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.identityId = output.identityId
            self.lastModifiedDate = output.lastModifiedDate
            self.logins = output.logins
        } else {
            self.creationDate = nil
            self.identityId = nil
            self.lastModifiedDate = nil
            self.logins = nil
        }
    }
}

/// A description of the identity.
public struct DescribeIdentityOutput: Swift.Equatable {
    /// Date on which the identity was created.
    public var creationDate: ClientRuntime.Date?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// Date on which the identity was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The provider names.
    public var logins: [Swift.String]?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        identityId: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        logins: [Swift.String]? = nil
    )
    {
        self.creationDate = creationDate
        self.identityId = identityId
        self.lastModifiedDate = lastModifiedDate
        self.logins = logins
    }
}

struct DescribeIdentityOutputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String]?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension DescribeIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the DescribeIdentityPool action.
public struct DescribeIdentityPoolInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension DescribeIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DescribeIdentityPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIdentityPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct DescribeIdentityPoolOutput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init(
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct DescribeIdentityPoolOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension DescribeIdentityPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities) ?? false
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

enum DescribeIdentityPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeveloperUserAlreadyRegisteredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeveloperUserAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided developer user identifier is already registered with Cognito under a different identity ID.
public struct DeveloperUserAlreadyRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This developer user identifier is already registered with Cognito.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeveloperUserAlreadyRegisteredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeveloperUserAlreadyRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeveloperUserAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServerError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .internalServerError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "AccessDenied"
            case .internalServerError: return "InternalServerError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ExternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception thrown when a dependent service such as Facebook or Twitter is not responding
public struct ExternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by an ExternalServiceException
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExternalServiceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ExternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCredentialsForIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRoleArn = self.customRoleArn {
            try encodeContainer.encode(customRoleArn, forKey: .customRoleArn)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsMap0) in logins {
                try loginsContainer.encode(loginsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetCredentialsForIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetCredentialsForIdentity action.
public struct GetCredentialsForIdentityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the role to be assumed when multiple roles were received in the token from the identity provider. For example, a SAML-based identity provider. This parameter is optional for identity providers that do not support role customization.
    public var customRoleArn: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. The name-value pair will follow the syntax "provider_name": "provider_user_identifier". Logins should not be specified when trying to get credentials for an unauthenticated identity. The Logins parameter is required when using identities associated with external identity providers such as Facebook. For examples of Logins maps, see the code examples in the [External Identity Providers](https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html) section of the Amazon Cognito Developer Guide.
    public var logins: [Swift.String:Swift.String]?

    public init(
        customRoleArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.customRoleArn = customRoleArn
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetCredentialsForIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let customRoleArn: Swift.String?
}

extension GetCredentialsForIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let customRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customRoleArn)
        customRoleArn = customRoleArnDecoded
    }
}

extension GetCredentialsForIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCredentialsForIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.identityId = output.identityId
        } else {
            self.credentials = nil
            self.identityId = nil
        }
    }
}

/// Returned in response to a successful GetCredentialsForIdentity operation.
public struct GetCredentialsForIdentityOutput: Swift.Equatable {
    /// Credentials for the provided identity ID.
    public var credentials: CognitoIdentityClientTypes.Credentials?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init(
        credentials: CognitoIdentityClientTypes.Credentials? = nil,
        identityId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.identityId = identityId
    }
}

struct GetCredentialsForIdentityOutputBody: Swift.Equatable {
    let identityId: Swift.String?
    let credentials: CognitoIdentityClientTypes.Credentials?
}

extension GetCredentialsForIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case identityId = "IdentityId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum GetCredentialsForIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExternalServiceException": return try await ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidIdentityPoolConfigurationException": return try await InvalidIdentityPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsMap0) in logins {
                try loginsContainer.encode(loginsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetId action.
public struct GetIdInput: Swift.Equatable {
    /// A standard AWS account ID (9+ digits).
    public var accountId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. The available provider names for Logins are as follows:
    ///
    /// * Facebook: graph.facebook.com
    ///
    /// * Amazon Cognito user pool: cognito-idp..amazonaws.com/, for example, cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789.
    ///
    /// * Google: accounts.google.com
    ///
    /// * Amazon: www.amazon.com
    ///
    /// * Twitter: api.twitter.com
    ///
    /// * Digits: www.digits.com
    public var logins: [Swift.String:Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.identityPoolId = identityPoolId
        self.logins = logins
    }
}

struct GetIdInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let identityPoolId: Swift.String?
    let logins: [Swift.String:Swift.String]?
}

extension GetIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// Returned in response to a GetId request.
public struct GetIdOutput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init(
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct GetIdOutputBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension GetIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

enum GetIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExternalServiceException": return try await ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdentityPoolRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension GetIdentityPoolRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetIdentityPoolRoles action.
public struct GetIdentityPoolRolesInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolRolesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension GetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension GetIdentityPoolRolesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentityPoolRolesOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.roleMappings = output.roleMappings
            self.roles = output.roles
        } else {
            self.identityPoolId = nil
            self.roleMappings = nil
            self.roles = nil
        }
    }
}

/// Returned in response to a successful GetIdentityPoolRoles operation.
public struct GetIdentityPoolRolesOutput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    public var identityPoolId: Swift.String?
    /// How users for a specific identity provider are to mapped to roles. This is a String-to-[RoleMapping] object map. The string identifies the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".
    public var roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// The map of roles associated with this pool. Currently only authenticated and unauthenticated roles are supported.
    public var roles: [Swift.String:Swift.String]?

    public init(
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct GetIdentityPoolRolesOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let roles: [Swift.String:Swift.String]?
    let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension GetIdentityPoolRolesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

enum GetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOpenIdTokenForDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsMap0) in logins {
                try loginsContainer.encode(loginsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principalTags0) in principalTags {
                try principalTagsContainer.encode(principalTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tokenDuration = self.tokenDuration {
            try encodeContainer.encode(tokenDuration, forKey: .tokenDuration)
        }
    }
}

extension GetOpenIdTokenForDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetOpenIdTokenForDeveloperIdentity action.
public struct GetOpenIdTokenForDeveloperIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. Each name-value pair represents a user from a public provider or developer provider. If the user is from a developer provider, the name-value pair will follow the syntax "developer_provider_name": "developer_user_identifier". The developer provider is the "domain" by which Cognito will refer to your users; you provided this domain while creating/updating the identity pool. The developer user identifier is an identifier from your backend that uniquely identifies a user. When you create an identity pool, you can specify the supported logins.
    /// This member is required.
    public var logins: [Swift.String:Swift.String]?
    /// Use this operation to configure attribute mappings for custom providers.
    public var principalTags: [Swift.String:Swift.String]?
    /// The expiration time of the token, in seconds. You can specify a custom expiration time for the token so that you can cache it. If you don't provide an expiration time, the token is valid for 15 minutes. You can exchange the token with Amazon STS for temporary AWS credentials, which are valid for a maximum of one hour. The maximum token duration you can set is 24 hours. You should take care in setting the expiration time for a token, as there are significant security implications: an attacker could use a leaked token to access your AWS resources for the token's duration. Please provide for a small grace period, usually no more than 5 minutes, to account for clock skew.
    public var tokenDuration: Swift.Int?

    public init(
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        tokenDuration: Swift.Int? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.logins = logins
        self.principalTags = principalTags
        self.tokenDuration = tokenDuration
    }
}

struct GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let principalTags: [Swift.String:Swift.String]?
    let tokenDuration: Swift.Int?
}

extension GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
        let tokenDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tokenDuration)
        tokenDuration = tokenDurationDecoded
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOpenIdTokenForDeveloperIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// Returned in response to a successful GetOpenIdTokenForDeveloperIdentity request.
public struct GetOpenIdTokenForDeveloperIdentityOutput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An OpenID token.
    public var token: Swift.String?

    public init(
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenForDeveloperIdentityOutputBody: Swift.Equatable {
    let identityId: Swift.String?
    let token: Swift.String?
}

extension GetOpenIdTokenForDeveloperIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

enum GetOpenIdTokenForDeveloperIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeveloperUserAlreadyRegisteredException": return try await DeveloperUserAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOpenIdTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsMap0) in logins {
                try loginsContainer.encode(loginsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetOpenIdTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the GetOpenIdToken action.
public struct GetOpenIdTokenInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens. When using graph.facebook.com and www.amazon.com, supply the access_token returned from the provider's authflow. For accounts.google.com, an Amazon Cognito user pool provider, or any other OpenID Connect provider, always include the id_token.
    public var logins: [Swift.String:Swift.String]?

    public init(
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetOpenIdTokenInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
}

extension GetOpenIdTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetOpenIdTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOpenIdTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// Returned in response to a successful GetOpenIdToken request.
public struct GetOpenIdTokenOutput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID. Note that the IdentityId returned may not match the one passed on input.
    public var identityId: Swift.String?
    /// An OpenID token, valid for 10 minutes.
    public var token: Swift.String?

    public init(
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenOutputBody: Swift.Equatable {
    let identityId: Swift.String?
    let token: Swift.String?
}

extension GetOpenIdTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

enum GetOpenIdTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExternalServiceException": return try await ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPrincipalTagAttributeMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
    }
}

extension GetPrincipalTagAttributeMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// You can use this operation to get the provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
    }
}

struct GetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
}

extension GetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
    }
}

extension GetPrincipalTagAttributeMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPrincipalTagAttributeMapOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct GetPrincipalTagAttributeMapOutput: Swift.Equatable {
    /// You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.
    public var identityPoolId: Swift.String?
    /// You can use this operation to get the provider name.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags. The PrincipalTagsoperation enables you to reference user attributes in your IAM permissions policy.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to list
    public var useDefaults: Swift.Bool?

    public init(
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct GetPrincipalTagAttributeMapOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension GetPrincipalTagAttributeMapOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

enum GetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoIdentityClientTypes.IdentityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logins)
            for identityprovidername0 in logins {
                try loginsContainer.encode(identityprovidername0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A description of the identity.
    public struct IdentityDescription: Swift.Equatable {
        /// Date on which the identity was created.
        public var creationDate: ClientRuntime.Date?
        /// A unique identifier in the format REGION:GUID.
        public var identityId: Swift.String?
        /// Date on which the identity was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The provider names.
        public var logins: [Swift.String]?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            identityId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            logins: [Swift.String]? = nil
        )
        {
            self.creationDate = creationDate
            self.identityId = identityId
            self.lastModifiedDate = lastModifiedDate
            self.logins = logins
        }
    }

}

extension CognitoIdentityClientTypes.IdentityPoolShortDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = self.identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A description of the identity pool.
    public struct IdentityPoolShortDescription: Swift.Equatable {
        /// An identity pool ID in the format REGION:GUID.
        public var identityPoolId: Swift.String?
        /// A string that you provide.
        public var identityPoolName: Swift.String?

        public init(
            identityPoolId: Swift.String? = nil,
            identityPoolName: Swift.String? = nil
        )
        {
            self.identityPoolId = identityPoolId
            self.identityPoolName = identityPoolName
        }
    }

}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the service encounters an error during processing the request.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by an InternalErrorException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityPoolConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidIdentityPoolConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if the identity pool has no role associated for the given auth type (auth/unauth) or if the AssumeRole fails.
public struct InvalidIdentityPoolConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned for an InvalidIdentityPoolConfigurationException
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidIdentityPoolConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidIdentityPoolConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidIdentityPoolConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown for missing or bad input parameter(s).
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by an InvalidParameterException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the total number of user pools has exceeded a preset limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a LimitExceededException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hideDisabled = self.hideDisabled {
            try encodeContainer.encode(hideDisabled, forKey: .hideDisabled)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the ListIdentities action.
public struct ListIdentitiesInput: Swift.Equatable {
    /// An optional boolean parameter that allows you to hide disabled identities. If omitted, the ListIdentities API will include disabled identities in the response.
    public var hideDisabled: Swift.Bool?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of identities to return.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        hideDisabled: Swift.Bool? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hideDisabled = hideDisabled
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentitiesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let hideDisabled: Swift.Bool?
}

extension ListIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let hideDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hideDisabled)
        hideDisabled = hideDisabledDecoded
    }
}

extension ListIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.identities = output.identities
            self.identityPoolId = output.identityPoolId
            self.nextToken = output.nextToken
        } else {
            self.identities = nil
            self.identityPoolId = nil
            self.nextToken = nil
        }
    }
}

/// The response to a ListIdentities request.
public struct ListIdentitiesOutput: Swift.Equatable {
    /// An object containing a set of identities and associated mappings.
    public var identities: [CognitoIdentityClientTypes.IdentityDescription]?
    /// An identity pool ID in the format REGION:GUID.
    public var identityPoolId: Swift.String?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        identities: [CognitoIdentityClientTypes.IdentityDescription]? = nil,
        identityPoolId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identities = identities
        self.identityPoolId = identityPoolId
        self.nextToken = nextToken
    }
}

struct ListIdentitiesOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identities: [CognitoIdentityClientTypes.IdentityDescription]?
    let nextToken: Swift.String?
}

extension ListIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identities = "Identities"
        case identityPoolId = "IdentityPoolId"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityDescription?].self, forKey: .identities)
        var identitiesDecoded0:[CognitoIdentityClientTypes.IdentityDescription]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [CognitoIdentityClientTypes.IdentityDescription]()
            for structure0 in identitiesContainer {
                if let structure0 = structure0 {
                    identitiesDecoded0?.append(structure0)
                }
            }
        }
        identities = identitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentityPoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentityPoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the ListIdentityPools action.
public struct ListIdentityPoolsInput: Swift.Equatable {
    /// The maximum number of identities to return.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIdentityPoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityPoolsOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPools = output.identityPools
            self.nextToken = output.nextToken
        } else {
            self.identityPools = nil
            self.nextToken = nil
        }
    }
}

/// The result of a successful ListIdentityPools action.
public struct ListIdentityPoolsOutput: Swift.Equatable {
    /// The identity pools returned by the ListIdentityPools action.
    public var identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    /// A pagination token.
    public var nextToken: Swift.String?

    public init(
        identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityPools = identityPools
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsOutputBody: Swift.Equatable {
    let identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    let nextToken: Swift.String?
}

extension ListIdentityPoolsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPools = "IdentityPools"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityPoolShortDescription?].self, forKey: .identityPools)
        var identityPoolsDecoded0:[CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil
        if let identityPoolsContainer = identityPoolsContainer {
            identityPoolsDecoded0 = [CognitoIdentityClientTypes.IdentityPoolShortDescription]()
            for structure0 in identityPoolsContainer {
                if let structure0 = structure0 {
                    identityPoolsDecoded0?.append(structure0)
                }
            }
        }
        identityPools = identityPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdentityPoolsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool that the tags are assigned to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags that are assigned to the identity pool.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LookupDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerUserIdentifier = self.developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension LookupDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the LookupDeveloperIdentityInput action.
public struct LookupDeveloperIdentityInput: Swift.Equatable {
    /// A unique ID used by your backend authentication process to identify a user. Typically, a developer identity provider would issue many developer user identifiers, in keeping with the number of users.
    public var developerUserIdentifier: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of identities to return.
    public var maxResults: Swift.Int?
    /// A pagination token. The first call you make will have NextToken set to null. After that the service will return NextToken values as needed. For example, let's say you make a request with MaxResults set to 10, and there are 20 matches in the database. The service will return a pagination token as a part of the response. This token can be used to call the API again and get results starting from the 11th match.
    public var nextToken: Swift.String?

    public init(
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityId: Swift.String?
    let developerUserIdentifier: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension LookupDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupDeveloperIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LookupDeveloperIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.developerUserIdentifierList = output.developerUserIdentifierList
            self.identityId = output.identityId
            self.nextToken = output.nextToken
        } else {
            self.developerUserIdentifierList = nil
            self.identityId = nil
            self.nextToken = nil
        }
    }
}

/// Returned in response to a successful LookupDeveloperIdentity action.
public struct LookupDeveloperIdentityOutput: Swift.Equatable {
    /// This is the list of developer user identifiers associated with an identity ID. Cognito supports the association of multiple developer user identifiers with an identity ID.
    public var developerUserIdentifierList: [Swift.String]?
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?
    /// A pagination token. The first call you make will have NextToken set to null. After that the service will return NextToken values as needed. For example, let's say you make a request with MaxResults set to 10, and there are 20 matches in the database. The service will return a pagination token as a part of the response. This token can be used to call the API again and get results starting from the 11th match.
    public var nextToken: Swift.String?

    public init(
        developerUserIdentifierList: [Swift.String]? = nil,
        identityId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifierList = developerUserIdentifierList
        self.identityId = identityId
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityOutputBody: Swift.Equatable {
    let identityId: Swift.String?
    let developerUserIdentifierList: [Swift.String]?
    let nextToken: Swift.String?
}

extension LookupDeveloperIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifierList = "DeveloperUserIdentifierList"
        case identityId = "IdentityId"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .developerUserIdentifierList)
        var developerUserIdentifierListDecoded0:[Swift.String]? = nil
        if let developerUserIdentifierListContainer = developerUserIdentifierListContainer {
            developerUserIdentifierListDecoded0 = [Swift.String]()
            for string0 in developerUserIdentifierListContainer {
                if let string0 = string0 {
                    developerUserIdentifierListDecoded0?.append(string0)
                }
            }
        }
        developerUserIdentifierList = developerUserIdentifierListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum LookupDeveloperIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoIdentityClientTypes.MappingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claim = "Claim"
        case matchType = "MatchType"
        case roleARN = "RoleARN"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claim = self.claim {
            try encodeContainer.encode(claim, forKey: .claim)
        }
        if let matchType = self.matchType {
            try encodeContainer.encode(matchType.rawValue, forKey: .matchType)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claim)
        claim = claimDecoded
        let matchTypeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.MappingRuleMatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A rule that maps a claim name, a claim value, and a match type to a role ARN.
    public struct MappingRule: Swift.Equatable {
        /// The claim name that must be present in the token, for example, "isAdmin" or "paid".
        /// This member is required.
        public var claim: Swift.String?
        /// The match condition that specifies how closely the claim value in the IdP token must match Value.
        /// This member is required.
        public var matchType: CognitoIdentityClientTypes.MappingRuleMatchType?
        /// The role ARN.
        /// This member is required.
        public var roleARN: Swift.String?
        /// A brief string that the claim must match, for example, "paid" or "yes".
        /// This member is required.
        public var value: Swift.String?

        public init(
            claim: Swift.String? = nil,
            matchType: CognitoIdentityClientTypes.MappingRuleMatchType? = nil,
            roleARN: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.claim = claim
            self.matchType = matchType
            self.roleARN = roleARN
            self.value = value
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum MappingRuleMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case notEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingRuleMatchType] {
            return [
                .contains,
                .equals,
                .notEqual,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equals: return "Equals"
            case .notEqual: return "NotEqual"
            case .startsWith: return "StartsWith"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MappingRuleMatchType(rawValue: rawValue) ?? MappingRuleMatchType.sdkUnknown(rawValue)
        }
    }
}

extension MergeDeveloperIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationUserIdentifier = self.destinationUserIdentifier {
            try encodeContainer.encode(destinationUserIdentifier, forKey: .destinationUserIdentifier)
        }
        if let developerProviderName = self.developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let sourceUserIdentifier = self.sourceUserIdentifier {
            try encodeContainer.encode(sourceUserIdentifier, forKey: .sourceUserIdentifier)
        }
    }
}

extension MergeDeveloperIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the MergeDeveloperIdentities action.
public struct MergeDeveloperIdentitiesInput: Swift.Equatable {
    /// User identifier for the destination user. The value should be a DeveloperUserIdentifier.
    /// This member is required.
    public var destinationUserIdentifier: Swift.String?
    /// The "domain" by which Cognito will refer to your users. This is a (pseudo) domain name that you provide while creating an identity pool. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. For the DeveloperProviderName, you can use letters as well as period (.), underscore (_), and dash (-).
    /// This member is required.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// User identifier for the source user. The value should be a DeveloperUserIdentifier.
    /// This member is required.
    public var sourceUserIdentifier: Swift.String?

    public init(
        destinationUserIdentifier: Swift.String? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        sourceUserIdentifier: Swift.String? = nil
    )
    {
        self.destinationUserIdentifier = destinationUserIdentifier
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.sourceUserIdentifier = sourceUserIdentifier
    }
}

struct MergeDeveloperIdentitiesInputBody: Swift.Equatable {
    let sourceUserIdentifier: Swift.String?
    let destinationUserIdentifier: Swift.String?
    let developerProviderName: Swift.String?
    let identityPoolId: Swift.String?
}

extension MergeDeveloperIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUserIdentifier)
        sourceUserIdentifier = sourceUserIdentifierDecoded
        let destinationUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationUserIdentifier)
        destinationUserIdentifier = destinationUserIdentifierDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension MergeDeveloperIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeDeveloperIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// Returned in response to a successful MergeDeveloperIdentities action.
public struct MergeDeveloperIdentitiesOutput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    public var identityId: Swift.String?

    public init(
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct MergeDeveloperIdentitiesOutputBody: Swift.Equatable {
    let identityId: Swift.String?
}

extension MergeDeveloperIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

enum MergeDeveloperIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotAuthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a user is not authorized to access the requested resource.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a NotAuthorizedException
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a user tries to use a login which is already linked to another account.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a ResourceConflictException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the requested resource (for example, a dataset or record) does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a ResourceNotFoundException.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes.RoleMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ambiguousRoleResolution = "AmbiguousRoleResolution"
        case rulesConfiguration = "RulesConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ambiguousRoleResolution = self.ambiguousRoleResolution {
            try encodeContainer.encode(ambiguousRoleResolution.rawValue, forKey: .ambiguousRoleResolution)
        }
        if let rulesConfiguration = self.rulesConfiguration {
            try encodeContainer.encode(rulesConfiguration, forKey: .rulesConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RoleMappingType.self, forKey: .type)
        type = typeDecoded
        let ambiguousRoleResolutionDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.AmbiguousRoleResolutionType.self, forKey: .ambiguousRoleResolution)
        ambiguousRoleResolution = ambiguousRoleResolutionDecoded
        let rulesConfigurationDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RulesConfigurationType.self, forKey: .rulesConfiguration)
        rulesConfiguration = rulesConfigurationDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// A role mapping.
    public struct RoleMapping: Swift.Equatable {
        /// If you specify Token or Rules as the Type, AmbiguousRoleResolution is required. Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type.
        public var ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType?
        /// The rules to be used for mapping users to roles. If you specify Rules as the role mapping type, RulesConfiguration is required.
        public var rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType?
        /// The role mapping type. Token will use cognito:roles and cognito:preferred_role claims from the Cognito identity provider token to map groups to roles. Rules will attempt to match claims from the token to map to a role.
        /// This member is required.
        public var type: CognitoIdentityClientTypes.RoleMappingType?

        public init(
            ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType? = nil,
            rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType? = nil,
            type: CognitoIdentityClientTypes.RoleMappingType? = nil
        )
        {
            self.ambiguousRoleResolution = ambiguousRoleResolution
            self.rulesConfiguration = rulesConfiguration
            self.type = type
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum RoleMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rules
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleMappingType] {
            return [
                .rules,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rules: return "Rules"
            case .token: return "Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleMappingType(rawValue: rawValue) ?? RoleMappingType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.RulesConfigurationType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for mappingrule0 in rules {
                try rulesContainer.encode(mappingrule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.MappingRule?].self, forKey: .rules)
        var rulesDecoded0:[CognitoIdentityClientTypes.MappingRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CognitoIdentityClientTypes.MappingRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CognitoIdentityClientTypes {
    /// A container for rules.
    public struct RulesConfigurationType: Swift.Equatable {
        /// An array of rules. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
        /// This member is required.
        public var rules: [CognitoIdentityClientTypes.MappingRule]?

        public init(
            rules: [CognitoIdentityClientTypes.MappingRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SetIdentityPoolRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let roleMappings = roleMappings {
            var roleMappingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roleMappings)
            for (dictKey0, roleMappingMap0) in roleMappings {
                try roleMappingsContainer.encode(roleMappingMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roles)
            for (dictKey0, rolesMap0) in roles {
                try rolesContainer.encode(rolesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension SetIdentityPoolRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the SetIdentityPoolRoles action.
public struct SetIdentityPoolRolesInput: Swift.Equatable {
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// How users for a specific identity provider are to mapped to roles. This is a string to [RoleMapping] object map. The string identifies the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Up to 25 rules can be specified per identity provider.
    public var roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// The map of roles associated with this pool. For a given role, the key will be either "authenticated" or "unauthenticated" and the value will be the Role ARN.
    /// This member is required.
    public var roles: [Swift.String:Swift.String]?

    public init(
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct SetIdentityPoolRolesInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let roles: [Swift.String:Swift.String]?
    let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension SetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

extension SetIdentityPoolRolesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetIdentityPoolRolesOutput: Swift.Equatable {

    public init() { }
}

enum SetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetPrincipalTagAttributeMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = self.identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principalTags0) in principalTags {
                try principalTagsContainer.encode(principalTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaults = self.useDefaults {
            try encodeContainer.encode(useDefaults, forKey: .useDefaults)
        }
    }
}

extension SetPrincipalTagAttributeMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// The ID of the Identity Pool you want to set attribute mappings for.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The provider name you want to use for attribute mappings.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to use default (username and clientID) attribute mappings.
    public var useDefaults: Swift.Bool?

    public init(
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension SetPrincipalTagAttributeMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetPrincipalTagAttributeMapOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct SetPrincipalTagAttributeMapOutput: Swift.Equatable {
    /// The ID of the Identity Pool you want to set attribute mappings for.
    public var identityPoolId: Swift.String?
    /// The provider name you want to use for attribute mappings.
    public var identityProviderName: Swift.String?
    /// You can use this operation to add principal tags. The PrincipalTagsoperation enables you to reference user attributes in your IAM permissions policy.
    public var principalTags: [Swift.String:Swift.String]?
    /// You can use this operation to select default (username and clientID) attribute mappings.
    public var useDefaults: Swift.Bool?

    public init(
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityProviderName: Swift.String?
    let useDefaults: Swift.Bool?
    let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

enum SetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, identityPoolTagsType0) in tags {
                try tagsContainer.encode(identityPoolTagsType0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the identity pool.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a request is throttled.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by a TooManyRequestsException
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnlinkDeveloperIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerProviderName = self.developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let developerUserIdentifier = self.developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

extension UnlinkDeveloperIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the UnlinkDeveloperIdentity action.
public struct UnlinkDeveloperIdentityInput: Swift.Equatable {
    /// The "domain" by which Cognito will refer to your users.
    /// This member is required.
    public var developerProviderName: Swift.String?
    /// A unique ID used by your backend authentication process to identify a user.
    /// This member is required.
    public var developerUserIdentifier: Swift.String?
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        developerProviderName: Swift.String? = nil,
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.developerProviderName = developerProviderName
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnlinkDeveloperIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let identityPoolId: Swift.String?
    let developerProviderName: Swift.String?
    let developerUserIdentifier: Swift.String?
}

extension UnlinkDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
    }
}

extension UnlinkDeveloperIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnlinkDeveloperIdentityOutput: Swift.Equatable {

    public init() { }
}

enum UnlinkDeveloperIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnlinkIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsMap0) in logins {
                try loginsContainer.encode(loginsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let loginsToRemove = loginsToRemove {
            var loginsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loginsToRemove)
            for identityprovidername0 in loginsToRemove {
                try loginsToRemoveContainer.encode(identityprovidername0)
            }
        }
    }
}

extension UnlinkIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input to the UnlinkIdentity action.
public struct UnlinkIdentityInput: Swift.Equatable {
    /// A unique identifier in the format REGION:GUID.
    /// This member is required.
    public var identityId: Swift.String?
    /// A set of optional name-value pairs that map provider names to provider tokens.
    /// This member is required.
    public var logins: [Swift.String:Swift.String]?
    /// Provider names to unlink from this identity.
    /// This member is required.
    public var loginsToRemove: [Swift.String]?

    public init(
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        loginsToRemove: [Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
        self.loginsToRemove = loginsToRemove
    }
}

struct UnlinkIdentityInputBody: Swift.Equatable {
    let identityId: Swift.String?
    let logins: [Swift.String:Swift.String]?
    let loginsToRemove: [Swift.String]?
}

extension UnlinkIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let loginsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loginsToRemove)
        var loginsToRemoveDecoded0:[Swift.String]? = nil
        if let loginsToRemoveContainer = loginsToRemoveContainer {
            loginsToRemoveDecoded0 = [Swift.String]()
            for string0 in loginsToRemoveContainer {
                if let string0 = string0 {
                    loginsToRemoveDecoded0?.append(string0)
                }
            }
        }
        loginsToRemove = loginsToRemoveDecoded0
    }
}

extension UnlinkIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnlinkIdentityOutput: Swift.Equatable {

    public init() { }
}

enum UnlinkIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExternalServiceException": return try await ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoIdentityClientTypes.UnprocessedIdentityId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension CognitoIdentityClientTypes {
    /// An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and IdentityId.
    public struct UnprocessedIdentityId: Swift.Equatable {
        /// The error code indicating the type of error that occurred.
        public var errorCode: CognitoIdentityClientTypes.ErrorCode?
        /// A unique identifier in the format REGION:GUID.
        public var identityId: Swift.String?

        public init(
            errorCode: CognitoIdentityClientTypes.ErrorCode? = nil,
            identityId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.identityId = identityId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeystype0 in tagKeys {
                try tagKeysContainer.encode(tagkeystype0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the identity pool.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the user pool.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdentityPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = self.allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityprovider0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityprovider0)
            }
        }
        if let developerProviderName = self.developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = self.identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identityPoolTagsType0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identityPoolTagsType0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for arnstring0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(arnstring0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for arnstring0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(arnstring0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityProviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityProviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateIdentityPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct UpdateIdentityPoolInput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init(
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities) ?? false
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension UpdateIdentityPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdentityPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// An object representing an Amazon Cognito identity pool.
public struct UpdateIdentityPoolOutput: Swift.Equatable {
    /// Enables or disables the Basic (Classic) authentication flow. For more information, see [Identity Pools (Federated Identities) Authentication Flow](https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html) in the Amazon Cognito Developer Guide.
    public var allowClassicFlow: Swift.Bool?
    /// TRUE if the identity pool supports unauthenticated logins.
    /// This member is required.
    public var allowUnauthenticatedIdentities: Swift.Bool
    /// A list representing an Amazon Cognito user pool and its client ID.
    public var cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// The "domain" by which Cognito will refer to your users.
    public var developerProviderName: Swift.String?
    /// An identity pool ID in the format REGION:GUID.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A string that you provide.
    /// This member is required.
    public var identityPoolName: Swift.String?
    /// The tags that are assigned to the identity pool. A tag is a label that you can apply to identity pools to categorize and manage them in different ways, such as by purpose, owner, environment, or other criteria.
    public var identityPoolTags: [Swift.String:Swift.String]?
    /// The ARNs of the OpenID Connect providers.
    public var openIdConnectProviderARNs: [Swift.String]?
    /// An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.
    public var samlProviderARNs: [Swift.String]?
    /// Optional key:value pairs mapping provider names to provider app IDs.
    public var supportedLoginProviders: [Swift.String:Swift.String]?

    public init(
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let identityPoolName: Swift.String?
    let allowUnauthenticatedIdentities: Swift.Bool
    let allowClassicFlow: Swift.Bool?
    let supportedLoginProviders: [Swift.String:Swift.String]?
    let developerProviderName: Swift.String?
    let openIdConnectProviderARNs: [Swift.String]?
    let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    let samlProviderARNs: [Swift.String]?
    let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities) ?? false
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

enum UpdateIdentityPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
